/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunktrudesk"] = self["webpackChunktrudesk"] || []).push([[4],{

/***/ 986:
/*!************************************************!*\
  !*** ./src/public/js/modules/ajaximgupload.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! modules/helpers */ 11)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers) {\r\n  var aiu = {}\r\n\r\n  aiu.init = function () {\r\n    $(document).ready(function () {\r\n      $('#profileImageInput').on('change', function () {\r\n        var val = $(this).val()\r\n        if (val === '') return true\r\n\r\n        var form = $('#aUploadImageForm')\r\n        var formData = new FormData($(form)[0])\r\n        var timestamp = new Date().getTime()\r\n\r\n        $.ajax({\r\n          url: '/accounts/uploadImage',\r\n          type: 'POST',\r\n          data: formData,\r\n          // async: false,\r\n          cache: false,\r\n          contentType: false,\r\n          processData: false,\r\n          success: function (data) {\r\n            form.find('img').attr('src', data + '?' + timestamp)\r\n          },\r\n          error: function (err) {\r\n            console.log('[trudesk:ajaximgupload:onChange] Error - ', err)\r\n            helpers.UI.showSnackbar({\r\n              text: 'An error occurred. Please check console. 2',\r\n              actionTextColor: '#B92929'\r\n            })\r\n          }\r\n        })\r\n\r\n        $(this).val('')\r\n      })\r\n    })\r\n  }\r\n\r\n  return aiu\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/modules/ajaximgupload.js?");

/***/ }),

/***/ 987:
/*!***************************************************!*\
  !*** ./src/public/js/modules/attachmentUpload.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! underscore */ 1), __webpack_require__(/*! modules/helpers */ 11), __webpack_require__(/*! modules/socket */ 36)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (\r\n  $,\r\n  _,\r\n  helpers,\r\n  socket\r\n) {\r\n  var attachmentUploader = {}\r\n\r\n  attachmentUploader.init = function () {\r\n    $(document).ready(function () {\r\n      $('.attachmentInput1').each(function () {\r\n        $(this).on('change', function () {\r\n          var self = $(this)\r\n          var val = self.val()\r\n          if (val === '') return true\r\n\r\n          var form = $('#attachmentForm')\r\n          if (_.isUndefined(form) || _.isNull(form)) return false\r\n\r\n          var formData = new FormData($(form)[0])\r\n\r\n          $.ajax({\r\n            url: '/tickets/uploadattachment',\r\n            type: 'POST',\r\n            data: formData,\r\n            // async: false,\r\n            cache: false,\r\n            contentType: false,\r\n            processData: false,\r\n            success: function (data) {\r\n              // helpers.showFlash('Attachment Successfully Uploaded.');\r\n              helpers.UI.showSnackbar('Attachment Successfully Uploaded', false)\r\n\r\n              // Refresh Attachments - Socket.IO\r\n              if (_.isUndefined(data.ticket)) return false\r\n\r\n              socket.ui.refreshTicketAttachments(data.ticket._id)\r\n            },\r\n            error: function (err) {\r\n              console.log('[trudesk:attachmentUpload:onChange] Error - ' + err)\r\n              // helpers.showFlash(err.responseText, true);\r\n              helpers.UI.showSnackbar(err.responseText, true)\r\n            }\r\n          })\r\n\r\n          self.val('')\r\n        })\r\n      })\r\n    })\r\n  }\r\n\r\n  return attachmentUploader\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/modules/attachmentUpload.js?");

/***/ }),

/***/ 975:
/*!***********************************************!*\
  !*** ./src/public/js/pages/accountsImport.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! underscore */ 1),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! velocity */ 14),\r\n  __webpack_require__(/*! uikit */ 4),\r\n  __webpack_require__(/*! modules/socket */ 36),\r\n\r\n  __webpack_require__(/*! jquery_steps */ 976),\r\n  __webpack_require__(/*! jquery_actual */ 977),\r\n  __webpack_require__(/*! history */ 52)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, velocity, UIkit, socket) {\r\n  var accountsImportPage = {}\r\n  var state = {}\r\n  accountsImportPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var testPage = $('#page-content').find('.accountsImport')\r\n      if (testPage.length < 1) {\r\n        if (typeof callback === 'function') {\r\n          return callback()\r\n        }\r\n\r\n        return false\r\n      }\r\n\r\n      helpers.resizeAll()\r\n\r\n      accountsImportPage.wizardCSV()\r\n      accountsImportPage.csvUpload()\r\n\r\n      accountsImportPage.wizardJson()\r\n      accountsImportPage.jsonUpload()\r\n\r\n      accountsImportPage.wizardLdap()\r\n\r\n      state.csvUploaded = false\r\n      state.csvData = null\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  accountsImportPage.wizardCSV = function () {\r\n    var $wizardCsv = $('#wizard_csv')\r\n\r\n    if ($wizardCsv.length) {\r\n      $wizardCsv.steps({\r\n        headerTag: 'h3',\r\n        bodyTag: 'section',\r\n        transitionEffect: 'slideLeft',\r\n        trigger: 'change',\r\n        cssClass: 'wizard wizard-green',\r\n        onInit: function (event, currentIndex) {\r\n          contentHeight($wizardCsv, currentIndex)\r\n\r\n          $wizardCsv\r\n            .find('.button_next')\r\n            .addClass('disabled')\r\n            .attr('aria-disabled', true)\r\n            .find('a')\r\n            .attr('disabled', true)\r\n\r\n          setTimeout(function () {\r\n            $(window).resize()\r\n          }, 100)\r\n        },\r\n        onStepChanging: function (event, currentIndex, newIndex) {\r\n          if (currentIndex === 0 && newIndex === 1) {\r\n            // Review Uploaded Data\r\n            if (!state.csvUploaded) {\r\n              return false\r\n            }\r\n          }\r\n\r\n          return true\r\n        },\r\n        onStepChanged: function (event, currentIndex) {\r\n          if (currentIndex === 2) {\r\n            // Last step Disable all until done.\r\n            $wizardCsv.find('.steps ul li').each(function () {\r\n              $(this).addClass('disabled')\r\n            })\r\n            $wizardCsv.find('.actions ul li').addClass('disabled')\r\n            $wizardCsv\r\n              .find('.button_previous')\r\n              .addClass('disabled')\r\n              .attr('aria-disabled', true)\r\n\r\n            var csvStatusBox = $('#csv-import-status-box')\r\n            var csvStatusUL = csvStatusBox.find('ul')\r\n            csvStatusUL.append('<li>Starting import...</li>')\r\n            disableUIElements()\r\n\r\n            // send data\r\n            setTimeout(function () {\r\n              socket.accountsImporter.sendAccountData('csv', state.addedUsers, state.updatedUsers)\r\n            }, 1000)\r\n          }\r\n\r\n          // Disable all future steps when moving backwards\r\n          $('.steps .current')\r\n            .nextAll()\r\n            .removeClass('done')\r\n            .addClass('disabled')\r\n\r\n          contentHeight($wizardCsv, currentIndex)\r\n        },\r\n        onFinished: function () {\r\n          location.href = '/accounts'\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  accountsImportPage.csvUpload = function () {\r\n    var progressbar = $('#progressbar')\r\n\r\n    var bar = progressbar.find('.uk-progress-bar')\r\n\r\n    var settings = {\r\n      action: '/accounts/import/csv/upload',\r\n      allow: '*.csv',\r\n      loadstart: function () {\r\n        bar.css('width', '0%').text('0%')\r\n        progressbar.removeClass('uk-hidden')\r\n      },\r\n      progress: function (percent) {\r\n        percent = Math.ceil(percent)\r\n        bar.css('width', percent + '%').text(percent + '%')\r\n      },\r\n      notallowed: function () {\r\n        helpers.UI.showSnackbar('Invalid File Type. Please upload a CSV file.', true)\r\n      },\r\n      error: function (err) {\r\n        console.error(err)\r\n        helpers.UI.showSnackbar('An unknown error occurred. Check Console', true)\r\n      },\r\n      allcomplete: function (response) {\r\n        response = JSON.parse(response)\r\n        if (!response.success) {\r\n          console.log(response)\r\n          helpers.UI.showSnackbar('An Error occurred. Check Console', true)\r\n          return false\r\n        }\r\n\r\n        state.csvUploaded = true\r\n        state.csvData = response.contents\r\n        state.addedUsers = response.addedUsers\r\n        state.updatedUsers = response.updatedUsers\r\n\r\n        $('#csv-review-list').val(csvReviewRender(response.addedUsers, response.updatedUsers))\r\n\r\n        console.log(state.csvData)\r\n\r\n        bar.css('width', '100%').text('100%')\r\n\r\n        setTimeout(function () {\r\n          progressbar.addClass('uk-hidden')\r\n\r\n          $('#wizard_csv').steps('setStep', 1)\r\n        }, 1000)\r\n\r\n        // helpers.UI.showSnackbar('Upload Complete', false);\r\n      }\r\n    }\r\n\r\n    UIkit.uploadSelect($('#upload-select'), settings)\r\n    UIkit.uploadDrop($('#upload-drop'), settings)\r\n  }\r\n\r\n  accountsImportPage.wizardJson = function () {\r\n    var $wizardJson = $('#wizard_json')\r\n\r\n    if ($wizardJson.length) {\r\n      $wizardJson.steps({\r\n        headerTag: 'h3',\r\n        bodyTag: 'section',\r\n        transitionEffect: 'slideLeft',\r\n        trigger: 'change',\r\n        cssClass: 'wizard wizard-blue-gray',\r\n        onInit: function (event, currentIndex) {\r\n          contentHeight($wizardJson, currentIndex)\r\n\r\n          $wizardJson\r\n            .find('.button_next')\r\n            .addClass('disabled')\r\n            .attr('aria-disabled', true)\r\n            .find('a')\r\n            .attr('disabled', true)\r\n\r\n          setTimeout(function () {\r\n            $(window).resize()\r\n          }, 100)\r\n        },\r\n        onStepChanging: function (event, currentIndex, newIndex) {\r\n          if (currentIndex === 0 && newIndex === 1) {\r\n            // Review Uploaded Data\r\n            if (!state.jsonUploaded) {\r\n              return false\r\n            }\r\n          }\r\n\r\n          return true\r\n        },\r\n        onStepChanged: function (event, currentIndex) {\r\n          if (currentIndex === 2) {\r\n            // Last step Disable all until done.\r\n            $wizardJson.find('.steps ul li').each(function () {\r\n              $(this).addClass('disabled')\r\n            })\r\n            $wizardJson.find('.actions ul li').addClass('disabled')\r\n            $wizardJson\r\n              .find('.button_previous')\r\n              .addClass('disabled')\r\n              .attr('aria-disabled', true)\r\n\r\n            var csvStatusBox = $('#json-import-status-box')\r\n            var csvStatusUL = csvStatusBox.find('ul')\r\n            csvStatusUL.append('<li>Starting import...</li>')\r\n            disableUIElements()\r\n\r\n            // send data\r\n            setTimeout(function () {\r\n              socket.accountsImporter.sendAccountData('json', state.addedUsers, state.updatedUsers)\r\n            }, 1000)\r\n          }\r\n\r\n          // Disable all future steps when moving backwards\r\n          $('.steps .current')\r\n            .nextAll()\r\n            .removeClass('done')\r\n            .addClass('disabled')\r\n\r\n          contentHeight($wizardJson, currentIndex)\r\n        },\r\n        onFinished: function () {\r\n          location.href = '/accounts'\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  accountsImportPage.jsonUpload = function () {\r\n    var progressbar = $('#json-progressbar')\r\n\r\n    var bar = progressbar.find('.uk-progress-bar')\r\n\r\n    var settings = {\r\n      action: '/accounts/import/json/upload',\r\n      allow: '*.json',\r\n      loadstart: function () {\r\n        bar.css('width', '0%').text('0%')\r\n        progressbar.removeClass('uk-hidden')\r\n      },\r\n      progress: function (percent) {\r\n        percent = Math.ceil(percent)\r\n        bar.css('width', percent + '%').text(percent + '%')\r\n      },\r\n      notallowed: function () {\r\n        helpers.UI.showSnackbar('Invalid File Type. Please upload a JSON file.', true)\r\n      },\r\n      error: function (err) {\r\n        console.error(err)\r\n        helpers.UI.showSnackbar('An unknown error occurred. Check Console', true)\r\n      },\r\n      allcomplete: function (response) {\r\n        response = JSON.parse(response)\r\n        if (!response.success) {\r\n          console.log(response)\r\n          helpers.UI.showSnackbar('An Error occurred. Check Console', true)\r\n          return false\r\n        }\r\n\r\n        state.jsonUploaded = true\r\n        state.jsonData = response.contents\r\n        state.addedUsers = response.addedUsers\r\n        state.updatedUsers = response.updatedUsers\r\n\r\n        $('#json-review-list').val(csvReviewRender(response.addedUsers, response.updatedUsers))\r\n\r\n        bar.css('width', '100%').text('100%')\r\n\r\n        setTimeout(function () {\r\n          progressbar.addClass('uk-hidden')\r\n\r\n          $('#wizard_json').steps('setStep', 1)\r\n        }, 1000)\r\n      }\r\n    }\r\n\r\n    UIkit.uploadSelect($('#json-upload-select'), settings)\r\n    UIkit.uploadDrop($('#json-upload-drop'), settings)\r\n  }\r\n\r\n  accountsImportPage.wizardLdap = function () {\r\n    var $wizardLdap = $('#wizard_ldap')\r\n    var $connectionForm = $('#wizard_ldap_connection_form')\r\n\r\n    var ldapSuccess = false\r\n\r\n    var addedUsers = []\r\n\r\n    var updatedUsers = []\r\n\r\n    if ($wizardLdap.length) {\r\n      $wizardLdap.steps({\r\n        headerTag: 'h3',\r\n        bodyTag: 'section',\r\n        transitionEffect: 'slideLeft',\r\n        trigger: 'change',\r\n        cssClass: 'wizard',\r\n        onInit: function (event, currentIndex) {\r\n          contentHeight($wizardLdap, currentIndex)\r\n\r\n          // $wizardLdap.find('.button_next').addClass('disabled').attr('aria-disabled', true).find('a').attr('disabled', true);\r\n          $wizardLdap.find('.button_next > a').html(\"Connect  <i class='material-icons'>&#xE315;</i>\")\r\n\r\n          setTimeout(function () {\r\n            $(window).resize()\r\n          }, 100)\r\n        },\r\n        onStepChanging: function (event, currentIndex, newIndex) {\r\n          if (currentIndex === 0 && newIndex === 1) {\r\n            var verifyStatus = $('#wizard_ldap_verify_text')\r\n            var data = $connectionForm.serializeObject()\r\n\r\n            $wizardLdap.find('#wizard_ldap_verify_spinner').removeClass('uk-hidden')\r\n            $wizardLdap.find('#wizard_ldap_verify_icon').addClass('uk-hidden')\r\n            $wizardLdap.find('.button_next > a').html(\"Next  <i class='material-icons'>&#xE315;</i>\")\r\n            setTimeout(function () {\r\n              $.ajax({\r\n                url: '/accounts/import/ldap/bind',\r\n                method: 'POST',\r\n                headers: {\r\n                  'Content-Type': 'application/json'\r\n                },\r\n                contentType: 'application/json',\r\n                dataType: 'json',\r\n                data: JSON.stringify(data),\r\n                beforeSend: function () {\r\n                  // $wizardLdap.siblings('.card-spinner').removeClass('uk-hidden');\r\n                },\r\n                error: function (err) {\r\n                  console.error(err)\r\n                  verifyStatus.text(\r\n                    'An error occured while trying to bind to the ldap server. Please check connection settings.'\r\n                  )\r\n                  $wizardLdap.find('#wizard_ldap_verify_spinner').addClass('uk-hidden')\r\n                  $wizardLdap\r\n                    .find('#wizard_ldap_verify_icon')\r\n                    .removeClass('md-color-green uk-hidden')\r\n                    .addClass('md-color-red')\r\n                    .find('> i')\r\n                    .html('&#xE000;')\r\n                  // $wizardLdap.steps('setStep', 0);\r\n                },\r\n                success: function (response) {\r\n                  if (response.success) {\r\n                    ldapSuccess = true\r\n                    verifyStatus.text('Successfully connected to ldap server. Please click next to review accounts.')\r\n                    $wizardLdap.find('#wizard_ldap_verify_spinner').addClass('uk-hidden')\r\n                    $wizardLdap\r\n                      .find('#wizard_ldap_verify_icon')\r\n                      .removeClass('md-color-red uk-hidden')\r\n                      .addClass('md-color-green')\r\n                      .find('> i')\r\n                      .html('&#xE86C;')\r\n                    addedUsers = response.addedUsers\r\n                    updatedUsers = response.updatedUsers\r\n\r\n                    $('#ldap-review-list').val(ldapReviewRender(response.addedUsers, response.updatedUsers))\r\n                  } else {\r\n                    verifyStatus.text(\r\n                      'An error occured while trying to bind to the ldap server. Please check connection settings.'\r\n                    )\r\n                    $wizardLdap.find('#wizard_ldap_verify_spinner').addClass('uk-hidden')\r\n                    $wizardLdap\r\n                      .find('#wizard_ldap_verify_icon')\r\n                      .removeClass('md-color-green uk-hidden')\r\n                      .addClass('md-color-red')\r\n                      .find('> i')\r\n                      .html('&#xE000;')\r\n                  }\r\n                },\r\n                complete: function () {\r\n                  setTimeout(function () {\r\n                    $wizardLdap.siblings('.card-spinner').addClass('uk-hidden')\r\n                  }, 800)\r\n                }\r\n              })\r\n            }, 500)\r\n          }\r\n\r\n          if (newIndex === 0) {\r\n            ldapSuccess = false\r\n          }\r\n\r\n          if (currentIndex === 1 && newIndex === 0) {\r\n            // Verify to Connection\r\n            $wizardLdap.find('.button_next > a').html(\"Connect  <i class='material-icons'>&#xE315;</i>\")\r\n          }\r\n\r\n          if (currentIndex === 1 && newIndex === 2) {\r\n            // Verify to Review\r\n            if (!ldapSuccess) return false\r\n          }\r\n\r\n          // if (newIndex === 3) {\r\n          //\r\n          //     // $wizardLdap.find('.button_previous').addClass('disabled').attr('aria-disabled', true);\r\n          //     // $wizardLdap.find('.button_finish').addClass('disabled').attr('aria-disabled', true);\r\n          // }\r\n\r\n          return true\r\n        },\r\n        onStepChanged: function (event, currentIndex) {\r\n          if (currentIndex === 3) {\r\n            // Last step Disable all until done.\r\n            $wizardLdap.find('.steps ul li').each(function () {\r\n              $(this).addClass('disabled')\r\n            })\r\n            $wizardLdap.find('.actions ul li').addClass('disabled')\r\n            $wizardLdap\r\n              .find('.button_previous')\r\n              .addClass('disabled')\r\n              .attr('aria-disabled', true)\r\n\r\n            var ldapStatusBox = $('#ldap-import-status-box')\r\n            var ldapStatusUL = ldapStatusBox.find('ul')\r\n            ldapStatusUL.append('<li>Starting import...</li>')\r\n            disableUIElements()\r\n\r\n            // send data\r\n            setTimeout(function () {\r\n              socket.accountsImporter.sendAccountData('ldap', addedUsers, updatedUsers)\r\n            }, 1000)\r\n          }\r\n\r\n          // Disable all future steps when moving backwards\r\n          $('.steps .current')\r\n            .nextAll()\r\n            .removeClass('done')\r\n            .addClass('disabled')\r\n\r\n          contentHeight($wizardLdap, currentIndex)\r\n        },\r\n        onFinished: function () {\r\n          location.href = '/accounts'\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  function disableUIElements () {\r\n    // $(window).on('beforeunload', function() {\r\n    //     return 'Are you sure? We are still importing users.';\r\n    // });\r\n\r\n    $('.sidebar').css({ width: 0 })\r\n    $('.side-nav-bottom-panel').css({ width: 0 })\r\n    $('#page-content').css('margin-left', 0)\r\n    $('.top-menu').css({ display: 'none' })\r\n    $('.js-wizard-select-wrapper').css({ display: 'none' })\r\n    $('.js-wizard-cancel').each(function () {\r\n      $(this).css({ display: 'none' })\r\n    })\r\n  }\r\n\r\n  function ldapReviewRender (addedUsers, updatedUsers) {\r\n    var addedUsersTemplate = []\r\n    var updatedUsersTemplate = []\r\n\r\n    if (addedUsers === null) addedUsers = []\r\n    if (updatedUsers === null) updatedUsers = []\r\n\r\n    for (var i = 0; i < addedUsers.length; i++) {\r\n      addedUsersTemplate.push(\r\n        addedUsers[i].sAMAccountName +\r\n          ' | action=add username=' +\r\n          addedUsers[i].sAMAccountName +\r\n          ' name=' +\r\n          addedUsers[i].displayName +\r\n          ' email=' +\r\n          addedUsers[i].mail +\r\n          ' title=' +\r\n          addedUsers[i].title\r\n      )\r\n    }\r\n\r\n    for (var k = 0; k < updatedUsers.length; k++) {\r\n      updatedUsersTemplate.push(\r\n        updatedUsers[k].username +\r\n          ' | action=update username=' +\r\n          updatedUsers[k].username +\r\n          ' name=' +\r\n          updatedUsers[k].fullname +\r\n          ' email=' +\r\n          updatedUsers[k].email +\r\n          ' title=' +\r\n          updatedUsers[k].title\r\n      )\r\n    }\r\n\r\n    var sep = []\r\n\r\n    if (addedUsersTemplate.length > 0) {\r\n      sep.push('----------------')\r\n    }\r\n\r\n    return _.union(addedUsersTemplate, sep, updatedUsersTemplate).join('\\r')\r\n  }\r\n\r\n  function csvReviewRender (addedUsers, updatedUsers) {\r\n    var addedUsersTemplate = []\r\n    var updatedUsersTemplate = []\r\n\r\n    if (addedUsers === null) addedUsers = []\r\n    if (updatedUsers === null) updatedUsers = []\r\n\r\n    for (var i = 0; i < addedUsers.length; i++) {\r\n      addedUsersTemplate.push(\r\n        addedUsers[i].username +\r\n          ' | action=add username=' +\r\n          addedUsers[i].username +\r\n          ' name=' +\r\n          addedUsers[i].fullname +\r\n          ' email=' +\r\n          addedUsers[i].email +\r\n          ' title=' +\r\n          addedUsers[i].title\r\n      )\r\n    }\r\n\r\n    for (var k = 0; k < updatedUsers.length; k++) {\r\n      updatedUsersTemplate.push(\r\n        updatedUsers[k].username +\r\n          ' | action=update username=' +\r\n          updatedUsers[k].username +\r\n          ' name=' +\r\n          updatedUsers[k].fullname +\r\n          ' email=' +\r\n          updatedUsers[k].email +\r\n          ' title=' +\r\n          updatedUsers[k].title\r\n      )\r\n    }\r\n\r\n    var sep = []\r\n\r\n    if (addedUsersTemplate.length > 0) {\r\n      sep.push('----------------')\r\n    }\r\n\r\n    return _.union(addedUsersTemplate, sep, updatedUsersTemplate).join('\\r')\r\n  }\r\n\r\n  function contentHeight (thisWizard, step) {\r\n    var thisHeight = $(thisWizard)\r\n      .find('.step-' + step)\r\n      .actual('outerHeight')\r\n    $(thisWizard)\r\n      .children('.content')\r\n      .velocity({ height: thisHeight }, { duration: 140, easing: [0.215, 0.61, 0.355, 1] })\r\n  }\r\n\r\n  return accountsImportPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/accountsImport.js?");

/***/ }),

/***/ 983:
/*!*********************************************!*\
  !*** ./src/public/js/pages/createNotice.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! chosen */ 19), __webpack_require__(/*! history */ 52), __webpack_require__(/*! colorpicker */ 772)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\r\n  var createNotice = {}\r\n\r\n  createNotice.init = function (callback) {\r\n    $(document).ready(function () {\r\n      $('select[name=\"nColor\"]').simplecolorpicker({ theme: 'fontawesome' })\r\n      $('select[name=\"nFontColor\"]').simplecolorpicker({ theme: 'fontawesome' })\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return createNotice\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/createNotice.js?");

/***/ }),

/***/ 973:
/*!******************************************!*\
  !*** ./src/public/js/pages/dashboard.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:46 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! underscore */ 1),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! countup */ 15),\r\n  __webpack_require__(/*! c3 */ 164),\r\n  __webpack_require__(/*! d3 */ 165),\r\n  __webpack_require__(/*! moment */ 5),\r\n  __webpack_require__(/*! d3pie */ 231),\r\n  __webpack_require__(/*! metricsgraphics */ 232),\r\n  __webpack_require__(/*! peity */ 25),\r\n  __webpack_require__(/*! history */ 52)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, CountUp, c3, d3, moment) {\r\n  var dashboardPage = {}\r\n\r\n  dashboardPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var testPage = $('#page-content').find('.dashboard')\r\n      if (testPage.length < 1) {\r\n        if (typeof callback === 'function') {\r\n          return callback()\r\n        }\r\n\r\n        return true\r\n      }\r\n\r\n      helpers.resizeAll()\r\n\r\n      dashboardPage.shortDateFormat = window.trudeskSettingsService.getSettings().shortDateFormat.value\r\n\r\n      var parms = {\r\n        full_width: true,\r\n        height: 250,\r\n        target: '#breakdownGraph',\r\n        x_accessor: 'date',\r\n        y_accessor: 'value',\r\n        y_extended_ticks: true,\r\n        show_tooltips: false,\r\n        area: [1],\r\n        aggregate_rollover: true,\r\n        transition_on_update: false\r\n        // colors: ['#2196f3']\r\n      }\r\n\r\n      var showOverdue =\r\n        $('#__showOverdueTickets')\r\n          .text()\r\n          .toLowerCase() === 'true'\r\n      if (showOverdue) {\r\n        var overdueCard = $('#overdue_tickets')\r\n        var $overdueTableBody = overdueCard.find('table.uk-table > tbody')\r\n        $overdueTableBody.empty() // Clear\r\n        $.ajax({\r\n          url: '/api/v1/tickets/overdue',\r\n          method: 'GET',\r\n          success: function (_data) {\r\n            var overdueSpinner = overdueCard.find('.card-spinner')\r\n            var html = ''\r\n            _.each(_data.tickets, function (ticket) {\r\n              html += '<tr class=\"uk-table-middle\">'\r\n              html +=\r\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><a href=\"/tickets/' +\r\n                ticket.uid +\r\n                '\">T#' +\r\n                ticket.uid +\r\n                '</a></td>'\r\n              html +=\r\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><span class=\"uk-badge ticket-status-open uk-width-1-1\">Open</span></td>'\r\n              html += '<td class=\"uk-width-6-10\">' + ticket.subject + '</td>'\r\n              if (ticket.updated) {\r\n                html +=\r\n                  '<td class=\"uk-width-2-10 uk-text-right uk-text-muted uk-text-small\">' +\r\n                  moment\r\n                    .utc(ticket.updated)\r\n                    .tz(helpers.getTimezone())\r\n                    .format(dashboardPage.shortDateFormat) +\r\n                  '</td>'\r\n              } else {\r\n                html +=\r\n                  '<td class=\"uk-width-2-10 uk-text-right uk-text-muted uk-text-small\">' +\r\n                  moment\r\n                    .utc(ticket.date)\r\n                    .tz(helpers.getTimezone())\r\n                    .format(dashboardPage.shortDateFormat) +\r\n                  '</td>'\r\n              }\r\n              html += '</tr>'\r\n            })\r\n\r\n            $overdueTableBody.append(html)\r\n            $overdueTableBody.ajaxify()\r\n            overdueSpinner.animate({ opacity: 0 }, 600, function () {\r\n              $(this).hide()\r\n            })\r\n          },\r\n          error: function (err) {\r\n            console.log('[trudesk:dashboard:loadOverdue] Error - ' + err.responseText)\r\n            helpers.UI.showSnackbar(err.responseText, true)\r\n          }\r\n        })\r\n      }\r\n\r\n      getData(30)\r\n\r\n      $('#select_timespan').on('change', function () {\r\n        var self = $(this)\r\n        getData(self.val())\r\n      })\r\n\r\n      function getData (timespan) {\r\n        $.ajax({\r\n          url: '/api/v1/tickets/stats/' + timespan,\r\n          method: 'GET',\r\n          success: function (_data) {\r\n            var lastUpdated = $('#lastUpdated').find('span')\r\n\r\n            var formatString = helpers.getLongDateFormat() + ' ' + helpers.getTimeFormat()\r\n            var formated = moment.utc(_data.lastUpdated, 'MM/DD/YYYY hh:mm:ssa').format(formatString)\r\n\r\n            lastUpdated.text(formated)\r\n\r\n            if (!_data.data) {\r\n              console.log('[trudesk:dashboard:getData] Error - Invalid Graph Data')\r\n              helpers.UI.showSnackbar('Error - Invalid Graph Data', true)\r\n            } else if (_data.data.length < 1) {\r\n              // No data in graph. Show No Data avaliable\r\n              var $breakdownGraph = $('#breakdownGraph')\r\n              $breakdownGraph.empty()\r\n              $breakdownGraph.append('<div class=\"no-data-available-text\">No Data Available</div>')\r\n            } else {\r\n              $('#breakdownGraph').empty()\r\n              parms.data = MG.convert.date(_data.data, 'date')\r\n              MG.data_graphic(parms)\r\n            }\r\n\r\n            var tCount = _data.ticketCount\r\n\r\n            var ticketCount = $('#ticketCount')\r\n            var oldTicketCount = ticketCount.text() === '--' ? 0 : ticketCount.text()\r\n            var totalTicketText = 'Total Tickets (last ' + timespan + 'd)'\r\n            // if (timespan == 0)\r\n            //     totalTicketText = 'Total Tickets (lifetime)';\r\n            ticketCount\r\n              .parents('.tru-card-content')\r\n              .find('span.uk-text-small')\r\n              .text(totalTicketText)\r\n            var theAnimation = new CountUp('ticketCount', parseInt(oldTicketCount), tCount, 0, 1.5)\r\n            theAnimation.start()\r\n\r\n            var closedCount = Number(_data.closedCount)\r\n            var closedPercent = Math.round((closedCount / tCount) * 100)\r\n\r\n            var textComplete = $('#text_complete')\r\n            var oldTextComplete = textComplete.text() === '--' ? 0 : textComplete.text()\r\n            var completeAnimation = new CountUp('text_complete', parseInt(oldTextComplete), closedPercent, 0, 1.5)\r\n            completeAnimation.start()\r\n\r\n            var pieComplete = $('#pie_complete')\r\n            pieComplete.text(closedPercent + '/100')\r\n            pieComplete.peity('donut', {\r\n              height: 24,\r\n              width: 24,\r\n              fill: ['#29b955', '#ccc']\r\n            })\r\n\r\n            var $responseTimeText = $('#responseTime_text')\r\n            // var responseTime_graph = $('#responseTime_graph');\r\n            var oldResponseTime = $responseTimeText.text() === '--' ? 0 : $responseTimeText.text()\r\n            var responseTime = _data.ticketAvg\r\n            var responseTimeAnimation = new CountUp(\r\n              'responseTime_text',\r\n              parseInt(oldResponseTime),\r\n              responseTime,\r\n              0,\r\n              1.5\r\n            )\r\n            responseTimeAnimation.start()\r\n\r\n            // QuickStats\r\n            var mostRequester = $('#mostRequester')\r\n            if (_data.mostRequester) {\r\n              mostRequester.text(_data.mostRequester.name + ' (' + _data.mostRequester.value + ')')\r\n            }\r\n            var mostCommenter = $('#mostCommenter')\r\n            if (_data.mostCommenter) {\r\n              mostCommenter.text(_data.mostCommenter.name + ' (' + _data.mostCommenter.value + ')')\r\n            } else {\r\n              mostCommenter.text('--')\r\n            }\r\n\r\n            var mostAssignee = $('#mostAssignee')\r\n            if (_data.mostAssignee) {\r\n              mostAssignee.text(_data.mostAssignee.name + ' (' + _data.mostAssignee.value + ')')\r\n            } else {\r\n              mostAssignee.text('--')\r\n            }\r\n\r\n            var mostActiveTicket = $('#mostActiveTicket')\r\n            if (_data.mostActiveTicket) {\r\n              mostActiveTicket\r\n                .attr('href', '/tickets/' + _data.mostActiveTicket.uid)\r\n                .text('T#' + _data.mostActiveTicket.uid)\r\n            }\r\n          },\r\n          error: function (err) {\r\n            console.log('[trudesk:dashboard:getData] Error - ' + err.responseText)\r\n            helpers.UI.showSnackbar(err.responseText, true)\r\n          }\r\n        })\r\n\r\n        $('#topTenTags')\r\n          .parents('.panel')\r\n          .find('.card-spinner')\r\n          .css({ display: 'block', opacity: 1 })\r\n        $.ajax({\r\n          url: '/api/v1/tickets/count/tags/' + timespan,\r\n          method: 'GET',\r\n          success: function (data) {\r\n            var arr = _.map(data.tags, function (v, key) {\r\n              return [key, v]\r\n            })\r\n\r\n            arr = _.first(arr, 10)\r\n            var colors = [\r\n              '#e74c3c',\r\n              '#3498db',\r\n              '#9b59b6',\r\n              '#34495e',\r\n              '#1abc9c',\r\n              '#2ecc71',\r\n              '#03A9F4',\r\n              '#00BCD4',\r\n              '#009688',\r\n              '#4CAF50',\r\n              '#FF5722',\r\n              '#CDDC39',\r\n              '#FFC107',\r\n              '#00E5FF',\r\n              '#E040FB',\r\n              '#607D8B'\r\n            ]\r\n\r\n            var c = _.object(\r\n              _.map(arr, function (v) {\r\n                return v[0]\r\n              }),\r\n              _.shuffle(colors)\r\n            )\r\n\r\n            c3.generate({\r\n              bindto: d3.select('#topTenTags'),\r\n              size: {\r\n                height: 200\r\n              },\r\n              data: {\r\n                columns: arr,\r\n                type: 'donut',\r\n                colors: c,\r\n                empty: { label: { text: 'No Data Available' } }\r\n              },\r\n              donut: {\r\n                label: {\r\n                  format: function () {\r\n                    return ''\r\n                  }\r\n                }\r\n              }\r\n            })\r\n\r\n            $('#topTenTags')\r\n              .parents('.panel')\r\n              .find('.card-spinner')\r\n              .animate({ opacity: 0 }, 600, function () {\r\n                $(this).hide()\r\n              })\r\n          }\r\n        })\r\n\r\n        $('#pieChart')\r\n          .parent()\r\n          .find('.card-spinner')\r\n          .css({ display: 'block', opacity: 1 })\r\n        $.ajax({\r\n          url: '/api/v1/tickets/count/topgroups/' + timespan + '/5',\r\n          method: 'GET',\r\n          success: function (data) {\r\n            var arr = _.map(data.items, function (v) {\r\n              return [v.name, v.count]\r\n            })\r\n\r\n            var colors = [\r\n              '#e74c3c',\r\n              '#3498db',\r\n              '#9b59b6',\r\n              '#34495e',\r\n              '#1abc9c',\r\n              '#2ecc71',\r\n              '#03A9F4',\r\n              '#00BCD4',\r\n              '#009688',\r\n              '#4CAF50',\r\n              '#FF5722',\r\n              '#CDDC39',\r\n              '#FFC107',\r\n              '#00E5FF',\r\n              '#E040FB',\r\n              '#607D8B'\r\n            ]\r\n\r\n            colors = _.shuffle(colors)\r\n\r\n            var c = _.object(\r\n              _.map(arr, function (v) {\r\n                return v[0]\r\n              }),\r\n              colors\r\n            )\r\n\r\n            c3.generate({\r\n              bindto: d3.select('#pieChart'),\r\n              size: {\r\n                height: 200\r\n              },\r\n              data: {\r\n                columns: arr,\r\n                type: 'pie',\r\n                colors: c,\r\n                empty: { label: { text: 'No Data Available' } }\r\n              },\r\n              donut: {\r\n                label: {\r\n                  format: function () {\r\n                    return ''\r\n                  }\r\n                }\r\n              }\r\n            })\r\n\r\n            $('#pieChart')\r\n              .parent()\r\n              .find('.card-spinner')\r\n              .animate({ opacity: 0 }, 600, function () {\r\n                $(this).hide()\r\n              })\r\n          }\r\n        })\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return dashboardPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/dashboard.js?");

/***/ }),

/***/ 978:
/*!***************************************!*\
  !*** ./src/public/js/pages/groups.js ***!
  \***************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! uikit */ 4),\r\n  __webpack_require__(/*! datatables */ 3),\r\n  __webpack_require__(/*! dt_responsive */ 26),\r\n  __webpack_require__(/*! dt_grouping */ 27),\r\n  // 'dt_foundation',\r\n  __webpack_require__(/*! dt_scroller */ 28),\r\n  __webpack_require__(/*! history */ 52)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, helpers, UIkit) {\r\n  var groupsPage = {}\r\n\r\n  groupsPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      // get all filters\r\n      var filterArray = []\r\n      $('#group_list')\r\n        .children()\r\n        .each(function () {\r\n          var thisfilter = $(this).attr('data-uk-filter')\r\n          if ($.inArray(thisfilter, filterArray) === -1) {\r\n            filterArray.push(thisfilter)\r\n          }\r\n        })\r\n\r\n      var filterArrayLength = filterArray.length\r\n\r\n      var grid = UIkit.grid($('#group_list'), {\r\n        controls: '',\r\n        gutter: 20\r\n      })\r\n\r\n      // find user\r\n      $('#group_list_search')\r\n        .keyup(function () {\r\n          var sValue = $(this)\r\n            .val()\r\n            .toLowerCase()\r\n\r\n          if (sValue.length > 2) {\r\n            var filteredItems = ''\r\n            for (var $i = 0; $i < filterArrayLength; $i++) {\r\n              if (filterArray[$i].toLowerCase().indexOf(sValue) !== -1) {\r\n                filteredItems += (filteredItems.length > 1 ? ',' : '') + filterArray[$i]\r\n              }\r\n            }\r\n\r\n            if (filteredItems) {\r\n              // filter grid items\r\n              grid.filter(filteredItems)\r\n            } else {\r\n              // show all\r\n              grid.filter('all')\r\n            }\r\n          } else {\r\n            // reset filter\r\n            grid.filter()\r\n          }\r\n        })\r\n        .on('blur', function () {\r\n          // clear search input\r\n          // $(this).val('');\r\n        })\r\n\r\n      //            var table = $('#groupsTable');\r\n      //            table.dataTable({\r\n      //                searching: true,\r\n      //                bLengthChange: false,\r\n      //                bPaginate: false,\r\n      //                iDisplayLength: 99999,\r\n      //                bInfo: false,\r\n      //                scrollY: '100%',\r\n      //                order: [[1, 'asc']],\r\n      //                columnDefs: [\r\n      //                    {\"width\": \"50px\", \"targets\": 0}\r\n      //                ]\r\n      //            });\r\n      /// /                .rowGrouping({\r\n      /// /                iGroupingColumnIndex: 5,\r\n      /// /                sGroupingColumnSortDirection: \"asc\",\r\n      /// /                iGroupingOrderByColumnIndex: 1,\r\n      /// /                bHideGroupingColumn: false,\r\n      /// /                bHideGroupingOrderByColumn: false\r\n      /// /            });\r\n      //\r\n      //            helpers.resizeDataTables('.groupsList');\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return groupsPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/groups.js?");

/***/ }),

/***/ 985:
/*!*************************************!*\
  !*** ./src/public/js/pages/logs.js ***!
  \*************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! modules/socket */ 36), __webpack_require__(/*! history */ 52)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, socket) {\r\n  var logsPage = {}\r\n\r\n  logsPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      socket.ui.fetchServerLogs()\r\n      var $sLogs = $('#serverlogs')\r\n      if ($sLogs.length > 0) {\r\n        $sLogs.scrollTop(99999999999999 * 999999999999999)\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return logsPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/logs.js?");

/***/ }),

/***/ 974:
/*!*****************************************!*\
  !*** ./src/public/js/pages/messages.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! underscore */ 1),\r\n  __webpack_require__(/*! angular */ 7),\r\n  __webpack_require__(/*! uikit */ 4),\r\n  __webpack_require__(/*! moment */ 5),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! modules/socket */ 36),\r\n  __webpack_require__(/*! history */ 52),\r\n  __webpack_require__(/*! isinview */ 359)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, angular, UIKit, moment, helpers) {\r\n  var messagesPage = {}\r\n\r\n  messagesPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var $messageScroller = $('#message-content.scrollable')\r\n\r\n      var $messagesWrapper = $('#messages')\r\n\r\n      var $scrollspy = $('#conversation-scrollspy')\r\n\r\n      var $spinner = $scrollspy.find('i')\r\n\r\n      var $searchBox = $('.search-box').find('input')\r\n\r\n      var $nextPage = 2\r\n\r\n      var $enabled = true\r\n\r\n      var $loading = false\r\n\r\n      // $inview             = null,\r\n\r\n      var $recentMessages = {}\r\n\r\n      var $convoId = $('#message-content[data-conversation-id]').attr('data-conversation-id')\r\n\r\n      var $loggedInAccountId = window.trudeskSessionService.getUser()._id\r\n\r\n      // Setup Context Menu\r\n      helpers.setupContextMenu('#convo-list > ul > li', function (action, target) {\r\n        var $li = $(target)\r\n        if (!$li.is('li')) {\r\n          $li = $(target).parents('li')\r\n        }\r\n        var convoId = $li.attr('data-conversation-id')\r\n        if (action.toLowerCase() === 'delete') {\r\n          UIKit.modal.confirm(\r\n            'Are you sure you want to delete this conversation?',\r\n            function () {\r\n              // Confirm\r\n              deleteConversation(convoId)\r\n            },\r\n            function () {\r\n              // Cancel\r\n            },\r\n            {\r\n              labels: {\r\n                Ok: 'YES'\r\n              },\r\n              confirmButtonClass: 'md-btn-danger'\r\n            }\r\n          )\r\n        }\r\n      })\r\n\r\n      $searchBox.off('keyup')\r\n      $searchBox.on('keyup', onSearchKeyUp)\r\n\r\n      $(window).off('$trudesk:ready.messages')\r\n      $(window).on('$trudesk:ready.messages', function () {\r\n        helpers.scrollToBottom($messageScroller)\r\n\r\n        // set active\r\n        if ($convoId !== undefined) {\r\n          var item = $('ul > li[data-conversation-id=\"' + $convoId + '\"]')\r\n          item.addClass('active')\r\n        }\r\n\r\n        // Remove All Chat Boxes\r\n        if (\r\n          $('#__page')\r\n            .text()\r\n            .toLowerCase() === 'messages'\r\n        ) {\r\n          $('.chat-box-position').each(function () {\r\n            var self = $(this)\r\n            self.remove()\r\n          })\r\n\r\n          $('.message-textbox')\r\n            .find('input')\r\n            .focus()\r\n\r\n          $messageScroller.scroll(function () {\r\n            if ($scrollspy.isInView($messageScroller)) {\r\n              var run = _.throttle(loadMoreMessages, 100)\r\n              run()\r\n            }\r\n          })\r\n        }\r\n      })\r\n\r\n      function deleteConversation (convoId) {\r\n        $.ajax({\r\n          url: '/api/v1/messages/conversation/' + convoId,\r\n          method: 'DELETE',\r\n          success: function (response) {\r\n            if (response.success) {\r\n              // Check if on conversation\r\n              var $convo = $('#message-content[data-conversation-id=\"' + response.conversation._id + '\"]')\r\n              if ($convo.length > 0) {\r\n                History.pushState(null, null, '/messages', false)\r\n              } else {\r\n                var $convoLI = $('#convo-list').find('li[data-conversation-id=\"' + response.conversation._id + '\"]')\r\n                if ($convoLI.length > 0) {\r\n                  $convoLI.remove()\r\n                }\r\n              }\r\n\r\n              $.event.trigger('$trudesk:chat:conversation:deleted', {\r\n                conversation: response.conversation\r\n              })\r\n\r\n              helpers.UI.showSnackbar('Conversation Deleted.', false)\r\n            }\r\n          },\r\n          error: function (error) {\r\n            console.log(error)\r\n          }\r\n        })\r\n      }\r\n\r\n      function onSearchKeyUp () {\r\n        var searchTerm = $searchBox.val().toLowerCase()\r\n        $('.all-user-list li').each(function () {\r\n          if ($(this).filter('[data-search-term *= ' + searchTerm + ']').length > 0 || searchTerm.length < 1) {\r\n            $(this).show()\r\n          } else {\r\n            $(this).hide()\r\n          }\r\n        })\r\n      }\r\n\r\n      function loadMoreMessages () {\r\n        if (!$enabled || $loading) return false\r\n        if (_.isUndefined($convoId)) return false\r\n        $loading = true\r\n        $spinner.removeClass('uk-hidden')\r\n\r\n        // Load Messages\r\n        $.ajax({\r\n          url: '/api/v1/messages/conversation/' + $convoId + '?page=' + $nextPage\r\n        })\r\n          .done(function (data) {\r\n            $spinner.addClass('uk-hidden')\r\n            var messages = data.messages\r\n            if (_.size(messages) < 1) {\r\n              $enabled = false\r\n              $loading = false\r\n              return false\r\n            }\r\n\r\n            var html = ''\r\n\r\n            _.each(messages, function (m) {\r\n              var h = buildMessageHTML(m)\r\n              if (h.length > 0) html += h\r\n            })\r\n\r\n            var stage = $('<div></div>')\r\n              .appendTo('body')\r\n              .addClass('stage')\r\n              .css({\r\n                opacity: 0,\r\n                visibility: 'hidden',\r\n                position: 'absolute',\r\n                top: '-9999em',\r\n                left: '-9999em'\r\n              })\r\n              .append(html)\r\n            var height = $(stage).outerHeight()\r\n            $(stage).remove()\r\n\r\n            $messagesWrapper.prepend(html)\r\n\r\n            UIKit.$html.trigger('changed.uk.dom')\r\n            $messageScroller.scrollTop(height, true)\r\n\r\n            $nextPage = $nextPage + 1\r\n            $loading = false\r\n          })\r\n          .error(function (err) {\r\n            console.log(err)\r\n          })\r\n      }\r\n\r\n      function buildMessageHTML (message) {\r\n        var html = ''\r\n        var loggedInAccountId = window.trudeskSessionService.getUser()._id\r\n        if (loggedInAccountId === undefined) return false\r\n        var left = true\r\n        if (message.owner._id.toString() === loggedInAccountId.toString()) {\r\n          left = false\r\n        }\r\n\r\n        var image = message.owner.image === undefined ? 'defaultProfile.jpg' : message.owner.image\r\n\r\n        if (left) {\r\n          html += '<div class=\"message message-left\">'\r\n          html +=\r\n            '<img class=\"profileImage\" src=\"/uploads/users/' +\r\n            image +\r\n            '\" data-userId=\"' +\r\n            message.owner._id +\r\n            '\" data-uk-tooltip=\"{pos:\\'left\\', animation: false}\" title=\"' +\r\n            message.owner.fullname +\r\n            ' - ' +\r\n            moment(message.createdAt)\r\n              .tz(helpers.getTimezone())\r\n              .format(helpers.getShortDateFormat() + ' ' + helpers.getTimeFormat()) +\r\n            '\"/>'\r\n          html += '<div class=\"message-body\">'\r\n          html += '<p>' + message.body + '</p>'\r\n          html += '</div>'\r\n          html += '</div>'\r\n        } else {\r\n          html += '<div class=\"message message-right\">'\r\n          html +=\r\n            '<div class=\"message-body\" data-uk-tooltip=\"{pos:\\'right\\', animation: false}\" title=\"' +\r\n            moment(message.createdAt)\r\n              .tz(helpers.getTimezone())\r\n              .format(helpers.getShortDateFormat() + ' ' + helpers.getTimeFormat()) +\r\n            '\">'\r\n          html += '<p>' + message.body + '</p>'\r\n          html += '</div>'\r\n          html += '</div>'\r\n        }\r\n\r\n        return html\r\n      }\r\n\r\n      // Remove all Events in the .conversation namespace for this page.\r\n      $(window).off('.conversation')\r\n\r\n      // On user Typing\r\n      $(window).on('$trudesk:chat:typing.conversation', function (event, data) {\r\n        var convoListItem = $('#convo-list').find('li[data-conversation-id=\"' + data.cid + '\"]')\r\n        if (convoListItem.length > 0) {\r\n          $recentMessages[data.cid] = convoListItem.find('.message-subject').text()\r\n          convoListItem.find('.message-subject').text(data.fromUser.fullname + ' is typing...')\r\n        }\r\n      })\r\n\r\n      $(window).on('$trudesk:chat:stoptyping.conversation', function (event, data) {\r\n        var convoListItem = $('#convo-list').find('li[data-conversation-id=\"' + data.cid + '\"]')\r\n        if (convoListItem.length > 0) {\r\n          convoListItem.find('.message-subject').text($recentMessages[data.cid])\r\n        }\r\n      })\r\n\r\n      // On Chat Message\r\n      $(window).on('$trudesk:chat:message.conversation', function (event, data) {\r\n        var message = {\r\n          _id: data.messageId,\r\n          conversation: data.conversation,\r\n          body: data.message,\r\n          owner: data.fromUser\r\n        }\r\n\r\n        var html = buildMessageHTML(message)\r\n        var messageWrapper = $('#message-content[data-conversation-id=\"' + message.conversation + '\"]')\r\n        if (messageWrapper.length > 0) {\r\n          messageWrapper.find('#messages').append(html)\r\n        }\r\n\r\n        var convoListItem = $('li[data-conversation-id=\"' + data.conversation + '\"]')\r\n        if (convoListItem.length > 0) {\r\n          convoListItem.attr('data-updatedAt', new Date())\r\n          var ul = convoListItem.parent('ul')\r\n          var li = ul.children('li')\r\n          li.detach().sort(function (a, b) {\r\n            return new Date($(a).attr('data-updatedAt')) < new Date($(b).attr('data-updatedAt'))\r\n          })\r\n\r\n          ul.append(li)\r\n\r\n          var fromName = message.owner.fullname\r\n          if (message.owner._id.toString() === $loggedInAccountId) {\r\n            fromName = 'You'\r\n          }\r\n\r\n          convoListItem.find('.message-subject').text(fromName + ': ' + message.body)\r\n          $recentMessages[message.conversation] = fromName + ': ' + message.body\r\n          var timezone = helpers.getTimezone()\r\n          convoListItem.find('.message-date').text(\r\n            moment\r\n              .utc()\r\n              .tz(timezone)\r\n              .calendar()\r\n          )\r\n        } else {\r\n          var convoUL = $('#convo-list > ul.message-items')\r\n          if (convoUL.length > 0) {\r\n            var partner = message.owner\r\n            if (message.owner._id.toString() === $loggedInAccountId.toString()) {\r\n              partner = data.toUser\r\n            }\r\n            var newLI = buildConversationListItem({\r\n              _id: message.conversation,\r\n              partner: partner,\r\n              updatedAt: new Date(),\r\n              recentMessage: message.owner.fullname + ': ' + message.body\r\n            })\r\n\r\n            var $injector = angular.injector(['ng', 'trudesk'])\r\n            $injector.invoke([\r\n              '$compile',\r\n              '$rootScope',\r\n              function ($compile, $rootScope) {\r\n                var $scope = convoUL.prepend(newLI).scope()\r\n                $compile(convoUL)($scope || $rootScope)\r\n                $rootScope.$digest()\r\n              }\r\n            ])\r\n          }\r\n        }\r\n\r\n        UIKit.$html.trigger('changed.uk.dom')\r\n        helpers.scrollToBottom($messageScroller)\r\n      })\r\n\r\n      function buildConversationListItem (data) {\r\n        var html = ''\r\n\r\n        html +=\r\n          '<li ng-click=\"loadConversation(\\'' +\r\n          data._id +\r\n          '\\');\" data-conversation-id=\"' +\r\n          data._id +\r\n          '\" data-updatedAt=\"' +\r\n          data.updatedAt +\r\n          '\">'\r\n        html += '<div class=\"profile-pic\">'\r\n        var imageUrl = 'defaultProfile.jpg'\r\n        if (data.partner.image) {\r\n          imageUrl = data.partner.image\r\n        }\r\n        html +=\r\n          '<img src=\"/uploads/users/' +\r\n          imageUrl +\r\n          '\" class=\"uk-border-circle profileImage\" data-userid=\"' +\r\n          data.partner._id +\r\n          '\" />'\r\n        html += '<span class=\"user-online uk-border-circle\" data-user-status-id=\"' + data.partner._id + '\"></span>'\r\n        html += '</div>'\r\n        html += '<div class=\"convo-info\">'\r\n        html += '<span class=\"message-from\">' + data.partner.fullname + '</span>'\r\n        html += '<span class=\"message-date\">' + moment(data.updatedAt).calendar() + '</span>'\r\n        html += '<span class=\"message-subject\">' + data.recentMessage + '</span>'\r\n        html += '</div>'\r\n        html += '</li>'\r\n\r\n        return html\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return messagesPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/messages.js?");

/***/ }),

/***/ 982:
/*!****************************************!*\
  !*** ./src/public/js/pages/notices.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! colorpicker */ 772),\r\n  __webpack_require__(/*! datatables */ 3),\r\n  __webpack_require__(/*! dt_responsive */ 26),\r\n  __webpack_require__(/*! dt_grouping */ 27),\r\n  // 'dt_foundation',\r\n  __webpack_require__(/*! dt_scroller */ 28),\r\n  __webpack_require__(/*! history */ 52)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, helpers) {\r\n  var noticesPage = {}\r\n\r\n  noticesPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var table = $('#noticesTable')\r\n      table.dataTable({\r\n        searching: false,\r\n        bLengthChange: false,\r\n        bPaginate: false,\r\n        bInfo: false,\r\n        bSort: false,\r\n        scrollY: '100%',\r\n        order: [[3, 'desc']],\r\n        columnDefs: [\r\n          { width: '50px', targets: 0 },\r\n          { width: '20%', targets: 1 },\r\n          { width: '50%', targets: 2 },\r\n          { width: '20%', targets: 3 },\r\n          { width: '50px', targets: 4 }\r\n        ],\r\n        oLanguage: {\r\n          sEmptyTable: 'No notices to display.'\r\n        }\r\n      })\r\n      //                .rowGrouping({\r\n      //                iGroupingColumnIndex: 5,\r\n      //                sGroupingColumnSortDirection: \"asc\",\r\n      //                iGroupingOrderByColumnIndex: 1,\r\n      //                bHideGroupingColumn: false,\r\n      //                bHideGroupingOrderByColumn: false\r\n      //            });\r\n\r\n      helpers.resizeDataTables('.noticesList')\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return noticesPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/notices.js?");

/***/ }),

/***/ 984:
/*!****************************************!*\
  !*** ./src/public/js/pages/plugins.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! modules/helpers */ 11), __webpack_require__(/*! tether */ 16), __webpack_require__(/*! history */ 52)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, helpers, Tether) {\r\n  var pluginsPage = {}\r\n\r\n  pluginsPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var $searchPluginList = $('#search_plugin_list')\r\n      $searchPluginList.off('keyup')\r\n      $searchPluginList.on('keyup', function () {\r\n        var value = this.value.toLowerCase()\r\n        $('table#plugin_list_table')\r\n          .find('tbody')\r\n          .find('tr')\r\n          .each(function () {\r\n            var id = $(this)\r\n              .find('td')\r\n              .text()\r\n              .toLowerCase()\r\n            $(this).toggle(id.indexOf(value) !== -1)\r\n          })\r\n      })\r\n\r\n      if ($('.plugin-tether').length > 0) {\r\n        // eslint-disable-next-line\r\n        new Tether({\r\n          element: '.plugin-tether',\r\n          target: '.tether-plugins',\r\n          attachment: 'top left',\r\n          targetAttachment: 'top right',\r\n          offset: '0 -20px'\r\n        })\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return pluginsPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/plugins.js?");

/***/ }),

/***/ 979:
/*!****************************************!*\
  !*** ./src/public/js/pages/profile.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! qrcode */ 362), __webpack_require__(/*! history */ 52)], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\r\n  var profile = {}\r\n\r\n  profile.init = function (callback) {\r\n    $(document).ready(function () {\r\n      generateQRCode()\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  function generateQRCode () {\r\n    var $totp = $('#totp-qrcode')\r\n    var hasKey = $totp.attr('data-hasKey')\r\n    var key = $totp.attr('data-totpkey')\r\n    if (hasKey === 'true') {\r\n      $totp.qrcode({ width: 242, height: 242, text: key })\r\n    } else {\r\n      $('input#tOTPKey').addClass('hide')\r\n      $('.totp-settings-wrap .panel-body2').addClass('hide')\r\n    }\r\n  }\r\n\r\n  return profile\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/profile.js?");

/***/ }),

/***/ 980:
/*!****************************************!*\
  !*** ./src/public/js/pages/reports.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! underscore */ 1),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! countup */ 15),\r\n  __webpack_require__(/*! c3 */ 164),\r\n  __webpack_require__(/*! d3pie */ 231),\r\n  __webpack_require__(/*! metricsgraphics */ 232),\r\n  __webpack_require__(/*! peity */ 25),\r\n  __webpack_require__(/*! history */ 52)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, CountUp, c3) {\r\n  var reportsPage = {}\r\n\r\n  function getData (timespan) {\r\n    var parms = {\r\n      full_width: true,\r\n      height: 250,\r\n      target: '#test',\r\n      x_accessor: 'date',\r\n      y_accessor: 'value',\r\n      y_extended_ticks: true,\r\n      show_tooltips: false,\r\n      aggregate_rollover: true,\r\n      transition_on_update: false,\r\n      colors: ['#2196f3', 'red']\r\n    }\r\n\r\n    $.ajax({\r\n      url: '/api/v1/tickets/stats/' + timespan,\r\n      method: 'GET',\r\n      success: function (_data) {\r\n        var lastUpdated = $('#lastUpdated').find('span')\r\n        lastUpdated.text(_data.lastUpdated)\r\n\r\n        if (!_data.data) {\r\n          console.log('[trudesk:dashboard:getData] Error - Invalid Graph Data')\r\n          helpers.UI.showSnackbar('Error - Invalid Graph Data', true)\r\n        } else {\r\n          parms.data = MG.convert.date(_data.data, 'date')\r\n          MG.data_graphic(parms)\r\n        }\r\n\r\n        // var tCount = _(_data.data).reduce(function(m, x) { return m + x.value; }, 0);\r\n        var tCount = _data.ticketCount\r\n\r\n        var ticketCount = $('#ticketCount')\r\n        var oldTicketCount = ticketCount.text() === '--' ? 0 : ticketCount.text()\r\n        var totalTicketText = 'Total Tickets (last ' + timespan + 'd)'\r\n        if (timespan === 0) {\r\n          totalTicketText = 'Total Tickets (lifetime)'\r\n        }\r\n        ticketCount\r\n          .parents('.tru-card-content')\r\n          .find('span.uk-text-small')\r\n          .text(totalTicketText)\r\n        var theAnimation = new CountUp('ticketCount', parseInt(oldTicketCount), tCount, 0, 1.5)\r\n        theAnimation.start()\r\n\r\n        var closedCount = Number(_data.closedCount)\r\n        var closedPercent = Math.round((closedCount / tCount) * 100)\r\n\r\n        var textComplete = $('#text_complete')\r\n        var oldTextComplete = textComplete.text() === '--' ? 0 : textComplete.text()\r\n        var completeAnimation = new CountUp('text_complete', parseInt(oldTextComplete), closedPercent, 0, 1.5)\r\n        completeAnimation.start()\r\n\r\n        var pieComplete = $('#pie_complete')\r\n        pieComplete.text(closedPercent + '/100')\r\n        pieComplete.peity('donut', {\r\n          height: 24,\r\n          width: 24,\r\n          fill: ['#29b955', '#ccc']\r\n        })\r\n\r\n        var responseTimeText = $('#responseTime_text')\r\n        // var responseTime_graph = $('#responseTime_graph');\r\n        var oldResponseTime = responseTimeText.text() === '--' ? 0 : responseTimeText.text()\r\n        var responseTime = _data.ticketAvg\r\n        var responeTimeAnimation = new CountUp('responseTime_text', parseInt(oldResponseTime), responseTime, 0, 1.5)\r\n        responeTimeAnimation.start()\r\n      }\r\n    }).error(function (err) {\r\n      // console.log(err);\r\n      console.log('[trudesk:dashboard:getData] Error - ' + err.responseText)\r\n      helpers.UI.showSnackbar(err.responseText, true)\r\n    })\r\n\r\n    $.ajax({\r\n      url: '/api/v1/tickets/count/tags/' + timespan,\r\n      method: 'GET',\r\n      success: function (data) {\r\n        var arr = _.map(data.tags, function (v, key) {\r\n          return [key, v]\r\n        })\r\n\r\n        arr = _.first(arr, 10)\r\n\r\n        var colors = [\r\n          '#e74c3c',\r\n          '#3498db',\r\n          '#9b59b6',\r\n          '#34495e',\r\n          '#1abc9c',\r\n          '#2ecc71',\r\n          '#03A9F4',\r\n          '#00BCD4',\r\n          '#009688',\r\n          '#4CAF50',\r\n          '#FF5722',\r\n          '#CDDC39',\r\n          '#FFC107',\r\n          '#00E5FF',\r\n          '#E040FB',\r\n          '#607D8B'\r\n        ]\r\n\r\n        var c = _.object(\r\n          _.map(arr, function (v) {\r\n            return v[0]\r\n          }),\r\n          _.shuffle(colors)\r\n        )\r\n\r\n        c3.generate({\r\n          bindto: d3.select('#topTenTags'),\r\n          size: {\r\n            height: 200\r\n          },\r\n          data: {\r\n            columns: arr,\r\n            type: 'donut',\r\n            colors: c,\r\n            empty: { label: { text: 'No Data Available' } }\r\n          },\r\n          donut: {\r\n            label: {\r\n              format: function () {\r\n                return ''\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n    })\r\n\r\n    $.ajax({\r\n      url: '/api/v1/tickets/count/topgroups/' + timespan + '/5',\r\n      method: 'GET',\r\n      success: function (data) {\r\n        var arr = _.map(data.items, function (v) {\r\n          return [v.name, v.count]\r\n        })\r\n\r\n        var colors = [\r\n          '#e74c3c',\r\n          '#3498db',\r\n          '#9b59b6',\r\n          '#34495e',\r\n          '#1abc9c',\r\n          '#2ecc71',\r\n          '#03A9F4',\r\n          '#00BCD4',\r\n          '#009688',\r\n          '#4CAF50',\r\n          '#FF5722',\r\n          '#CDDC39',\r\n          '#FFC107',\r\n          '#00E5FF',\r\n          '#E040FB',\r\n          '#607D8B'\r\n        ]\r\n\r\n        colors = _.shuffle(colors)\r\n\r\n        var c = _.object(\r\n          _.map(arr, function (v) {\r\n            return v[0]\r\n          }),\r\n          colors\r\n        )\r\n\r\n        c3.generate({\r\n          bindto: d3.select('#pieChart'),\r\n          size: {\r\n            height: 200\r\n          },\r\n          data: {\r\n            columns: arr,\r\n            type: 'pie',\r\n            colors: c,\r\n            empty: { label: { text: 'No Data Available' } }\r\n          },\r\n          donut: {\r\n            label: {\r\n              format: function () {\r\n                return ''\r\n              }\r\n            }\r\n          }\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  reportsPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var testPage = $('#page-content').find('.reportsOverview')\r\n      if (testPage.length < 1) {\r\n        if (typeof callback === 'function') {\r\n          return callback()\r\n        }\r\n      } else {\r\n        helpers.resizeAll()\r\n\r\n        getData(30)\r\n\r\n        $('#select_timespan').on('change', function () {\r\n          var self = $(this)\r\n          getData(self.val())\r\n        })\r\n\r\n        if (typeof callback === 'function') {\r\n          return callback()\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  return reportsPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/reports.js?");

/***/ }),

/***/ 981:
/*!*************************************************!*\
  !*** ./src/public/js/pages/reportsBreakdown.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n *       .                             .o8                     oooo\r\n *    .o8                             \"888                     `888\r\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\r\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\r\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\r\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\r\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\r\n *  ========================================================================\r\n *  Author:     Chris Brame\r\n *  Updated:    1/20/19 4:43 PM\r\n *  Copyright (c) 2014-2019. All rights reserved.\r\n */\r\n\r\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n  __webpack_require__(/*! jquery */ 0),\r\n  __webpack_require__(/*! underscore */ 1),\r\n  __webpack_require__(/*! modules/helpers */ 11),\r\n  __webpack_require__(/*! countup */ 15),\r\n  __webpack_require__(/*! c3 */ 164),\r\n  __webpack_require__(/*! d3pie */ 231),\r\n  __webpack_require__(/*! moment */ 5),\r\n  __webpack_require__(/*! metricsgraphics */ 232),\r\n  __webpack_require__(/*! peity */ 25),\r\n  __webpack_require__(/*! history */ 52)\r\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, CountUp, c3, d3pie, moment) {\r\n  var reportsBreakdownPage = {}\r\n\r\n  reportsBreakdownPage.init = function (callback) {\r\n    $(document).ready(function () {\r\n      var testPage = $('#page-content').find('.reportsBreakdownGroup')\r\n      if (testPage.length < 1) {\r\n        testPage = $('#page-content').find('.reportsBreakdownUser')\r\n        if (testPage.length < 1) {\r\n          if (typeof callback === 'function') {\r\n            return callback()\r\n          }\r\n\r\n          return true\r\n        }\r\n      }\r\n\r\n      helpers.resizeAll()\r\n\r\n      var parms = {\r\n        full_width: true,\r\n        height: 250,\r\n        target: '#test',\r\n        x_accessor: 'date',\r\n        y_accessor: 'value',\r\n        y_extended_ticks: true,\r\n        show_tooltips: false,\r\n        aggregate_rollover: true,\r\n        transition_on_update: false,\r\n        colors: ['green', 'red']\r\n      }\r\n\r\n      $('#select_group').on('change', function () {\r\n        var self = $(this)\r\n        getData('/api/v1/tickets/stats/group/' + self.val())\r\n      })\r\n\r\n      $('#select_user').on('change', function () {\r\n        var self = $(this)\r\n\r\n        getData('/api/v1/tickets/stats/user/' + self.val())\r\n      })\r\n\r\n      function getData (url) {\r\n        $.ajax({\r\n          url: url,\r\n          method: 'GET',\r\n          success: function (_data) {\r\n            if (_data.data.graphData) {\r\n              parms.data = MG.convert.date(_data.data.graphData, 'date')\r\n              MG.data_graphic(parms)\r\n            }\r\n\r\n            var tCount = _data.data.ticketCount\r\n            var ticketCount = $('#ticketCount')\r\n            var oldTicketCount = ticketCount.text() === '--' ? 0 : ticketCount.text()\r\n            var totalTicketText = 'Total Tickets (lifetime)'\r\n            ticketCount\r\n              .parents('.tru-card-content')\r\n              .find('span.uk-text-small')\r\n              .text(totalTicketText)\r\n            var theAnimation = new CountUp('ticketCount', parseInt(oldTicketCount), tCount, 0, 1.5)\r\n            theAnimation.start()\r\n\r\n            var closedCount = Number(_data.data.closedCount)\r\n            var closedPercent = Math.round((closedCount / tCount) * 100)\r\n\r\n            var textComplete = $('#text_complete')\r\n            var oldTextComplete = textComplete.text() === '--' ? 0 : textComplete.text()\r\n            var completeAnimation = new CountUp('text_complete', parseInt(oldTextComplete), closedPercent, 0, 1.5)\r\n            completeAnimation.start()\r\n\r\n            var pieComplete = $('#pie_complete')\r\n            pieComplete.text(closedPercent + '/100')\r\n            pieComplete.peity('donut', {\r\n              height: 24,\r\n              width: 24,\r\n              fill: ['#29b955', '#ccc']\r\n            })\r\n\r\n            var responseTimeText = $('#responseTime_text')\r\n            // var responseTime_graph = $('#responseTime_graph');\r\n            var oldResponseTime = responseTimeText.text() === '--' ? 0 : responseTimeText.text()\r\n            var responseTime = _data.data.avgResponse\r\n            var responseTimeAnimation = new CountUp(\r\n              'responseTime_text',\r\n              parseInt(oldResponseTime),\r\n              responseTime,\r\n              0,\r\n              1.5\r\n            )\r\n            responseTimeAnimation.start()\r\n\r\n            var recentTicketsBody = $('tbody.recent-tickets')\r\n            recentTicketsBody.html('')\r\n            var html = ''\r\n            var sortedTickets = _.sortBy(_data.data.recentTickets, 'uid').reverse()\r\n            _.each(sortedTickets, function (ticket) {\r\n              var status = ''\r\n              switch (ticket.status) {\r\n                case 0:\r\n                  status = 'new'\r\n                  break\r\n                case 1:\r\n                  status = 'open'\r\n                  break\r\n                case 2:\r\n                  status = 'pending'\r\n                  break\r\n                case 3:\r\n                  status = 'closed'\r\n                  break\r\n              }\r\n              html += '<tr class=\"uk-table-middle\">'\r\n              html +=\r\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><a href=\"/tickets/' +\r\n                ticket.uid +\r\n                '\">T#' +\r\n                ticket.uid +\r\n                '</a></td>'\r\n              html +=\r\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><span class=\"uk-badge ticket-status-' +\r\n                status +\r\n                ' uk-width-1-1\">' +\r\n                status +\r\n                '</span></td>'\r\n              html += '<td class=\"uk-width-6-10\">'\r\n              html += ticket.subject\r\n              html += '</td>'\r\n              html += '<td class=\"uk-width-2-10 uk-text-right uk-text-muted uk-text-small\">'\r\n              html += moment\r\n                .utc(ticket.updated)\r\n                .tz(helpers.getTimezone())\r\n                .format(helpers.getShortDateFormat())\r\n              html += '</td>'\r\n              html += '</tr>'\r\n            })\r\n\r\n            recentTicketsBody.append(html)\r\n\r\n            var arr = _.map(_data.data.tags, function (v, key) {\r\n              return [key, v]\r\n            })\r\n\r\n            var colors = [\r\n              '#e53935',\r\n              '#d81b60',\r\n              '#8e24aa',\r\n              '#1e88e5',\r\n              '#00897b',\r\n              '#43a047',\r\n              '#00acc1',\r\n              '#e65100',\r\n              '#6d4c41',\r\n              '#455a64'\r\n            ]\r\n\r\n            var c = _.object(\r\n              _.map(arr, function (v) {\r\n                return v[0]\r\n              }),\r\n              colors\r\n            )\r\n\r\n            c3.generate({\r\n              bindto: d3.select('#topTags'),\r\n              size: {\r\n                height: 200\r\n              },\r\n              data: {\r\n                columns: arr,\r\n                type: 'donut',\r\n                colors: c\r\n              },\r\n              donut: {\r\n                label: {\r\n                  format: function () {\r\n                    return ''\r\n                  }\r\n                }\r\n              }\r\n            })\r\n\r\n            helpers.UI.matchHeight()\r\n          }\r\n        }).error(function (err) {\r\n          // console.log(err);\r\n          console.log('[trudesk:reportsBreakdownGroup:getData] Error - ' + err.responseText)\r\n          helpers.UI.showSnackbar(JSON.parse(err.responseText).error, true)\r\n        })\r\n      }\r\n\r\n      if (typeof callback === 'function') {\r\n        return callback()\r\n      }\r\n    })\r\n  }\r\n\r\n  return reportsBreakdownPage\r\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/pages/reportsBreakdown.js?");

/***/ }),

/***/ 977:
/*!************************************************!*\
  !*** ./src/public/js/plugins/jquery.actual.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Copyright 2012, Ben Lin (http://dreamerslab.com/)\r\n * Licensed under the MIT License (LICENSE.txt).\r\n *\r\n * Version: 1.0.19\r\n *\r\n * Requires: jQuery >= 1.2.3\r\n */\r\n;(function (factory) {\r\n  if (true) {\r\n    // AMD. Register module depending on jQuery using requirejs define.\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else {}\r\n})(function ($) {\r\n  $.fn.addBack = $.fn.addBack || $.fn.andSelf\r\n\r\n  $.fn.extend({\r\n    actual: function (method, options) {\r\n      // check if the jQuery method exist\r\n      if (!this[method]) {\r\n        throw '$.actual => The jQuery method \"' + method + '\" you called does not exist'\r\n      }\r\n\r\n      var defaults = {\r\n        absolute: false,\r\n        clone: false,\r\n        includeMargin: false,\r\n        display: 'block'\r\n      }\r\n\r\n      var configs = $.extend(defaults, options)\r\n\r\n      var $target = this.eq(0)\r\n      var fix, restore\r\n\r\n      if (configs.clone === true) {\r\n        fix = function () {\r\n          var style = 'position: absolute !important; top: -1000 !important; '\r\n\r\n          // this is useful with css3pie\r\n          $target = $target\r\n            .clone()\r\n            .attr('style', style)\r\n            .appendTo('body')\r\n        }\r\n\r\n        restore = function () {\r\n          // remove DOM element after getting the width\r\n          $target.remove()\r\n        }\r\n      } else {\r\n        var tmp = []\r\n        var style = ''\r\n        var $hidden\r\n\r\n        fix = function () {\r\n          // get all hidden parents\r\n          $hidden = $target\r\n            .parents()\r\n            .addBack()\r\n            .filter(':hidden')\r\n          style += 'visibility: hidden !important; display: ' + configs.display + ' !important; '\r\n\r\n          if (configs.absolute === true) style += 'position: absolute !important; '\r\n\r\n          // save the origin style props\r\n          // set the hidden el css to be got the actual value later\r\n          $hidden.each(function () {\r\n            // Save original style. If no style was set, attr() returns undefined\r\n            var $this = $(this)\r\n            var thisStyle = $this.attr('style')\r\n\r\n            tmp.push(thisStyle)\r\n            // Retain as much of the original style as possible, if there is one\r\n            $this.attr('style', thisStyle ? thisStyle + ';' + style : style)\r\n          })\r\n        }\r\n\r\n        restore = function () {\r\n          // restore origin style values\r\n          $hidden.each(function (i) {\r\n            var $this = $(this)\r\n            var _tmp = tmp[i]\r\n\r\n            if (_tmp === undefined) {\r\n              $this.removeAttr('style')\r\n            } else {\r\n              $this.attr('style', _tmp)\r\n            }\r\n          })\r\n        }\r\n      }\r\n\r\n      fix()\r\n      // get the actual value with user specific methed\r\n      // it can be 'width', 'height', 'outerWidth', 'innerWidth'... etc\r\n      // configs.includeMargin only works for 'outerWidth' and 'outerHeight'\r\n      var actual = /(outer)/.test(method) ? $target[method](configs.includeMargin) : $target[method]()\r\n\r\n      restore()\r\n      // IMPORTANT, this plugin only return the value of the first element\r\n      return actual\r\n    }\r\n  })\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/plugins/jquery.actual.js?");

/***/ }),

/***/ 360:
/*!******************************************************!*\
  !*** ./src/public/js/plugins/jquery.documentsize.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var $ = __webpack_require__(/*! jquery */ 0);\n// jQuery.documentSize, v1.2.3\r\n// Copyright (c) 2015-2016 Michael Heim, Zeilenwechsel.de\r\n// Distributed under MIT license\r\n// http://github.com/hashchange/jquery.documentsize\r\n\r\n;(function (root, factory) {\r\n  'use strict'\r\n\r\n  if (true) {\r\n    module.exports = factory(__webpack_require__(/*! jquery */ 0))\r\n  } else {}\r\n})(this, function (jQuery) {\r\n  'use strict'\r\n  ;(function ($) {\r\n    'use strict'\r\n\r\n    // IIFE generating the functions $.documentWidth, $.documentHeight, $.windowWidth, $.windowHeight, and\r\n    // $.scrollbarWidth.\r\n    //\r\n    // These functions need to run feature detections which requires insertion of an iframe ($.documentWidth/Height) and\r\n    // a div ($.scrollbarWidth). The body element in the main document must be available when that happens (ie, the\r\n    // opening body tag must have been parsed).\r\n    //\r\n    // For that reason, the detection does not run instantly - after all, the code might be loaded and run while parsing\r\n    // the head. Instead, detection happens on DOM-ready, or when any of the functions is invoked for the first time.\r\n    // Given the purpose of the functions, they won't be called until after the opening body tag has been parsed.\r\n\r\n    var _scrollbarWidth,\r\n      _supportsWindowInnerWidth,\r\n      _supportsSubpixelAccuracy,\r\n      elementNameForDocSizeQuery,\r\n      ieVersion,\r\n      useGetComputedStyle = !!window.getComputedStyle\r\n\r\n    /**\r\n     * @param   {Document} [_document=document]\r\n     * @returns {number}\r\n     */\r\n    $.documentWidth = function (_document) {\r\n      var width\r\n\r\n      _document || (_document = document)\r\n\r\n      try {\r\n        if (elementNameForDocSizeQuery === undefined) testDocumentScroll()\r\n        width = _document[elementNameForDocSizeQuery].scrollWidth\r\n      } catch (e) {\r\n        // Fallback for unsupported, broken browsers which can't run the behaviour test successfully\r\n        width = guessDocumentSize('Width', _document)\r\n      }\r\n\r\n      return width\r\n    }\r\n\r\n    /**\r\n     * @param   {Document} [_document=document]\r\n     * @returns {number}\r\n     */\r\n    $.documentHeight = function (_document) {\r\n      var height\r\n\r\n      _document || (_document = document)\r\n\r\n      try {\r\n        if (elementNameForDocSizeQuery === undefined) testDocumentScroll()\r\n        height = _document[elementNameForDocSizeQuery].scrollHeight\r\n      } catch (e) {\r\n        // Fallback for unsupported, broken browsers which can't run the behaviour test successfully\r\n        height = guessDocumentSize('Height', _document)\r\n      }\r\n\r\n      return height\r\n    }\r\n\r\n    /**\r\n     * @param   {string|Object|Window} [options=\"visual\"]  (a) viewport option: strings \"visual\", \"layout\" (case-\r\n     *                                                         insensitive), or a hash with a `viewport` property\r\n     *                                                     (b) the window argument\r\n     * @param   {string|Object|Window} [_window=window]    same as first argument; positions for window and viewport\r\n     *                                                     argument are interchangeable\r\n     * @returns {number}\r\n     */\r\n    $.windowWidth = function (options, _window) {\r\n      var config = getWindowQueryConfig(arguments)\r\n      return getWindowSize('Width', config)\r\n    }\r\n\r\n    /**\r\n     * @param   {string|Object|Window} [options=\"visual\"]  (a) viewport option: strings \"visual\", \"layout\" (case-\r\n     *                                                         insensitive), or a hash with a `viewport` property\r\n     *                                                     (b) the window argument\r\n     * @param   {string|Object|Window} [_window=window]    same as first argument; positions for window and viewport\r\n     *                                                     argument are interchangeable\r\n     * @returns {number}\r\n     */\r\n    $.windowHeight = function (options, _window) {\r\n      var config = getWindowQueryConfig(arguments)\r\n      return getWindowSize('Height', config)\r\n    }\r\n\r\n    /**\r\n     * @param   {Window} [_window=window]\r\n     * @returns {number}\r\n     */\r\n    $.pinchZoomFactor = function (_window) {\r\n      // Calculate the zoom factor based on the width, not the height. getPinchZoomFactor() does just that.\r\n      //\r\n      // It would be more accurate to use the longest side for the calculation, keeping the effect of rounding errors\r\n      // low (unless the browser supports sub-pixel accuracy anyway).\r\n      //\r\n      // Unfortunately, iOS does not allow that approach. Switching from normal to minimal UI is not reflected in the\r\n      // clientHeight, so the zoom factor would seem to change when the UI disappears (even though in reality, it\r\n      // doesn't). We have to use the width, irrespective of orientation.\r\n\r\n      return getPinchZoomFactor(_window)\r\n    }\r\n\r\n    /**\r\n     * @returns {number}\r\n     */\r\n    $.scrollbarWidth = browserScrollbarWidth\r\n\r\n    /**\r\n     * Returns the window width or height. Does the actual work of $.windowWidth() and $.windowHeight().\r\n     *\r\n     * Handles minimal UI in iOS properly. Returns the size of either the visual viewport (default) or the layout\r\n     * viewport.\r\n     *\r\n     * Precision:\r\n     *\r\n     * - The maximum rounding error for the visual viewport is +/- 1px.\r\n     * - Layout viewport width is precise.\r\n     * - Layout viewport height would potentially be prone to larger rounding errors (though in practice they rarely\r\n     *   seem to exceed +/- 2px). Additional logic is employed to detect and correct these errors. As a result, the\r\n     *   layout viewport height is precise as well.\r\n     *\r\n     * @param   {string}            dimension  must be \"Width\" or \"Height\" (upper case!)\r\n     * @param   {WindowQueryConfig} config\r\n     * @returns {number}\r\n     */\r\n    function getWindowSize (dimension, config) {\r\n      var ddeClientHeight,\r\n        visualSize,\r\n        zoomFactor,\r\n        snapToKnownHeight,\r\n        lBound,\r\n        uBound,\r\n        _window = config.window,\r\n        scrollbarsConsumeSpace = browserScrollbarWidth() !== 0,\r\n        getLayoutViewportWidth = config.useLayoutViewport && dimension === 'Width',\r\n        useClientSize = scrollbarsConsumeSpace || !supportsWindowInnerWidth() || getLayoutViewportWidth,\r\n        size = useClientSize\r\n          ? _window.document.documentElement['client' + dimension]\r\n          : getWindowInnerSize(dimension, _window)\r\n\r\n      if (config.useLayoutViewport && !useClientSize) {\r\n        // Looking for the layout viewport height on mobile. Calculate it from window.innerHeight and the zoom\r\n        // factor, so as to capture the real height when the browser is in minimal UI on iOS.\r\n        //\r\n        // NB The layout viewport has a size in full CSS pixels (unaffected by zooming, hence no sub pixels).\r\n\r\n        visualSize = size\r\n        zoomFactor = getPinchZoomFactor(_window, { asRange: true })\r\n\r\n        size = Math.round(visualSize * zoomFactor.calculated)\r\n\r\n        // Fix rounding errors, caused by the visual height ignoring sub-pixel fractions. If we know we are near a\r\n        // known layout viewport height, use that.\r\n        if (!supportsSubpixelAccuracy()) {\r\n          ddeClientHeight = _window.document.documentElement.clientHeight\r\n\r\n          // In Android, the height we get from ddE.clientHeight and the one calculated from window.innerHeight\r\n          // should be the same, except for rounding errors in the calculation. So basically, we could just set\r\n          // any calculated value to the clientHeight, no matter how large the difference is. (That is, if we even\r\n          // end up here - in some versions of Chrome on Android, for instance, we have sub-pixel accuracy.)\r\n          //\r\n          // Not so in iOS. In minimal UI, the real layout viewport may be larger than the one reported by\r\n          // clientHeight, by about 60px. So we need to impose reasonable limits on what is considered to be near\r\n          // the clientHeight.\r\n          //\r\n          // - If the calculated value is within 3px of the clientHeight, we consider it to be a clear case of a\r\n          //   rounding error.\r\n          // - Alternatively, the clientHeight must be between the theoretical maximum and minimum values of the\r\n          //   computation, assuming maximum rounding errors at every stage.\r\n          // - If we use that range, its upper bound is capped at 30px above the clientHeight - keeping a safe\r\n          //   distance from current minimal UI heights, or possible future ones.\r\n\r\n          lBound = (visualSize - 1) * zoomFactor.min\r\n          uBound = (visualSize + 1) * zoomFactor.max\r\n\r\n          snapToKnownHeight =\r\n            (size <= ddeClientHeight + 3 && size >= ddeClientHeight - 3) ||\r\n            (lBound <= ddeClientHeight && uBound >= ddeClientHeight && uBound < ddeClientHeight + 30)\r\n\r\n          if (snapToKnownHeight) size = ddeClientHeight\r\n        }\r\n      }\r\n\r\n      return size\r\n    }\r\n\r\n    /**\r\n     * Calculates the zoom factor for pinch zooming on mobile. A factor > 1 means that the page is zoomed in (content\r\n     * enlarged).\r\n     *\r\n     * The zoom factor returned here measures the size of the visual viewport with respect to the size of the layout\r\n     * viewport. Note that browsers usually calculate their zoom level with respect to the ideal viewport, not the\r\n     * layout viewport (see Peter-Paul Koch, The Mobile Web Handbook, Chapter 3: Viewports, Section \"Minimum and Maximum\r\n     * Zoom\").\r\n     *\r\n     * Ignores page zoom on the desktop (returning a zoom factor of 1). For the distinction between pinch and page zoom,\r\n     * again see Chapter 3 in PPK's book.\r\n     *\r\n     * @param   {Window}  [_window=window]\r\n     * @param   {Object}  [options]\r\n     * @param   {boolean} [options.asRange=false]\r\n     * @returns {number|ZoomAccuracyRange}\r\n     */\r\n    function getPinchZoomFactor (_window, options) {\r\n      var ddeClientWidth,\r\n        windowInnerWidth,\r\n        asRange = options && options.asRange,\r\n        factors = {\r\n          calculated: 1,\r\n          min: 1,\r\n          max: 1\r\n        },\r\n        skip = browserScrollbarWidth() !== 0 || !supportsWindowInnerWidth()\r\n\r\n      if (!skip) {\r\n        _window || (_window = window)\r\n        ddeClientWidth = _window.document.documentElement.clientWidth\r\n        windowInnerWidth = getWindowInnerWidth(_window)\r\n\r\n        // Calculate the zoom factor, assuming window.innerWidth is precise (no rounding errors).\r\n        factors.calculated = ddeClientWidth / windowInnerWidth\r\n\r\n        // If requested, determine the minimum and maximum value of the zoom factor in the presence of rounding errors.\r\n        if (asRange) {\r\n          if (supportsSubpixelAccuracy()) {\r\n            // No need to take rounding errors into account\r\n            factors.min = factors.max = factors.calculated\r\n          } else {\r\n            factors.min = ddeClientWidth / (windowInnerWidth + 1)\r\n            factors.max = ddeClientWidth / (windowInnerWidth - 1)\r\n          }\r\n        }\r\n      }\r\n\r\n      return asRange ? factors : factors.calculated\r\n    }\r\n\r\n    /**\r\n     * Handles the argument juggling for $.windowWidth() and $.windowHeight(). Extracts the window and viewport settings\r\n     * from the arguments, applying the defaults (use global window, use visual viewport) where necessary.\r\n     *\r\n     * Examines the first two arguments. The window and the viewport setting can appear in either position,\r\n     * interchangeably. The viewport setting can be passed in as a string, or as part of an options hash,\r\n     * `{ viewport: ... }`.\r\n     *\r\n     * Recognized viewport names are \"visual\" and \"layout\" (case-insensitive).\r\n     *\r\n     * @param   {Array|Arguments} args\r\n     * @returns {WindowQueryConfig}\r\n     */\r\n    function getWindowQueryConfig (args) {\r\n      var isWindowArg0,\r\n        isOptionArg0,\r\n        isOptionArg1,\r\n        // Defaults\r\n        _window = window,\r\n        _useVisualViewport = true\r\n\r\n      if (args && args.length) {\r\n        // Coerce to a real array\r\n        args = Array.prototype.slice.call(args)\r\n\r\n        // Examine the first argument. Cast strings to an options hash with a `viewport` property.\r\n        isWindowArg0 = isWindow(args[0])\r\n        if (!isWindowArg0) args[0] = castStringToViewportOption(args[0])\r\n        isOptionArg0 = !isWindowArg0 && args[0]\r\n\r\n        // Examine the second argument. Again, cast strings to an options hash with a `viewport` property.\r\n        if (!isOptionArg0) args[1] = castStringToViewportOption(args[1])\r\n        isOptionArg1 = !isOptionArg0 && args[1]\r\n\r\n        // Extract window and viewport option, if available.\r\n        if (isWindowArg0) {\r\n          _window = args[0]\r\n          if (isOptionArg1 && args[1].viewport) _useVisualViewport = isVisualViewport(args[1].viewport)\r\n        } else if (isOptionArg0) {\r\n          if (args[0].viewport) _useVisualViewport = isVisualViewport(args[0].viewport)\r\n          if (isWindow(args[1])) _window = args[1]\r\n        } else if (!args[0] && args[1]) {\r\n          // First argument was falsy, e.g. undefined, null. Ignore it. But process the second, non-falsy argument.\r\n          if (isOptionArg1 && args[1].viewport) {\r\n            _useVisualViewport = isVisualViewport(args[1].viewport)\r\n          } else if (isWindow(args[1])) {\r\n            _window = args[1]\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        window: _window,\r\n        useVisualViewport: _useVisualViewport,\r\n        useLayoutViewport: !_useVisualViewport\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Checks if the argument is the name of the visual viewport. The check is case-insensitive.\r\n     *\r\n     * Expects a string. Tolerates falsy values, returning false then (argument is not naming the visual viewport).\r\n     * Throws an error for everything else. Also throws an error if the viewport name is a string but not recognized\r\n     * (typo alert).\r\n     *\r\n     * Helper for getWindowQueryConfig().\r\n     *\r\n     * @param   {string} [name]  strings \"visual\", \"layout\" (case-insensitive)\r\n     * @returns {boolean}\r\n     */\r\n    function isVisualViewport (name) {\r\n      var viewport = isString(name) && name.toLowerCase()\r\n\r\n      if (name && !viewport) throw new Error('Invalid viewport option: ' + name)\r\n      if (viewport && viewport !== 'visual' && viewport !== 'layout') throw new Error('Invalid viewport name: ' + name)\r\n\r\n      return viewport === 'visual'\r\n    }\r\n\r\n    /**\r\n     * Examines a value and casts a string to a hash with a `viewport` property (the string being its value). If the\r\n     * value is not a string, or if the string is empty, it is returned as-is. Helper for getWindowQueryConfig().\r\n     *\r\n     * @param   {*} arg\r\n     * @returns {*}\r\n     */\r\n    function castStringToViewportOption (arg) {\r\n      return isString(arg) && arg !== '' ? { viewport: arg } : arg\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser supports window.innerWidth and window.innerHeight.\r\n     *\r\n     * The check is run on demand, rather than up front while loading the component, because the window properties can\r\n     * behave strangely in the early stages of opening a window. The component might be loaded in the document head,\r\n     * which could potentially be early enough to run into these oddities. So we wait until the first call.\r\n     *\r\n     * IE 8 does not support window.innerWidth and .innerHeight. FF has a bug which as only been fixed in FF25 (released\r\n     * 29 Oct 2013). It manifests itself in a fictional return value of 10 for these properties. See\r\n     *\r\n     * - https://developer.mozilla.org/en-US/docs/Web/API/Window.innerWidth\r\n     * - https://developer.mozilla.org/en-US/docs/Web/API/Window.innerHeight\r\n     * - https://bugzilla.mozilla.org/show_bug.cgi?id=641188\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function supportsWindowInnerWidth () {\r\n      if (_supportsWindowInnerWidth === undefined) _supportsWindowInnerWidth = getWindowInnerWidth() > 10\r\n      return _supportsWindowInnerWidth\r\n    }\r\n\r\n    /**\r\n     * Does the actual work of $.scrollbarWidth. Protected from external modification. See $.scrollbarWidth for details.\r\n     *\r\n     * Adapted from Ben Alman's scrollbarWidth plugin. See\r\n     * - http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth\r\n     * - http://jsbin.com/zeliy/1\r\n     *\r\n     * @returns {number}\r\n     */\r\n    function browserScrollbarWidth () {\r\n      var testEl\r\n\r\n      if (_scrollbarWidth === undefined) {\r\n        testEl = document.createElement('div')\r\n        testEl.style.cssText =\r\n          'width: 100px; height: 100px; overflow: scroll; position: absolute; top: -500px; left: -500px; margin: 0px; padding: 0px; border: none;'\r\n\r\n        document.body.appendChild(testEl)\r\n        _scrollbarWidth = testEl.offsetWidth - testEl.clientWidth\r\n        document.body.removeChild(testEl)\r\n      }\r\n\r\n      return _scrollbarWidth\r\n    }\r\n\r\n    /**\r\n     * Detects which element to use for a document size query (body or documentElement).\r\n     *\r\n     * Sandbox\r\n     * -------\r\n     *\r\n     * The detection is sandboxed in an iframe element created for the purpose. If the iframe window can't be\r\n     * accessed because of some obscure policy restriction or browser bug, the main window and document is used\r\n     * as a fallback.\r\n     *\r\n     * The test is designed to minimize the visual and rendering impact in the test window, in case the fallback\r\n     * should ever be used.\r\n     *\r\n     * Test method\r\n     * -----------\r\n     *\r\n     * We can't test directly which call to use (at least not with an even worse amount of intervention than is\r\n     * already the case, which matters if the iframe is not accessible). But we can work by exclusion.\r\n     *\r\n     * In Chrome (desktop and mobile), Safari (also iOS), and Opera, body.scrollWidth returns the true document\r\n     * width. In Firefox and IE, body.scrollWidth responds to the body content size instead. In those browsers,\r\n     * true document width is returned by document.documentElement.scrollWidth.\r\n     *\r\n     * So we test the behaviour of body.scrollWidth by manipulating the body size, while keeping the document size\r\n     * constant.\r\n     *\r\n     * - We prepare for the test by making sure the body does not display its overflow.\r\n     * - Then we inject a small test element into the body and give it a relative position far outside the viewport.\r\n     *\r\n     * The body size is expanded, but the document size remains unaffected because the body hides the overflowing\r\n     * test element (either outright, or by putting it in a hidden part of the scroll pane). Then we check if\r\n     * body.scrollWidth has responded to the change. From that, we infer the right element to use for a document\r\n     * width query.\r\n     *\r\n     * The function does not return anything. It sets the elementNameForDocSizeQuery in the closure instead.\r\n     */\r\n    function testDocumentScroll () {\r\n      var initialDocumentState,\r\n        _testEl,\r\n        initialScrollWidth,\r\n        responds,\r\n        iframe = createTestIframe(),\r\n        _document = (iframe && iframe.contentDocument) || document,\r\n        _body = _document.body,\r\n        inIframe = _document !== document\r\n\r\n      // Create a test element which will be used to to expand the body content way to the right.\r\n      _testEl = _document.createElement('div')\r\n      _testEl.style.cssText = 'width: 1px; height: 1px; position: relative; top: 0px; left: 32000px;'\r\n\r\n      // Make sure that the body (but not the window) hides its overflow. Only applies if the iframe is not\r\n      // accessible. The iframe document already contains the required styles.\r\n      if (!inIframe) initialDocumentState = prepareGlobalDocument()\r\n\r\n      // Inject the test element, then test if the body.scrollWidth property responds\r\n      initialScrollWidth = _body.scrollWidth\r\n      _body.appendChild(_testEl)\r\n      responds = initialScrollWidth !== _body.scrollWidth\r\n      _body.removeChild(_testEl)\r\n\r\n      // Restore the overflow settings for window and body\r\n      if (!inIframe) restoreGlobalDocument(initialDocumentState)\r\n\r\n      // If body.scrollWidth responded, it reacts to body content size, not document size. Default to\r\n      // ddE.scrollWidth. If it did not react, however, it is linked to the (unchanged) document size.\r\n      elementNameForDocSizeQuery = responds ? 'documentElement' : 'body'\r\n\r\n      if (iframe) document.body.removeChild(iframe)\r\n    }\r\n\r\n    /**\r\n     * Creates an iframe document with an HTML5 doctype and UTF-8 encoding and positions it off screen. Window size\r\n     * is 500px x 500px. Body and window (document element) are set to overflow: hidden.\r\n     *\r\n     * In case the content document of the iframe can't be accessed for some reason, the function returns undefined.\r\n     * This is unlikely to ever happen, though.\r\n     *\r\n     * @returns {HTMLIFrameElement|undefined}\r\n     */\r\n    function createTestIframe () {\r\n      var iframe = document.createElement('iframe'),\r\n        body = document.body\r\n\r\n      iframe.style.cssText =\r\n        'position: absolute; top: -600px; left: -600px; width: 500px; height: 500px; margin: 0px; padding: 0px; border: none; display: block;'\r\n      iframe.frameborder = '0'\r\n\r\n      body.appendChild(iframe)\r\n      iframe.src = 'about:blank'\r\n\r\n      if (!iframe.contentDocument) return\r\n\r\n      iframe.contentDocument.write(\r\n        '<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title></title><style type=\"text/css\">html, body { overflow: hidden; }</style></head><body></body></html>'\r\n      )\r\n\r\n      return iframe\r\n    }\r\n\r\n    /**\r\n     * Makes sure the body (but not the window) hides its overflow. Works with the global document, returns the initial\r\n     * state before manipulation (including properties indicating what has been modified).\r\n     *\r\n     * Used only if iframe creation or access has failed for some reason.\r\n     */\r\n    function prepareGlobalDocument () {\r\n      var ddEStyle,\r\n        bodyStyle,\r\n        ddE = document.documentElement,\r\n        body = document.body,\r\n        ddEComputedStyles = useGetComputedStyle ? window.getComputedStyle(ddE, null) : ddE.currentStyle,\r\n        bodyComputedStyles = useGetComputedStyle ? window.getComputedStyle(body, null) : body.currentStyle,\r\n        ddEOverflowX = (ddEComputedStyles.overflowX || ddEComputedStyles.overflow || 'visible').toLowerCase(),\r\n        bodyOverflowX = (bodyComputedStyles.overflowX || bodyComputedStyles.overflow || 'visible').toLowerCase(),\r\n        modifyBody = bodyOverflowX !== 'hidden',\r\n        modifyDocumentElement = ddEOverflowX === 'visible',\r\n        initialState = {\r\n          documentElement: {\r\n            modified: modifyDocumentElement\r\n          },\r\n          body: {\r\n            modified: modifyBody\r\n          }\r\n        }\r\n\r\n      if (modifyDocumentElement) {\r\n        ddEStyle = ddE.style\r\n        initialState.documentElement.styleOverflowX = ddEStyle.overflowX\r\n        ddEStyle.overflowX = 'auto'\r\n      }\r\n\r\n      if (modifyBody) {\r\n        bodyStyle = body.style\r\n        initialState.body.styleOverflowX = bodyStyle.overflowX\r\n        bodyStyle.overflowX = 'hidden'\r\n      }\r\n\r\n      return initialState\r\n    }\r\n\r\n    /**\r\n     * Restores the body and documentElement styles to their initial state, which is passed in as an argument. Works\r\n     * with the global document.\r\n     *\r\n     * Used only if iframe creation or access has failed for some reason.\r\n     *\r\n     * @param {Object} previousState  the initial state, as returned by prepareGlobalDocument()\r\n     */\r\n    function restoreGlobalDocument (previousState) {\r\n      if (previousState.documentElement.modified)\r\n        document.documentElement.style.overflowX = previousState.documentElement.styleOverflowX\r\n      if (previousState.body.modified) document.body.style.overflowX = previousState.body.styleOverflowX\r\n    }\r\n\r\n    /**\r\n     * Returns a best guess for the window width or height. Used as a fallback for unsupported browsers which are too\r\n     * broken to even run the feature test.\r\n     *\r\n     * The conventional jQuery method of guessing the document size is used here: every conceivable value is queried and\r\n     * the largest one is picked.\r\n     *\r\n     * @param {string}   dimension    accepted values are \"Width\" or \"Height\" (capitalized first letter!)\r\n     * @param {Document} [_document]\r\n     */\r\n    function guessDocumentSize (dimension, _document) {\r\n      var ddE = _document.documentElement\r\n\r\n      return Math.max(\r\n        ddE.body['scroll' + dimension],\r\n        _document['scroll' + dimension],\r\n        ddE.body['offset' + dimension],\r\n        _document['offset' + dimension],\r\n        _document['client' + dimension]\r\n      )\r\n    }\r\n\r\n    /**\r\n     * Returns window.innerWidth.\r\n     *\r\n     * Along the way, the return value is examined to see if the browser supports sub-pixel accuracy (floating-point\r\n     * values).\r\n     *\r\n     * @param   {Window} [_window=window]\r\n     * @returns {number}\r\n     */\r\n    function getWindowInnerWidth (_window) {\r\n      return getWindowInnerSize('Width', _window)\r\n    }\r\n\r\n    /**\r\n     * Returns window.innerHeight.\r\n     *\r\n     * Along the way, the return value is examined to see if the browser supports sub-pixel accuracy (floating-point\r\n     * values).\r\n     *\r\n     * @param   {Window} [_window=window]\r\n     * @returns {number}\r\n     */\r\n    function getWindowInnerHeight (_window) {\r\n      return getWindowInnerSize('Height', _window)\r\n    }\r\n\r\n    /**\r\n     * Returns window.innerWidth or window.innerHeight, depending on the dimension argument.\r\n     *\r\n     * Along the way, the return value is examined to see if the browser supports sub-pixel accuracy (floating-point\r\n     * values).\r\n     *\r\n     * @param   {string} dimension  must be \"Width\" or \"Height\" (upper case!)\r\n     * @param   {Window} [_window=window]\r\n     * @returns {number}\r\n     */\r\n    function getWindowInnerSize (dimension, _window) {\r\n      var size = (_window || window)['inner' + dimension]\r\n\r\n      // Check for fractions. Exclude undefined return values in browsers which don't support window.innerWidth/Height.\r\n      if (size) checkForFractions(size)\r\n      return size\r\n    }\r\n\r\n    /**\r\n     * Accepts an observed value of window.innerWidth or window.innerHeight and examines it for fractional values.\r\n     * Caches the finding if there is one. Helper for getWindowInnerWidth() and friends.\r\n     *\r\n     * See supportsSubpixelAccuracy() for more.\r\n     *\r\n     * @param {number} sizeMeasurement\r\n     */\r\n    function checkForFractions (sizeMeasurement) {\r\n      // When checking the cached value, we can't accept false as a definitive answer. We have to continue checking\r\n      // unless the cached value is `true`.\r\n      //\r\n      // See supportsSubpixelAccuracy().\r\n      if (!_supportsSubpixelAccuracy && isFloat(sizeMeasurement)) _supportsSubpixelAccuracy = true\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not the browser supports sub-pixel accuracy (floating-point values) for window.innerWidth and\r\n     * window.innerHeight - as far as we know yet.\r\n     *\r\n     * The browser behaviour can't be tested directly, and must be figured out by continuous observation. We have to\r\n     * monitor the return values of window.innerWidth/Height for fractions. That is done with getWindowInnerWidth etc.\r\n     * As soon as we find a fraction, we know that the browser supports floating-point accuracy.\r\n     *\r\n     * However, we can never be sure of the opposite. If we haven't encountered a fraction yet, it could simply mean\r\n     * that we are at 100% zoom, and integers have indeed been the correct return value so far.\r\n     *\r\n     * So when the method here answers with true, it is definitive. When it returns false, that just means \"maybe not,\r\n     * but we don't know\". And the the return value might flip to true in a future query.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function supportsSubpixelAccuracy () {\r\n      return !!_supportsSubpixelAccuracy\r\n    }\r\n\r\n    function isWindow (value) {\r\n      // Identical to jQuery.isWindow()\r\n      return value != null && value.window == value // jshint ignore:line\r\n    }\r\n\r\n    function isString (value) {\r\n      // Done as in the Lodash compatibility build\r\n      return (\r\n        typeof value === 'string' ||\r\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]') ||\r\n        false\r\n      )\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not a value is of type number. Also rejects NaN as a number.\r\n     *\r\n     * NB This is not the same as $.isNumeric because $.isNumeric( \"3\" ) is true while isNumber( \"3\" ) is false.\r\n     *\r\n     * @param   {*} value\r\n     * @returns {boolean}\r\n     */\r\n    function isNumber (value) {\r\n      // Done as in the Lodash compatibility build, but rejecting NaN as a number.\r\n      var isNumeric =\r\n        typeof value === 'number' ||\r\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object Number]') ||\r\n        false\r\n\r\n      // Reject NaN before returning\r\n      return isNumeric && value === +value\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not a number is a float, ie has decimals.\r\n     *\r\n     * Requires the argument to be a number. If unsure, guard against false detections with\r\n     * `isNumber( value ) && isFloat ( value )`.\r\n     *\r\n     * For the technique, see http://stackoverflow.com/a/3885844/508355\r\n     *\r\n     * @param   {number} num\r\n     * @returns {boolean}\r\n     */\r\n    function isFloat (num) {\r\n      return num === +num && num !== (num | 0) // jshint ignore:line\r\n    }\r\n\r\n    /**\r\n     * Returns the IE version, or false if the browser is not IE.\r\n     *\r\n     * The result is determined by browser sniffing, rather than a test tailored to the use case. The function must only\r\n     * be called as a last resort, for scenarios where there is no alternative to browser sniffing.\r\n     *\r\n     * These scenarios include:\r\n     *\r\n     * - Preventing IE6 and IE7 from crashing\r\n     * - Preventing IE9 from blocking or delaying the load event\r\n     *\r\n     * The test follows the MSDN recommendation at https://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx#parsingua\r\n     * The result is cached.\r\n     *\r\n     * @returns {number|boolean}\r\n     */\r\n    function getIEVersion () {\r\n      var userAgent, userAgentTestRx\r\n\r\n      if (ieVersion === undefined) {\r\n        ieVersion = false\r\n        userAgent = navigator && navigator.userAgent\r\n\r\n        if (navigator && navigator.appName === 'Microsoft Internet Explorer' && userAgent) {\r\n          userAgentTestRx = new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})') // jshint ignore:line\r\n          if (userAgentTestRx.exec(userAgent) != null) ieVersion = parseFloat(RegExp.$1)\r\n        }\r\n      }\r\n\r\n      return ieVersion\r\n    }\r\n\r\n    /**\r\n     * Checks if we are dealing with a truly ancient version of IE (< IE8).\r\n     *\r\n     * This is done by browser sniffing, rather than a test tailored to the use case. Use it only if there is no\r\n     * alternative.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function isAncientIE () {\r\n      var ieVersion = getIEVersion()\r\n      return ieVersion && ieVersion < 8\r\n    }\r\n\r\n    /**\r\n     * Checks if the browser is IE9.\r\n     *\r\n     * This is done by browser sniffing, rather than a test tailored to the use case. Use it only if there is no\r\n     * alternative.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function isIE9 () {\r\n      return getIEVersion() === 9\r\n    }\r\n\r\n    // Let's prime $.documentWidth(), $.documentHeight() and $.scrollbarWidth() immediately after the DOM is ready. It\r\n    // is best to do it up front because the test touches the DOM, so let's get it over with before people set up\r\n    // handlers for mutation events and such.\r\n    //\r\n    // This step has to be skipped for the following browsers:\r\n    //\r\n    // - ancient versions of IE (IE6, IE7).\r\n    //   IE6 and IE7 can't handle the feature tests on DOM ready - they crash right away. Later on, the tests are ok.\r\n    //\r\n    // - IE9.\r\n    //   If the feature tests were run on DOM ready, the window load event would become unreliable. The event might not\r\n    //   fire until the user moves the mouse over the document. This bug is rare and not triggered by jQuery.documentSize\r\n    //   alone; third-party code likely plays a role. The exact circumstances are not clear - see issue #3.\r\n    //\r\n    // For these browsers, we don't run the feature tests preemptively. Instead, we do it on demand, when the first\r\n    // document size query is made.\r\n    if (typeof $ === 'function' && !isAncientIE() && !isIE9()) {\r\n      // Try-catch acts as a safety net for unsupported, broken browsers\r\n      try {\r\n        $(function () {\r\n          if (elementNameForDocSizeQuery === undefined) testDocumentScroll()\r\n          browserScrollbarWidth()\r\n        })\r\n      } catch (e) {}\r\n    }\r\n\r\n    /**\r\n     * Custom types.\r\n     *\r\n     * For easier documentation and type inference.\r\n     */\r\n\r\n    /**\r\n     * @name ZoomAccuracyRange\r\n     * @type {Object}\r\n     *\r\n     * @property {number} calculated\r\n     * @property {number} min\r\n     * @property {number} max\r\n     */\r\n\r\n    /**\r\n     * @name WindowQueryConfig\r\n     * @type {Object}\r\n     *\r\n     * @property {Window}  window\r\n     * @property {boolean} useVisualViewport\r\n     * @property {boolean} useLayoutViewport\r\n     */\r\n  })(typeof jQuery !== 'undefined' ? jQuery : typeof Zepto !== 'undefined' ? Zepto : $)\r\n  return jQuery.documentSize\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/plugins/jquery.documentsize.js?");

/***/ }),

/***/ 359:
/*!**************************************************!*\
  !*** ./src/public/js/plugins/jquery.isinview.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var $ = __webpack_require__(/*! jquery */ 0);\n// jQuery.isInView, v1.0.3\r\n// Copyright (c)2015 Michael Heim, Zeilenwechsel.de\r\n// Distributed under MIT license\r\n// http://github.com/hashchange/jquery.isinview\r\n\r\n;(function (root, factory) {\r\n  'use strict'\r\n\r\n  if (true) {\r\n    module.exports = factory(__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! jquery_docsize */ 360))\r\n  } else {}\r\n})(this, function (jQuery) {\r\n  'use strict'\r\n  ;(function ($) {\r\n    'use strict'\r\n\r\n    var _useGetComputedStyle = !!window.getComputedStyle, // IE8, my dear, this is for you\r\n      _isIOS,\r\n      root = window,\r\n      $root = $(window)\r\n\r\n    /**\r\n     * API\r\n     */\r\n\r\n    /**\r\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\r\n     * @returns {boolean|Object|undefined}\r\n     */\r\n    $.fn.hasScrollbar = function (axis) {\r\n      return hasScrollbar(this, axis)\r\n    }\r\n\r\n    /**\r\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\r\n     * @returns {number|Object|undefined}\r\n     */\r\n    $.fn.scrollbarWidth = function (axis) {\r\n      return effectiveScrollbarWith(this, axis)\r\n    }\r\n\r\n    /**\r\n     * @returns {Window|undefined}\r\n     */\r\n    $.fn.ownerWindow = function () {\r\n      return ownerWindow(this)\r\n    }\r\n\r\n    /**\r\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\r\n     * @param {Object}                                    [opts]\r\n     * @param {boolean}                                   [opts.partially=false]\r\n     * @param {boolean}                                   [opts.excludeHidden=false]\r\n     * @param {string}                                    [opts.direction=\"both\"]\r\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {jQuery}\r\n     */\r\n    $.fn.inView = function (container, opts) {\r\n      return inView(this, container, opts)\r\n    }\r\n\r\n    /**\r\n     * @param {Object}        [opts]\r\n     * @param {boolean}       [opts.partially=false]\r\n     * @param {boolean}       [opts.excludeHidden=false]\r\n     * @param {string}        [opts.direction=\"both\"]\r\n     * @param {string}        [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string} [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {jQuery}\r\n     */\r\n    $.fn.inViewport = function (opts) {\r\n      return inView(this, ownerWindow(this), opts)\r\n    }\r\n\r\n    /**\r\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\r\n     * @param {Object}                                    [opts]\r\n     * @param {boolean}                                   [opts.partially=false]\r\n     * @param {boolean}                                   [opts.excludeHidden=false]\r\n     * @param {string}                                    [opts.direction=\"both\"]\r\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    $.fn.isInView = function (container, opts) {\r\n      return isInView(this, container, opts)\r\n    }\r\n\r\n    /**\r\n     * @param {Object}        [opts]\r\n     * @param {boolean}       [opts.partially=false]\r\n     * @param {boolean}       [opts.excludeHidden=false]\r\n     * @param {string}        [opts.direction=\"both\"]\r\n     * @param {string}        [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string} [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    $.fn.isInViewport = function (opts) {\r\n      return isInView(this, ownerWindow(this), opts)\r\n    }\r\n\r\n    $.expr.match.inviewport = /^(?:inVieport)$/i\r\n\r\n    $.expr.setFilters.inviewport = $.expr.createPseudo(function () {\r\n      return $.expr.createPseudo(function (elems, matches) {\r\n        var i,\r\n          config,\r\n          length = elems.length\r\n\r\n        if (length) {\r\n          config = _prepareConfig($(elems))\r\n          checkHierarchy(elems[0], config.container)\r\n\r\n          for (i = 0; i < length; i++) {\r\n            matches[i] = _isInView(elems[i], config) ? elems[i] : undefined\r\n          }\r\n        }\r\n      })\r\n    })\r\n\r\n    /**\r\n     * Internals\r\n     */\r\n\r\n    /**\r\n     * Does the actual work of $.fn.hasScrollbar. Protected from external modification. See $.fn.hasScrollbar for\r\n     * details.\r\n     *\r\n     * @param   {jQuery} $elem\r\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\r\n     * @returns {boolean|Object|undefined}\r\n     */\r\n    function hasScrollbar ($elem, axis) {\r\n      var $body,\r\n        elemProps,\r\n        bodyProps,\r\n        innerWidth,\r\n        innerHeight,\r\n        scrollWidth,\r\n        scrollHeight,\r\n        query = { target: {} },\r\n        result = {},\r\n        context = {},\r\n        elem = $elem[0]\r\n\r\n      $elem = $elem.eq(0)\r\n      axis || (axis = 'both')\r\n\r\n      query.getBoth = axis === 'both'\r\n      query.getHorizontal = axis === 'horizontal' || query.getBoth\r\n      query.getVertical = axis === 'vertical' || query.getBoth\r\n\r\n      if (axis !== 'horizontal' && axis !== 'vertical' && axis !== 'both')\r\n        throw new Error('Invalid parameter value: axis = ' + axis)\r\n      if (!$elem.length) return\r\n\r\n      // Transformations:\r\n      // - If called on a window, we need window, document, documentElement and body, and discard the element\r\n      // - If called on the document or document element, we treat it like a call on window (above)\r\n      // - If called on the body, we need document, documentElement and the body itself (again, we discard the element\r\n      //   to avoid ambiguity)\r\n      // - If called on an iframe element, we treat it like a window call, using the iframe content window\r\n      query.target.isWindow = $.isWindow(elem)\r\n      if (query.target.isWindow) {\r\n        context.document = elem.document\r\n      } else if (elem.nodeType === 9) {\r\n        context.document = elem\r\n        query.target.isWindow = true\r\n      } else if (elem === elem.ownerDocument.documentElement) {\r\n        context.document = elem.ownerDocument\r\n        query.target.isWindow = true\r\n      } else if (elem.nodeType === 1 && elem.tagName.toLowerCase() === 'iframe') {\r\n        context.document = elem.contentDocument || elem.contentWindow.document\r\n        query.target.isWindow = true\r\n      } else if (elem === elem.ownerDocument.body) {\r\n        context.document = elem.ownerDocument\r\n        query.target.isBody = true\r\n      }\r\n\r\n      if (query.target.isWindow || query.target.isBody) {\r\n        context.window = context.document.defaultView || context.document.parentWindow\r\n        context.$document = $(context.document)\r\n        context.documentElement = context.document.documentElement\r\n        context.body = context.document.body\r\n\r\n        elem = $elem = undefined // won't be needed; discard, to avoid ambiguity in the code below\r\n      }\r\n\r\n      if (query.target.isWindow) {\r\n        result = _windowHasScrollbar(query, context)\r\n      } else if (query.target.isBody) {\r\n        // Checking for body scroll bars.\r\n        //\r\n        // body.clientWidth returns the width of the body, minus the scroll bars. We can simply compare it to the\r\n        // full width, provided that the browser displays scroll bars which take up space.\r\n        //\r\n        // By implication, this check DOES NOT work for an effective body overflow of \"auto\" in browsers which\r\n        // display scroll bars of width 0. (Affects iOS, other mobile browsers, and Safari on OS X when used without\r\n        // an attached mouse.) There simply is no reliable, bullet-proof way to determine the width of the body\r\n        // content, ie the true body scroll width, in those browsers.\r\n        bodyProps = _getViewportOverflows(query, context).body\r\n\r\n        $body = $(context.body)\r\n        if (query.getHorizontal)\r\n          result.horizontal =\r\n            bodyProps.overflowScrollX || (bodyProps.overflowAutoX && context.body.clientHeight < $body.height())\r\n        if (query.getVertical)\r\n          result.vertical =\r\n            bodyProps.overflowScrollY || (bodyProps.overflowAutoY && context.body.clientWidth < $body.width())\r\n      } else {\r\n        // Scroll bars on an ordinary HTML element\r\n        //\r\n        // If we deal with an ordinary element, we always need the overflow settings for both axes because the axes\r\n        // interact (one scroll bar can cause another).\r\n        elemProps = getCss(elem, ['overflow', 'overflowX', 'overflowY'], { toLowerCase: true })\r\n        elemProps = getAppliedOverflows(elemProps, true)\r\n\r\n        scrollWidth = elem.scrollWidth\r\n        scrollHeight = elem.scrollHeight\r\n\r\n        result.horizontal =\r\n          scrollWidth > 0 &&\r\n          (elemProps.overflowScrollX || (elemProps.overflowAutoX && (innerWidth = $elem.innerWidth()) < scrollWidth))\r\n        result.vertical =\r\n          scrollHeight > 0 &&\r\n          (elemProps.overflowScrollY || (elemProps.overflowAutoY && (innerHeight = $elem.innerHeight()) < scrollHeight))\r\n\r\n        // Detect if the appearance of one scroll bar causes the other to appear, too.\r\n        result.vertical =\r\n          result.vertical ||\r\n          (result.horizontal &&\r\n            elemProps.overflowAutoY &&\r\n            (innerHeight !== undefined ? innerHeight : $elem.innerHeight()) - $.scrollbarWidth() < scrollHeight)\r\n        result.horizontal =\r\n          result.horizontal ||\r\n          (result.vertical &&\r\n            elemProps.overflowAutoX &&\r\n            (innerWidth !== undefined ? innerWidth : $elem.innerWidth()) - $.scrollbarWidth() < scrollWidth)\r\n      }\r\n\r\n      return query.getBoth ? result : query.getHorizontal ? result.horizontal : result.vertical\r\n    }\r\n\r\n    /**\r\n     * Does the actual work of $.fn.scrollbarWidth. Protected from external modification. See $.fn.scrollbarWidth for\r\n     * details.\r\n     *\r\n     * @param   {jQuery} $elem\r\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\r\n     * @returns {number|Object}\r\n     */\r\n    function effectiveScrollbarWith ($elem, axis) {\r\n      var queryHorizontal,\r\n        queryVertical,\r\n        queryBoth,\r\n        elemHasScrollbar,\r\n        horizontal,\r\n        vertical,\r\n        globalWidth = $.scrollbarWidth()\r\n\r\n      axis || (axis = 'both')\r\n\r\n      queryBoth = axis === 'both'\r\n      queryHorizontal = axis === 'horizontal' || queryBoth\r\n      queryVertical = axis === 'vertical' || queryBoth\r\n\r\n      if (axis !== 'horizontal' && axis !== 'vertical' && axis !== 'both')\r\n        throw new Error('Invalid parameter value: axis = ' + axis)\r\n      if (!$elem.length) return\r\n\r\n      // Bail out early, without an $elem.hasScrollbar() query, if scroll bars don't take up any space.\r\n      if (globalWidth === 0) return queryBoth ? { horizontal: 0, vertical: 0 } : 0\r\n\r\n      elemHasScrollbar = queryBoth\r\n        ? hasScrollbar($elem)\r\n        : queryHorizontal\r\n        ? { horizontal: hasScrollbar($elem, 'horizontal') }\r\n        : { vertical: hasScrollbar($elem, 'vertical') }\r\n\r\n      if (queryHorizontal) horizontal = elemHasScrollbar.horizontal ? globalWidth : 0\r\n      if (queryVertical) vertical = elemHasScrollbar.vertical ? globalWidth : 0\r\n\r\n      return queryBoth ? { horizontal: horizontal, vertical: vertical } : queryHorizontal ? horizontal : vertical\r\n    }\r\n\r\n    /**\r\n     * Does the actual work of $.fn.ownerWindow. Protected from external modification. See $.fn.ownerWindow for details.\r\n     *\r\n     * @param   {jQuery} $elem\r\n     * @returns {Window|undefined}\r\n     */\r\n    function ownerWindow ($elem) {\r\n      var elem = $elem[0],\r\n        ownerDocument = elem && (elem.nodeType === 9 ? elem : elem.ownerDocument)\r\n\r\n      return (\r\n        (ownerDocument && (ownerDocument.defaultView || ownerDocument.parentWindow)) ||\r\n        ($.isWindow(elem) && elem) ||\r\n        undefined\r\n      )\r\n    }\r\n\r\n    /**\r\n     * Does the actual work of $.fn.inView. Protected from external modification. See $.fn.inView for details.\r\n     *\r\n     * @param {jQuery}                                    $elems\r\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\r\n     * @param {Object}                                    [opts]\r\n     * @param {boolean}                                   [opts.partially=false]\r\n     * @param {boolean}                                   [opts.excludeHidden=false]\r\n     * @param {string}                                    [opts.direction=\"both\"]\r\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {jQuery}\r\n     */\r\n    function inView ($elems, container, opts) {\r\n      var config,\r\n        elemsInView = []\r\n\r\n      if (!$elems.length) return $()\r\n\r\n      config = _prepareConfig($elems, container, opts)\r\n\r\n      // Check if the elements are children of the container. For performance reasons, only the first element is\r\n      // examined.\r\n      checkHierarchy($elems[0], config.container)\r\n\r\n      $elems.each(function () {\r\n        if (_isInView(this, config)) elemsInView.push(this)\r\n      })\r\n\r\n      return $(elemsInView)\r\n    }\r\n\r\n    /**\r\n     * Does the actual work of $.fn.isInView. Protected from external modification. See $.fn.isInView for details.\r\n     *\r\n     * @param {jQuery}                                    $elem\r\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\r\n     * @param {Object}                                    [opts]\r\n     * @param {boolean}                                   [opts.partially=false]\r\n     * @param {boolean}                                   [opts.excludeHidden=false]\r\n     * @param {string}                                    [opts.direction=\"both\"]\r\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function isInView ($elem, container, opts) {\r\n      var config,\r\n        elem = $elem[0]\r\n\r\n      if (!$elem.length) return false\r\n\r\n      config = _prepareConfig($elem, container, opts)\r\n      checkHierarchy(elem, config.container)\r\n\r\n      return _isInView(elem, config)\r\n    }\r\n\r\n    /**\r\n     * Prepares the configuration for a single element query. Returns the config object which is to be consumed by\r\n     * _isInView().\r\n     *\r\n     * @param {jQuery}                                    $elem                       single element, or set of elements\r\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\r\n     * @param {Object}                                    [opts]\r\n     * @param {boolean}                                   [opts.partially=false]\r\n     * @param {boolean}                                   [opts.excludeHidden=false]\r\n     * @param {string}                                    [opts.direction=\"both\"]\r\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\r\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    function _prepareConfig ($elem, container, opts) {\r\n      var $container,\r\n        direction,\r\n        config = {}\r\n\r\n      opts || (opts = {})\r\n\r\n      container || (container = ownerWindow($elem))\r\n      config.$container = $container = wrapContainer(container)\r\n      config.container = container = $container[0]\r\n\r\n      checkOptions(opts)\r\n\r\n      direction = opts.direction || 'both'\r\n      config.useVertical = direction === 'both' || direction === 'vertical'\r\n      config.useHorizontal = direction === 'both' || direction === 'horizontal'\r\n\r\n      config.partially = opts.partially\r\n      config.excludeHidden = opts.excludeHidden\r\n      config.borderBox = opts.box !== 'content-box'\r\n      config.containerIsWindow = $.isWindow(container)\r\n\r\n      if (opts.tolerance !== undefined) {\r\n        config.toleranceType = isNumber(opts.tolerance) || opts.tolerance.slice(-3) === 'px' ? 'add' : 'multiply'\r\n        config.tolerance =\r\n          config.toleranceType === 'add' ? parseFloat(opts.tolerance) : parseFloat(opts.tolerance) / 100 + 1\r\n      } else {\r\n        config.tolerance = 0\r\n        config.toleranceType = 'add'\r\n      }\r\n\r\n      // Create an object to cache DOM queries with regard to the viewport, for faster repeated access.\r\n      config.cache = {}\r\n\r\n      return config\r\n    }\r\n\r\n    /**\r\n     * Returns if an element is in view, with regard to a given configuration.\r\n     *\r\n     * The configuration is built with _prepareConfig().\r\n     *\r\n     * @param {HTMLElement}        elem\r\n     * @param {Object}             config\r\n     * @param {HTMLElement|Window} config.container\r\n     * @param {jQuery}             config.$container\r\n     * @param {boolean}            config.containerIsWindow\r\n     * @param {Object}             config.cache\r\n     * @param {boolean}            config.useHorizontal\r\n     * @param {boolean}            config.useVertical\r\n     * @param {boolean}            config.partially\r\n     * @param {boolean}            config.excludeHidden\r\n     * @param {boolean}            config.borderBox\r\n     * @param {number}             config.tolerance\r\n     * @param {string}             config.toleranceType\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function _isInView (elem, config) {\r\n      var containerWidth,\r\n        containerHeight,\r\n        hTolerance,\r\n        vTolerance,\r\n        rect,\r\n        container = config.container,\r\n        $container = config.$container,\r\n        cache = config.cache,\r\n        elemInView = true\r\n\r\n      if (elem === container) throw new Error('Invalid container: is the same as the element')\r\n\r\n      // When hidden elements are ignored, we check if an element consumes space in the document. And we bail out\r\n      // immediately if it doesn't.\r\n      //\r\n      // The test employed for this works in the vast majority of cases, but there is a limitation. We use offsetWidth\r\n      // and offsetHeight, which considers the content (incl. borders) but ignores margins. Zero-size content with a\r\n      // margin might actually consume space sometimes, but it won't be detected (see http://jsbin.com/tiwabo/3).\r\n      //\r\n      // That said, the definition of visibility and the actual test are the same as in jQuery :visible.\r\n      if (config.excludeHidden && !(elem.offsetWidth > 0 && elem.offsetHeight > 0)) return false\r\n\r\n      if (config.useHorizontal) containerWidth = getNetContainerWidth($container, config.containerIsWindow, cache)\r\n      if (config.useVertical) containerHeight = getNetContainerHeight($container, config.containerIsWindow, cache)\r\n\r\n      // Convert tolerance to a px value (if given as a percentage)\r\n      hTolerance =\r\n        cache.hTolerance !== undefined\r\n          ? cache.hTolerance\r\n          : (cache.hTolerance = config.toleranceType === 'add' ? config.tolerance : containerWidth * config.tolerance)\r\n      vTolerance =\r\n        cache.vTolerance !== undefined\r\n          ? cache.vTolerance\r\n          : (cache.vTolerance = config.toleranceType === 'add' ? config.tolerance : containerHeight * config.tolerance)\r\n\r\n      // We can safely use getBoundingClientRect without a fallback. Its core properties (top, left, bottom, right)\r\n      // are supported on the desktop for ages (IE5+). On mobile, too: supported from Blackberry 6+ (2010), iOS 4\r\n      // (2010, iPhone 3GS+), according to the jQuery source comment in $.fn.offset.\r\n      //\r\n      // In oldIE (up to IE8), the coordinates were 2px off in each dimension because the \"viewport\" began at (2,2) of\r\n      // the window. Can be feature-tested by creating an absolutely positioned div at (0,0) and reading the rect\r\n      // coordinates. Won't be fixed here because the quirk is too minor to justify the overhead, just for oldIE.\r\n      //\r\n      // (See http://stackoverflow.com/a/10231202/508355 and Zakas, Professional Javascript (2012), p. 406)\r\n\r\n      rect = config.borderBox ? elem.getBoundingClientRect() : getContentRect(elem)\r\n      if (!config.containerIsWindow) rect = getRelativeRect(rect, $container, cache)\r\n\r\n      if (config.partially) {\r\n        if (config.useVertical) elemInView = rect.top < containerHeight + vTolerance && rect.bottom > -vTolerance\r\n        if (config.useHorizontal)\r\n          elemInView = elemInView && rect.left < containerWidth + hTolerance && rect.right > -hTolerance\r\n      } else {\r\n        if (config.useVertical)\r\n          elemInView =\r\n            rect.top >= -vTolerance &&\r\n            rect.top < containerHeight + vTolerance &&\r\n            rect.bottom > -vTolerance &&\r\n            rect.bottom <= containerHeight + vTolerance\r\n        if (config.useHorizontal)\r\n          elemInView =\r\n            elemInView &&\r\n            rect.left >= -hTolerance &&\r\n            rect.left < containerWidth + hTolerance &&\r\n            rect.right > -hTolerance &&\r\n            rect.right <= containerWidth + hTolerance\r\n      }\r\n\r\n      return elemInView\r\n    }\r\n\r\n    /**\r\n     * Gets the TextRectangle coordinates relative to a container element.\r\n     *\r\n     * Do not call if the container is a window (redundant) or a document. Both calls would fail.\r\n     */\r\n    function getRelativeRect (rect, $container, cache) {\r\n      var containerPaddingRectRoot\r\n\r\n      if (cache && cache.containerPaddingRectRoot) {\r\n        containerPaddingRectRoot = cache.containerPaddingRectRoot\r\n      } else {\r\n        // gBCR coordinates enclose padding, and leave out margin. That is perfect for scrolling because\r\n        //\r\n        // - padding scrolls (ie,o it is part of the scrollable area, and gBCR puts it inside)\r\n        // - margin doesn't scroll (ie, it pushes the scrollable area to another position, and gBCR records that)\r\n        //\r\n        // Borders, however, don't scroll, so they are not part of the scrollable area, but gBCR puts them inside.\r\n        //\r\n        // (See http://jsbin.com/pivata/10 for an extensive test of gBCR behaviour.)\r\n\r\n        containerPaddingRectRoot = getPaddingRectRoot($container[0])\r\n\r\n        // Cache the calculations\r\n        if (cache) cache.containerPaddingRectRoot = containerPaddingRectRoot\r\n      }\r\n\r\n      return {\r\n        top: rect.top - containerPaddingRectRoot.top,\r\n        bottom: rect.bottom - containerPaddingRectRoot.top,\r\n        left: rect.left - containerPaddingRectRoot.left,\r\n        right: rect.right - containerPaddingRectRoot.left\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Calculates the rect of the content-box. Similar to getBoundingClientRect, but excludes padding and borders - and\r\n     * is much slower.\r\n     *\r\n     * @param   {HTMLElement} elem\r\n     * @returns {ClientRect}\r\n     */\r\n    function getContentRect (elem) {\r\n      var rect = elem.getBoundingClientRect(),\r\n        props = getCss(\r\n          elem,\r\n          [\r\n            'borderTopWidth',\r\n            'borderRightWidth',\r\n            'borderBottomWidth',\r\n            'borderLeftWidth',\r\n            'paddingTop',\r\n            'paddingRight',\r\n            'paddingBottom',\r\n            'paddingLeft'\r\n          ],\r\n          { toFloat: true }\r\n        )\r\n\r\n      return {\r\n        top: rect.top + props.paddingTop + props.borderTopWidth,\r\n        right: rect.right - (props.paddingRight + props.borderRightWidth),\r\n        bottom: rect.bottom - (props.paddingBottom + props.borderBottomWidth),\r\n        left: rect.left + props.paddingLeft + props.borderLeftWidth\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns the top, left coordinates of the rect of the padding box (offset box).\r\n     *\r\n     * The coordinates match those of getBoundingClientRect, but exclude the borders.\r\n     *\r\n     * Does not care about bottom, right coordinates, in order to speed up the process.\r\n     *\r\n     * @param   {HTMLElement} elem\r\n     * @returns {{ top: number, left: number }}\r\n     */\r\n    function getPaddingRectRoot (elem) {\r\n      var rect = elem.getBoundingClientRect(),\r\n        props = getCss(elem, ['borderTopWidth', 'borderLeftWidth'], { toFloat: true })\r\n\r\n      return {\r\n        top: rect.top + props.borderTopWidth,\r\n        left: rect.left + props.borderLeftWidth\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Returns the scroll bar state of the window. Helper for hasScrollbar().\r\n     *\r\n     * @param {Object} query\r\n     * @param {Object} context\r\n     *\r\n     * @returns {{vertical: boolean, horizontal: boolean}}\r\n     */\r\n    function _windowHasScrollbar (query, context) {\r\n      var windowInnerHeight,\r\n        windowInnerWidth,\r\n        windowProps,\r\n        scrollbarWidth = $.scrollbarWidth(),\r\n        result = {},\r\n        doneX = !query.getHorizontal,\r\n        doneY = !query.getVertical\r\n\r\n      // We may be able to take a shortcut. The window.innerWidth and -Height report the dimensions of the viewport\r\n      // including scroll bars, and documentElement.clientWidth and -Height report them without scroll bars. That\r\n      // gives the presence of a scroll bar away, as long as\r\n      //\r\n      // - the scroll bars actually take up space (width > 0)\r\n      // - the browser supports window.innerWidth/Height (IE8, for instance, does not)\r\n      // - the browser doesn't report a buggy value. FF has a bug which as only been fixed in FF25 (released 29 Oct\r\n      //   2013). It manifests itself in a fictional return value of 10 for these properties. See\r\n      //   * https://developer.mozilla.org/en-US/docs/Web/API/Window.innerWidth\r\n      //   * https://developer.mozilla.org/en-US/docs/Web/API/Window.innerHeight\r\n      //   * https://bugzilla.mozilla.org/show_bug.cgi?id=641188\r\n\r\n      if (query.getHorizontal && scrollbarWidth > 0) {\r\n        windowInnerHeight = context.window.innerHeight\r\n        if (windowInnerHeight > 10) {\r\n          result.horizontal = windowInnerHeight > context.documentElement.clientHeight\r\n          doneX = true\r\n        }\r\n      }\r\n\r\n      if (query.getVertical && scrollbarWidth > 0) {\r\n        windowInnerWidth = context.window.innerWidth\r\n        if (windowInnerWidth > 10) {\r\n          result.vertical = windowInnerWidth > context.documentElement.clientWidth\r\n          doneY = true\r\n        }\r\n      }\r\n\r\n      if (!doneX || !doneY) {\r\n        // Shortcut didn't work. We have to evaluate overflow settings, window and document size.\r\n\r\n        windowProps = _getViewportOverflows(query, context).window\r\n\r\n        // Handle the trivial cases first: window set to overflow: scroll or to overflow: hidden.\r\n        if (!doneX && windowProps.overflowScrollX) result.horizontal = doneX = true\r\n        if (!doneY && windowProps.overflowScrollY) result.vertical = doneY = true\r\n\r\n        if (!doneX && windowProps.overflowHiddenX) {\r\n          result.horizontal = false\r\n          doneX = true\r\n        }\r\n\r\n        if (!doneY && windowProps.overflowHiddenY) {\r\n          result.vertical = false\r\n          doneY = true\r\n        }\r\n\r\n        // Handle the remaining overflow: auto case\r\n        //\r\n        // (There is no actual overflow: visible case for the viewport, see getAppliedViewportOverflows.)\r\n        if (!doneX) result.horizontal = context.documentElement.clientWidth < $.documentWidth(context.document)\r\n        if (!doneY) result.vertical = context.documentElement.clientHeight < $.documentHeight(context.document)\r\n      }\r\n\r\n      return result\r\n    }\r\n\r\n    /**\r\n     * Returns the applied overflow for the viewport (documentElement) and body in an aggregated `{ window: ...,\r\n     * body: ...}` hash. Helper for hasScrollbar().\r\n     *\r\n     * If we deal with window or body scroll bars, we always need the settings for both body and window (documentElement)\r\n     * because they are interdependent. See getAppliedViewportOverflows().\r\n     *\r\n     * @param {Object} query\r\n     * @param {Object} context\r\n     * @returns {{window: AppliedOverflow, body: AppliedOverflow}}\r\n     */\r\n    function _getViewportOverflows (query, context) {\r\n      var windowProps,\r\n        bodyProps,\r\n        overflowPropNames = ['overflow'],\r\n        bodyOverflowPropNames = ['overflow']\r\n\r\n      if (query.getHorizontal) {\r\n        overflowPropNames.push('overflowX')\r\n        bodyOverflowPropNames.push('overflowX')\r\n      }\r\n      if (query.getVertical) {\r\n        overflowPropNames.push('overflowY')\r\n        bodyOverflowPropNames.push('overflowY')\r\n      }\r\n\r\n      windowProps = getCss(context.documentElement, overflowPropNames, { toLowerCase: true })\r\n      bodyProps = getCss(context.body, bodyOverflowPropNames, { toLowerCase: true })\r\n\r\n      return getAppliedViewportOverflows(windowProps, bodyProps)\r\n    }\r\n\r\n    /**\r\n     * Determines the effective overflow setting of an element, separately for each axis, based on the `overflow`,\r\n     * `overflowX` and `overflowY` properties of the element which must be passed in as a hash.\r\n     *\r\n     * Returns a hash of the computed results for overflowX, overflowY. Also adds boolean status properties to the hash\r\n     * if the createBooleans flag is set. These are properties for mere convenience. They signal if a particular\r\n     * overflow type applies (e.g. overflowHiddenX = true/false).\r\n     *\r\n     * ATTN The method does not take the special relation of body and documentElement into account. That is handled by\r\n     * the more specific getAppliedViewportOverflows() function.\r\n     *\r\n     * The effective overflow setting is established as follows:\r\n     *\r\n     * - If a computed value for `overflow(X/Y)` exists, it gets applied to the axis.\r\n     * - If not, the computed value of the general `overflow` setting gets applied to the axis.\r\n     * - If there is no computed value at all, the overflow default gets applied to the axis. The default is\r\n     *   \"visible\" in seemingly every browser out there. Falling back to the default should never be necessary,\r\n     *   though, because there always is a computed value.\r\n     *\r\n     * @param {Object}        props            hash of element properties (computed values)\r\n     * @param {string}        props.overflow\r\n     * @param {string}        props.overflowX\r\n     * @param {string}        props.overflowY\r\n     * @param {boolean=false} createBooleans   if true, create the full set of boolean status properties, e.g.\r\n     *                                         overflowVisibleX (true/false), overflowHiddenY (true/false) etc\r\n     * @returns {AppliedOverflow}              hash of the computed results: overflowX, overflowY, optional boolean\r\n     *                                         status properties\r\n     */\r\n    function getAppliedOverflows (props, createBooleans) {\r\n      var status = {}\r\n\r\n      // Establish the applied overflow (e.g. overflowX: \"scroll\")\r\n      status.overflowX = props.overflowX || props.overflow || 'visible'\r\n      status.overflowY = props.overflowY || props.overflow || 'visible'\r\n\r\n      // Create the derived boolean status properties (e.g overflowScrollX: true)\r\n      if (createBooleans) {\r\n        $.each(['Visible', 'Auto', 'Scroll', 'Hidden'], function (index, type) {\r\n          var lcType = type.toLowerCase()\r\n          status['overflow' + type + 'X'] = status.overflowX === lcType\r\n          status['overflow' + type + 'Y'] = status.overflowY === lcType\r\n        })\r\n      }\r\n\r\n      return status\r\n    }\r\n\r\n    /**\r\n     * Determines the effective overflow setting of the viewport and body, separately for each axis, based on the\r\n     * `overflow`, `overflowX` and `overflowY` properties of the documentElement and body which must be passed in as a\r\n     * hash.\r\n     *\r\n     * Returns the results for viewport and body in an aggregated `{ window: ..., body: ...}` hash.\r\n     *\r\n     * For the basic resolution mechanism, see getAppliedOverflows(). When determining the effective overflow, the\r\n     * peculiarities of viewport and body are taken into account:\r\n     *\r\n     * - Viewport and body overflows are interdependent. If the nominal viewport overflow for a given axis is \"visible\",\r\n     *   the viewport inherits the body overflow for that axis, and the body overflow is set to \"visible\". Curiously,\r\n     *   that transfer is _not_ reflected in the computed values, it just manifests in behaviour.\r\n     *\r\n     * - Once that is done, if the viewport overflow is still \"visible\" for an axis, it is effectively turned into\r\n     *   \"auto\". Scroll bars appear when the content overflows the viewport (ie, \"auto\" behaviour). Hence, this function\r\n     *   will indeed report \"auto\". Again, the transformation is only manifest in behaviour, not in the computed values.\r\n     *\r\n     * - In iOS, if the effective overflow setting of the viewport is \"hidden\", it is ignored and treated as \"auto\".\r\n     *   Content can still overflow the viewport, and scroll bars appear as needed.\r\n     *\r\n     *   Now, the catch. This behaviour is impossible to feature-detect. The computed values are not at all affected by\r\n     *   it, and the results reported eg. for clientHeight, offsetHeight, scrollHeight of body and documentElement do\r\n     *   not differ between Safari on iOS and, say, Chrome on the desktop. The numbers don't give the behaviour away.\r\n     *\r\n     *   So we have to resort to browser sniffing here. It sucks, but there is literally no other option.\r\n     *\r\n     * NB Additional status properties (see getAppliedOverflows) are always generated here.\r\n     *\r\n     * @param {Object} documentElementProps            hash of documentElement properties (computed values)\r\n     * @param {string} documentElementProps.overflow\r\n     * @param {string} documentElementProps.overflowX\r\n     * @param {string} documentElementProps.overflowY\r\n     *\r\n     * @param {Object} bodyProps                       hash of body properties (computed values)\r\n     * @param {string} bodyProps.overflow\r\n     * @param {string} bodyProps.overflowX\r\n     * @param {string} bodyProps.overflowY\r\n     *\r\n     * @returns {{window: AppliedOverflow, body: AppliedOverflow}}\r\n     */\r\n    function getAppliedViewportOverflows (documentElementProps, bodyProps) {\r\n      var _window = getAppliedOverflows(documentElementProps, false),\r\n        body = getAppliedOverflows(bodyProps, false),\r\n        consolidated = { window: {}, body: {} }\r\n\r\n      // Handle the interdependent relationship between body and window (documentElement) overflow\r\n      if (_window.overflowX === 'visible') {\r\n        // If the window overflow is set to \"visible\", body props get transferred to the window, body changes to\r\n        // \"visible\". (Nothing really changes if both are set to \"visible\".)\r\n        consolidated.body.overflowX = 'visible'\r\n        consolidated.window.overflowX = body.overflowX\r\n      } else {\r\n        // No transfer of properties.\r\n        // - If body overflow is \"visible\", it remains that way, and the window stays as it is.\r\n        // - If body and window are set to properties other than \"visible\", they keep their divergent settings.\r\n        consolidated.body.overflowX = body.overflowX\r\n        consolidated.window.overflowX = _window.overflowX\r\n      }\r\n\r\n      // Repeat for overflowY\r\n      if (_window.overflowY === 'visible') {\r\n        consolidated.body.overflowY = 'visible'\r\n        consolidated.window.overflowY = body.overflowY\r\n      } else {\r\n        consolidated.body.overflowY = body.overflowY\r\n        consolidated.window.overflowY = _window.overflowY\r\n      }\r\n\r\n      // window.overflow(X/Y): \"visible\" actually means \"auto\" because scroll bars appear as needed; transform\r\n      if (consolidated.window.overflowX === 'visible') consolidated.window.overflowX = 'auto'\r\n      if (consolidated.window.overflowY === 'visible') consolidated.window.overflowY = 'auto'\r\n\r\n      // In iOS, window.overflow(X/Y): \"hidden\" actually means \"auto\"; transform\r\n      if (isIOS()) {\r\n        if (consolidated.window.overflowX === 'hidden') consolidated.window.overflowX = 'auto'\r\n        if (consolidated.window.overflowY === 'hidden') consolidated.window.overflowY = 'auto'\r\n      }\r\n\r\n      // Add the boolean status properties to the result\r\n      consolidated.window = getAppliedOverflows(consolidated.window, true)\r\n      consolidated.body = getAppliedOverflows(consolidated.body, true)\r\n\r\n      return consolidated\r\n    }\r\n\r\n    /**\r\n     * Establishes the container and returns it in a jQuery wrapper.\r\n     *\r\n     * Resolves and normalizes the input, which may be a document, HTMLElement, window, or selector string. Corrects\r\n     * likely mistakes, such as passing in a document or an iframe, rather than the corresponding window.\r\n     *\r\n     * @param {Window|Document|HTMLElement|HTMLIFrameElement|jQuery|string} container\r\n     * @returns {jQuery}\r\n     */\r\n    function wrapContainer (container) {\r\n      var $container,\r\n        isJquery = container instanceof $\r\n\r\n      if (!isJquery && !$.isWindow(container) && !container.nodeType && !isString(container))\r\n        throw new Error('Invalid container: not a window, node, jQuery object or selector string')\r\n\r\n      $container = isJquery ? container : container === root ? $root : $(container)\r\n\r\n      if (!$container.length) throw new Error('Invalid container: empty jQuery object')\r\n\r\n      container = $container[0]\r\n\r\n      if (container.nodeType === 9) {\r\n        // Document is passed in, transform to window\r\n        $container = wrapContainer(container.defaultView || container.parentWindow)\r\n      } else if (container.nodeType === 1 && container.tagName.toLowerCase() === 'iframe') {\r\n        // IFrame element is passed in, transform to IFrame content window\r\n        $container = wrapContainer(container.contentWindow)\r\n      }\r\n\r\n      // Check if the container matches the requirements\r\n      if (!$.isWindow($container[0]) && $container.css('overflow') === 'visible')\r\n        throw new Error(\r\n          'Invalid container: is set to overflow:visible. Containers must have the ability to obscure some of their content, otherwise the in-view test is pointless. Containers must be set to overflow:scroll/auto/hide, or be a window (or document, or iframe, as proxies for a window)'\r\n        )\r\n\r\n      return $container\r\n    }\r\n\r\n    /**\r\n     * Checks if the element is a descendant of the container, and throws an error otherwise. Also checks the type of\r\n     * the element (must indeed be an element node).\r\n     *\r\n     * For performance reasons, this check should *not* be run on every element in a set.\r\n     *\r\n     * @param {HTMLElement}                 elem\r\n     * @param {Window|Document|HTMLElement} container\r\n     */\r\n    function checkHierarchy (elem, container) {\r\n      var elemIsContained\r\n\r\n      if (elem.nodeType !== 1) throw new Error('Invalid node: is not an element')\r\n\r\n      if ($.isWindow(container)) {\r\n        elemIsContained =\r\n          elem.ownerDocument && container === (elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow)\r\n      } else if (container.nodeType === 9) {\r\n        // We need a DOM element for this check, so we use the documentElement as a proxy if the container is a document.\r\n        elemIsContained = $.contains(container.documentElement, elem)\r\n      } else {\r\n        elemIsContained = $.contains(container, elem)\r\n      }\r\n\r\n      if (!elemIsContained) throw new Error('Invalid container: is not an ancestor of the element')\r\n    }\r\n\r\n    /**\r\n     * Spots likely option mistakes and throws appropriate errors.\r\n     *\r\n     * @param {Object} opts\r\n     */\r\n    function checkOptions (opts) {\r\n      var isNum, isNumWithUnit\r\n\r\n      if (\r\n        opts.direction &&\r\n        !(opts.direction === 'vertical' || opts.direction === 'horizontal' || opts.direction === 'both')\r\n      ) {\r\n        throw new Error('Invalid option value: direction = \"' + opts.direction + '\"')\r\n      }\r\n\r\n      if (opts.box && !(opts.box === 'border-box' || opts.box === 'content-box')) {\r\n        throw new Error('Invalid option value: box = \"' + opts.box + '\"')\r\n      }\r\n\r\n      if (opts.tolerance !== undefined) {\r\n        isNum = isNumber(opts.tolerance)\r\n        isNumWithUnit = isString(opts.tolerance) && /^[+-]?\\d*\\.?\\d+(px|%)?$/.test(opts.tolerance)\r\n        if (!(isNum || isNumWithUnit)) throw new Error('Invalid option value: tolerance = \"' + opts.tolerance + '\"')\r\n      }\r\n    }\r\n\r\n    /**\r\n     * Gets the width of a jQuery-wrapped container, excluding scroll bars. Also supports quirks mode for window\r\n     * containers, unlike jQuery's $( window ).width(). Makes use of caching if a cache object is provided.\r\n     *\r\n     * @param   {jQuery}  $container\r\n     * @param   {boolean} isWindow    required to speed up the process\r\n     * @param   {Object}  [cache]\r\n     * @returns {number}\r\n     */\r\n    function getNetContainerWidth ($container, isWindow, cache) {\r\n      var width\r\n\r\n      if (cache && cache.netContainerWidth !== undefined) {\r\n        width = cache.netContainerWidth\r\n      } else {\r\n        width = isWindow\r\n          ? getWindowDimension($container, 'Width')\r\n          : $container.innerWidth() - getContainerScrollbarWidths($container, cache).vertical\r\n\r\n        if (cache) cache.netContainerWidth = width\r\n      }\r\n\r\n      return width\r\n    }\r\n\r\n    /**\r\n     * Gets the height of a jQuery-wrapped container, excluding scroll bars. Also supports quirks mode for window\r\n     * containers, unlike jQuery's $( window ).height(). Makes use of caching if a cache object is provided.\r\n     *\r\n     * @param   {jQuery}  $container\r\n     * @param   {boolean} isWindow    required to speed up the process\r\n     * @param   {Object}  [cache]\r\n     * @returns {number}\r\n     */\r\n    function getNetContainerHeight ($container, isWindow, cache) {\r\n      var height\r\n\r\n      if (cache && cache.netContainerHeight !== undefined) {\r\n        height = cache.netContainerHeight\r\n      } else {\r\n        height = isWindow\r\n          ? getWindowDimension($container, 'Height')\r\n          : $container.innerHeight() - getContainerScrollbarWidths($container, cache).horizontal\r\n\r\n        if (cache) cache.netContainerHeight = height\r\n      }\r\n\r\n      return height\r\n    }\r\n\r\n    /**\r\n     * Gets the effective scroll bar widths of a given container. Makes use of caching if a cache object is provided.\r\n     *\r\n     * @param   {jQuery} $container\r\n     * @param   {Object} [cache]\r\n     * @returns {Object}\r\n     */\r\n    function getContainerScrollbarWidths ($container, cache) {\r\n      var containerScrollbarWidths\r\n\r\n      if (cache && cache.containerScrollbarWidths) {\r\n        containerScrollbarWidths = cache.containerScrollbarWidths\r\n      } else {\r\n        containerScrollbarWidths = effectiveScrollbarWith($container)\r\n        if (cache) cache.containerScrollbarWidths = containerScrollbarWidths\r\n      }\r\n\r\n      return containerScrollbarWidths\r\n    }\r\n\r\n    /**\r\n     * Gets the width or height of a jQuery-wrapped window. Use it instead of $container.width(). Supports quirks mode,\r\n     * unlike jQuery.\r\n     *\r\n     * Window dimensions are calculated as in Zakas, Professional Javascript (2012), p. 404. The standards mode part of\r\n     * it is the same as in jQuery, too.\r\n     *\r\n     * @param {jQuery} $window\r\n     * @param {string} dimension  \"Width\" or \"Height\" (capitalized!)\r\n     * @returns {number}\r\n     */\r\n    function getWindowDimension ($window, dimension) {\r\n      var doc = $window[0].document,\r\n        property = 'client' + dimension\r\n\r\n      return doc.compatMode === 'BackCompat' ? doc.body[property] : doc.documentElement[property]\r\n    }\r\n\r\n    /**\r\n     * Returns the computed style for a property, or an array of properties, as a hash.\r\n     *\r\n     * Building a CSS properties hash this way can be significantly faster than the more convenient, conventional jQuery\r\n     * approach, $( elem ).css( propertiesArray ).\r\n     *\r\n     * ATTN\r\n     * ====\r\n     *\r\n     * We are using an internal jQuery API here: $.css(). The current signature was introduced in jQuery 1.9.0. It may\r\n     * break without warning with any change of the minor version.\r\n     *\r\n     * For that reason, the $.css API is monitored by the tests in api.jquery.css.spec.js which verify that it works as\r\n     * expected.\r\n     *\r\n     * @param {HTMLElement}     elem\r\n     * @param {string|string[]} properties\r\n     * @param {Object}          [opts]\r\n     * @param {boolean}         [opts.toLowerCase=false]  ensures return values in lower case\r\n     * @param {boolean}         [opts.toFloat=false]      converts return values to numbers, using parseFloat\r\n     *\r\n     * @returns {Object}        property names and their values\r\n     */\r\n    function getCss (elem, properties, opts) {\r\n      var i,\r\n        length,\r\n        name,\r\n        props = {},\r\n        _window = elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow,\r\n        computedStyles = _useGetComputedStyle ? _window.getComputedStyle(elem, null) : elem.currentStyle\r\n\r\n      opts || (opts = {})\r\n\r\n      if (!$.isArray(properties)) properties = [properties]\r\n      length = properties.length\r\n\r\n      for (i = 0; i < length; i++) {\r\n        name = properties[i]\r\n        props[name] = $.css(elem, name, false, computedStyles)\r\n        if (opts.toLowerCase && props[name] && props[name].toLowerCase) props[name] = props[name].toLowerCase()\r\n        if (opts.toFloat) props[name] = parseFloat(props[name])\r\n      }\r\n\r\n      return props\r\n    }\r\n\r\n    /**\r\n     * Returns the bounding client rect, including width and height properties. Ensures compatibility with IE8, which\r\n     * supports getBoundingClientRect but doesn't calculate width and height.\r\n     *\r\n     * Use only when width and height are actually needed.\r\n     *\r\n     * Will be removed when IE8 support is dropped entirely.\r\n     *\r\n     * @param   {HTMLElement} elem\r\n     * @returns {ClientRect}\r\n     */\r\n    function getBoundingClientRectCompat (elem) {\r\n      var elemRect = elem.getBoundingClientRect()\r\n\r\n      if (elemRect.width === undefined || elemRect.height === undefined) {\r\n        // Fix for IE8\r\n        elemRect = {\r\n          top: elemRect.top,\r\n          left: elemRect.left,\r\n          bottom: elemRect.bottom,\r\n          right: elemRect.right,\r\n          width: elemRect.right - elemRect.left,\r\n          height: elemRect.bottom - elemRect.top\r\n        }\r\n      }\r\n\r\n      return elemRect\r\n    }\r\n\r\n    /**\r\n     * Detects if the browser is on iOS. Works for Safari as well as other browsers, say, Chrome on iOS.\r\n     *\r\n     * Required for some iOS behaviour which can't be feature-detected in any way.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    function isIOS () {\r\n      if (_isIOS === undefined) _isIOS = /iPad|iPhone|iPod/g.test(navigator.userAgent)\r\n      return _isIOS\r\n    }\r\n\r\n    /**\r\n     * Calls parseFloat on each value. Useful for removing units from numeric values.\r\n     *\r\n     * @param   {Object} object\r\n     * @returns {Object}\r\n     */\r\n    function toFloat (object) {\r\n      var transformed = {}\r\n\r\n      $.map(object, function (value, key) {\r\n        transformed[key] = parseFloat(value)\r\n      })\r\n\r\n      return transformed\r\n    }\r\n\r\n    /**\r\n     * Returns whether or not a value is of type number. Also rejects NaN as a number.\r\n     *\r\n     * NB This is not the same as $.isNumeric because $.isNumeric( \"3\" ) is true while isNumber( \"3\" ) is false.\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\r\n    function isNumber (value) {\r\n      // Done as in the Lodash compatibility build, but rejecting NaN as a number.\r\n      var isNumeric =\r\n        typeof value === 'number' ||\r\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object Number]') ||\r\n        false\r\n\r\n      // Reject NaN before returning\r\n      return isNumeric && value === +value\r\n    }\r\n\r\n    function isString (value) {\r\n      // Done as in the Lodash compatibility build\r\n      return (\r\n        typeof value === 'string' ||\r\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]') ||\r\n        false\r\n      )\r\n    }\r\n\r\n    /**\r\n     * Custom types.\r\n     *\r\n     * For easier documentation and type inference.\r\n     */\r\n\r\n    /**\r\n     * @name  AppliedOverflow\r\n     * @type  {Object}\r\n     *\r\n     * @property {string}  overflowX\r\n     * @property {string}  overflowY\r\n     * @property {boolean} overflowVisibleX\r\n     * @property {boolean} overflowVisibleY\r\n     * @property {boolean} overflowAutoX\r\n     * @property {boolean} overflowAutoY\r\n     * @property {boolean} overflowScrollX\r\n     * @property {boolean} overflowScrollY\r\n     * @property {boolean} overflowHiddenX\r\n     * @property {boolean} overflowHiddenY\r\n     */\r\n  })(typeof jQuery !== 'undefined' ? jQuery : $)\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/plugins/jquery.isinview.js?");

/***/ }),

/***/ 976:
/*!***********************************************!*\
  !*** ./src/public/js/plugins/jquery.steps.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/*!\r\n * jQuery Steps v1.1.0 - 09/04/2014\r\n * Copyright (c) 2014 Rafael Staib (http://www.jquery-steps.com)\r\n * Licensed under MIT http://www.opensource.org/licenses/MIT\r\n */\r\n;(function ($, undefined) {\r\n  $.fn.extend({\r\n    _aria: function (name, value) {\r\n      return this.attr('aria-' + name, value)\r\n    },\r\n\r\n    _removeAria: function (name) {\r\n      return this.removeAttr('aria-' + name)\r\n    },\r\n\r\n    _enableAria: function (enable) {\r\n      return enable == null || enable\r\n        ? this.removeClass('disabled')._aria('disabled', 'false')\r\n        : this.addClass('disabled')._aria('disabled', 'true')\r\n    },\r\n\r\n    _showAria: function (show) {\r\n      return show == null || show ? this.show()._aria('hidden', 'false') : this.hide()._aria('hidden', 'true')\r\n    },\r\n\r\n    _selectAria: function (select) {\r\n      return select == null || select\r\n        ? this.addClass('current')._aria('selected', 'true')\r\n        : this.removeClass('current')._aria('selected', 'false')\r\n    },\r\n\r\n    _id: function (id) {\r\n      return id ? this.attr('id', id) : this.attr('id')\r\n    }\r\n  })\r\n\r\n  if (!String.prototype.format) {\r\n    String.prototype.format = function () {\r\n      var args = arguments.length === 1 && $.isArray(arguments[0]) ? arguments[0] : arguments\r\n      var formattedString = this\r\n      for (var i = 0; i < args.length; i++) {\r\n        var pattern = new RegExp('\\\\{' + i + '\\\\}', 'gm')\r\n        formattedString = formattedString.replace(pattern, args[i])\r\n      }\r\n      return formattedString\r\n    }\r\n  }\r\n\r\n  /**\r\n   * A global unique id count.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @property _uniqueId\r\n   * @type Integer\r\n   **/\r\n  var _uniqueId = 0\r\n\r\n  /**\r\n   * The plugin prefix for cookies.\r\n   *\r\n   * @final\r\n   * @private\r\n   * @property _cookiePrefix\r\n   * @type String\r\n   **/\r\n  var _cookiePrefix = 'jQu3ry_5teps_St@te_'\r\n\r\n  /**\r\n   * Suffix for the unique tab id.\r\n   *\r\n   * @final\r\n   * @private\r\n   * @property _tabSuffix\r\n   * @type String\r\n   * @since 0.9.7\r\n   **/\r\n  var _tabSuffix = '-t-'\r\n\r\n  /**\r\n   * Suffix for the unique tabpanel id.\r\n   *\r\n   * @final\r\n   * @private\r\n   * @property _tabpanelSuffix\r\n   * @type String\r\n   * @since 0.9.7\r\n   **/\r\n  var _tabpanelSuffix = '-p-'\r\n\r\n  /**\r\n   * Suffix for the unique title id.\r\n   *\r\n   * @final\r\n   * @private\r\n   * @property _titleSuffix\r\n   * @type String\r\n   * @since 0.9.7\r\n   **/\r\n  var _titleSuffix = '-h-'\r\n\r\n  /**\r\n   * An error message for an \"index out of range\" error.\r\n   *\r\n   * @final\r\n   * @private\r\n   * @property _indexOutOfRangeErrorMessage\r\n   * @type String\r\n   **/\r\n  var _indexOutOfRangeErrorMessage = 'Index out of range.'\r\n\r\n  /**\r\n   * An error message for an \"missing corresponding element\" error.\r\n   *\r\n   * @final\r\n   * @private\r\n   * @property _missingCorrespondingElementErrorMessage\r\n   * @type String\r\n   **/\r\n  var _missingCorrespondingElementErrorMessage = 'One or more corresponding step {0} are missing.'\r\n\r\n  /**\r\n   * Adds a step to the cache.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method addStepToCache\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param step {Object} The step object to add\r\n   **/\r\n  function addStepToCache (wizard, step) {\r\n    getSteps(wizard).push(step)\r\n  }\r\n\r\n  function analyzeData (wizard, options, state) {\r\n    var stepTitles = wizard.children(options.headerTag),\r\n      stepContents = wizard.children(options.bodyTag)\r\n\r\n    // Validate content\r\n    if (stepTitles.length > stepContents.length) {\r\n      throwError(_missingCorrespondingElementErrorMessage, 'contents')\r\n    } else if (stepTitles.length < stepContents.length) {\r\n      throwError(_missingCorrespondingElementErrorMessage, 'titles')\r\n    }\r\n\r\n    var startIndex = options.startIndex\r\n\r\n    state.stepCount = stepTitles.length\r\n\r\n    // Tries to load the saved state (step position)\r\n    if (options.saveState && $.cookie) {\r\n      var savedState = $.cookie(_cookiePrefix + getUniqueId(wizard))\r\n      // Sets the saved position to the start index if not undefined or out of range\r\n      var savedIndex = parseInt(savedState, 0)\r\n      if (!isNaN(savedIndex) && savedIndex < state.stepCount) {\r\n        startIndex = savedIndex\r\n      }\r\n    }\r\n\r\n    state.currentIndex = startIndex\r\n\r\n    stepTitles.each(function (index) {\r\n      var item = $(this), // item == header\r\n        content = stepContents.eq(index),\r\n        modeData = content.data('mode'),\r\n        mode =\r\n          modeData == null\r\n            ? contentMode.html\r\n            : getValidEnumValue(\r\n                contentMode,\r\n                /^\\s*$/.test(modeData) || isNaN(modeData) ? modeData : parseInt(modeData, 0)\r\n              ),\r\n        contentUrl = mode === contentMode.html || content.data('url') === undefined ? '' : content.data('url'),\r\n        contentLoaded = mode !== contentMode.html && content.data('loaded') === '1',\r\n        step = $.extend({}, stepModel, {\r\n          title: item.html(),\r\n          content: mode === contentMode.html ? content.html() : '',\r\n          contentUrl: contentUrl,\r\n          contentMode: mode,\r\n          contentLoaded: contentLoaded\r\n        })\r\n\r\n      addStepToCache(wizard, step)\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Triggers the onCanceled event.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method cancel\r\n   * @param wizard {Object} The jQuery wizard object\r\n   **/\r\n  function cancel (wizard) {\r\n    wizard.triggerHandler('canceled')\r\n  }\r\n\r\n  function decreaseCurrentIndexBy (state, decreaseBy) {\r\n    return state.currentIndex - decreaseBy\r\n  }\r\n\r\n  /**\r\n   * Removes the control functionality completely and transforms the current state to the initial HTML structure.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method destroy\r\n   * @param wizard {Object} A jQuery wizard object\r\n   **/\r\n  function destroy (wizard, options) {\r\n    var eventNamespace = getEventNamespace(wizard)\r\n\r\n    // Remove virtual data objects from the wizard\r\n    wizard\r\n      .unbind(eventNamespace)\r\n      .removeData('uid')\r\n      .removeData('options')\r\n      .removeData('state')\r\n      .removeData('steps')\r\n      .removeData('eventNamespace')\r\n      .find('.actions a')\r\n      .unbind(eventNamespace)\r\n\r\n    // Remove attributes and CSS classes from the wizard\r\n    wizard.removeClass(options.clearFixCssClass + ' vertical')\r\n\r\n    var contents = wizard.find('.content > *')\r\n\r\n    // Remove virtual data objects from panels and their titles\r\n    contents\r\n      .removeData('loaded')\r\n      .removeData('mode')\r\n      .removeData('url')\r\n\r\n    // Remove attributes, CSS classes and reset inline styles on all panels and their titles\r\n    contents\r\n      .removeAttr('id')\r\n      .removeAttr('role')\r\n      .removeAttr('tabindex')\r\n      .removeAttr('class')\r\n      .removeAttr('style')\r\n      ._removeAria('labelledby')\r\n      ._removeAria('hidden')\r\n\r\n    // Empty panels if the mode is set to 'async' or 'iframe'\r\n    wizard.find(\".content > [data-mode='async'],.content > [data-mode='iframe']\").empty()\r\n\r\n    var wizardSubstitute = $('<{0} class=\"{1}\"></{0}>'.format(wizard.get(0).tagName, wizard.attr('class')))\r\n\r\n    var wizardId = wizard._id()\r\n    if (wizardId != null && wizardId !== '') {\r\n      wizardSubstitute._id(wizardId)\r\n    }\r\n\r\n    wizardSubstitute.html(wizard.find('.content').html())\r\n    wizard.after(wizardSubstitute)\r\n    wizard.remove()\r\n\r\n    return wizardSubstitute\r\n  }\r\n\r\n  /**\r\n   * Triggers the onFinishing and onFinished event.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method finishStep\r\n   * @param wizard {Object} The jQuery wizard object\r\n   * @param state {Object} The state container of the current wizard\r\n   **/\r\n  function finishStep (wizard, state) {\r\n    var currentStep = wizard.find('.steps li').eq(state.currentIndex)\r\n\r\n    if (wizard.triggerHandler('finishing', [state.currentIndex])) {\r\n      currentStep.addClass('done').removeClass('error')\r\n      wizard.triggerHandler('finished', [state.currentIndex])\r\n    } else {\r\n      currentStep.addClass('error')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets or creates if not exist an unique event namespace for the given wizard instance.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method getEventNamespace\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @return {String} Returns the unique event namespace for the given wizard\r\n   */\r\n  function getEventNamespace (wizard) {\r\n    var eventNamespace = wizard.data('eventNamespace')\r\n\r\n    if (eventNamespace == null) {\r\n      eventNamespace = '.' + getUniqueId(wizard)\r\n      wizard.data('eventNamespace', eventNamespace)\r\n    }\r\n\r\n    return eventNamespace\r\n  }\r\n\r\n  function getStepAnchor (wizard, index) {\r\n    var uniqueId = getUniqueId(wizard)\r\n\r\n    return wizard.find('#' + uniqueId + _tabSuffix + index)\r\n  }\r\n\r\n  function getStepPanel (wizard, index) {\r\n    var uniqueId = getUniqueId(wizard)\r\n\r\n    return wizard.find('#' + uniqueId + _tabpanelSuffix + index)\r\n  }\r\n\r\n  function getStepTitle (wizard, index) {\r\n    var uniqueId = getUniqueId(wizard)\r\n\r\n    return wizard.find('#' + uniqueId + _titleSuffix + index)\r\n  }\r\n\r\n  function getOptions (wizard) {\r\n    return wizard.data('options')\r\n  }\r\n\r\n  function getState (wizard) {\r\n    return wizard.data('state')\r\n  }\r\n\r\n  function getSteps (wizard) {\r\n    return wizard.data('steps')\r\n  }\r\n\r\n  /**\r\n   * Gets a specific step object by index.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method getStep\r\n   * @param index {Integer} An integer that belongs to the position of a step\r\n   * @return {Object} A specific step object\r\n   **/\r\n  function getStep (wizard, index) {\r\n    var steps = getSteps(wizard)\r\n\r\n    if (index < 0 || index >= steps.length) {\r\n      throwError(_indexOutOfRangeErrorMessage)\r\n    }\r\n\r\n    return steps[index]\r\n  }\r\n\r\n  /**\r\n   * Gets or creates if not exist an unique id from the given wizard instance.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method getUniqueId\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @return {String} Returns the unique id for the given wizard\r\n   */\r\n  function getUniqueId (wizard) {\r\n    var uniqueId = wizard.data('uid')\r\n\r\n    if (uniqueId == null) {\r\n      uniqueId = wizard._id()\r\n      if (uniqueId == null) {\r\n        uniqueId = 'steps-uid-'.concat(_uniqueId)\r\n        wizard._id(uniqueId)\r\n      }\r\n\r\n      _uniqueId++\r\n      wizard.data('uid', uniqueId)\r\n    }\r\n\r\n    return uniqueId\r\n  }\r\n\r\n  /**\r\n   * Gets a valid enum value by checking a specific enum key or value.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method getValidEnumValue\r\n   * @param enumType {Object} Type of enum\r\n   * @param keyOrValue {Object} Key as `String` or value as `Integer` to check for\r\n   */\r\n  function getValidEnumValue (enumType, keyOrValue) {\r\n    validateArgument('enumType', enumType)\r\n    validateArgument('keyOrValue', keyOrValue)\r\n\r\n    // Is key\r\n    if (typeof keyOrValue === 'string') {\r\n      var value = enumType[keyOrValue]\r\n      if (value === undefined) {\r\n        throwError(\"The enum key '{0}' does not exist.\", keyOrValue)\r\n      }\r\n\r\n      return value\r\n    }\r\n    // Is value\r\n    else if (typeof keyOrValue === 'number') {\r\n      for (var key in enumType) {\r\n        if (enumType[key] === keyOrValue) {\r\n          return keyOrValue\r\n        }\r\n      }\r\n\r\n      throwError(\"Invalid enum value '{0}'.\", keyOrValue)\r\n    }\r\n    // Type is not supported\r\n    else {\r\n      throwError('Invalid key or value type.')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Routes to the next step.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method goToNextStep\r\n   * @param wizard {Object} The jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @return {Boolean} Indicates whether the action executed\r\n   **/\r\n  function goToNextStep (wizard, options, state) {\r\n    return paginationClick(wizard, options, state, increaseCurrentIndexBy(state, 1))\r\n  }\r\n\r\n  /**\r\n   * Routes to the previous step.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method goToPreviousStep\r\n   * @param wizard {Object} The jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @return {Boolean} Indicates whether the action executed\r\n   **/\r\n  function goToPreviousStep (wizard, options, state) {\r\n    return paginationClick(wizard, options, state, decreaseCurrentIndexBy(state, 1))\r\n  }\r\n\r\n  /**\r\n   * Routes to a specific step by a given index.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method goToStep\r\n   * @param wizard {Object} The jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param index {Integer} The position (zero-based) to route to\r\n   * @return {Boolean} Indicates whether the action succeeded or failed\r\n   **/\r\n  function goToStep (wizard, options, state, index) {\r\n    if (index < 0 || index >= state.stepCount) {\r\n      throwError(_indexOutOfRangeErrorMessage)\r\n    }\r\n\r\n    if (options.forceMoveForward && index < state.currentIndex) {\r\n      return\r\n    }\r\n\r\n    var oldIndex = state.currentIndex\r\n    if (wizard.triggerHandler('stepChanging', [state.currentIndex, index])) {\r\n      // Save new state\r\n      state.currentIndex = index\r\n      saveCurrentStateToCookie(wizard, options, state)\r\n\r\n      // Change visualisation\r\n      refreshStepNavigation(wizard, options, state, oldIndex)\r\n      refreshPagination(wizard, options, state)\r\n      loadAsyncContent(wizard, options, state)\r\n      startTransitionEffect(wizard, options, state, index, oldIndex, function () {\r\n        wizard.triggerHandler('stepChanged', [index, oldIndex])\r\n      })\r\n    } else {\r\n      wizard\r\n        .find('.steps li')\r\n        .eq(oldIndex)\r\n        .addClass('error')\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  function increaseCurrentIndexBy (state, increaseBy) {\r\n    return state.currentIndex + increaseBy\r\n  }\r\n\r\n  /**\r\n   * Initializes the component.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method initialize\r\n   * @param options {Object} The component settings\r\n   **/\r\n  function initialize (options) {\r\n    /*jshint -W040 */\r\n    var opts = $.extend(true, {}, defaults, options)\r\n\r\n    return this.each(function () {\r\n      var wizard = $(this)\r\n      var state = {\r\n        currentIndex: opts.startIndex,\r\n        currentStep: null,\r\n        stepCount: 0,\r\n        transitionElement: null\r\n      }\r\n\r\n      // Create data container\r\n      wizard.data('options', opts)\r\n      wizard.data('state', state)\r\n      wizard.data('steps', [])\r\n\r\n      analyzeData(wizard, opts, state)\r\n      render(wizard, opts, state)\r\n      registerEvents(wizard, opts)\r\n\r\n      // Trigger focus\r\n      if (opts.autoFocus && _uniqueId === 0) {\r\n        getStepAnchor(wizard, opts.startIndex).focus()\r\n      }\r\n\r\n      wizard.triggerHandler('init', [opts.startIndex])\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Inserts a new step to a specific position.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method insertStep\r\n   * @param wizard {Object} The jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param index {Integer} The position (zero-based) to add\r\n   * @param step {Object} The step object to add\r\n   * @example\r\n   *     $(\"#wizard\").steps().insert(0, {\r\n   *         title: \"Title\",\r\n   *         content: \"\", // optional\r\n   *         contentMode: \"async\", // optional\r\n   *         contentUrl: \"/Content/Step/1\" // optional\r\n   *     });\r\n   * @chainable\r\n   **/\r\n  function insertStep (wizard, options, state, index, step) {\r\n    if (index < 0 || index > state.stepCount) {\r\n      throwError(_indexOutOfRangeErrorMessage)\r\n    }\r\n\r\n    // TODO: Validate step object\r\n\r\n    // Change data\r\n    step = $.extend({}, stepModel, step)\r\n    insertStepToCache(wizard, index, step)\r\n    if (state.currentIndex !== state.stepCount && state.currentIndex >= index) {\r\n      state.currentIndex++\r\n      saveCurrentStateToCookie(wizard, options, state)\r\n    }\r\n    state.stepCount++\r\n\r\n    var contentContainer = wizard.find('.content'),\r\n      header = $('<{0}>{1}</{0}>'.format(options.headerTag, step.title)),\r\n      body = $('<{0}></{0}>'.format(options.bodyTag))\r\n\r\n    if (step.contentMode == null || step.contentMode === contentMode.html) {\r\n      body.html(step.content)\r\n    }\r\n\r\n    if (index === 0) {\r\n      contentContainer.prepend(body).prepend(header)\r\n    } else {\r\n      getStepPanel(wizard, index - 1)\r\n        .after(body)\r\n        .after(header)\r\n    }\r\n\r\n    renderBody(wizard, state, body, index)\r\n    renderTitle(wizard, options, state, header, index)\r\n    refreshSteps(wizard, options, state, index)\r\n    if (index === state.currentIndex) {\r\n      refreshStepNavigation(wizard, options, state)\r\n    }\r\n    refreshPagination(wizard, options, state)\r\n\r\n    return wizard\r\n  }\r\n\r\n  /**\r\n   * Inserts a step object to the cache at a specific position.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method insertStepToCache\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param index {Integer} The position (zero-based) to add\r\n   * @param step {Object} The step object to add\r\n   **/\r\n  function insertStepToCache (wizard, index, step) {\r\n    getSteps(wizard).splice(index, 0, step)\r\n  }\r\n\r\n  /**\r\n   * Handles the keyup DOM event for pagination.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @event keyup\r\n   * @param event {Object} An event object\r\n   */\r\n  function keyUpHandler (event) {\r\n    var wizard = $(this),\r\n      options = getOptions(wizard),\r\n      state = getState(wizard)\r\n\r\n    if (options.suppressPaginationOnFocus && wizard.find(':focus').is(':input')) {\r\n      event.preventDefault()\r\n      return false\r\n    }\r\n\r\n    var keyCodes = { left: 37, right: 39 }\r\n    if (event.keyCode === keyCodes.left) {\r\n      event.preventDefault()\r\n      goToPreviousStep(wizard, options, state)\r\n    } else if (event.keyCode === keyCodes.right) {\r\n      event.preventDefault()\r\n      goToNextStep(wizard, options, state)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Loads and includes async content.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method loadAsyncContent\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   */\r\n  function loadAsyncContent (wizard, options, state) {\r\n    if (state.stepCount > 0) {\r\n      var currentIndex = state.currentIndex,\r\n        currentStep = getStep(wizard, currentIndex)\r\n\r\n      if (!options.enableContentCache || !currentStep.contentLoaded) {\r\n        switch (getValidEnumValue(contentMode, currentStep.contentMode)) {\r\n          case contentMode.iframe:\r\n            wizard\r\n              .find('.content > .body')\r\n              .eq(state.currentIndex)\r\n              .empty()\r\n              .html('<iframe src=\"' + currentStep.contentUrl + '\" frameborder=\"0\" scrolling=\"no\" />')\r\n              .data('loaded', '1')\r\n            break\r\n\r\n          case contentMode.async:\r\n            var currentStepContent = getStepPanel(wizard, currentIndex)\r\n              ._aria('busy', 'true')\r\n              .empty()\r\n              .append(renderTemplate(options.loadingTemplate, { text: options.labels.loading }))\r\n\r\n            $.ajax({ url: currentStep.contentUrl, cache: false }).done(function (data) {\r\n              currentStepContent\r\n                .empty()\r\n                .html(data)\r\n                ._aria('busy', 'false')\r\n                .data('loaded', '1')\r\n              wizard.triggerHandler('contentLoaded', [currentIndex])\r\n            })\r\n            break\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fires the action next or previous click event.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method paginationClick\r\n   * @param wizard {Object} The jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param index {Integer} The position (zero-based) to route to\r\n   * @return {Boolean} Indicates whether the event fired successfully or not\r\n   **/\r\n  function paginationClick (wizard, options, state, index) {\r\n    var oldIndex = state.currentIndex\r\n\r\n    if (index >= 0 && index < state.stepCount && !(options.forceMoveForward && index < state.currentIndex)) {\r\n      var anchor = getStepAnchor(wizard, index),\r\n        parent = anchor.parent(),\r\n        isDisabled = parent.hasClass('disabled')\r\n\r\n      // Enable the step to make the anchor clickable!\r\n      parent._enableAria()\r\n      anchor.click()\r\n\r\n      // An error occured\r\n      if (oldIndex === state.currentIndex && isDisabled) {\r\n        // Disable the step again if current index has not changed; prevents click action.\r\n        parent._enableAria(false)\r\n        return false\r\n      }\r\n\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Fires when a pagination click happens.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @event click\r\n   * @param event {Object} An event object\r\n   */\r\n  function paginationClickHandler (event) {\r\n    event.preventDefault()\r\n\r\n    var anchor = $(this),\r\n      wizard = anchor\r\n        .parent()\r\n        .parent()\r\n        .parent()\r\n        .parent(),\r\n      options = getOptions(wizard),\r\n      state = getState(wizard),\r\n      href = anchor.attr('href')\r\n\r\n    if (anchor.parent().hasClass('disabled')) return false\r\n\r\n    switch (href.substring(href.lastIndexOf('#') + 1)) {\r\n      case 'cancel':\r\n        cancel(wizard)\r\n        break\r\n\r\n      case 'finish':\r\n        finishStep(wizard, state)\r\n        break\r\n\r\n      case 'next':\r\n        goToNextStep(wizard, options, state)\r\n        break\r\n\r\n      case 'previous':\r\n        goToPreviousStep(wizard, options, state)\r\n        break\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Refreshs the visualization state for the entire pagination.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method refreshPagination\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   */\r\n  function refreshPagination (wizard, options, state) {\r\n    if (options.enablePagination) {\r\n      var finish = wizard.find(\".actions a[href$='#finish']\").parent(),\r\n        next = wizard.find(\".actions a[href$='#next']\").parent()\r\n\r\n      if (!options.forceMoveForward) {\r\n        var previous = wizard.find(\".actions a[href$='#previous']\").parent()\r\n        previous._enableAria(state.currentIndex > 0)\r\n      }\r\n\r\n      if (options.enableFinishButton && options.showFinishButtonAlways) {\r\n        finish._enableAria(state.stepCount > 0)\r\n        next._enableAria(state.stepCount > 1 && state.stepCount > state.currentIndex + 1)\r\n      } else {\r\n        finish._showAria(options.enableFinishButton && state.stepCount === state.currentIndex + 1)\r\n        next\r\n          ._showAria(state.stepCount === 0 || state.stepCount > state.currentIndex + 1)\r\n          ._enableAria(state.stepCount > state.currentIndex + 1 || !options.enableFinishButton)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Refreshs the visualization state for the step navigation (tabs).\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method refreshStepNavigation\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param [oldIndex] {Integer} The index of the prior step\r\n   */\r\n  function refreshStepNavigation (wizard, options, state, oldIndex) {\r\n    var currentOrNewStepAnchor = getStepAnchor(wizard, state.currentIndex),\r\n      currentInfo = $('<span class=\"current-info audible\">' + options.labels.current + ' </span>'),\r\n      stepTitles = wizard.find('.content > .title')\r\n\r\n    if (oldIndex != null) {\r\n      var oldStepAnchor = getStepAnchor(wizard, oldIndex)\r\n      oldStepAnchor\r\n        .parent()\r\n        .addClass('done')\r\n        .removeClass('error')\r\n        ._selectAria(false)\r\n      stepTitles\r\n        .eq(oldIndex)\r\n        .removeClass('current')\r\n        .next('.body')\r\n        .removeClass('current')\r\n      currentInfo = oldStepAnchor.find('.current-info')\r\n      currentOrNewStepAnchor.focus()\r\n    }\r\n\r\n    currentOrNewStepAnchor\r\n      .prepend(currentInfo)\r\n      .parent()\r\n      ._selectAria()\r\n      .removeClass('done')\r\n      ._enableAria()\r\n    stepTitles\r\n      .eq(state.currentIndex)\r\n      .addClass('current')\r\n      .next('.body')\r\n      .addClass('current')\r\n  }\r\n\r\n  /**\r\n   * Refreshes step buttons and their related titles beyond a certain position.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method refreshSteps\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param index {Integer} The start point for refreshing ids\r\n   */\r\n  function refreshSteps (wizard, options, state, index) {\r\n    var uniqueId = getUniqueId(wizard)\r\n\r\n    for (var i = index; i < state.stepCount; i++) {\r\n      var uniqueStepId = uniqueId + _tabSuffix + i,\r\n        uniqueBodyId = uniqueId + _tabpanelSuffix + i,\r\n        uniqueHeaderId = uniqueId + _titleSuffix + i,\r\n        title = wizard\r\n          .find('.title')\r\n          .eq(i)\r\n          ._id(uniqueHeaderId)\r\n\r\n      wizard\r\n        .find('.steps a')\r\n        .eq(i)\r\n        ._id(uniqueStepId)\r\n        ._aria('controls', uniqueBodyId)\r\n        .attr('href', '#' + uniqueHeaderId)\r\n        .html(renderTemplate(options.titleTemplate, { index: i + 1, title: title.html() }))\r\n      wizard\r\n        .find('.body')\r\n        .eq(i)\r\n        ._id(uniqueBodyId)\r\n        ._aria('labelledby', uniqueHeaderId)\r\n    }\r\n  }\r\n\r\n  function registerEvents (wizard, options) {\r\n    var eventNamespace = getEventNamespace(wizard)\r\n\r\n    wizard.bind('canceled' + eventNamespace, options.onCanceled)\r\n    wizard.bind('contentLoaded' + eventNamespace, options.onContentLoaded)\r\n    wizard.bind('finishing' + eventNamespace, options.onFinishing)\r\n    wizard.bind('finished' + eventNamespace, options.onFinished)\r\n    wizard.bind('init' + eventNamespace, options.onInit)\r\n    wizard.bind('stepChanging' + eventNamespace, options.onStepChanging)\r\n    wizard.bind('stepChanged' + eventNamespace, options.onStepChanged)\r\n\r\n    if (options.enableKeyNavigation) {\r\n      wizard.bind('keyup' + eventNamespace, keyUpHandler)\r\n    }\r\n\r\n    wizard.find('.actions a').bind('click' + eventNamespace, paginationClickHandler)\r\n  }\r\n\r\n  /**\r\n   * Removes a specific step by an given index.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method removeStep\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param index {Integer} The position (zero-based) of the step to remove\r\n   * @return Indecates whether the item is removed.\r\n   **/\r\n  function removeStep (wizard, options, state, index) {\r\n    // Index out of range and try deleting current item will return false.\r\n    if (index < 0 || index >= state.stepCount || state.currentIndex === index) {\r\n      return false\r\n    }\r\n\r\n    // Change data\r\n    removeStepFromCache(wizard, index)\r\n    if (state.currentIndex > index) {\r\n      state.currentIndex--\r\n      saveCurrentStateToCookie(wizard, options, state)\r\n    }\r\n    state.stepCount--\r\n\r\n    getStepTitle(wizard, index).remove()\r\n    getStepPanel(wizard, index).remove()\r\n    getStepAnchor(wizard, index)\r\n      .parent()\r\n      .remove()\r\n\r\n    // Set the \"first\" class to the new first step button\r\n    if (index === 0) {\r\n      wizard\r\n        .find('.steps li')\r\n        .first()\r\n        .addClass('first')\r\n    }\r\n\r\n    // Set the \"last\" class to the new last step button\r\n    if (index === state.stepCount) {\r\n      wizard\r\n        .find('.steps li')\r\n        .eq(index)\r\n        .addClass('last')\r\n    }\r\n\r\n    refreshSteps(wizard, options, state, index)\r\n    refreshPagination(wizard, options, state)\r\n\r\n    return true\r\n  }\r\n\r\n  function removeStepFromCache (wizard, index) {\r\n    getSteps(wizard).splice(index, 1)\r\n  }\r\n\r\n  /**\r\n   * Transforms the base html structure to a more sensible html structure.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method render\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   **/\r\n  function render (wizard, options, state) {\r\n    // Create a content wrapper and copy HTML from the intial wizard structure\r\n    var wrapperTemplate = '<{0} class=\"{1}\">{2}</{0}>',\r\n      orientation = getValidEnumValue(stepsOrientation, options.stepsOrientation),\r\n      verticalCssClass = orientation === stepsOrientation.vertical ? ' vertical' : '',\r\n      contentWrapper = $(\r\n        wrapperTemplate.format(options.contentContainerTag, 'content ' + options.clearFixCssClass, wizard.html())\r\n      ),\r\n      stepsWrapper = $(\r\n        wrapperTemplate.format(\r\n          options.stepsContainerTag,\r\n          'steps ' + options.clearFixCssClass,\r\n          '<ul role=\"tablist\"></ul>'\r\n        )\r\n      ),\r\n      stepTitles = contentWrapper.children(options.headerTag),\r\n      stepContents = contentWrapper.children(options.bodyTag)\r\n\r\n    // Transform the wizard wrapper and remove the inner HTML\r\n    wizard\r\n      .attr('role', 'application')\r\n      .empty()\r\n      .append(stepsWrapper)\r\n      .append(contentWrapper)\r\n      .addClass(options.cssClass + ' ' + options.clearFixCssClass + verticalCssClass)\r\n\r\n    // Add WIA-ARIA support\r\n    stepContents.each(function (index) {\r\n      renderBody(wizard, state, $(this), index)\r\n    })\r\n\r\n    stepTitles.each(function (index) {\r\n      renderTitle(wizard, options, state, $(this), index)\r\n    })\r\n\r\n    refreshStepNavigation(wizard, options, state)\r\n    renderPagination(wizard, options, state)\r\n  }\r\n\r\n  /**\r\n   * Transforms the body to a proper tabpanel.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method renderBody\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param body {Object} A jQuery body object\r\n   * @param index {Integer} The position of the body\r\n   */\r\n  function renderBody (wizard, state, body, index) {\r\n    var uniqueId = getUniqueId(wizard),\r\n      uniqueBodyId = uniqueId + _tabpanelSuffix + index,\r\n      uniqueHeaderId = uniqueId + _titleSuffix + index\r\n\r\n    body\r\n      ._id(uniqueBodyId)\r\n      .attr('role', 'tabpanel')\r\n      ._aria('labelledby', uniqueHeaderId)\r\n      .addClass('body' + ' step-' + index)\r\n      .attr('data-step', index)\r\n      ._showAria(state.currentIndex === index)\r\n  }\r\n\r\n  /**\r\n   * Renders a pagination if enabled.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method renderPagination\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   */\r\n  function renderPagination (wizard, options, state) {\r\n    if (options.enablePagination) {\r\n      var pagination = '<{0} class=\"actions no-ajaxy {1}\"><ul role=\"menu\" aria-label=\"{2}\">{3}</ul></{0}>',\r\n        buttonTemplate = '<li class=\"button_{0} no-ajaxy\"><a href=\"#{0}\" role=\"menuitem\" class=\"no-ajaxy\">{1}</a></li>',\r\n        buttons = ''\r\n\r\n      if (!options.forceMoveForward) {\r\n        buttons += buttonTemplate.format('previous', options.labels.previous)\r\n      }\r\n\r\n      buttons += buttonTemplate.format('next', options.labels.next)\r\n\r\n      if (options.enableFinishButton) {\r\n        buttons += buttonTemplate.format('finish', options.labels.finish)\r\n      }\r\n\r\n      if (options.enableCancelButton) {\r\n        buttons += buttonTemplate.format('cancel', options.labels.cancel)\r\n      }\r\n\r\n      wizard.append(\r\n        pagination.format(options.actionContainerTag, options.clearFixCssClass, options.labels.pagination, buttons)\r\n      )\r\n\r\n      refreshPagination(wizard, options, state)\r\n      loadAsyncContent(wizard, options, state)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Renders a template and replaces all placeholder.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method renderTemplate\r\n   * @param template {String} A template\r\n   * @param substitutes {Object} A list of substitute\r\n   * @return {String} The rendered template\r\n   */\r\n  function renderTemplate (template, substitutes) {\r\n    var matches = template.match(/#([a-z]*)#/gi)\r\n\r\n    for (var i = 0; i < matches.length; i++) {\r\n      var match = matches[i],\r\n        key = match.substring(1, match.length - 1)\r\n\r\n      if (substitutes[key] === undefined) {\r\n        throwError(\"The key '{0}' does not exist in the substitute collection!\", key)\r\n      }\r\n\r\n      template = template.replace(match, substitutes[key])\r\n    }\r\n\r\n    return template\r\n  }\r\n\r\n  /**\r\n   * Transforms the title to a step item button.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method renderTitle\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   * @param header {Object} A jQuery header object\r\n   * @param index {Integer} The position of the header\r\n   */\r\n  function renderTitle (wizard, options, state, header, index) {\r\n    var uniqueId = getUniqueId(wizard),\r\n      uniqueStepId = uniqueId + _tabSuffix + index,\r\n      uniqueBodyId = uniqueId + _tabpanelSuffix + index,\r\n      uniqueHeaderId = uniqueId + _titleSuffix + index,\r\n      stepCollection = wizard.find('.steps > ul'),\r\n      title = renderTemplate(options.titleTemplate, {\r\n        index: index + 1,\r\n        title: header.html()\r\n      }),\r\n      stepItem = $(\r\n        '<li role=\"tab\"><a id=\"' +\r\n          uniqueStepId +\r\n          '\" href=\"#' +\r\n          uniqueHeaderId +\r\n          '\" aria-controls=\"' +\r\n          uniqueBodyId +\r\n          '\" class=\"no-ajaxy\">' +\r\n          title +\r\n          '</a></li>'\r\n      )\r\n\r\n    stepItem._enableAria(options.enableAllSteps || state.currentIndex > index)\r\n\r\n    if (state.currentIndex > index) {\r\n      stepItem.addClass('done')\r\n    }\r\n\r\n    header\r\n      ._id(uniqueHeaderId)\r\n      .attr('tabindex', '-1')\r\n      .addClass('title')\r\n\r\n    if (index === 0) {\r\n      stepCollection.prepend(stepItem)\r\n    } else {\r\n      stepCollection\r\n        .find('li')\r\n        .eq(index - 1)\r\n        .after(stepItem)\r\n    }\r\n\r\n    // Set the \"first\" class to the new first step button\r\n    if (index === 0) {\r\n      stepCollection\r\n        .find('li')\r\n        .removeClass('first')\r\n        .eq(index)\r\n        .addClass('first')\r\n    }\r\n\r\n    // Set the \"last\" class to the new last step button\r\n    if (index === state.stepCount - 1) {\r\n      stepCollection\r\n        .find('li')\r\n        .removeClass('last')\r\n        .eq(index)\r\n        .addClass('last')\r\n    }\r\n\r\n    // Register click event\r\n    stepItem.children('a').bind('click' + getEventNamespace(wizard), stepClickHandler)\r\n  }\r\n\r\n  /**\r\n   * Saves the current state to a cookie.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method saveCurrentStateToCookie\r\n   * @param wizard {Object} A jQuery wizard object\r\n   * @param options {Object} Settings of the current wizard\r\n   * @param state {Object} The state container of the current wizard\r\n   */\r\n  function saveCurrentStateToCookie (wizard, options, state) {\r\n    if (options.saveState && $.cookie) {\r\n      $.cookie(_cookiePrefix + getUniqueId(wizard), state.currentIndex)\r\n    }\r\n  }\r\n\r\n  function startTransitionEffect (wizard, options, state, index, oldIndex, doneCallback) {\r\n    var stepContents = wizard.find('.content > .body'),\r\n      effect = getValidEnumValue(transitionEffect, options.transitionEffect),\r\n      effectSpeed = options.transitionEffectSpeed,\r\n      newStep = stepContents.eq(index),\r\n      currentStep = stepContents.eq(oldIndex)\r\n\r\n    switch (effect) {\r\n      case transitionEffect.fade:\r\n      case transitionEffect.slide:\r\n        var hide = effect === transitionEffect.fade ? 'fadeOut' : 'slideUp',\r\n          show = effect === transitionEffect.fade ? 'fadeIn' : 'slideDown'\r\n\r\n        state.transitionElement = newStep\r\n        currentStep[hide](effectSpeed, function () {\r\n          var wizard = $(this)\r\n              ._showAria(false)\r\n              .parent()\r\n              .parent(),\r\n            state = getState(wizard)\r\n\r\n          if (state.transitionElement) {\r\n            state.transitionElement[show](effectSpeed, function () {\r\n              $(this)._showAria()\r\n            })\r\n              .promise()\r\n              .done(doneCallback)\r\n            state.transitionElement = null\r\n          }\r\n        })\r\n        break\r\n\r\n      case transitionEffect.slideLeft:\r\n        var outerWidth = currentStep.outerWidth(true),\r\n          posFadeOut = index > oldIndex ? -outerWidth : outerWidth,\r\n          posFadeIn = index > oldIndex ? outerWidth : -outerWidth\r\n\r\n        $.when(\r\n          currentStep.animate({ left: posFadeOut }, effectSpeed, function () {\r\n            $(this)._showAria(false)\r\n          }),\r\n          newStep\r\n            .css('left', posFadeIn + 'px')\r\n            ._showAria()\r\n            .animate({ left: 0 }, effectSpeed)\r\n        ).done(doneCallback)\r\n        break\r\n\r\n      default:\r\n        $.when(currentStep._showAria(false), newStep._showAria()).done(doneCallback)\r\n        break\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fires when a step click happens.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @event click\r\n   * @param event {Object} An event object\r\n   */\r\n  function stepClickHandler (event) {\r\n    event.preventDefault()\r\n\r\n    var anchor = $(this),\r\n      wizard = anchor\r\n        .parent()\r\n        .parent()\r\n        .parent()\r\n        .parent(),\r\n      options = getOptions(wizard),\r\n      state = getState(wizard),\r\n      oldIndex = state.currentIndex\r\n\r\n    if (anchor.parent().is(':not(.disabled):not(.current)')) {\r\n      var href = anchor.attr('href'),\r\n        position = parseInt(href.substring(href.lastIndexOf('-') + 1), 0)\r\n\r\n      goToStep(wizard, options, state, position)\r\n    }\r\n\r\n    // If nothing has changed\r\n    if (oldIndex === state.currentIndex) {\r\n      getStepAnchor(wizard, oldIndex).focus()\r\n      return false\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function throwError (message) {\r\n    if (arguments.length > 1) {\r\n      message = message.format(Array.prototype.slice.call(arguments, 1))\r\n    }\r\n\r\n    throw new Error(message)\r\n  }\r\n\r\n  /**\r\n   * Checks an argument for null or undefined and throws an error if one check applies.\r\n   *\r\n   * @static\r\n   * @private\r\n   * @method validateArgument\r\n   * @param argumentName {String} The name of the given argument\r\n   * @param argumentValue {Object} The argument itself\r\n   */\r\n  function validateArgument (argumentName, argumentValue) {\r\n    if (argumentValue == null) {\r\n      throwError(\"The argument '{0}' is null or undefined.\", argumentName)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Represents a jQuery wizard plugin.\r\n   *\r\n   * @class steps\r\n   * @constructor\r\n   * @param [method={}] The name of the method as `String` or an JSON object for initialization\r\n   * @param [params=]* {Array} Additional arguments for a method call\r\n   * @chainable\r\n   **/\r\n  $.fn.steps = function (method) {\r\n    if ($.fn.steps[method]) {\r\n      return $.fn.steps[method].apply(this, Array.prototype.slice.call(arguments, 1))\r\n    } else if (typeof method === 'object' || !method) {\r\n      return initialize.apply(this, arguments)\r\n    } else {\r\n      $.error('Method ' + method + ' does not exist on jQuery.steps')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds a new step.\r\n   *\r\n   * @method add\r\n   * @param step {Object} The step object to add\r\n   * @chainable\r\n   **/\r\n  $.fn.steps.add = function (step) {\r\n    var state = getState(this)\r\n    return insertStep(this, getOptions(this), state, state.stepCount, step)\r\n  }\r\n\r\n  /**\r\n   * Gets the step count.\r\n   *\r\n   * @method count\r\n   * @return {Integer} step count\r\n   * @for steps\r\n   **/\r\n  $.fn.steps.count = function () {\r\n    var state = getState(this)\r\n    return state.stepCount\r\n  }\r\n\r\n  /**\r\n   * Removes the control functionality completely and transforms the current state to the initial HTML structure.\r\n   *\r\n   * @method destroy\r\n   * @chainable\r\n   **/\r\n  $.fn.steps.destroy = function () {\r\n    return destroy(this, getOptions(this))\r\n  }\r\n\r\n  /**\r\n   * Triggers the onFinishing and onFinished event.\r\n   *\r\n   * @method finish\r\n   **/\r\n  $.fn.steps.finish = function () {\r\n    finishStep(this, getState(this))\r\n  }\r\n\r\n  /**\r\n   * Gets the current step index.\r\n   *\r\n   * @method getCurrentIndex\r\n   * @return {Integer} The actual step index (zero-based)\r\n   * @for steps\r\n   **/\r\n  $.fn.steps.getCurrentIndex = function () {\r\n    return getState(this).currentIndex\r\n  }\r\n\r\n  /**\r\n   * Gets the current step object.\r\n   *\r\n   * @method getCurrentStep\r\n   * @return {Object} The actual step object\r\n   **/\r\n  $.fn.steps.getCurrentStep = function () {\r\n    return getStep(this, getState(this).currentIndex)\r\n  }\r\n\r\n  /**\r\n   * Gets a specific step object by index.\r\n   *\r\n   * @method getStep\r\n   * @param index {Integer} An integer that belongs to the position of a step\r\n   * @return {Object} A specific step object\r\n   **/\r\n  $.fn.steps.getStep = function (index) {\r\n    return getStep(this, index)\r\n  }\r\n\r\n  /**\r\n   * Inserts a new step to a specific position.\r\n   *\r\n   * @method insert\r\n   * @param index {Integer} The position (zero-based) to add\r\n   * @param step {Object} The step object to add\r\n   * @example\r\n   *     $(\"#wizard\").steps().insert(0, {\r\n   *         title: \"Title\",\r\n   *         content: \"\", // optional\r\n   *         contentMode: \"async\", // optional\r\n   *         contentUrl: \"/Content/Step/1\" // optional\r\n   *     });\r\n   * @chainable\r\n   **/\r\n  $.fn.steps.insert = function (index, step) {\r\n    return insertStep(this, getOptions(this), getState(this), index, step)\r\n  }\r\n\r\n  /**\r\n   * Routes to the next step.\r\n   *\r\n   * @method next\r\n   * @return {Boolean} Indicates whether the action executed\r\n   **/\r\n  $.fn.steps.next = function () {\r\n    return goToNextStep(this, getOptions(this), getState(this))\r\n  }\r\n\r\n  /**\r\n   * Routes to the previous step.\r\n   *\r\n   * @method previous\r\n   * @return {Boolean} Indicates whether the action executed\r\n   **/\r\n  $.fn.steps.previous = function () {\r\n    return goToPreviousStep(this, getOptions(this), getState(this))\r\n  }\r\n\r\n  /**\r\n   * Removes a specific step by an given index.\r\n   *\r\n   * @method remove\r\n   * @param index {Integer} The position (zero-based) of the step to remove\r\n   * @return Indecates whether the item is removed.\r\n   **/\r\n  $.fn.steps.remove = function (index) {\r\n    return removeStep(this, getOptions(this), getState(this), index)\r\n  }\r\n\r\n  /**\r\n   * Sets a specific step object by index.\r\n   *\r\n   * @method setStep\r\n   * @param index {Integer} An integer that belongs to the position of a step\r\n   **/\r\n  $.fn.steps.setStep = function (index) {\r\n    var options = getOptions(this),\r\n      state = getState(this)\r\n    return goToStep(this, options, state, index)\r\n  }\r\n\r\n  /**\r\n   * Skips an certain amount of steps.\r\n   *\r\n   * @method skip\r\n   * @param count {Integer} The amount of steps that should be skipped\r\n   * @return {Boolean} Indicates whether the action executed\r\n   **/\r\n  $.fn.steps.skip = function (count) {\r\n    throw new Error('Not yet implemented!')\r\n  }\r\n\r\n  /**\r\n   * An enum represents the different content types of a step and their loading mechanisms.\r\n   *\r\n   * @class contentMode\r\n   * @for steps\r\n   **/\r\n  var contentMode = ($.fn.steps.contentMode = {\r\n    /**\r\n     * HTML embedded content\r\n     *\r\n     * @readOnly\r\n     * @property html\r\n     * @type Integer\r\n     * @for contentMode\r\n     **/\r\n    html: 0,\r\n\r\n    /**\r\n     * IFrame embedded content\r\n     *\r\n     * @readOnly\r\n     * @property iframe\r\n     * @type Integer\r\n     * @for contentMode\r\n     **/\r\n    iframe: 1,\r\n\r\n    /**\r\n     * Async embedded content\r\n     *\r\n     * @readOnly\r\n     * @property async\r\n     * @type Integer\r\n     * @for contentMode\r\n     **/\r\n    async: 2\r\n  })\r\n\r\n  /**\r\n   * An enum represents the orientation of the steps navigation.\r\n   *\r\n   * @class stepsOrientation\r\n   * @for steps\r\n   **/\r\n  var stepsOrientation = ($.fn.steps.stepsOrientation = {\r\n    /**\r\n     * Horizontal orientation\r\n     *\r\n     * @readOnly\r\n     * @property horizontal\r\n     * @type Integer\r\n     * @for stepsOrientation\r\n     **/\r\n    horizontal: 0,\r\n\r\n    /**\r\n     * Vertical orientation\r\n     *\r\n     * @readOnly\r\n     * @property vertical\r\n     * @type Integer\r\n     * @for stepsOrientation\r\n     **/\r\n    vertical: 1\r\n  })\r\n\r\n  /**\r\n   * An enum that represents the various transition animations.\r\n   *\r\n   * @class transitionEffect\r\n   * @for steps\r\n   **/\r\n  var transitionEffect = ($.fn.steps.transitionEffect = {\r\n    /**\r\n     * No transition animation\r\n     *\r\n     * @readOnly\r\n     * @property none\r\n     * @type Integer\r\n     * @for transitionEffect\r\n     **/\r\n    none: 0,\r\n\r\n    /**\r\n     * Fade in transition\r\n     *\r\n     * @readOnly\r\n     * @property fade\r\n     * @type Integer\r\n     * @for transitionEffect\r\n     **/\r\n    fade: 1,\r\n\r\n    /**\r\n     * Slide up transition\r\n     *\r\n     * @readOnly\r\n     * @property slide\r\n     * @type Integer\r\n     * @for transitionEffect\r\n     **/\r\n    slide: 2,\r\n\r\n    /**\r\n     * Slide left transition\r\n     *\r\n     * @readOnly\r\n     * @property slideLeft\r\n     * @type Integer\r\n     * @for transitionEffect\r\n     **/\r\n    slideLeft: 3\r\n  })\r\n\r\n  var stepModel = ($.fn.steps.stepModel = {\r\n    title: '',\r\n    content: '',\r\n    contentUrl: '',\r\n    contentMode: contentMode.html,\r\n    contentLoaded: false\r\n  })\r\n\r\n  /**\r\n   * An object that represents the default settings.\r\n   * There are two possibities to override the sub-properties.\r\n   * Either by doing it generally (global) or on initialization.\r\n   *\r\n   * @static\r\n   * @class defaults\r\n   * @for steps\r\n   * @example\r\n   *   // Global approach\r\n   *   $.steps.defaults.headerTag = \"h3\";\r\n   * @example\r\n   *   // Initialization approach\r\n   *   $(\"#wizard\").steps({ headerTag: \"h3\" });\r\n   **/\r\n  var defaults = ($.fn.steps.defaults = {\r\n    /**\r\n     * The header tag is used to find the step button text within the declared wizard area.\r\n     *\r\n     * @property headerTag\r\n     * @type String\r\n     * @default \"h1\"\r\n     * @for defaults\r\n     **/\r\n    headerTag: 'h1',\r\n\r\n    /**\r\n     * The body tag is used to find the step content within the declared wizard area.\r\n     *\r\n     * @property bodyTag\r\n     * @type String\r\n     * @default \"div\"\r\n     * @for defaults\r\n     **/\r\n    bodyTag: 'div',\r\n\r\n    /**\r\n     * The content container tag which will be used to wrap all step contents.\r\n     *\r\n     * @property contentContainerTag\r\n     * @type String\r\n     * @default \"div\"\r\n     * @for defaults\r\n     **/\r\n    contentContainerTag: 'div',\r\n\r\n    /**\r\n     * The action container tag which will be used to wrap the pagination navigation.\r\n     *\r\n     * @property actionContainerTag\r\n     * @type String\r\n     * @default \"div\"\r\n     * @for defaults\r\n     **/\r\n    actionContainerTag: 'div',\r\n\r\n    /**\r\n     * The steps container tag which will be used to wrap the steps navigation.\r\n     *\r\n     * @property stepsContainerTag\r\n     * @type String\r\n     * @default \"div\"\r\n     * @for defaults\r\n     **/\r\n    stepsContainerTag: 'div',\r\n\r\n    /**\r\n     * The css class which will be added to the outer component wrapper.\r\n     *\r\n     * @property cssClass\r\n     * @type String\r\n     * @default \"wizard\"\r\n     * @for defaults\r\n     * @example\r\n     *     <div class=\"wizard\">\r\n     *         ...\r\n     *     </div>\r\n     **/\r\n    cssClass: 'wizard',\r\n\r\n    /**\r\n     * The css class which will be used for floating scenarios.\r\n     *\r\n     * @property clearFixCssClass\r\n     * @type String\r\n     * @default \"clearfix\"\r\n     * @for defaults\r\n     **/\r\n    clearFixCssClass: 'clearfix',\r\n\r\n    /**\r\n     * Determines whether the steps are vertically or horizontally oriented.\r\n     *\r\n     * @property stepsOrientation\r\n     * @type stepsOrientation\r\n     * @default horizontal\r\n     * @for defaults\r\n     * @since 1.0.0\r\n     **/\r\n    stepsOrientation: stepsOrientation.horizontal,\r\n\r\n    /*\r\n     * Tempplates\r\n     */\r\n\r\n    /**\r\n     * The title template which will be used to create a step button.\r\n     *\r\n     * @property titleTemplate\r\n     * @type String\r\n     * @default \"<span class=\\\"number\\\">#index#.</span> #title#\"\r\n     * @for defaults\r\n     **/\r\n    titleTemplate: '<span class=\"number\">#index#</span> <span class=\\'title\\'>#title#</span>',\r\n\r\n    /**\r\n     * The loading template which will be used to create the loading animation.\r\n     *\r\n     * @property loadingTemplate\r\n     * @type String\r\n     * @default \"<span class=\\\"spinner\\\"></span> #text#\"\r\n     * @for defaults\r\n     **/\r\n    loadingTemplate: '<span class=\"spinner\"></span> #text#',\r\n\r\n    /*\r\n     * Behaviour\r\n     */\r\n\r\n    /**\r\n     * Sets the focus to the first wizard instance in order to enable the key navigation from the begining if `true`.\r\n     *\r\n     * @property autoFocus\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     * @since 0.9.4\r\n     **/\r\n    autoFocus: false,\r\n\r\n    /**\r\n     * Enables all steps from the begining if `true` (all steps are clickable).\r\n     *\r\n     * @property enableAllSteps\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     **/\r\n    enableAllSteps: false,\r\n\r\n    /**\r\n     * Enables keyboard navigation if `true` (arrow left and arrow right).\r\n     *\r\n     * @property enableKeyNavigation\r\n     * @type Boolean\r\n     * @default true\r\n     * @for defaults\r\n     **/\r\n    enableKeyNavigation: true,\r\n\r\n    /**\r\n     * Enables pagination if `true`.\r\n     *\r\n     * @property enablePagination\r\n     * @type Boolean\r\n     * @default true\r\n     * @for defaults\r\n     **/\r\n    enablePagination: true,\r\n\r\n    /**\r\n     * Suppresses pagination if a form field is focused.\r\n     *\r\n     * @property suppressPaginationOnFocus\r\n     * @type Boolean\r\n     * @default true\r\n     * @for defaults\r\n     **/\r\n    suppressPaginationOnFocus: true,\r\n\r\n    /**\r\n     * Enables cache for async loaded or iframe embedded content.\r\n     *\r\n     * @property enableContentCache\r\n     * @type Boolean\r\n     * @default true\r\n     * @for defaults\r\n     **/\r\n    enableContentCache: true,\r\n\r\n    /**\r\n     * Shows the cancel button if enabled.\r\n     *\r\n     * @property enableCancelButton\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     **/\r\n    enableCancelButton: false,\r\n\r\n    /**\r\n     * Shows the finish button if enabled.\r\n     *\r\n     * @property enableFinishButton\r\n     * @type Boolean\r\n     * @default true\r\n     * @for defaults\r\n     **/\r\n    enableFinishButton: true,\r\n\r\n    /**\r\n     * Not yet implemented.\r\n     *\r\n     * @property preloadContent\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     **/\r\n    preloadContent: false,\r\n\r\n    /**\r\n     * Shows the finish button always (on each step; right beside the next button) if `true`.\r\n     * Otherwise the next button will be replaced by the finish button if the last step becomes active.\r\n     *\r\n     * @property showFinishButtonAlways\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     **/\r\n    showFinishButtonAlways: false,\r\n\r\n    /**\r\n     * Prevents jumping to a previous step.\r\n     *\r\n     * @property forceMoveForward\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     **/\r\n    forceMoveForward: false,\r\n\r\n    /**\r\n     * Saves the current state (step position) to a cookie.\r\n     * By coming next time the last active step becomes activated.\r\n     *\r\n     * @property saveState\r\n     * @type Boolean\r\n     * @default false\r\n     * @for defaults\r\n     **/\r\n    saveState: false,\r\n\r\n    /**\r\n     * The position to start on (zero-based).\r\n     *\r\n     * @property startIndex\r\n     * @type Integer\r\n     * @default 0\r\n     * @for defaults\r\n     **/\r\n    startIndex: 0,\r\n\r\n    /*\r\n     * Animation Effect Configuration\r\n     */\r\n\r\n    /**\r\n     * The animation effect which will be used for step transitions.\r\n     *\r\n     * @property transitionEffect\r\n     * @type transitionEffect\r\n     * @default none\r\n     * @for defaults\r\n     **/\r\n    transitionEffect: transitionEffect.none,\r\n\r\n    /**\r\n     * Animation speed for step transitions (in milliseconds).\r\n     *\r\n     * @property transitionEffectSpeed\r\n     * @type Integer\r\n     * @default 200\r\n     * @for defaults\r\n     **/\r\n    transitionEffectSpeed: 280,\r\n\r\n    /*\r\n     * Events\r\n     */\r\n\r\n    /**\r\n     * Fires before the step changes and can be used to prevent step changing by returning `false`.\r\n     * Very useful for form validation.\r\n     *\r\n     * @property onStepChanging\r\n     * @type Event\r\n     * @default function (event, currentIndex, newIndex) { return true; }\r\n     * @for defaults\r\n     **/\r\n    onStepChanging: function (event, currentIndex, newIndex) {\r\n      return true\r\n    },\r\n\r\n    /**\r\n     * Fires after the step has change.\r\n     *\r\n     * @property onStepChanged\r\n     * @type Event\r\n     * @default function (event, currentIndex, priorIndex) { }\r\n     * @for defaults\r\n     **/\r\n    onStepChanged: function (event, currentIndex, priorIndex) {},\r\n\r\n    /**\r\n     * Fires after cancelation.\r\n     *\r\n     * @property onCanceled\r\n     * @type Event\r\n     * @default function (event) { }\r\n     * @for defaults\r\n     **/\r\n    onCanceled: function (event) {},\r\n\r\n    /**\r\n     * Fires before finishing and can be used to prevent completion by returning `false`.\r\n     * Very useful for form validation.\r\n     *\r\n     * @property onFinishing\r\n     * @type Event\r\n     * @default function (event, currentIndex) { return true; }\r\n     * @for defaults\r\n     **/\r\n    onFinishing: function (event, currentIndex) {\r\n      return true\r\n    },\r\n\r\n    /**\r\n     * Fires after completion.\r\n     *\r\n     * @property onFinished\r\n     * @type Event\r\n     * @default function (event, currentIndex) { }\r\n     * @for defaults\r\n     **/\r\n    onFinished: function (event, currentIndex) {},\r\n\r\n    /**\r\n     * Fires after async content is loaded.\r\n     *\r\n     * @property onContentLoaded\r\n     * @type Event\r\n     * @default function (event, index) { }\r\n     * @for defaults\r\n     **/\r\n    onContentLoaded: function (event, currentIndex) {},\r\n\r\n    /**\r\n     * Fires when the wizard is initialized.\r\n     *\r\n     * @property onInit\r\n     * @type Event\r\n     * @default function (event) { }\r\n     * @for defaults\r\n     **/\r\n    onInit: function (event, currentIndex) {},\r\n\r\n    /**\r\n     * Contains all labels.\r\n     *\r\n     * @property labels\r\n     * @type Object\r\n     * @for defaults\r\n     **/\r\n    labels: {\r\n      /**\r\n       * Label for the cancel button.\r\n       *\r\n       * @property cancel\r\n       * @type String\r\n       * @default \"Cancel\"\r\n       * @for defaults\r\n       **/\r\n      cancel: 'Cancel',\r\n\r\n      /**\r\n       * This label is important for accessability reasons.\r\n       * Indicates which step is activated.\r\n       *\r\n       * @property current\r\n       * @type String\r\n       * @default \"current step:\"\r\n       * @for defaults\r\n       **/\r\n      current: 'current step:',\r\n\r\n      /**\r\n       * This label is important for accessability reasons and describes the kind of navigation.\r\n       *\r\n       * @property pagination\r\n       * @type String\r\n       * @default \"Pagination\"\r\n       * @for defaults\r\n       * @since 0.9.7\r\n       **/\r\n      pagination: 'Pagination',\r\n\r\n      /**\r\n       * Label for the finish button.\r\n       *\r\n       * @property finish\r\n       * @type String\r\n       * @default \"Finish\"\r\n       * @for defaults\r\n       **/\r\n      finish: 'Finish',\r\n\r\n      /**\r\n       * Label for the next button.\r\n       *\r\n       * @property next\r\n       * @type String\r\n       * @default \"Next\"\r\n       * @for defaults\r\n       **/\r\n      next: \"Next <i class='material-icons'>&#xE315;</i>\",\r\n\r\n      /**\r\n       * Label for the previous button.\r\n       *\r\n       * @property previous\r\n       * @type String\r\n       * @default \"Previous\"\r\n       * @for defaults\r\n       **/\r\n      previous: \"<i class='material-icons'>&#xE314;</i> Previous\",\r\n\r\n      /**\r\n       * Label for the loading animation.\r\n       *\r\n       * @property loading\r\n       * @type String\r\n       * @default \"Loading ...\"\r\n       * @for defaults\r\n       **/\r\n      loading: 'Loading ...'\r\n    }\r\n  })\r\n})(jQuery)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/plugins/jquery.steps.js?");

/***/ }),

/***/ 164:
/*!***************************************!*\
  !*** ./src/public/js/vendor/c3/c3.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* @license C3.js v0.6.12 | (c) C3 Team and other contributors | http://c3js.org/ */\r\n;(function (global, factory) {\r\n   true\r\n    ? (module.exports = factory())\r\n    : 0\r\n})(this, function () {\r\n  'use strict'\r\n\r\n  function _typeof (obj) {\r\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\r\n      _typeof = function (obj) {\r\n        return typeof obj\r\n      }\r\n    } else {\r\n      _typeof = function (obj) {\r\n        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype\r\n          ? 'symbol'\r\n          : typeof obj\r\n      }\r\n    }\r\n\r\n    return _typeof(obj)\r\n  }\r\n\r\n  function _classCallCheck (instance, Constructor) {\r\n    if (!(instance instanceof Constructor)) {\r\n      throw new TypeError('Cannot call a class as a function')\r\n    }\r\n  }\r\n\r\n  function _defineProperty (obj, key, value) {\r\n    if (key in obj) {\r\n      Object.defineProperty(obj, key, {\r\n        value: value,\r\n        enumerable: true,\r\n        configurable: true,\r\n        writable: true\r\n      })\r\n    } else {\r\n      obj[key] = value\r\n    }\r\n\r\n    return obj\r\n  }\r\n\r\n  function ChartInternal (api) {\r\n    var $$ = this\r\n    $$.d3 = window.d3 ? window.d3 :  true ? __webpack_require__(/*! d3 */ 165) : 0\r\n    $$.api = api\r\n    $$.config = $$.getDefaultConfig()\r\n    $$.data = {}\r\n    $$.cache = {}\r\n    $$.axes = {}\r\n  }\r\n\r\n  function Chart (config) {\r\n    var $$ = (this.internal = new ChartInternal(this))\r\n    $$.loadConfig(config)\r\n    $$.beforeInit(config)\r\n    $$.init()\r\n    $$.afterInit(config) // bind \"this\" to nested API\r\n    ;(function bindThis (fn, target, argThis) {\r\n      Object.keys(fn).forEach(function (key) {\r\n        target[key] = fn[key].bind(argThis)\r\n\r\n        if (Object.keys(fn[key]).length > 0) {\r\n          bindThis(fn[key], target[key], argThis)\r\n        }\r\n      })\r\n    })(Chart.prototype, this, this)\r\n  }\r\n\r\n  function AxisInternal (component, params) {\r\n    var internal = this\r\n    internal.component = component\r\n    internal.params = params || {}\r\n    internal.d3 = component.d3\r\n    internal.scale = internal.d3.scaleLinear()\r\n    internal.range\r\n    internal.orient = 'bottom'\r\n    internal.innerTickSize = 6\r\n    internal.outerTickSize = this.params.withOuterTick ? 6 : 0\r\n    internal.tickPadding = 3\r\n    internal.tickValues = null\r\n    internal.tickFormat\r\n    internal.tickArguments\r\n    internal.tickOffset = 0\r\n    internal.tickCulling = true\r\n    internal.tickCentered\r\n    internal.tickTextCharSize\r\n    internal.tickTextRotate = internal.params.tickTextRotate\r\n    internal.tickLength\r\n    internal.axis = internal.generateAxis()\r\n  }\r\n\r\n  AxisInternal.prototype.axisX = function (selection, x, tickOffset) {\r\n    selection.attr('transform', function (d) {\r\n      return 'translate(' + Math.ceil(x(d) + tickOffset) + ', 0)'\r\n    })\r\n  }\r\n\r\n  AxisInternal.prototype.axisY = function (selection, y) {\r\n    selection.attr('transform', function (d) {\r\n      return 'translate(0,' + Math.ceil(y(d)) + ')'\r\n    })\r\n  }\r\n\r\n  AxisInternal.prototype.scaleExtent = function (domain) {\r\n    var start = domain[0],\r\n      stop = domain[domain.length - 1]\r\n    return start < stop ? [start, stop] : [stop, start]\r\n  }\r\n\r\n  AxisInternal.prototype.generateTicks = function (scale) {\r\n    var internal = this\r\n    var i,\r\n      domain,\r\n      ticks = []\r\n\r\n    if (scale.ticks) {\r\n      return scale.ticks.apply(scale, internal.tickArguments)\r\n    }\r\n\r\n    domain = scale.domain()\r\n\r\n    for (i = Math.ceil(domain[0]); i < domain[1]; i++) {\r\n      ticks.push(i)\r\n    }\r\n\r\n    if (ticks.length > 0 && ticks[0] > 0) {\r\n      ticks.unshift(ticks[0] - (ticks[1] - ticks[0]))\r\n    }\r\n\r\n    return ticks\r\n  }\r\n\r\n  AxisInternal.prototype.copyScale = function () {\r\n    var internal = this\r\n    var newScale = internal.scale.copy(),\r\n      domain\r\n\r\n    if (internal.params.isCategory) {\r\n      domain = internal.scale.domain()\r\n      newScale.domain([domain[0], domain[1] - 1])\r\n    }\r\n\r\n    return newScale\r\n  }\r\n\r\n  AxisInternal.prototype.textFormatted = function (v) {\r\n    var internal = this,\r\n      formatted = internal.tickFormat ? internal.tickFormat(v) : v\r\n    return typeof formatted !== 'undefined' ? formatted : ''\r\n  }\r\n\r\n  AxisInternal.prototype.updateRange = function () {\r\n    var internal = this\r\n    internal.range = internal.scale.rangeExtent\r\n      ? internal.scale.rangeExtent()\r\n      : internal.scaleExtent(internal.scale.range())\r\n    return internal.range\r\n  }\r\n\r\n  AxisInternal.prototype.updateTickTextCharSize = function (tick) {\r\n    var internal = this\r\n\r\n    if (internal.tickTextCharSize) {\r\n      return internal.tickTextCharSize\r\n    }\r\n\r\n    var size = {\r\n      h: 11.5,\r\n      w: 5.5\r\n    }\r\n    tick\r\n      .select('text')\r\n      .text(function (d) {\r\n        return internal.textFormatted(d)\r\n      })\r\n      .each(function (d) {\r\n        var box = this.getBoundingClientRect(),\r\n          text = internal.textFormatted(d),\r\n          h = box.height,\r\n          w = text ? box.width / text.length : undefined\r\n\r\n        if (h && w) {\r\n          size.h = h\r\n          size.w = w\r\n        }\r\n      })\r\n      .text('')\r\n    internal.tickTextCharSize = size\r\n    return size\r\n  }\r\n\r\n  AxisInternal.prototype.isVertical = function () {\r\n    return this.orient === 'left' || this.orient === 'right'\r\n  }\r\n\r\n  AxisInternal.prototype.tspanData = function (d, i, scale) {\r\n    var internal = this\r\n    var splitted = internal.params.tickMultiline\r\n      ? internal.splitTickText(d, scale)\r\n      : [].concat(internal.textFormatted(d))\r\n\r\n    if (internal.params.tickMultiline && internal.params.tickMultilineMax > 0) {\r\n      splitted = internal.ellipsify(splitted, internal.params.tickMultilineMax)\r\n    }\r\n\r\n    return splitted.map(function (s) {\r\n      return {\r\n        index: i,\r\n        splitted: s,\r\n        length: splitted.length\r\n      }\r\n    })\r\n  }\r\n\r\n  AxisInternal.prototype.splitTickText = function (d, scale) {\r\n    var internal = this,\r\n      tickText = internal.textFormatted(d),\r\n      maxWidth = internal.params.tickWidth,\r\n      subtext,\r\n      spaceIndex,\r\n      textWidth,\r\n      splitted = []\r\n\r\n    if (Object.prototype.toString.call(tickText) === '[object Array]') {\r\n      return tickText\r\n    }\r\n\r\n    if (!maxWidth || maxWidth <= 0) {\r\n      maxWidth = internal.isVertical() ? 95 : internal.params.isCategory ? Math.ceil(scale(1) - scale(0)) - 12 : 110\r\n    }\r\n\r\n    function split (splitted, text) {\r\n      spaceIndex = undefined\r\n\r\n      for (var i = 1; i < text.length; i++) {\r\n        if (text.charAt(i) === ' ') {\r\n          spaceIndex = i\r\n        }\r\n\r\n        subtext = text.substr(0, i + 1)\r\n        textWidth = internal.tickTextCharSize.w * subtext.length // if text width gets over tick width, split by space index or crrent index\r\n\r\n        if (maxWidth < textWidth) {\r\n          return split(\r\n            splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)),\r\n            text.slice(spaceIndex ? spaceIndex + 1 : i)\r\n          )\r\n        }\r\n      }\r\n\r\n      return splitted.concat(text)\r\n    }\r\n\r\n    return split(splitted, tickText + '')\r\n  }\r\n\r\n  AxisInternal.prototype.ellipsify = function (splitted, max) {\r\n    if (splitted.length <= max) {\r\n      return splitted\r\n    }\r\n\r\n    var ellipsified = splitted.slice(0, max)\r\n    var remaining = 3\r\n\r\n    for (var i = max - 1; i >= 0; i--) {\r\n      var available = ellipsified[i].length\r\n      ellipsified[i] = ellipsified[i].substr(0, available - remaining).padEnd(available, '.')\r\n      remaining -= available\r\n\r\n      if (remaining <= 0) {\r\n        break\r\n      }\r\n    }\r\n\r\n    return ellipsified\r\n  }\r\n\r\n  AxisInternal.prototype.updateTickLength = function () {\r\n    var internal = this\r\n    internal.tickLength = Math.max(internal.innerTickSize, 0) + internal.tickPadding\r\n  }\r\n\r\n  AxisInternal.prototype.lineY2 = function (d) {\r\n    var internal = this,\r\n      tickPosition = internal.scale(d) + (internal.tickCentered ? 0 : internal.tickOffset)\r\n    return internal.range[0] < tickPosition && tickPosition < internal.range[1] ? internal.innerTickSize : 0\r\n  }\r\n\r\n  AxisInternal.prototype.textY = function () {\r\n    var internal = this,\r\n      rotate = internal.tickTextRotate\r\n    return rotate ? 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1) : internal.tickLength\r\n  }\r\n\r\n  AxisInternal.prototype.textTransform = function () {\r\n    var internal = this,\r\n      rotate = internal.tickTextRotate\r\n    return rotate ? 'rotate(' + rotate + ')' : ''\r\n  }\r\n\r\n  AxisInternal.prototype.textTextAnchor = function () {\r\n    var internal = this,\r\n      rotate = internal.tickTextRotate\r\n    return rotate ? (rotate > 0 ? 'start' : 'end') : 'middle'\r\n  }\r\n\r\n  AxisInternal.prototype.tspanDx = function () {\r\n    var internal = this,\r\n      rotate = internal.tickTextRotate\r\n    return rotate ? 8 * Math.sin(Math.PI * (rotate / 180)) : 0\r\n  }\r\n\r\n  AxisInternal.prototype.tspanDy = function (d, i) {\r\n    var internal = this,\r\n      dy = internal.tickTextCharSize.h\r\n\r\n    if (i === 0) {\r\n      if (internal.isVertical()) {\r\n        dy = -((d.length - 1) * (internal.tickTextCharSize.h / 2) - 3)\r\n      } else {\r\n        dy = '.71em'\r\n      }\r\n    }\r\n\r\n    return dy\r\n  }\r\n\r\n  AxisInternal.prototype.generateAxis = function () {\r\n    var internal = this,\r\n      d3 = internal.d3,\r\n      params = internal.params\r\n\r\n    function axis (g, transition) {\r\n      var self\r\n      g.each(function () {\r\n        var g = (axis.g = d3.select(this))\r\n        var scale0 = this.__chart__ || internal.scale,\r\n          scale1 = (this.__chart__ = internal.copyScale())\r\n        var ticksValues = internal.tickValues ? internal.tickValues : internal.generateTicks(scale1),\r\n          ticks = g.selectAll('.tick').data(ticksValues, scale1),\r\n          tickEnter = ticks\r\n            .enter()\r\n            .insert('g', '.domain')\r\n            .attr('class', 'tick')\r\n            .style('opacity', 1e-6),\r\n          // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.\r\n          tickExit = ticks.exit().remove(),\r\n          tickUpdate = ticks.merge(tickEnter),\r\n          tickTransform,\r\n          tickX,\r\n          tickY\r\n\r\n        if (params.isCategory) {\r\n          internal.tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2)\r\n          tickX = internal.tickCentered ? 0 : internal.tickOffset\r\n          tickY = internal.tickCentered ? internal.tickOffset : 0\r\n        } else {\r\n          internal.tickOffset = tickX = 0\r\n        }\r\n\r\n        internal.updateRange()\r\n        internal.updateTickLength()\r\n        internal.updateTickTextCharSize(g.select('.tick'))\r\n        var lineUpdate = tickUpdate.select('line').merge(tickEnter.append('line')),\r\n          textUpdate = tickUpdate.select('text').merge(tickEnter.append('text'))\r\n        var tspans = tickUpdate\r\n            .selectAll('text')\r\n            .selectAll('tspan')\r\n            .data(function (d, i) {\r\n              return internal.tspanData(d, i, scale1)\r\n            }),\r\n          tspanEnter = tspans.enter().append('tspan'),\r\n          tspanUpdate = tspanEnter.merge(tspans).text(function (d) {\r\n            return d.splitted\r\n          })\r\n        tspans.exit().remove()\r\n        var path = g.selectAll('.domain').data([0]),\r\n          pathUpdate = path\r\n            .enter()\r\n            .append('path')\r\n            .merge(path)\r\n            .attr('class', 'domain') // TODO: each attr should be one function and change its behavior by internal.orient, probably\r\n\r\n        switch (internal.orient) {\r\n          case 'bottom': {\r\n            tickTransform = internal.axisX\r\n            lineUpdate\r\n              .attr('x1', tickX)\r\n              .attr('x2', tickX)\r\n              .attr('y2', function (d, i) {\r\n                return internal.lineY2(d, i)\r\n              })\r\n            textUpdate\r\n              .attr('x', 0)\r\n              .attr('y', function (d, i) {\r\n                return internal.textY(d, i)\r\n              })\r\n              .attr('transform', function (d, i) {\r\n                return internal.textTransform(d, i)\r\n              })\r\n              .style('text-anchor', function (d, i) {\r\n                return internal.textTextAnchor(d, i)\r\n              })\r\n            tspanUpdate\r\n              .attr('x', 0)\r\n              .attr('dy', function (d, i) {\r\n                return internal.tspanDy(d, i)\r\n              })\r\n              .attr('dx', function (d, i) {\r\n                return internal.tspanDx(d, i)\r\n              })\r\n            pathUpdate.attr(\r\n              'd',\r\n              'M' +\r\n                internal.range[0] +\r\n                ',' +\r\n                internal.outerTickSize +\r\n                'V0H' +\r\n                internal.range[1] +\r\n                'V' +\r\n                internal.outerTickSize\r\n            )\r\n            break\r\n          }\r\n\r\n          case 'top': {\r\n            // TODO: rotated tick text\r\n            tickTransform = internal.axisX\r\n            lineUpdate\r\n              .attr('x1', tickX)\r\n              .attr('x2', tickX)\r\n              .attr('y2', function (d, i) {\r\n                return -1 * internal.lineY2(d, i)\r\n              })\r\n            textUpdate\r\n              .attr('x', 0)\r\n              .attr('y', function (d, i) {\r\n                return -1 * internal.textY(d, i) - (params.isCategory ? 2 : internal.tickLength - 2)\r\n              })\r\n              .attr('transform', function (d, i) {\r\n                return internal.textTransform(d, i)\r\n              })\r\n              .style('text-anchor', function (d, i) {\r\n                return internal.textTextAnchor(d, i)\r\n              })\r\n            tspanUpdate\r\n              .attr('x', 0)\r\n              .attr('dy', function (d, i) {\r\n                return internal.tspanDy(d, i)\r\n              })\r\n              .attr('dx', function (d, i) {\r\n                return internal.tspanDx(d, i)\r\n              })\r\n            pathUpdate.attr(\r\n              'd',\r\n              'M' +\r\n                internal.range[0] +\r\n                ',' +\r\n                -internal.outerTickSize +\r\n                'V0H' +\r\n                internal.range[1] +\r\n                'V' +\r\n                -internal.outerTickSize\r\n            )\r\n            break\r\n          }\r\n\r\n          case 'left': {\r\n            tickTransform = internal.axisY\r\n            lineUpdate\r\n              .attr('x2', -internal.innerTickSize)\r\n              .attr('y1', tickY)\r\n              .attr('y2', tickY)\r\n            textUpdate\r\n              .attr('x', -internal.tickLength)\r\n              .attr('y', internal.tickOffset)\r\n              .style('text-anchor', 'end')\r\n            tspanUpdate.attr('x', -internal.tickLength).attr('dy', function (d, i) {\r\n              return internal.tspanDy(d, i)\r\n            })\r\n            pathUpdate.attr(\r\n              'd',\r\n              'M' +\r\n                -internal.outerTickSize +\r\n                ',' +\r\n                internal.range[0] +\r\n                'H0V' +\r\n                internal.range[1] +\r\n                'H' +\r\n                -internal.outerTickSize\r\n            )\r\n            break\r\n          }\r\n\r\n          case 'right': {\r\n            tickTransform = internal.axisY\r\n            lineUpdate\r\n              .attr('x2', internal.innerTickSize)\r\n              .attr('y1', tickY)\r\n              .attr('y2', tickY)\r\n            textUpdate\r\n              .attr('x', internal.tickLength)\r\n              .attr('y', internal.tickOffset)\r\n              .style('text-anchor', 'start')\r\n            tspanUpdate.attr('x', internal.tickLength).attr('dy', function (d, i) {\r\n              return internal.tspanDy(d, i)\r\n            })\r\n            pathUpdate.attr(\r\n              'd',\r\n              'M' +\r\n                internal.outerTickSize +\r\n                ',' +\r\n                internal.range[0] +\r\n                'H0V' +\r\n                internal.range[1] +\r\n                'H' +\r\n                internal.outerTickSize\r\n            )\r\n            break\r\n          }\r\n        }\r\n\r\n        if (scale1.rangeBand) {\r\n          var x = scale1,\r\n            dx = x.rangeBand() / 2\r\n\r\n          scale0 = scale1 = function scale1 (d) {\r\n            return x(d) + dx\r\n          }\r\n        } else if (scale0.rangeBand) {\r\n          scale0 = scale1\r\n        } else {\r\n          tickExit.call(tickTransform, scale1, internal.tickOffset)\r\n        }\r\n\r\n        tickEnter.call(tickTransform, scale0, internal.tickOffset)\r\n        self = (transition ? tickUpdate.transition(transition) : tickUpdate)\r\n          .style('opacity', 1)\r\n          .call(tickTransform, scale1, internal.tickOffset)\r\n      })\r\n      return self\r\n    }\r\n\r\n    axis.scale = function (x) {\r\n      if (!arguments.length) {\r\n        return internal.scale\r\n      }\r\n\r\n      internal.scale = x\r\n      return axis\r\n    }\r\n\r\n    axis.orient = function (x) {\r\n      if (!arguments.length) {\r\n        return internal.orient\r\n      }\r\n\r\n      internal.orient =\r\n        x in\r\n        {\r\n          top: 1,\r\n          right: 1,\r\n          bottom: 1,\r\n          left: 1\r\n        }\r\n          ? x + ''\r\n          : 'bottom'\r\n      return axis\r\n    }\r\n\r\n    axis.tickFormat = function (format) {\r\n      if (!arguments.length) {\r\n        return internal.tickFormat\r\n      }\r\n\r\n      internal.tickFormat = format\r\n      return axis\r\n    }\r\n\r\n    axis.tickCentered = function (isCentered) {\r\n      if (!arguments.length) {\r\n        return internal.tickCentered\r\n      }\r\n\r\n      internal.tickCentered = isCentered\r\n      return axis\r\n    }\r\n\r\n    axis.tickOffset = function () {\r\n      return internal.tickOffset\r\n    }\r\n\r\n    axis.tickInterval = function () {\r\n      var interval, length\r\n\r\n      if (params.isCategory) {\r\n        interval = internal.tickOffset * 2\r\n      } else {\r\n        length =\r\n          axis.g\r\n            .select('path.domain')\r\n            .node()\r\n            .getTotalLength() -\r\n          internal.outerTickSize * 2\r\n        interval = length / axis.g.selectAll('line').size()\r\n      }\r\n\r\n      return interval === Infinity ? 0 : interval\r\n    }\r\n\r\n    axis.ticks = function () {\r\n      if (!arguments.length) {\r\n        return internal.tickArguments\r\n      }\r\n\r\n      internal.tickArguments = arguments\r\n      return axis\r\n    }\r\n\r\n    axis.tickCulling = function (culling) {\r\n      if (!arguments.length) {\r\n        return internal.tickCulling\r\n      }\r\n\r\n      internal.tickCulling = culling\r\n      return axis\r\n    }\r\n\r\n    axis.tickValues = function (x) {\r\n      if (typeof x === 'function') {\r\n        internal.tickValues = function () {\r\n          return x(internal.scale.domain())\r\n        }\r\n      } else {\r\n        if (!arguments.length) {\r\n          return internal.tickValues\r\n        }\r\n\r\n        internal.tickValues = x\r\n      }\r\n\r\n      return axis\r\n    }\r\n\r\n    return axis\r\n  }\r\n\r\n  var CLASS = {\r\n    target: 'c3-target',\r\n    chart: 'c3-chart',\r\n    chartLine: 'c3-chart-line',\r\n    chartLines: 'c3-chart-lines',\r\n    chartBar: 'c3-chart-bar',\r\n    chartBars: 'c3-chart-bars',\r\n    chartText: 'c3-chart-text',\r\n    chartTexts: 'c3-chart-texts',\r\n    chartArc: 'c3-chart-arc',\r\n    chartArcs: 'c3-chart-arcs',\r\n    chartArcsTitle: 'c3-chart-arcs-title',\r\n    chartArcsBackground: 'c3-chart-arcs-background',\r\n    chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',\r\n    chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',\r\n    chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',\r\n    selectedCircle: 'c3-selected-circle',\r\n    selectedCircles: 'c3-selected-circles',\r\n    eventRect: 'c3-event-rect',\r\n    eventRects: 'c3-event-rects',\r\n    eventRectsSingle: 'c3-event-rects-single',\r\n    eventRectsMultiple: 'c3-event-rects-multiple',\r\n    zoomRect: 'c3-zoom-rect',\r\n    brush: 'c3-brush',\r\n    dragZoom: 'c3-drag-zoom',\r\n    focused: 'c3-focused',\r\n    defocused: 'c3-defocused',\r\n    region: 'c3-region',\r\n    regions: 'c3-regions',\r\n    title: 'c3-title',\r\n    tooltipContainer: 'c3-tooltip-container',\r\n    tooltip: 'c3-tooltip',\r\n    tooltipName: 'c3-tooltip-name',\r\n    shape: 'c3-shape',\r\n    shapes: 'c3-shapes',\r\n    line: 'c3-line',\r\n    lines: 'c3-lines',\r\n    bar: 'c3-bar',\r\n    bars: 'c3-bars',\r\n    circle: 'c3-circle',\r\n    circles: 'c3-circles',\r\n    arc: 'c3-arc',\r\n    arcLabelLine: 'c3-arc-label-line',\r\n    arcs: 'c3-arcs',\r\n    area: 'c3-area',\r\n    areas: 'c3-areas',\r\n    empty: 'c3-empty',\r\n    text: 'c3-text',\r\n    texts: 'c3-texts',\r\n    gaugeValue: 'c3-gauge-value',\r\n    grid: 'c3-grid',\r\n    gridLines: 'c3-grid-lines',\r\n    xgrid: 'c3-xgrid',\r\n    xgrids: 'c3-xgrids',\r\n    xgridLine: 'c3-xgrid-line',\r\n    xgridLines: 'c3-xgrid-lines',\r\n    xgridFocus: 'c3-xgrid-focus',\r\n    ygrid: 'c3-ygrid',\r\n    ygrids: 'c3-ygrids',\r\n    ygridLine: 'c3-ygrid-line',\r\n    ygridLines: 'c3-ygrid-lines',\r\n    axis: 'c3-axis',\r\n    axisX: 'c3-axis-x',\r\n    axisXLabel: 'c3-axis-x-label',\r\n    axisY: 'c3-axis-y',\r\n    axisYLabel: 'c3-axis-y-label',\r\n    axisY2: 'c3-axis-y2',\r\n    axisY2Label: 'c3-axis-y2-label',\r\n    legendBackground: 'c3-legend-background',\r\n    legendItem: 'c3-legend-item',\r\n    legendItemEvent: 'c3-legend-item-event',\r\n    legendItemTile: 'c3-legend-item-tile',\r\n    legendItemHidden: 'c3-legend-item-hidden',\r\n    legendItemFocused: 'c3-legend-item-focused',\r\n    dragarea: 'c3-dragarea',\r\n    EXPANDED: '_expanded_',\r\n    SELECTED: '_selected_',\r\n    INCLUDED: '_included_'\r\n  }\r\n\r\n  var asHalfPixel = function asHalfPixel (n) {\r\n    return Math.ceil(n) + 0.5\r\n  }\r\n  var ceil10 = function ceil10 (v) {\r\n    return Math.ceil(v / 10) * 10\r\n  }\r\n  var diffDomain = function diffDomain (d) {\r\n    return d[1] - d[0]\r\n  }\r\n  var getOption = function getOption (options, key, defaultValue) {\r\n    return isDefined(options[key]) ? options[key] : defaultValue\r\n  }\r\n  var getPathBox = function getPathBox (path) {\r\n    var box = path.getBoundingClientRect(),\r\n      items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],\r\n      minX = items[0].x,\r\n      minY = Math.min(items[0].y, items[1].y)\r\n    return {\r\n      x: minX,\r\n      y: minY,\r\n      width: box.width,\r\n      height: box.height\r\n    }\r\n  }\r\n  var hasValue = function hasValue (dict, value) {\r\n    var found = false\r\n    Object.keys(dict).forEach(function (key) {\r\n      if (dict[key] === value) {\r\n        found = true\r\n      }\r\n    })\r\n    return found\r\n  }\r\n  var isArray = function isArray (o) {\r\n    return Array.isArray(o)\r\n  }\r\n  var isDefined = function isDefined (v) {\r\n    return typeof v !== 'undefined'\r\n  }\r\n  var isEmpty = function isEmpty (o) {\r\n    return (\r\n      typeof o === 'undefined' ||\r\n      o === null ||\r\n      (isString(o) && o.length === 0) ||\r\n      (_typeof(o) === 'object' && Object.keys(o).length === 0)\r\n    )\r\n  }\r\n  var isFunction = function isFunction (o) {\r\n    return typeof o === 'function'\r\n  }\r\n  var isString = function isString (o) {\r\n    return typeof o === 'string'\r\n  }\r\n  var isUndefined = function isUndefined (v) {\r\n    return typeof v === 'undefined'\r\n  }\r\n  var isValue = function isValue (v) {\r\n    return v || v === 0\r\n  }\r\n  var notEmpty = function notEmpty (o) {\r\n    return !isEmpty(o)\r\n  }\r\n  var sanitise = function sanitise (str) {\r\n    return typeof str === 'string' ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;') : str\r\n  }\r\n\r\n  var Axis = function Axis (owner) {\r\n    _classCallCheck(this, Axis)\r\n\r\n    this.owner = owner\r\n    this.d3 = owner.d3\r\n    this.internal = AxisInternal\r\n  }\r\n\r\n  Axis.prototype.init = function init () {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      main = $$.main\r\n    $$.axes.x = main\r\n      .append('g')\r\n      .attr('class', CLASS.axis + ' ' + CLASS.axisX)\r\n      .attr('clip-path', config.axis_x_inner ? '' : $$.clipPathForXAxis)\r\n      .attr('transform', $$.getTranslate('x'))\r\n      .style('visibility', config.axis_x_show ? 'visible' : 'hidden')\r\n    $$.axes.x\r\n      .append('text')\r\n      .attr('class', CLASS.axisXLabel)\r\n      .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')\r\n      .style('text-anchor', this.textAnchorForXAxisLabel.bind(this))\r\n    $$.axes.y = main\r\n      .append('g')\r\n      .attr('class', CLASS.axis + ' ' + CLASS.axisY)\r\n      .attr('clip-path', config.axis_y_inner ? '' : $$.clipPathForYAxis)\r\n      .attr('transform', $$.getTranslate('y'))\r\n      .style('visibility', config.axis_y_show ? 'visible' : 'hidden')\r\n    $$.axes.y\r\n      .append('text')\r\n      .attr('class', CLASS.axisYLabel)\r\n      .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')\r\n      .style('text-anchor', this.textAnchorForYAxisLabel.bind(this))\r\n    $$.axes.y2 = main\r\n      .append('g')\r\n      .attr('class', CLASS.axis + ' ' + CLASS.axisY2) // clip-path?\r\n      .attr('transform', $$.getTranslate('y2'))\r\n      .style('visibility', config.axis_y2_show ? 'visible' : 'hidden')\r\n    $$.axes.y2\r\n      .append('text')\r\n      .attr('class', CLASS.axisY2Label)\r\n      .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')\r\n      .style('text-anchor', this.textAnchorForY2AxisLabel.bind(this))\r\n  }\r\n\r\n  Axis.prototype.getXAxis = function getXAxis (\r\n    scale,\r\n    orient,\r\n    tickFormat,\r\n    tickValues,\r\n    withOuterTick,\r\n    withoutTransition,\r\n    withoutRotateTickText\r\n  ) {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      axisParams = {\r\n        isCategory: $$.isCategorized(),\r\n        withOuterTick: withOuterTick,\r\n        tickMultiline: config.axis_x_tick_multiline,\r\n        tickMultilineMax: config.axis_x_tick_multiline ? Number(config.axis_x_tick_multilineMax) : 0,\r\n        tickWidth: config.axis_x_tick_width,\r\n        tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,\r\n        withoutTransition: withoutTransition\r\n      },\r\n      axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient)\r\n\r\n    if ($$.isTimeSeries() && tickValues && typeof tickValues !== 'function') {\r\n      tickValues = tickValues.map(function (v) {\r\n        return $$.parseDate(v)\r\n      })\r\n    } // Set tick\r\n\r\n    axis.tickFormat(tickFormat).tickValues(tickValues)\r\n\r\n    if ($$.isCategorized()) {\r\n      axis.tickCentered(config.axis_x_tick_centered)\r\n\r\n      if (isEmpty(config.axis_x_tick_culling)) {\r\n        config.axis_x_tick_culling = false\r\n      }\r\n    }\r\n\r\n    return axis\r\n  }\r\n\r\n  Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues (targets, axis) {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      tickValues\r\n\r\n    if (config.axis_x_tick_fit || config.axis_x_tick_count) {\r\n      tickValues = this.generateTickValues(\r\n        $$.mapTargetsToUniqueXs(targets),\r\n        config.axis_x_tick_count,\r\n        $$.isTimeSeries()\r\n      )\r\n    }\r\n\r\n    if (axis) {\r\n      axis.tickValues(tickValues)\r\n    } else {\r\n      $$.xAxis.tickValues(tickValues)\r\n      $$.subXAxis.tickValues(tickValues)\r\n    }\r\n\r\n    return tickValues\r\n  }\r\n\r\n  Axis.prototype.getYAxis = function getYAxis (\r\n    scale,\r\n    orient,\r\n    tickFormat,\r\n    tickValues,\r\n    withOuterTick,\r\n    withoutTransition,\r\n    withoutRotateTickText\r\n  ) {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      axisParams = {\r\n        withOuterTick: withOuterTick,\r\n        withoutTransition: withoutTransition,\r\n        tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate\r\n      },\r\n      axis = new this.internal(this, axisParams).axis\r\n        .scale(scale)\r\n        .orient(orient)\r\n        .tickFormat(tickFormat)\r\n\r\n    if ($$.isTimeSeriesY()) {\r\n      axis.ticks(config.axis_y_tick_time_type, config.axis_y_tick_time_interval)\r\n    } else {\r\n      axis.tickValues(tickValues)\r\n    }\r\n\r\n    return axis\r\n  }\r\n\r\n  Axis.prototype.getId = function getId (id) {\r\n    var config = this.owner.config\r\n    return id in config.data_axes ? config.data_axes[id] : 'y'\r\n  }\r\n\r\n  Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat () {\r\n    // #2251 previously set any negative values to a whole number,\r\n    // however both should be truncated according to the users format specification\r\n    var $$ = this.owner,\r\n      config = $$.config\r\n    var format = $$.isTimeSeries()\r\n      ? $$.defaultAxisTimeFormat\r\n      : $$.isCategorized()\r\n      ? $$.categoryName\r\n      : function (v) {\r\n          return v\r\n        }\r\n\r\n    if (config.axis_x_tick_format) {\r\n      if (isFunction(config.axis_x_tick_format)) {\r\n        format = config.axis_x_tick_format\r\n      } else if ($$.isTimeSeries()) {\r\n        format = function format (date) {\r\n          return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : ''\r\n        }\r\n      }\r\n    }\r\n\r\n    return isFunction(format)\r\n      ? function (v) {\r\n          return format.call($$, v)\r\n        }\r\n      : format\r\n  }\r\n\r\n  Axis.prototype.getTickValues = function getTickValues (tickValues, axis) {\r\n    return tickValues ? tickValues : axis ? axis.tickValues() : undefined\r\n  }\r\n\r\n  Axis.prototype.getXAxisTickValues = function getXAxisTickValues () {\r\n    return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis)\r\n  }\r\n\r\n  Axis.prototype.getYAxisTickValues = function getYAxisTickValues () {\r\n    return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis)\r\n  }\r\n\r\n  Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues () {\r\n    return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis)\r\n  }\r\n\r\n  Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId (axisId) {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      option\r\n\r\n    if (axisId === 'y') {\r\n      option = config.axis_y_label\r\n    } else if (axisId === 'y2') {\r\n      option = config.axis_y2_label\r\n    } else if (axisId === 'x') {\r\n      option = config.axis_x_label\r\n    }\r\n\r\n    return option\r\n  }\r\n\r\n  Axis.prototype.getLabelText = function getLabelText (axisId) {\r\n    var option = this.getLabelOptionByAxisId(axisId)\r\n    return isString(option) ? option : option ? option.text : null\r\n  }\r\n\r\n  Axis.prototype.setLabelText = function setLabelText (axisId, text) {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      option = this.getLabelOptionByAxisId(axisId)\r\n\r\n    if (isString(option)) {\r\n      if (axisId === 'y') {\r\n        config.axis_y_label = text\r\n      } else if (axisId === 'y2') {\r\n        config.axis_y2_label = text\r\n      } else if (axisId === 'x') {\r\n        config.axis_x_label = text\r\n      }\r\n    } else if (option) {\r\n      option.text = text\r\n    }\r\n  }\r\n\r\n  Axis.prototype.getLabelPosition = function getLabelPosition (axisId, defaultPosition) {\r\n    var option = this.getLabelOptionByAxisId(axisId),\r\n      position = option && _typeof(option) === 'object' && option.position ? option.position : defaultPosition\r\n    return {\r\n      isInner: position.indexOf('inner') >= 0,\r\n      isOuter: position.indexOf('outer') >= 0,\r\n      isLeft: position.indexOf('left') >= 0,\r\n      isCenter: position.indexOf('center') >= 0,\r\n      isRight: position.indexOf('right') >= 0,\r\n      isTop: position.indexOf('top') >= 0,\r\n      isMiddle: position.indexOf('middle') >= 0,\r\n      isBottom: position.indexOf('bottom') >= 0\r\n    }\r\n  }\r\n\r\n  Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition () {\r\n    return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right')\r\n  }\r\n\r\n  Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition () {\r\n    return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top')\r\n  }\r\n\r\n  Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition () {\r\n    return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top')\r\n  }\r\n\r\n  Axis.prototype.getLabelPositionById = function getLabelPositionById (id) {\r\n    return id === 'y2'\r\n      ? this.getY2AxisLabelPosition()\r\n      : id === 'y'\r\n      ? this.getYAxisLabelPosition()\r\n      : this.getXAxisLabelPosition()\r\n  }\r\n\r\n  Axis.prototype.textForXAxisLabel = function textForXAxisLabel () {\r\n    return this.getLabelText('x')\r\n  }\r\n\r\n  Axis.prototype.textForYAxisLabel = function textForYAxisLabel () {\r\n    return this.getLabelText('y')\r\n  }\r\n\r\n  Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel () {\r\n    return this.getLabelText('y2')\r\n  }\r\n\r\n  Axis.prototype.xForAxisLabel = function xForAxisLabel (forHorizontal, position) {\r\n    var $$ = this.owner\r\n\r\n    if (forHorizontal) {\r\n      return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width\r\n    } else {\r\n      return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0\r\n    }\r\n  }\r\n\r\n  Axis.prototype.dxForAxisLabel = function dxForAxisLabel (forHorizontal, position) {\r\n    if (forHorizontal) {\r\n      return position.isLeft ? '0.5em' : position.isRight ? '-0.5em' : '0'\r\n    } else {\r\n      return position.isTop ? '-0.5em' : position.isBottom ? '0.5em' : '0'\r\n    }\r\n  }\r\n\r\n  Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel (forHorizontal, position) {\r\n    if (forHorizontal) {\r\n      return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end'\r\n    } else {\r\n      return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end'\r\n    }\r\n  }\r\n\r\n  Axis.prototype.xForXAxisLabel = function xForXAxisLabel () {\r\n    return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.xForYAxisLabel = function xForYAxisLabel () {\r\n    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel () {\r\n    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel () {\r\n    return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel () {\r\n    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel () {\r\n    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel () {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      position = this.getXAxisLabelPosition()\r\n\r\n    if (config.axis_rotated) {\r\n      return position.isInner ? '1.2em' : -25 - ($$.config.axis_x_inner ? 0 : this.getMaxTickWidth('x'))\r\n    } else {\r\n      return position.isInner ? '-0.5em' : config.axis_x_height ? config.axis_x_height - 10 : '3em'\r\n    }\r\n  }\r\n\r\n  Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel () {\r\n    var $$ = this.owner,\r\n      position = this.getYAxisLabelPosition()\r\n\r\n    if ($$.config.axis_rotated) {\r\n      return position.isInner ? '-0.5em' : '3em'\r\n    } else {\r\n      return position.isInner ? '1.2em' : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10)\r\n    }\r\n  }\r\n\r\n  Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel () {\r\n    var $$ = this.owner,\r\n      position = this.getY2AxisLabelPosition()\r\n\r\n    if ($$.config.axis_rotated) {\r\n      return position.isInner ? '1.2em' : '-2.2em'\r\n    } else {\r\n      return position.isInner ? '-0.5em' : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15)\r\n    }\r\n  }\r\n\r\n  Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel () {\r\n    var $$ = this.owner\r\n    return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel () {\r\n    var $$ = this.owner\r\n    return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel () {\r\n    var $$ = this.owner\r\n    return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition())\r\n  }\r\n\r\n  Axis.prototype.getMaxTickWidth = function getMaxTickWidth (id, withoutRecompute) {\r\n    var $$ = this.owner,\r\n      config = $$.config,\r\n      maxWidth = 0,\r\n      targetsToShow,\r\n      scale,\r\n      axis,\r\n      dummy,\r\n      svg\r\n\r\n    if (withoutRecompute && $$.currentMaxTickWidths[id]) {\r\n      return $$.currentMaxTickWidths[id]\r\n    }\r\n\r\n    if ($$.svg) {\r\n      targetsToShow = $$.filterTargetsToShow($$.data.targets)\r\n\r\n      if (id === 'y') {\r\n        scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'))\r\n        axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true, true)\r\n      } else if (id === 'y2') {\r\n        scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'))\r\n        axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true, true)\r\n      } else {\r\n        scale = $$.x.copy().domain($$.getXDomain(targetsToShow))\r\n        axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true)\r\n        this.updateXAxisTickValues(targetsToShow, axis)\r\n      }\r\n\r\n      dummy = $$.d3\r\n        .select('body')\r\n        .append('div')\r\n        .classed('c3', true)\r\n      ;(svg = dummy\r\n        .append('svg')\r\n        .style('visibility', 'hidden')\r\n        .style('position', 'fixed')\r\n        .style('top', 0)\r\n        .style('left', 0)),\r\n        svg\r\n          .append('g')\r\n          .call(axis)\r\n          .each(function () {\r\n            $$.d3\r\n              .select(this)\r\n              .selectAll('text')\r\n              .each(function () {\r\n                var box = this.getBoundingClientRect()\r\n\r\n                if (maxWidth < box.width) {\r\n                  maxWidth = box.width\r\n                }\r\n              })\r\n            dummy.remove()\r\n          })\r\n    }\r\n\r\n    $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth\r\n    return $$.currentMaxTickWidths[id]\r\n  }\r\n\r\n  Axis.prototype.updateLabels = function updateLabels (withTransition) {\r\n    var $$ = this.owner\r\n    var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),\r\n      axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),\r\n      axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label)\r\n    ;(withTransition ? axisXLabel.transition() : axisXLabel)\r\n      .attr('x', this.xForXAxisLabel.bind(this))\r\n      .attr('dx', this.dxForXAxisLabel.bind(this))\r\n      .attr('dy', this.dyForXAxisLabel.bind(this))\r\n      .text(this.textForXAxisLabel.bind(this))\r\n    ;(withTransition ? axisYLabel.transition() : axisYLabel)\r\n      .attr('x', this.xForYAxisLabel.bind(this))\r\n      .attr('dx', this.dxForYAxisLabel.bind(this))\r\n      .attr('dy', this.dyForYAxisLabel.bind(this))\r\n      .text(this.textForYAxisLabel.bind(this))\r\n    ;(withTransition ? axisY2Label.transition() : axisY2Label)\r\n      .attr('x', this.xForY2AxisLabel.bind(this))\r\n      .attr('dx', this.dxForY2AxisLabel.bind(this))\r\n      .attr('dy', this.dyForY2AxisLabel.bind(this))\r\n      .text(this.textForY2AxisLabel.bind(this))\r\n  }\r\n\r\n  Axis.prototype.getPadding = function getPadding (padding, key, defaultValue, domainLength) {\r\n    var p = typeof padding === 'number' ? padding : padding[key]\r\n\r\n    if (!isValue(p)) {\r\n      return defaultValue\r\n    }\r\n\r\n    if (padding.unit === 'ratio') {\r\n      return padding[key] * domainLength\r\n    } // assume padding is pixels if unit is not specified\r\n\r\n    return this.convertPixelsToAxisPadding(p, domainLength)\r\n  }\r\n\r\n  Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding (pixels, domainLength) {\r\n    var $$ = this.owner,\r\n      length = $$.config.axis_rotated ? $$.width : $$.height\r\n    return domainLength * (pixels / length)\r\n  }\r\n\r\n  Axis.prototype.generateTickValues = function generateTickValues (values, tickCount, forTimeSeries) {\r\n    var tickValues = values,\r\n      targetCount,\r\n      start,\r\n      end,\r\n      count,\r\n      interval,\r\n      i,\r\n      tickValue\r\n\r\n    if (tickCount) {\r\n      targetCount = isFunction(tickCount) ? tickCount() : tickCount // compute ticks according to tickCount\r\n\r\n      if (targetCount === 1) {\r\n        tickValues = [values[0]]\r\n      } else if (targetCount === 2) {\r\n        tickValues = [values[0], values[values.length - 1]]\r\n      } else if (targetCount > 2) {\r\n        count = targetCount - 2\r\n        start = values[0]\r\n        end = values[values.length - 1]\r\n        interval = (end - start) / (count + 1) // re-construct unique values\r\n\r\n        tickValues = [start]\r\n\r\n        for (i = 0; i < count; i++) {\r\n          tickValue = +start + interval * (i + 1)\r\n          tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue)\r\n        }\r\n\r\n        tickValues.push(end)\r\n      }\r\n    }\r\n\r\n    if (!forTimeSeries) {\r\n      tickValues = tickValues.sort(function (a, b) {\r\n        return a - b\r\n      })\r\n    }\r\n\r\n    return tickValues\r\n  }\r\n\r\n  Axis.prototype.generateTransitions = function generateTransitions (duration) {\r\n    var $$ = this.owner,\r\n      axes = $$.axes\r\n    return {\r\n      axisX: duration ? axes.x.transition().duration(duration) : axes.x,\r\n      axisY: duration ? axes.y.transition().duration(duration) : axes.y,\r\n      axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,\r\n      axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx\r\n    }\r\n  }\r\n\r\n  Axis.prototype.redraw = function redraw (duration, isHidden) {\r\n    var $$ = this.owner,\r\n      transition = duration ? $$.d3.transition().duration(duration) : null\r\n    $$.axes.x.style('opacity', isHidden ? 0 : 1).call($$.xAxis, transition)\r\n    $$.axes.y.style('opacity', isHidden ? 0 : 1).call($$.yAxis, transition)\r\n    $$.axes.y2.style('opacity', isHidden ? 0 : 1).call($$.y2Axis, transition)\r\n    $$.axes.subx.style('opacity', isHidden ? 0 : 1).call($$.subXAxis, transition)\r\n  }\r\n\r\n  var c3 = {\r\n    version: '0.6.12',\r\n    chart: {\r\n      fn: Chart.prototype,\r\n      internal: {\r\n        fn: ChartInternal.prototype,\r\n        axis: {\r\n          fn: Axis.prototype,\r\n          internal: {\r\n            fn: AxisInternal.prototype\r\n          }\r\n        }\r\n      }\r\n    },\r\n    generate: function generate (config) {\r\n      return new Chart(config)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.beforeInit = function () {\r\n    // can do something\r\n  }\r\n\r\n  ChartInternal.prototype.afterInit = function () {\r\n    // can do something\r\n  }\r\n\r\n  ChartInternal.prototype.init = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    $$.initParams()\r\n\r\n    if (config.data_url) {\r\n      $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData)\r\n    } else if (config.data_json) {\r\n      $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys))\r\n    } else if (config.data_rows) {\r\n      $$.initWithData($$.convertRowsToData(config.data_rows))\r\n    } else if (config.data_columns) {\r\n      $$.initWithData($$.convertColumnsToData(config.data_columns))\r\n    } else {\r\n      throw Error('url or json or rows or columns is required.')\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initParams = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config // MEMO: clipId needs to be unique because it conflicts when multiple charts exist\r\n\r\n    $$.clipId = 'c3-' + +new Date() + '-clip'\r\n    $$.clipIdForXAxis = $$.clipId + '-xaxis'\r\n    $$.clipIdForYAxis = $$.clipId + '-yaxis'\r\n    $$.clipIdForGrid = $$.clipId + '-grid'\r\n    $$.clipIdForSubchart = $$.clipId + '-subchart'\r\n    $$.clipPath = $$.getClipPath($$.clipId)\r\n    $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis)\r\n    $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis)\r\n    $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid)\r\n    $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart)\r\n    $$.dragStart = null\r\n    $$.dragging = false\r\n    $$.flowing = false\r\n    $$.cancelClick = false\r\n    $$.mouseover = false\r\n    $$.transiting = false\r\n    $$.color = $$.generateColor()\r\n    $$.levelColor = $$.generateLevelColor()\r\n    $$.dataTimeParse = (config.data_xLocaltime ? d3.timeParse : d3.utcParse)($$.config.data_xFormat)\r\n    $$.axisTimeFormat = config.axis_x_localtime ? d3.timeFormat : d3.utcFormat\r\n\r\n    $$.defaultAxisTimeFormat = function (date) {\r\n      if (date.getMilliseconds()) {\r\n        return d3.timeFormat('.%L')(date)\r\n      }\r\n\r\n      if (date.getSeconds()) {\r\n        return d3.timeFormat(':%S')(date)\r\n      }\r\n\r\n      if (date.getMinutes()) {\r\n        return d3.timeFormat('%I:%M')(date)\r\n      }\r\n\r\n      if (date.getHours()) {\r\n        return d3.timeFormat('%I %p')(date)\r\n      }\r\n\r\n      if (date.getDay() && date.getDate() !== 1) {\r\n        return d3.timeFormat('%-m/%-d')(date)\r\n      }\r\n\r\n      if (date.getDate() !== 1) {\r\n        return d3.timeFormat('%-m/%-d')(date)\r\n      }\r\n\r\n      if (date.getMonth()) {\r\n        return d3.timeFormat('%-m/%-d')(date)\r\n      }\r\n\r\n      return d3.timeFormat('%Y/%-m/%-d')(date)\r\n    }\r\n\r\n    $$.hiddenTargetIds = []\r\n    $$.hiddenLegendIds = []\r\n    $$.focusedTargetIds = []\r\n    $$.defocusedTargetIds = []\r\n    $$.xOrient = config.axis_rotated ? (config.axis_x_inner ? 'right' : 'left') : config.axis_x_inner ? 'top' : 'bottom'\r\n    $$.yOrient = config.axis_rotated ? (config.axis_y_inner ? 'top' : 'bottom') : config.axis_y_inner ? 'right' : 'left'\r\n    $$.y2Orient = config.axis_rotated\r\n      ? config.axis_y2_inner\r\n        ? 'bottom'\r\n        : 'top'\r\n      : config.axis_y2_inner\r\n      ? 'left'\r\n      : 'right'\r\n    $$.subXOrient = config.axis_rotated ? 'left' : 'bottom'\r\n    $$.isLegendRight = config.legend_position === 'right'\r\n    $$.isLegendInset = config.legend_position === 'inset'\r\n    $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right'\r\n    $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left'\r\n    $$.legendStep = 0\r\n    $$.legendItemWidth = 0\r\n    $$.legendItemHeight = 0\r\n    $$.currentMaxTickWidths = {\r\n      x: 0,\r\n      y: 0,\r\n      y2: 0\r\n    }\r\n    $$.rotated_padding_left = 30\r\n    $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30\r\n    $$.rotated_padding_top = 5\r\n    $$.withoutFadeIn = {}\r\n    $$.intervalForObserveInserted = undefined\r\n    $$.axes.subx = d3.selectAll([]) // needs when excluding subchart.js\r\n  }\r\n\r\n  ChartInternal.prototype.initChartElements = function () {\r\n    if (this.initBar) {\r\n      this.initBar()\r\n    }\r\n\r\n    if (this.initLine) {\r\n      this.initLine()\r\n    }\r\n\r\n    if (this.initArc) {\r\n      this.initArc()\r\n    }\r\n\r\n    if (this.initGauge) {\r\n      this.initGauge()\r\n    }\r\n\r\n    if (this.initText) {\r\n      this.initText()\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initWithData = function (data) {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config\r\n    var defs,\r\n      main,\r\n      binding = true\r\n    $$.axis = new Axis($$)\r\n\r\n    if (!config.bindto) {\r\n      $$.selectChart = d3.selectAll([])\r\n    } else if (typeof config.bindto.node === 'function') {\r\n      $$.selectChart = config.bindto\r\n    } else {\r\n      $$.selectChart = d3.select(config.bindto)\r\n    }\r\n\r\n    if ($$.selectChart.empty()) {\r\n      $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0)\r\n      $$.observeInserted($$.selectChart)\r\n      binding = false\r\n    }\r\n\r\n    $$.selectChart.html('').classed('c3', true) // Init data as targets\r\n\r\n    $$.data.xs = {}\r\n    $$.data.targets = $$.convertDataToTargets(data)\r\n\r\n    if (config.data_filter) {\r\n      $$.data.targets = $$.data.targets.filter(config.data_filter)\r\n    } // Set targets to hide if needed\r\n\r\n    if (config.data_hide) {\r\n      $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide)\r\n    }\r\n\r\n    if (config.legend_hide) {\r\n      $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide)\r\n    } // Init sizes and scales\r\n\r\n    $$.updateSizes()\r\n    $$.updateScales() // Set domains for each scale\r\n\r\n    $$.x.domain(d3.extent($$.getXDomain($$.data.targets)))\r\n    $$.y.domain($$.getYDomain($$.data.targets, 'y'))\r\n    $$.y2.domain($$.getYDomain($$.data.targets, 'y2'))\r\n    $$.subX.domain($$.x.domain())\r\n    $$.subY.domain($$.y.domain())\r\n    $$.subY2.domain($$.y2.domain()) // Save original x domain for zoom update\r\n\r\n    $$.orgXDomain = $$.x.domain()\r\n    /*-- Basic Elements --*/\r\n    // Define svgs\r\n\r\n    $$.svg = $$.selectChart\r\n      .append('svg')\r\n      .style('overflow', 'hidden')\r\n      .on('mouseenter', function () {\r\n        return config.onmouseover.call($$)\r\n      })\r\n      .on('mouseleave', function () {\r\n        return config.onmouseout.call($$)\r\n      })\r\n\r\n    if ($$.config.svg_classname) {\r\n      $$.svg.attr('class', $$.config.svg_classname)\r\n    } // Define defs\r\n\r\n    defs = $$.svg.append('defs')\r\n    $$.clipChart = $$.appendClip(defs, $$.clipId)\r\n    $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis)\r\n    $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis)\r\n    $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid)\r\n    $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart)\r\n    $$.updateSvgSize() // Define regions\r\n\r\n    main = $$.main = $$.svg.append('g').attr('transform', $$.getTranslate('main'))\r\n\r\n    if ($$.initPie) {\r\n      $$.initPie()\r\n    }\r\n\r\n    if ($$.initDragZoom) {\r\n      $$.initDragZoom()\r\n    }\r\n\r\n    if ($$.initSubchart) {\r\n      $$.initSubchart()\r\n    }\r\n\r\n    if ($$.initTooltip) {\r\n      $$.initTooltip()\r\n    }\r\n\r\n    if ($$.initLegend) {\r\n      $$.initLegend()\r\n    }\r\n\r\n    if ($$.initTitle) {\r\n      $$.initTitle()\r\n    }\r\n\r\n    if ($$.initZoom) {\r\n      $$.initZoom()\r\n    } // Update selection based on size and scale\r\n    // TODO: currently this must be called after initLegend because of update of sizes, but it should be done in initSubchart.\r\n\r\n    if ($$.initSubchartBrush) {\r\n      $$.initSubchartBrush()\r\n    }\r\n    /*-- Main Region --*/\r\n    // text when empty\r\n\r\n    main\r\n      .append('text')\r\n      .attr('class', CLASS.text + ' ' + CLASS.empty)\r\n      .attr('text-anchor', 'middle') // horizontal centering of text at x position in all browsers.\r\n      .attr('dominant-baseline', 'middle') // vertical centering of text at y position in all browsers, except IE.\r\n    // Regions\r\n\r\n    $$.initRegion() // Grids\r\n\r\n    $$.initGrid() // Define g for chart area\r\n\r\n    main\r\n      .append('g')\r\n      .attr('clip-path', $$.clipPath)\r\n      .attr('class', CLASS.chart) // Grid lines\r\n\r\n    if (config.grid_lines_front) {\r\n      $$.initGridLines()\r\n    } // Cover whole with rects for events\r\n\r\n    $$.initEventRect() // Define g for chart\r\n\r\n    $$.initChartElements() // Add Axis\r\n\r\n    $$.axis.init() // Set targets\r\n\r\n    $$.updateTargets($$.data.targets) // Set default extent if defined\r\n\r\n    if (config.axis_x_selection) {\r\n      $$.brush.selectionAsValue($$.getDefaultSelection())\r\n    } // Draw with targets\r\n\r\n    if (binding) {\r\n      $$.updateDimension()\r\n      $$.config.oninit.call($$)\r\n      $$.redraw({\r\n        withTransition: false,\r\n        withTransform: true,\r\n        withUpdateXDomain: true,\r\n        withUpdateOrgXDomain: true,\r\n        withTransitionForAxis: false\r\n      })\r\n    } // Bind to resize event\r\n\r\n    $$.bindResize() // Bind to window focus event\r\n\r\n    $$.bindWindowFocus() // export element of the chart\r\n\r\n    $$.api.element = $$.selectChart.node()\r\n  }\r\n\r\n  ChartInternal.prototype.smoothLines = function (el, type) {\r\n    var $$ = this\r\n\r\n    if (type === 'grid') {\r\n      el.each(function () {\r\n        var g = $$.d3.select(this),\r\n          x1 = g.attr('x1'),\r\n          x2 = g.attr('x2'),\r\n          y1 = g.attr('y1'),\r\n          y2 = g.attr('y2')\r\n        g.attr({\r\n          x1: Math.ceil(x1),\r\n          x2: Math.ceil(x2),\r\n          y1: Math.ceil(y1),\r\n          y2: Math.ceil(y2)\r\n        })\r\n      })\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.updateSizes = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    var legendHeight = $$.legend ? $$.getLegendHeight() : 0,\r\n      legendWidth = $$.legend ? $$.getLegendWidth() : 0,\r\n      legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,\r\n      hasArc = $$.hasArcType(),\r\n      xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),\r\n      subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0\r\n    $$.currentWidth = $$.getCurrentWidth()\r\n    $$.currentHeight = $$.getCurrentHeight() // for main\r\n\r\n    $$.margin = config.axis_rotated\r\n      ? {\r\n          top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),\r\n          right: hasArc ? 0 : $$.getCurrentPaddingRight(),\r\n          bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),\r\n          left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())\r\n        }\r\n      : {\r\n          top: 4 + $$.getCurrentPaddingTop(),\r\n          // for top tick text\r\n          right: hasArc ? 0 : $$.getCurrentPaddingRight(),\r\n          bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),\r\n          left: hasArc ? 0 : $$.getCurrentPaddingLeft()\r\n        } // for subchart\r\n\r\n    $$.margin2 = config.axis_rotated\r\n      ? {\r\n          top: $$.margin.top,\r\n          right: NaN,\r\n          bottom: 20 + legendHeightForBottom,\r\n          left: $$.rotated_padding_left\r\n        }\r\n      : {\r\n          top: $$.currentHeight - subchartHeight - legendHeightForBottom,\r\n          right: NaN,\r\n          bottom: xAxisHeight + legendHeightForBottom,\r\n          left: $$.margin.left\r\n        } // for legend\r\n\r\n    $$.margin3 = {\r\n      top: 0,\r\n      right: NaN,\r\n      bottom: 0,\r\n      left: 0\r\n    }\r\n\r\n    if ($$.updateSizeForLegend) {\r\n      $$.updateSizeForLegend(legendHeight, legendWidth)\r\n    }\r\n\r\n    $$.width = $$.currentWidth - $$.margin.left - $$.margin.right\r\n    $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom\r\n\r\n    if ($$.width < 0) {\r\n      $$.width = 0\r\n    }\r\n\r\n    if ($$.height < 0) {\r\n      $$.height = 0\r\n    }\r\n\r\n    $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width\r\n    $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom\r\n\r\n    if ($$.width2 < 0) {\r\n      $$.width2 = 0\r\n    }\r\n\r\n    if ($$.height2 < 0) {\r\n      $$.height2 = 0\r\n    } // for arc\r\n\r\n    $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0)\r\n    $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10)\r\n\r\n    if ($$.hasType('gauge') && !config.gauge_fullCircle) {\r\n      $$.arcHeight += $$.height - $$.getGaugeLabelHeight()\r\n    }\r\n\r\n    if ($$.updateRadius) {\r\n      $$.updateRadius()\r\n    }\r\n\r\n    if ($$.isLegendRight && hasArc) {\r\n      $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargets = function (targets) {\r\n    var $$ = this\r\n    /*-- Main --*/\r\n    //-- Text --//\r\n\r\n    $$.updateTargetsForText(targets) //-- Bar --//\r\n\r\n    $$.updateTargetsForBar(targets) //-- Line --//\r\n\r\n    $$.updateTargetsForLine(targets) //-- Arc --//\r\n\r\n    if ($$.hasArcType() && $$.updateTargetsForArc) {\r\n      $$.updateTargetsForArc(targets)\r\n    }\r\n    /*-- Sub --*/\r\n\r\n    if ($$.updateTargetsForSubchart) {\r\n      $$.updateTargetsForSubchart(targets)\r\n    } // Fade-in each chart\r\n\r\n    $$.showTargets()\r\n  }\r\n\r\n  ChartInternal.prototype.showTargets = function () {\r\n    var $$ = this\r\n    $$.svg\r\n      .selectAll('.' + CLASS.target)\r\n      .filter(function (d) {\r\n        return $$.isTargetToShow(d.id)\r\n      })\r\n      .transition()\r\n      .duration($$.config.transition_duration)\r\n      .style('opacity', 1)\r\n  }\r\n\r\n  ChartInternal.prototype.redraw = function (options, transitions) {\r\n    var $$ = this,\r\n      main = $$.main,\r\n      d3 = $$.d3,\r\n      config = $$.config\r\n    var areaIndices = $$.getShapeIndices($$.isAreaType),\r\n      barIndices = $$.getShapeIndices($$.isBarType),\r\n      lineIndices = $$.getShapeIndices($$.isLineType)\r\n    var withY,\r\n      withSubchart,\r\n      withTransition,\r\n      withTransitionForExit,\r\n      withTransitionForAxis,\r\n      withTransform,\r\n      withUpdateXDomain,\r\n      withUpdateOrgXDomain,\r\n      withTrimXDomain,\r\n      withLegend,\r\n      withEventRect,\r\n      withDimension,\r\n      withUpdateXAxis\r\n    var hideAxis = $$.hasArcType()\r\n    var drawArea, drawBar, drawLine, xForText, yForText\r\n    var duration, durationForExit, durationForAxis\r\n    var transitionsToWait, waitForDraw, flow, transition\r\n    var targetsToShow = $$.filterTargetsToShow($$.data.targets),\r\n      tickValues,\r\n      i,\r\n      intervalForCulling,\r\n      xDomainForZoom\r\n    var xv = $$.xv.bind($$),\r\n      cx,\r\n      cy\r\n    options = options || {}\r\n    withY = getOption(options, 'withY', true)\r\n    withSubchart = getOption(options, 'withSubchart', true)\r\n    withTransition = getOption(options, 'withTransition', true)\r\n    withTransform = getOption(options, 'withTransform', false)\r\n    withUpdateXDomain = getOption(options, 'withUpdateXDomain', false)\r\n    withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', false)\r\n    withTrimXDomain = getOption(options, 'withTrimXDomain', true)\r\n    withUpdateXAxis = getOption(options, 'withUpdateXAxis', withUpdateXDomain)\r\n    withLegend = getOption(options, 'withLegend', false)\r\n    withEventRect = getOption(options, 'withEventRect', true)\r\n    withDimension = getOption(options, 'withDimension', true)\r\n    withTransitionForExit = getOption(options, 'withTransitionForExit', withTransition)\r\n    withTransitionForAxis = getOption(options, 'withTransitionForAxis', withTransition)\r\n    duration = withTransition ? config.transition_duration : 0\r\n    durationForExit = withTransitionForExit ? duration : 0\r\n    durationForAxis = withTransitionForAxis ? duration : 0\r\n    transitions = transitions || $$.axis.generateTransitions(durationForAxis) // update legend and transform each g\r\n\r\n    if (withLegend && config.legend_show) {\r\n      $$.updateLegend($$.mapToIds($$.data.targets), options, transitions)\r\n    } else if (withDimension) {\r\n      // need to update dimension (e.g. axis.y.tick.values) because y tick values should change\r\n      // no need to update axis in it because they will be updated in redraw()\r\n      $$.updateDimension(true)\r\n    } // MEMO: needed for grids calculation\r\n\r\n    if ($$.isCategorized() && targetsToShow.length === 0) {\r\n      $$.x.domain([0, $$.axes.x.selectAll('.tick').size()])\r\n    }\r\n\r\n    if (targetsToShow.length) {\r\n      $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain)\r\n\r\n      if (!config.axis_x_tick_values) {\r\n        tickValues = $$.axis.updateXAxisTickValues(targetsToShow)\r\n      }\r\n    } else {\r\n      $$.xAxis.tickValues([])\r\n      $$.subXAxis.tickValues([])\r\n    }\r\n\r\n    if (config.zoom_rescale && !options.flow) {\r\n      xDomainForZoom = $$.x.orgDomain()\r\n    }\r\n\r\n    $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom))\r\n    $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom))\r\n\r\n    if (!config.axis_y_tick_values && config.axis_y_tick_count) {\r\n      $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count))\r\n    }\r\n\r\n    if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {\r\n      $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count))\r\n    } // axes\r\n\r\n    $$.axis.redraw(durationForAxis, hideAxis) // Update axis label\r\n\r\n    $$.axis.updateLabels(withTransition) // show/hide if manual culling needed\r\n\r\n    if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {\r\n      if (config.axis_x_tick_culling && tickValues) {\r\n        for (i = 1; i < tickValues.length; i++) {\r\n          if (tickValues.length / i < config.axis_x_tick_culling_max) {\r\n            intervalForCulling = i\r\n            break\r\n          }\r\n        }\r\n\r\n        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {\r\n          var index = tickValues.indexOf(e)\r\n\r\n          if (index >= 0) {\r\n            d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block')\r\n          }\r\n        })\r\n      } else {\r\n        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block')\r\n      }\r\n    } // setup drawer - MEMO: these must be called after axis updated\r\n\r\n    drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined\r\n    drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined\r\n    drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined\r\n    xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true)\r\n    yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false) // update circleY based on updated parameters\r\n\r\n    $$.updateCircleY() // generate circle x/y functions depending on updated params\r\n\r\n    cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$)\r\n    cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$) // Update sub domain\r\n\r\n    if (withY) {\r\n      $$.subY.domain($$.getYDomain(targetsToShow, 'y'))\r\n      $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'))\r\n    } // xgrid focus\r\n\r\n    $$.updateXgridFocus() // Data empty label positioning and text.\r\n\r\n    main\r\n      .select('text.' + CLASS.text + '.' + CLASS.empty)\r\n      .attr('x', $$.width / 2)\r\n      .attr('y', $$.height / 2)\r\n      .text(config.data_empty_label_text)\r\n      .transition()\r\n      .style('opacity', targetsToShow.length ? 0 : 1) // event rect\r\n\r\n    if (withEventRect) {\r\n      $$.redrawEventRect()\r\n    } // grid\r\n\r\n    $$.updateGrid(duration) // rect for regions\r\n\r\n    $$.updateRegion(duration) // bars\r\n\r\n    $$.updateBar(durationForExit) // lines, areas and cricles\r\n\r\n    $$.updateLine(durationForExit)\r\n    $$.updateArea(durationForExit)\r\n    $$.updateCircle(cx, cy) // text\r\n\r\n    if ($$.hasDataLabel()) {\r\n      $$.updateText(xForText, yForText, durationForExit)\r\n    } // title\r\n\r\n    if ($$.redrawTitle) {\r\n      $$.redrawTitle()\r\n    } // arc\r\n\r\n    if ($$.redrawArc) {\r\n      $$.redrawArc(duration, durationForExit, withTransform)\r\n    } // subchart\r\n\r\n    if ($$.redrawSubchart) {\r\n      $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices)\r\n    } // circles for select\r\n\r\n    main\r\n      .selectAll('.' + CLASS.selectedCircles)\r\n      .filter($$.isBarType.bind($$))\r\n      .selectAll('circle')\r\n      .remove()\r\n\r\n    if (options.flow) {\r\n      flow = $$.generateFlow({\r\n        targets: targetsToShow,\r\n        flow: options.flow,\r\n        duration: options.flow.duration,\r\n        drawBar: drawBar,\r\n        drawLine: drawLine,\r\n        drawArea: drawArea,\r\n        cx: cx,\r\n        cy: cy,\r\n        xv: xv,\r\n        xForText: xForText,\r\n        yForText: yForText\r\n      })\r\n    }\r\n\r\n    if ($$.isTabVisible()) {\r\n      // Only use transition if tab visible. See #938.\r\n      if (duration) {\r\n        // transition should be derived from one transition\r\n        transition = d3.transition().duration(duration)\r\n        transitionsToWait = []\r\n        ;[\r\n          $$.redrawBar(drawBar, true, transition),\r\n          $$.redrawLine(drawLine, true, transition),\r\n          $$.redrawArea(drawArea, true, transition),\r\n          $$.redrawCircle(cx, cy, true, transition),\r\n          $$.redrawText(xForText, yForText, options.flow, true, transition),\r\n          $$.redrawRegion(true, transition),\r\n          $$.redrawGrid(true, transition)\r\n        ].forEach(function (transitions) {\r\n          transitions.forEach(function (transition) {\r\n            transitionsToWait.push(transition)\r\n          })\r\n        }) // Wait for end of transitions to call flow and onrendered callback\r\n\r\n        waitForDraw = $$.generateWait()\r\n        transitionsToWait.forEach(function (t) {\r\n          waitForDraw.add(t)\r\n        })\r\n        waitForDraw(function () {\r\n          if (flow) {\r\n            flow()\r\n          }\r\n\r\n          if (config.onrendered) {\r\n            config.onrendered.call($$)\r\n          }\r\n        })\r\n      } else {\r\n        $$.redrawBar(drawBar)\r\n        $$.redrawLine(drawLine)\r\n        $$.redrawArea(drawArea)\r\n        $$.redrawCircle(cx, cy)\r\n        $$.redrawText(xForText, yForText, options.flow)\r\n        $$.redrawRegion()\r\n        $$.redrawGrid()\r\n\r\n        if (flow) {\r\n          flow()\r\n        }\r\n\r\n        if (config.onrendered) {\r\n          config.onrendered.call($$)\r\n        }\r\n      }\r\n    } // update fadein condition\r\n\r\n    $$.mapToIds($$.data.targets).forEach(function (id) {\r\n      $$.withoutFadeIn[id] = true\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.updateAndRedraw = function (options) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      transitions\r\n    options = options || {} // same with redraw\r\n\r\n    options.withTransition = getOption(options, 'withTransition', true)\r\n    options.withTransform = getOption(options, 'withTransform', false)\r\n    options.withLegend = getOption(options, 'withLegend', false) // NOT same with redraw\r\n\r\n    options.withUpdateXDomain = getOption(options, 'withUpdateXDomain', true)\r\n    options.withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', true)\r\n    options.withTransitionForExit = false\r\n    options.withTransitionForTransform = getOption(options, 'withTransitionForTransform', options.withTransition) // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)\r\n\r\n    $$.updateSizes() // MEMO: called in updateLegend in redraw if withLegend\r\n\r\n    if (!(options.withLegend && config.legend_show)) {\r\n      transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0) // Update scales\r\n\r\n      $$.updateScales()\r\n      $$.updateSvgSize() // Update g positions\r\n\r\n      $$.transformAll(options.withTransitionForTransform, transitions)\r\n    } // Draw with new sizes & scales\r\n\r\n    $$.redraw(options, transitions)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawWithoutRescale = function () {\r\n    this.redraw({\r\n      withY: false,\r\n      withSubchart: false,\r\n      withEventRect: false,\r\n      withTransitionForAxis: false\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.isTimeSeries = function () {\r\n    return this.config.axis_x_type === 'timeseries'\r\n  }\r\n\r\n  ChartInternal.prototype.isCategorized = function () {\r\n    return this.config.axis_x_type.indexOf('categor') >= 0\r\n  }\r\n\r\n  ChartInternal.prototype.isCustomX = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs))\r\n  }\r\n\r\n  ChartInternal.prototype.isTimeSeriesY = function () {\r\n    return this.config.axis_y_type === 'timeseries'\r\n  }\r\n\r\n  ChartInternal.prototype.getTranslate = function (target) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      x,\r\n      y\r\n\r\n    if (target === 'main') {\r\n      x = asHalfPixel($$.margin.left)\r\n      y = asHalfPixel($$.margin.top)\r\n    } else if (target === 'context') {\r\n      x = asHalfPixel($$.margin2.left)\r\n      y = asHalfPixel($$.margin2.top)\r\n    } else if (target === 'legend') {\r\n      x = $$.margin3.left\r\n      y = $$.margin3.top\r\n    } else if (target === 'x') {\r\n      x = 0\r\n      y = config.axis_rotated ? 0 : $$.height\r\n    } else if (target === 'y') {\r\n      x = 0\r\n      y = config.axis_rotated ? $$.height : 0\r\n    } else if (target === 'y2') {\r\n      x = config.axis_rotated ? 0 : $$.width\r\n      y = config.axis_rotated ? 1 : 0\r\n    } else if (target === 'subx') {\r\n      x = 0\r\n      y = config.axis_rotated ? 0 : $$.height2\r\n    } else if (target === 'arc') {\r\n      x = $$.arcWidth / 2\r\n      y = $$.arcHeight / 2 - ($$.hasType('gauge') ? 6 : 0) // to prevent wrong display of min and max label\r\n    }\r\n\r\n    return 'translate(' + x + ',' + y + ')'\r\n  }\r\n\r\n  ChartInternal.prototype.initialOpacity = function (d) {\r\n    return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0\r\n  }\r\n\r\n  ChartInternal.prototype.initialOpacityForCircle = function (d) {\r\n    return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0\r\n  }\r\n\r\n  ChartInternal.prototype.opacityForCircle = function (d) {\r\n    var isPointShouldBeShown = isFunction(this.config.point_show) ? this.config.point_show(d) : this.config.point_show\r\n    var opacity = isPointShouldBeShown ? 1 : 0\r\n    return isValue(d.value) ? (this.isScatterType(d) ? 0.5 : opacity) : 0\r\n  }\r\n\r\n  ChartInternal.prototype.opacityForText = function () {\r\n    return this.hasDataLabel() ? 1 : 0\r\n  }\r\n\r\n  ChartInternal.prototype.xx = function (d) {\r\n    return d ? this.x(d.x) : null\r\n  }\r\n\r\n  ChartInternal.prototype.xv = function (d) {\r\n    var $$ = this,\r\n      value = d.value\r\n\r\n    if ($$.isTimeSeries()) {\r\n      value = $$.parseDate(d.value)\r\n    } else if ($$.isCategorized() && typeof d.value === 'string') {\r\n      value = $$.config.axis_x_categories.indexOf(d.value)\r\n    }\r\n\r\n    return Math.ceil($$.x(value))\r\n  }\r\n\r\n  ChartInternal.prototype.yv = function (d) {\r\n    var $$ = this,\r\n      yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y\r\n    return Math.ceil(yScale(d.value))\r\n  }\r\n\r\n  ChartInternal.prototype.subxx = function (d) {\r\n    return d ? this.subX(d.x) : null\r\n  }\r\n\r\n  ChartInternal.prototype.transformMain = function (withTransition, transitions) {\r\n    var $$ = this,\r\n      xAxis,\r\n      yAxis,\r\n      y2Axis\r\n\r\n    if (transitions && transitions.axisX) {\r\n      xAxis = transitions.axisX\r\n    } else {\r\n      xAxis = $$.main.select('.' + CLASS.axisX)\r\n\r\n      if (withTransition) {\r\n        xAxis = xAxis.transition()\r\n      }\r\n    }\r\n\r\n    if (transitions && transitions.axisY) {\r\n      yAxis = transitions.axisY\r\n    } else {\r\n      yAxis = $$.main.select('.' + CLASS.axisY)\r\n\r\n      if (withTransition) {\r\n        yAxis = yAxis.transition()\r\n      }\r\n    }\r\n\r\n    if (transitions && transitions.axisY2) {\r\n      y2Axis = transitions.axisY2\r\n    } else {\r\n      y2Axis = $$.main.select('.' + CLASS.axisY2)\r\n\r\n      if (withTransition) {\r\n        y2Axis = y2Axis.transition()\r\n      }\r\n    }\r\n\r\n    ;(withTransition ? $$.main.transition() : $$.main).attr('transform', $$.getTranslate('main'))\r\n    xAxis.attr('transform', $$.getTranslate('x'))\r\n    yAxis.attr('transform', $$.getTranslate('y'))\r\n    y2Axis.attr('transform', $$.getTranslate('y2'))\r\n    $$.main.select('.' + CLASS.chartArcs).attr('transform', $$.getTranslate('arc'))\r\n  }\r\n\r\n  ChartInternal.prototype.transformAll = function (withTransition, transitions) {\r\n    var $$ = this\r\n    $$.transformMain(withTransition, transitions)\r\n\r\n    if ($$.config.subchart_show) {\r\n      $$.transformContext(withTransition, transitions)\r\n    }\r\n\r\n    if ($$.legend) {\r\n      $$.transformLegend(withTransition)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.updateSvgSize = function () {\r\n    var $$ = this,\r\n      brush = $$.svg.select('.c3-brush .overlay')\r\n    $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight)\r\n    $$.svg\r\n      .selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid])\r\n      .select('rect')\r\n      .attr('width', $$.width)\r\n      .attr('height', $$.height)\r\n    $$.svg\r\n      .select('#' + $$.clipIdForXAxis)\r\n      .select('rect')\r\n      .attr('x', $$.getXAxisClipX.bind($$))\r\n      .attr('y', $$.getXAxisClipY.bind($$))\r\n      .attr('width', $$.getXAxisClipWidth.bind($$))\r\n      .attr('height', $$.getXAxisClipHeight.bind($$))\r\n    $$.svg\r\n      .select('#' + $$.clipIdForYAxis)\r\n      .select('rect')\r\n      .attr('x', $$.getYAxisClipX.bind($$))\r\n      .attr('y', $$.getYAxisClipY.bind($$))\r\n      .attr('width', $$.getYAxisClipWidth.bind($$))\r\n      .attr('height', $$.getYAxisClipHeight.bind($$))\r\n    $$.svg\r\n      .select('#' + $$.clipIdForSubchart)\r\n      .select('rect')\r\n      .attr('width', $$.width)\r\n      .attr('height', brush.size() ? brush.attr('height') : 0)\r\n  }\r\n\r\n  ChartInternal.prototype.updateDimension = function (withoutAxis) {\r\n    var $$ = this\r\n\r\n    if (!withoutAxis) {\r\n      if ($$.config.axis_rotated) {\r\n        $$.axes.x.call($$.xAxis)\r\n        $$.axes.subx.call($$.subXAxis)\r\n      } else {\r\n        $$.axes.y.call($$.yAxis)\r\n        $$.axes.y2.call($$.y2Axis)\r\n      }\r\n    }\r\n\r\n    $$.updateSizes()\r\n    $$.updateScales()\r\n    $$.updateSvgSize()\r\n    $$.transformAll(false)\r\n  }\r\n\r\n  ChartInternal.prototype.observeInserted = function (selection) {\r\n    var $$ = this,\r\n      observer\r\n\r\n    if (typeof MutationObserver === 'undefined') {\r\n      window.console.error('MutationObserver not defined.')\r\n      return\r\n    }\r\n\r\n    observer = new MutationObserver(function (mutations) {\r\n      mutations.forEach(function (mutation) {\r\n        if (mutation.type === 'childList' && mutation.previousSibling) {\r\n          observer.disconnect() // need to wait for completion of load because size calculation requires the actual sizes determined after that completion\r\n\r\n          $$.intervalForObserveInserted = window.setInterval(function () {\r\n            // parentNode will NOT be null when completed\r\n            if (selection.node().parentNode) {\r\n              window.clearInterval($$.intervalForObserveInserted)\r\n              $$.updateDimension()\r\n\r\n              if ($$.brush) {\r\n                $$.brush.update()\r\n              }\r\n\r\n              $$.config.oninit.call($$)\r\n              $$.redraw({\r\n                withTransform: true,\r\n                withUpdateXDomain: true,\r\n                withUpdateOrgXDomain: true,\r\n                withTransition: false,\r\n                withTransitionForTransform: false,\r\n                withLegend: true\r\n              })\r\n              selection.transition().style('opacity', 1)\r\n            }\r\n          }, 10)\r\n        }\r\n      })\r\n    })\r\n    observer.observe(selection.node(), {\r\n      attributes: true,\r\n      childList: true,\r\n      characterData: true\r\n    })\r\n  }\r\n  /**\r\n   * Binds handlers to the window resize event.\r\n   */\r\n\r\n  ChartInternal.prototype.bindResize = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    $$.resizeFunction = $$.generateResize() // need to call .remove\r\n\r\n    $$.resizeFunction.add(function () {\r\n      config.onresize.call($$)\r\n    })\r\n\r\n    if (config.resize_auto) {\r\n      $$.resizeFunction.add(function () {\r\n        if ($$.resizeTimeout !== undefined) {\r\n          window.clearTimeout($$.resizeTimeout)\r\n        }\r\n\r\n        $$.resizeTimeout = window.setTimeout(function () {\r\n          delete $$.resizeTimeout\r\n          $$.updateAndRedraw({\r\n            withUpdateXDomain: false,\r\n            withUpdateOrgXDomain: false,\r\n            withTransition: false,\r\n            withTransitionForTransform: false,\r\n            withLegend: true\r\n          })\r\n\r\n          if ($$.brush) {\r\n            $$.brush.update()\r\n          }\r\n        }, 100)\r\n      })\r\n    }\r\n\r\n    $$.resizeFunction.add(function () {\r\n      config.onresized.call($$)\r\n    })\r\n\r\n    $$.resizeIfElementDisplayed = function () {\r\n      // if element not displayed skip it\r\n      if ($$.api == null || !$$.api.element.offsetParent) {\r\n        return\r\n      }\r\n\r\n      $$.resizeFunction()\r\n    }\r\n\r\n    if (window.attachEvent) {\r\n      window.attachEvent('onresize', $$.resizeIfElementDisplayed)\r\n    } else if (window.addEventListener) {\r\n      window.addEventListener('resize', $$.resizeIfElementDisplayed, false)\r\n    } else {\r\n      // fallback to this, if this is a very old browser\r\n      var wrapper = window.onresize\r\n\r\n      if (!wrapper) {\r\n        // create a wrapper that will call all charts\r\n        wrapper = $$.generateResize()\r\n      } else if (!wrapper.add || !wrapper.remove) {\r\n        // there is already a handler registered, make sure we call it too\r\n        wrapper = $$.generateResize()\r\n        wrapper.add(window.onresize)\r\n      } // add this graph to the wrapper, we will be removed if the user calls destroy\r\n\r\n      wrapper.add($$.resizeFunction)\r\n\r\n      window.onresize = function () {\r\n        // if element not displayed skip it\r\n        if (!$$.api.element.offsetParent) {\r\n          return\r\n        }\r\n\r\n        wrapper()\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Binds handlers to the window focus event.\r\n   */\r\n\r\n  ChartInternal.prototype.bindWindowFocus = function () {\r\n    var _this = this\r\n\r\n    if (this.windowFocusHandler) {\r\n      // The handler is already set\r\n      return\r\n    }\r\n\r\n    this.windowFocusHandler = function () {\r\n      _this.redraw()\r\n    }\r\n\r\n    window.addEventListener('focus', this.windowFocusHandler)\r\n  }\r\n  /**\r\n   * Unbinds from the window focus event.\r\n   */\r\n\r\n  ChartInternal.prototype.unbindWindowFocus = function () {\r\n    window.removeEventListener('focus', this.windowFocusHandler)\r\n    delete this.windowFocusHandler\r\n  }\r\n\r\n  ChartInternal.prototype.generateResize = function () {\r\n    var resizeFunctions = []\r\n\r\n    function callResizeFunctions () {\r\n      resizeFunctions.forEach(function (f) {\r\n        f()\r\n      })\r\n    }\r\n\r\n    callResizeFunctions.add = function (f) {\r\n      resizeFunctions.push(f)\r\n    }\r\n\r\n    callResizeFunctions.remove = function (f) {\r\n      for (var i = 0; i < resizeFunctions.length; i++) {\r\n        if (resizeFunctions[i] === f) {\r\n          resizeFunctions.splice(i, 1)\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    return callResizeFunctions\r\n  }\r\n\r\n  ChartInternal.prototype.endall = function (transition, callback) {\r\n    var n = 0\r\n    transition\r\n      .each(function () {\r\n        ++n\r\n      })\r\n      .on('end', function () {\r\n        if (!--n) {\r\n          callback.apply(this, arguments)\r\n        }\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.generateWait = function () {\r\n    var transitionsToWait = [],\r\n      f = function f (callback) {\r\n        var timer = setInterval(function () {\r\n          var done = 0\r\n          transitionsToWait.forEach(function (t) {\r\n            if (t.empty()) {\r\n              done += 1\r\n              return\r\n            }\r\n\r\n            try {\r\n              t.transition()\r\n            } catch (e) {\r\n              done += 1\r\n            }\r\n          })\r\n\r\n          if (done === transitionsToWait.length) {\r\n            clearInterval(timer)\r\n\r\n            if (callback) {\r\n              callback()\r\n            }\r\n          }\r\n        }, 50)\r\n      }\r\n\r\n    f.add = function (transition) {\r\n      transitionsToWait.push(transition)\r\n    }\r\n\r\n    return f\r\n  }\r\n\r\n  ChartInternal.prototype.parseDate = function (date) {\r\n    var $$ = this,\r\n      parsedDate\r\n\r\n    if (date instanceof Date) {\r\n      parsedDate = date\r\n    } else if (typeof date === 'string') {\r\n      parsedDate = $$.dataTimeParse(date)\r\n    } else if (_typeof(date) === 'object') {\r\n      parsedDate = new Date(+date)\r\n    } else if (typeof date === 'number' && !isNaN(date)) {\r\n      parsedDate = new Date(+date)\r\n    }\r\n\r\n    if (!parsedDate || isNaN(+parsedDate)) {\r\n      window.console.error(\"Failed to parse x '\" + date + \"' to Date object\")\r\n    }\r\n\r\n    return parsedDate\r\n  }\r\n\r\n  ChartInternal.prototype.isTabVisible = function () {\r\n    return !document.hidden\r\n  }\r\n\r\n  ChartInternal.prototype.getPathBox = getPathBox\r\n  ChartInternal.prototype.CLASS = CLASS\r\n\r\n  /* jshint ignore:start */\r\n  // SVGPathSeg API polyfill\r\n  // https://github.com/progers/pathseg\r\n  //\r\n  // This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from\r\n  // SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec\r\n  // changes which were implemented in Firefox 43 and Chrome 46.\r\n  ;(function () {\r\n    if (!('SVGPathSeg' in window)) {\r\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg\r\n      window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {\r\n        this.pathSegType = type\r\n        this.pathSegTypeAsLetter = typeAsLetter\r\n        this._owningPathSegList = owningPathSegList\r\n      }\r\n\r\n      window.SVGPathSeg.prototype.classname = 'SVGPathSeg'\r\n      window.SVGPathSeg.PATHSEG_UNKNOWN = 0\r\n      window.SVGPathSeg.PATHSEG_CLOSEPATH = 1\r\n      window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2\r\n      window.SVGPathSeg.PATHSEG_MOVETO_REL = 3\r\n      window.SVGPathSeg.PATHSEG_LINETO_ABS = 4\r\n      window.SVGPathSeg.PATHSEG_LINETO_REL = 5\r\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6\r\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7\r\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8\r\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9\r\n      window.SVGPathSeg.PATHSEG_ARC_ABS = 10\r\n      window.SVGPathSeg.PATHSEG_ARC_REL = 11\r\n      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12\r\n      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13\r\n      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14\r\n      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15\r\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16\r\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17\r\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18\r\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19 // Notify owning PathSegList on any changes so they can be synchronized back to the path element.\r\n\r\n      window.SVGPathSeg.prototype._segmentChanged = function () {\r\n        if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this)\r\n      }\r\n\r\n      window.SVGPathSegClosePath = function (owningPathSegList) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, 'z', owningPathSegList)\r\n      }\r\n\r\n      window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegClosePath.prototype.toString = function () {\r\n        return '[object SVGPathSegClosePath]'\r\n      }\r\n\r\n      window.SVGPathSegClosePath.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter\r\n      }\r\n\r\n      window.SVGPathSegClosePath.prototype.clone = function () {\r\n        return new window.SVGPathSegClosePath(undefined)\r\n      }\r\n\r\n      window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, 'M', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegMovetoAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegMovetoAbs]'\r\n      }\r\n\r\n      window.SVGPathSegMovetoAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegMovetoAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegMovetoAbs(undefined, this._x, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, 'm', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegMovetoRel.prototype.toString = function () {\r\n        return '[object SVGPathSegMovetoRel]'\r\n      }\r\n\r\n      window.SVGPathSegMovetoRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegMovetoRel.prototype.clone = function () {\r\n        return new window.SVGPathSegMovetoRel(undefined, this._x, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, 'L', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegLinetoAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegLinetoAbs]'\r\n      }\r\n\r\n      window.SVGPathSegLinetoAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegLinetoAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegLinetoAbs(undefined, this._x, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, 'l', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegLinetoRel.prototype.toString = function () {\r\n        return '[object SVGPathSegLinetoRel]'\r\n      }\r\n\r\n      window.SVGPathSegLinetoRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegLinetoRel.prototype.clone = function () {\r\n        return new window.SVGPathSegLinetoRel(undefined, this._x, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, 'C', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._x1 = x1\r\n        this._y1 = y1\r\n        this._x2 = x2\r\n        this._y2 = y2\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoCubicAbs]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {\r\n        return (\r\n          this.pathSegTypeAsLetter +\r\n          ' ' +\r\n          this._x1 +\r\n          ' ' +\r\n          this._y1 +\r\n          ' ' +\r\n          this._x2 +\r\n          ' ' +\r\n          this._y2 +\r\n          ' ' +\r\n          this._x +\r\n          ' ' +\r\n          this._y\r\n        )\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x1', {\r\n        get: function get () {\r\n          return this._x1\r\n        },\r\n        set: function set (x1) {\r\n          this._x1 = x1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y1', {\r\n        get: function get () {\r\n          return this._y1\r\n        },\r\n        set: function set (y1) {\r\n          this._y1 = y1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x2', {\r\n        get: function get () {\r\n          return this._x2\r\n        },\r\n        set: function set (x2) {\r\n          this._x2 = x2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y2', {\r\n        get: function get () {\r\n          return this._y2\r\n        },\r\n        set: function set (y2) {\r\n          this._y2 = y2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, 'c', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._x1 = x1\r\n        this._y1 = y1\r\n        this._x2 = x2\r\n        this._y2 = y2\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoCubicRel.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoCubicRel]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {\r\n        return (\r\n          this.pathSegTypeAsLetter +\r\n          ' ' +\r\n          this._x1 +\r\n          ' ' +\r\n          this._y1 +\r\n          ' ' +\r\n          this._x2 +\r\n          ' ' +\r\n          this._y2 +\r\n          ' ' +\r\n          this._x +\r\n          ' ' +\r\n          this._y\r\n        )\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicRel.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x1', {\r\n        get: function get () {\r\n          return this._x1\r\n        },\r\n        set: function set (x1) {\r\n          this._x1 = x1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y1', {\r\n        get: function get () {\r\n          return this._y1\r\n        },\r\n        set: function set (y1) {\r\n          this._y1 = y1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x2', {\r\n        get: function get () {\r\n          return this._x2\r\n        },\r\n        set: function set (x2) {\r\n          this._x2 = x2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y2', {\r\n        get: function get () {\r\n          return this._y2\r\n        },\r\n        set: function set (y2) {\r\n          this._y2 = y2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, 'Q', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._x1 = x1\r\n        this._y1 = y1\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoQuadraticAbs]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x1', {\r\n        get: function get () {\r\n          return this._x1\r\n        },\r\n        set: function set (x1) {\r\n          this._x1 = x1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y1', {\r\n        get: function get () {\r\n          return this._y1\r\n        },\r\n        set: function set (y1) {\r\n          this._y1 = y1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, 'q', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._x1 = x1\r\n        this._y1 = y1\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoQuadraticRel]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x1', {\r\n        get: function get () {\r\n          return this._x1\r\n        },\r\n        set: function set (x1) {\r\n          this._x1 = x1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y1', {\r\n        get: function get () {\r\n          return this._y1\r\n        },\r\n        set: function set (y1) {\r\n          this._y1 = y1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, 'A', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._r1 = r1\r\n        this._r2 = r2\r\n        this._angle = angle\r\n        this._largeArcFlag = largeArcFlag\r\n        this._sweepFlag = sweepFlag\r\n      }\r\n\r\n      window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegArcAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegArcAbs]'\r\n      }\r\n\r\n      window.SVGPathSegArcAbs.prototype._asPathString = function () {\r\n        return (\r\n          this.pathSegTypeAsLetter +\r\n          ' ' +\r\n          this._r1 +\r\n          ' ' +\r\n          this._r2 +\r\n          ' ' +\r\n          this._angle +\r\n          ' ' +\r\n          (this._largeArcFlag ? '1' : '0') +\r\n          ' ' +\r\n          (this._sweepFlag ? '1' : '0') +\r\n          ' ' +\r\n          this._x +\r\n          ' ' +\r\n          this._y\r\n        )\r\n      }\r\n\r\n      window.SVGPathSegArcAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegArcAbs(\r\n          undefined,\r\n          this._x,\r\n          this._y,\r\n          this._r1,\r\n          this._r2,\r\n          this._angle,\r\n          this._largeArcFlag,\r\n          this._sweepFlag\r\n        )\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r1', {\r\n        get: function get () {\r\n          return this._r1\r\n        },\r\n        set: function set (r1) {\r\n          this._r1 = r1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r2', {\r\n        get: function get () {\r\n          return this._r2\r\n        },\r\n        set: function set (r2) {\r\n          this._r2 = r2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'angle', {\r\n        get: function get () {\r\n          return this._angle\r\n        },\r\n        set: function set (angle) {\r\n          this._angle = angle\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'largeArcFlag', {\r\n        get: function get () {\r\n          return this._largeArcFlag\r\n        },\r\n        set: function set (largeArcFlag) {\r\n          this._largeArcFlag = largeArcFlag\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'sweepFlag', {\r\n        get: function get () {\r\n          return this._sweepFlag\r\n        },\r\n        set: function set (sweepFlag) {\r\n          this._sweepFlag = sweepFlag\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, 'a', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._r1 = r1\r\n        this._r2 = r2\r\n        this._angle = angle\r\n        this._largeArcFlag = largeArcFlag\r\n        this._sweepFlag = sweepFlag\r\n      }\r\n\r\n      window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegArcRel.prototype.toString = function () {\r\n        return '[object SVGPathSegArcRel]'\r\n      }\r\n\r\n      window.SVGPathSegArcRel.prototype._asPathString = function () {\r\n        return (\r\n          this.pathSegTypeAsLetter +\r\n          ' ' +\r\n          this._r1 +\r\n          ' ' +\r\n          this._r2 +\r\n          ' ' +\r\n          this._angle +\r\n          ' ' +\r\n          (this._largeArcFlag ? '1' : '0') +\r\n          ' ' +\r\n          (this._sweepFlag ? '1' : '0') +\r\n          ' ' +\r\n          this._x +\r\n          ' ' +\r\n          this._y\r\n        )\r\n      }\r\n\r\n      window.SVGPathSegArcRel.prototype.clone = function () {\r\n        return new window.SVGPathSegArcRel(\r\n          undefined,\r\n          this._x,\r\n          this._y,\r\n          this._r1,\r\n          this._r2,\r\n          this._angle,\r\n          this._largeArcFlag,\r\n          this._sweepFlag\r\n        )\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r1', {\r\n        get: function get () {\r\n          return this._r1\r\n        },\r\n        set: function set (r1) {\r\n          this._r1 = r1\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r2', {\r\n        get: function get () {\r\n          return this._r2\r\n        },\r\n        set: function set (r2) {\r\n          this._r2 = r2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'angle', {\r\n        get: function get () {\r\n          return this._angle\r\n        },\r\n        set: function set (angle) {\r\n          this._angle = angle\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'largeArcFlag', {\r\n        get: function get () {\r\n          return this._largeArcFlag\r\n        },\r\n        set: function set (largeArcFlag) {\r\n          this._largeArcFlag = largeArcFlag\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'sweepFlag', {\r\n        get: function get () {\r\n          return this._sweepFlag\r\n        },\r\n        set: function set (sweepFlag) {\r\n          this._sweepFlag = sweepFlag\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, 'H', owningPathSegList)\r\n        this._x = x\r\n      }\r\n\r\n      window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegLinetoHorizontalAbs]'\r\n      }\r\n\r\n      window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x\r\n      }\r\n\r\n      window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegLinetoHorizontalAbs(undefined, this._x)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, 'h', owningPathSegList)\r\n        this._x = x\r\n      }\r\n\r\n      window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () {\r\n        return '[object SVGPathSegLinetoHorizontalRel]'\r\n      }\r\n\r\n      window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x\r\n      }\r\n\r\n      window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () {\r\n        return new window.SVGPathSegLinetoHorizontalRel(undefined, this._x)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, 'V', owningPathSegList)\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegLinetoVerticalAbs]'\r\n      }\r\n\r\n      window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegLinetoVerticalAbs(undefined, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, 'v', owningPathSegList)\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegLinetoVerticalRel.prototype.toString = function () {\r\n        return '[object SVGPathSegLinetoVerticalRel]'\r\n      }\r\n\r\n      window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegLinetoVerticalRel.prototype.clone = function () {\r\n        return new window.SVGPathSegLinetoVerticalRel(undefined, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._x2 = x2\r\n        this._y2 = y2\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoCubicSmoothAbs]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x2', {\r\n        get: function get () {\r\n          return this._x2\r\n        },\r\n        set: function set (x2) {\r\n          this._x2 = x2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y2', {\r\n        get: function get () {\r\n          return this._y2\r\n        },\r\n        set: function set (y2) {\r\n          this._y2 = y2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n        this._x2 = x2\r\n        this._y2 = y2\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoCubicSmoothRel]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x2', {\r\n        get: function get () {\r\n          return this._x2\r\n        },\r\n        set: function set (x2) {\r\n          this._x2 = x2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y2', {\r\n        get: function get () {\r\n          return this._y2\r\n        },\r\n        set: function set (y2) {\r\n          this._y2 = y2\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoQuadraticSmoothAbs]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {\r\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't', owningPathSegList)\r\n        this._x = x\r\n        this._y = y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype)\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {\r\n        return '[object SVGPathSegCurvetoQuadraticSmoothRel]'\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {\r\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\r\n      }\r\n\r\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {\r\n        return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y)\r\n      }\r\n\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'x', {\r\n        get: function get () {\r\n          return this._x\r\n        },\r\n        set: function set (x) {\r\n          this._x = x\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'y', {\r\n        get: function get () {\r\n          return this._y\r\n        },\r\n        set: function set (y) {\r\n          this._y = y\r\n\r\n          this._segmentChanged()\r\n        },\r\n        enumerable: true\r\n      }) // Add createSVGPathSeg* functions to window.SVGPathElement.\r\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-Interfacewindow.SVGPathElement.\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegClosePath = function () {\r\n        return new window.SVGPathSegClosePath(undefined)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {\r\n        return new window.SVGPathSegMovetoAbs(undefined, x, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {\r\n        return new window.SVGPathSegMovetoRel(undefined, x, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {\r\n        return new window.SVGPathSegLinetoAbs(undefined, x, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {\r\n        return new window.SVGPathSegLinetoRel(undefined, x, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {\r\n        return new window.SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {\r\n        return new window.SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {\r\n        return new window.SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {\r\n        return new window.SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\r\n        return new window.SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\r\n        return new window.SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {\r\n        return new window.SVGPathSegLinetoHorizontalAbs(undefined, x)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {\r\n        return new window.SVGPathSegLinetoHorizontalRel(undefined, x)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {\r\n        return new window.SVGPathSegLinetoVerticalAbs(undefined, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {\r\n        return new window.SVGPathSegLinetoVerticalRel(undefined, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {\r\n        return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {\r\n        return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {\r\n        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y)\r\n      }\r\n\r\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {\r\n        return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y)\r\n      }\r\n\r\n      if (!('getPathSegAtLength' in window.SVGPathElement.prototype)) {\r\n        // Add getPathSegAtLength to SVGPathElement.\r\n        // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength\r\n        // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.\r\n        window.SVGPathElement.prototype.getPathSegAtLength = function (distance) {\r\n          if (distance === undefined || !isFinite(distance)) throw 'Invalid arguments.'\r\n          var measurementElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')\r\n          measurementElement.setAttribute('d', this.getAttribute('d'))\r\n          var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1 // If the path is empty, return 0.\r\n\r\n          if (lastPathSegment <= 0) return 0\r\n\r\n          do {\r\n            measurementElement.pathSegList.removeItem(lastPathSegment)\r\n            if (distance > measurementElement.getTotalLength()) break\r\n            lastPathSegment--\r\n          } while (lastPathSegment > 0)\r\n\r\n          return lastPathSegment\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!('SVGPathSegList' in window)) {\r\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList\r\n      window.SVGPathSegList = function (pathElement) {\r\n        this._pathElement = pathElement\r\n        this._list = this._parsePath(this._pathElement.getAttribute('d')) // Use a MutationObserver to catch changes to the path's \"d\" attribute.\r\n\r\n        this._mutationObserverConfig = {\r\n          attributes: true,\r\n          attributeFilter: ['d']\r\n        }\r\n        this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this))\r\n\r\n        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig)\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.classname = 'SVGPathSegList'\r\n      Object.defineProperty(window.SVGPathSegList.prototype, 'numberOfItems', {\r\n        get: function get () {\r\n          this._checkPathSynchronizedToList()\r\n\r\n          return this._list.length\r\n        },\r\n        enumerable: true\r\n      }) // Add the pathSegList accessors to window.SVGPathElement.\r\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData\r\n\r\n      Object.defineProperty(window.SVGPathElement.prototype, 'pathSegList', {\r\n        get: function get () {\r\n          if (!this._pathSegList) this._pathSegList = new window.SVGPathSegList(this)\r\n          return this._pathSegList\r\n        },\r\n        enumerable: true\r\n      }) // FIXME: The following are not implemented and simply return window.SVGPathElement.pathSegList.\r\n\r\n      Object.defineProperty(window.SVGPathElement.prototype, 'normalizedPathSegList', {\r\n        get: function get () {\r\n          return this.pathSegList\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathElement.prototype, 'animatedPathSegList', {\r\n        get: function get () {\r\n          return this.pathSegList\r\n        },\r\n        enumerable: true\r\n      })\r\n      Object.defineProperty(window.SVGPathElement.prototype, 'animatedNormalizedPathSegList', {\r\n        get: function get () {\r\n          return this.pathSegList\r\n        },\r\n        enumerable: true\r\n      }) // Process any pending mutations to the path element and update the list as needed.\r\n      // This should be the first call of all public functions and is needed because\r\n      // MutationObservers are not synchronous so we can have pending asynchronous mutations.\r\n\r\n      window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () {\r\n        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords())\r\n      }\r\n\r\n      window.SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {\r\n        if (!this._pathElement) return\r\n        var hasPathMutations = false\r\n        mutationRecords.forEach(function (record) {\r\n          if (record.attributeName == 'd') hasPathMutations = true\r\n        })\r\n        if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute('d'))\r\n      } // Serialize the list and update the path's 'd' attribute.\r\n\r\n      window.SVGPathSegList.prototype._writeListToPath = function () {\r\n        this._pathElementMutationObserver.disconnect()\r\n\r\n        this._pathElement.setAttribute('d', window.SVGPathSegList._pathSegArrayAsString(this._list))\r\n\r\n        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig)\r\n      } // When a path segment changes the list needs to be synchronized back to the path element.\r\n\r\n      window.SVGPathSegList.prototype.segmentChanged = function (pathSeg) {\r\n        this._writeListToPath()\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.clear = function () {\r\n        this._checkPathSynchronizedToList()\r\n\r\n        this._list.forEach(function (pathSeg) {\r\n          pathSeg._owningPathSegList = null\r\n        })\r\n\r\n        this._list = []\r\n\r\n        this._writeListToPath()\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.initialize = function (newItem) {\r\n        this._checkPathSynchronizedToList()\r\n\r\n        this._list = [newItem]\r\n        newItem._owningPathSegList = this\r\n\r\n        this._writeListToPath()\r\n\r\n        return newItem\r\n      }\r\n\r\n      window.SVGPathSegList.prototype._checkValidIndex = function (index) {\r\n        if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw 'INDEX_SIZE_ERR'\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.getItem = function (index) {\r\n        this._checkPathSynchronizedToList()\r\n\r\n        this._checkValidIndex(index)\r\n\r\n        return this._list[index]\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {\r\n        this._checkPathSynchronizedToList() // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.\r\n\r\n        if (index > this.numberOfItems) index = this.numberOfItems\r\n\r\n        if (newItem._owningPathSegList) {\r\n          // SVG2 spec says to make a copy.\r\n          newItem = newItem.clone()\r\n        }\r\n\r\n        this._list.splice(index, 0, newItem)\r\n\r\n        newItem._owningPathSegList = this\r\n\r\n        this._writeListToPath()\r\n\r\n        return newItem\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.replaceItem = function (newItem, index) {\r\n        this._checkPathSynchronizedToList()\r\n\r\n        if (newItem._owningPathSegList) {\r\n          // SVG2 spec says to make a copy.\r\n          newItem = newItem.clone()\r\n        }\r\n\r\n        this._checkValidIndex(index)\r\n\r\n        this._list[index] = newItem\r\n        newItem._owningPathSegList = this\r\n\r\n        this._writeListToPath()\r\n\r\n        return newItem\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.removeItem = function (index) {\r\n        this._checkPathSynchronizedToList()\r\n\r\n        this._checkValidIndex(index)\r\n\r\n        var item = this._list[index]\r\n\r\n        this._list.splice(index, 1)\r\n\r\n        this._writeListToPath()\r\n\r\n        return item\r\n      }\r\n\r\n      window.SVGPathSegList.prototype.appendItem = function (newItem) {\r\n        this._checkPathSynchronizedToList()\r\n\r\n        if (newItem._owningPathSegList) {\r\n          // SVG2 spec says to make a copy.\r\n          newItem = newItem.clone()\r\n        }\r\n\r\n        this._list.push(newItem)\r\n\r\n        newItem._owningPathSegList = this // TODO: Optimize this to just append to the existing attribute.\r\n\r\n        this._writeListToPath()\r\n\r\n        return newItem\r\n      }\r\n\r\n      window.SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {\r\n        var string = ''\r\n        var first = true\r\n        pathSegArray.forEach(function (pathSeg) {\r\n          if (first) {\r\n            first = false\r\n            string += pathSeg._asPathString()\r\n          } else {\r\n            string += ' ' + pathSeg._asPathString()\r\n          }\r\n        })\r\n        return string\r\n      } // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.\r\n\r\n      window.SVGPathSegList.prototype._parsePath = function (string) {\r\n        if (!string || string.length == 0) return []\r\n        var owningPathSegList = this\r\n\r\n        var Builder = function Builder () {\r\n          this.pathSegList = []\r\n        }\r\n\r\n        Builder.prototype.appendSegment = function (pathSeg) {\r\n          this.pathSegList.push(pathSeg)\r\n        }\r\n\r\n        var Source = function Source (string) {\r\n          this._string = string\r\n          this._currentIndex = 0\r\n          this._endIndex = this._string.length\r\n          this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN\r\n\r\n          this._skipOptionalSpaces()\r\n        }\r\n\r\n        Source.prototype._isCurrentSpace = function () {\r\n          var character = this._string[this._currentIndex]\r\n          return (\r\n            character <= ' ' &&\r\n            (character == ' ' || character == '\\n' || character == '\\t' || character == '\\r' || character == '\\f')\r\n          )\r\n        }\r\n\r\n        Source.prototype._skipOptionalSpaces = function () {\r\n          while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\r\n            this._currentIndex++\r\n          }\r\n\r\n          return this._currentIndex < this._endIndex\r\n        }\r\n\r\n        Source.prototype._skipOptionalSpacesOrDelimiter = function () {\r\n          if (\r\n            this._currentIndex < this._endIndex &&\r\n            !this._isCurrentSpace() &&\r\n            this._string.charAt(this._currentIndex) != ','\r\n          )\r\n            return false\r\n\r\n          if (this._skipOptionalSpaces()) {\r\n            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ',') {\r\n              this._currentIndex++\r\n\r\n              this._skipOptionalSpaces()\r\n            }\r\n          }\r\n\r\n          return this._currentIndex < this._endIndex\r\n        }\r\n\r\n        Source.prototype.hasMoreData = function () {\r\n          return this._currentIndex < this._endIndex\r\n        }\r\n\r\n        Source.prototype.peekSegmentType = function () {\r\n          var lookahead = this._string[this._currentIndex]\r\n          return this._pathSegTypeFromChar(lookahead)\r\n        }\r\n\r\n        Source.prototype._pathSegTypeFromChar = function (lookahead) {\r\n          switch (lookahead) {\r\n            case 'Z':\r\n            case 'z':\r\n              return window.SVGPathSeg.PATHSEG_CLOSEPATH\r\n\r\n            case 'M':\r\n              return window.SVGPathSeg.PATHSEG_MOVETO_ABS\r\n\r\n            case 'm':\r\n              return window.SVGPathSeg.PATHSEG_MOVETO_REL\r\n\r\n            case 'L':\r\n              return window.SVGPathSeg.PATHSEG_LINETO_ABS\r\n\r\n            case 'l':\r\n              return window.SVGPathSeg.PATHSEG_LINETO_REL\r\n\r\n            case 'C':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS\r\n\r\n            case 'c':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL\r\n\r\n            case 'Q':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS\r\n\r\n            case 'q':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL\r\n\r\n            case 'A':\r\n              return window.SVGPathSeg.PATHSEG_ARC_ABS\r\n\r\n            case 'a':\r\n              return window.SVGPathSeg.PATHSEG_ARC_REL\r\n\r\n            case 'H':\r\n              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS\r\n\r\n            case 'h':\r\n              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL\r\n\r\n            case 'V':\r\n              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS\r\n\r\n            case 'v':\r\n              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL\r\n\r\n            case 'S':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS\r\n\r\n            case 's':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL\r\n\r\n            case 'T':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS\r\n\r\n            case 't':\r\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL\r\n\r\n            default:\r\n              return window.SVGPathSeg.PATHSEG_UNKNOWN\r\n          }\r\n        }\r\n\r\n        Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {\r\n          // Check for remaining coordinates in the current command.\r\n          if (\r\n            (lookahead == '+' || lookahead == '-' || lookahead == '.' || (lookahead >= '0' && lookahead <= '9')) &&\r\n            previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH\r\n          ) {\r\n            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS) return window.SVGPathSeg.PATHSEG_LINETO_ABS\r\n            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL) return window.SVGPathSeg.PATHSEG_LINETO_REL\r\n            return previousCommand\r\n          }\r\n\r\n          return window.SVGPathSeg.PATHSEG_UNKNOWN\r\n        }\r\n\r\n        Source.prototype.initialCommandIsMoveTo = function () {\r\n          // If the path is empty it is still valid, so return true.\r\n          if (!this.hasMoreData()) return true\r\n          var command = this.peekSegmentType() // Path must start with moveTo.\r\n\r\n          return command == window.SVGPathSeg.PATHSEG_MOVETO_ABS || command == window.SVGPathSeg.PATHSEG_MOVETO_REL\r\n        } // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.\r\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\r\n\r\n        Source.prototype._parseNumber = function () {\r\n          var exponent = 0\r\n          var integer = 0\r\n          var frac = 1\r\n          var decimal = 0\r\n          var sign = 1\r\n          var expsign = 1\r\n          var startIndex = this._currentIndex\r\n\r\n          this._skipOptionalSpaces() // Read the sign.\r\n\r\n          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '+')\r\n            this._currentIndex++\r\n          else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '-') {\r\n            this._currentIndex++\r\n            sign = -1\r\n          }\r\n          if (\r\n            this._currentIndex == this._endIndex ||\r\n            ((this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') &&\r\n              this._string.charAt(this._currentIndex) != '.')\r\n          )\r\n            // The first character of a number must be one of [0-9+-.].\r\n            return undefined // Read the integer part, build right-to-left.\r\n\r\n          var startIntPartIndex = this._currentIndex\r\n\r\n          while (\r\n            this._currentIndex < this._endIndex &&\r\n            this._string.charAt(this._currentIndex) >= '0' &&\r\n            this._string.charAt(this._currentIndex) <= '9'\r\n          ) {\r\n            this._currentIndex++\r\n          } // Advance to first non-digit.\r\n\r\n          if (this._currentIndex != startIntPartIndex) {\r\n            var scanIntPartIndex = this._currentIndex - 1\r\n            var multiplier = 1\r\n\r\n            while (scanIntPartIndex >= startIntPartIndex) {\r\n              integer += multiplier * (this._string.charAt(scanIntPartIndex--) - '0')\r\n              multiplier *= 10\r\n            }\r\n          } // Read the decimals.\r\n\r\n          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '.') {\r\n            this._currentIndex++ // There must be a least one digit following the .\r\n\r\n            if (\r\n              this._currentIndex >= this._endIndex ||\r\n              this._string.charAt(this._currentIndex) < '0' ||\r\n              this._string.charAt(this._currentIndex) > '9'\r\n            )\r\n              return undefined\r\n\r\n            while (\r\n              this._currentIndex < this._endIndex &&\r\n              this._string.charAt(this._currentIndex) >= '0' &&\r\n              this._string.charAt(this._currentIndex) <= '9'\r\n            ) {\r\n              frac *= 10\r\n              decimal += (this._string.charAt(this._currentIndex) - '0') / frac\r\n              this._currentIndex += 1\r\n            }\r\n          } // Read the exponent part.\r\n\r\n          if (\r\n            this._currentIndex != startIndex &&\r\n            this._currentIndex + 1 < this._endIndex &&\r\n            (this._string.charAt(this._currentIndex) == 'e' || this._string.charAt(this._currentIndex) == 'E') &&\r\n            this._string.charAt(this._currentIndex + 1) != 'x' &&\r\n            this._string.charAt(this._currentIndex + 1) != 'm'\r\n          ) {\r\n            this._currentIndex++ // Read the sign of the exponent.\r\n\r\n            if (this._string.charAt(this._currentIndex) == '+') {\r\n              this._currentIndex++\r\n            } else if (this._string.charAt(this._currentIndex) == '-') {\r\n              this._currentIndex++\r\n              expsign = -1\r\n            } // There must be an exponent.\r\n\r\n            if (\r\n              this._currentIndex >= this._endIndex ||\r\n              this._string.charAt(this._currentIndex) < '0' ||\r\n              this._string.charAt(this._currentIndex) > '9'\r\n            )\r\n              return undefined\r\n\r\n            while (\r\n              this._currentIndex < this._endIndex &&\r\n              this._string.charAt(this._currentIndex) >= '0' &&\r\n              this._string.charAt(this._currentIndex) <= '9'\r\n            ) {\r\n              exponent *= 10\r\n              exponent += this._string.charAt(this._currentIndex) - '0'\r\n              this._currentIndex++\r\n            }\r\n          }\r\n\r\n          var number = integer + decimal\r\n          number *= sign\r\n          if (exponent) number *= Math.pow(10, expsign * exponent)\r\n          if (startIndex == this._currentIndex) return undefined\r\n\r\n          this._skipOptionalSpacesOrDelimiter()\r\n\r\n          return number\r\n        }\r\n\r\n        Source.prototype._parseArcFlag = function () {\r\n          if (this._currentIndex >= this._endIndex) return undefined\r\n          var flag = false\r\n\r\n          var flagChar = this._string.charAt(this._currentIndex++)\r\n\r\n          if (flagChar == '0') flag = false\r\n          else if (flagChar == '1') flag = true\r\n          else return undefined\r\n\r\n          this._skipOptionalSpacesOrDelimiter()\r\n\r\n          return flag\r\n        }\r\n\r\n        Source.prototype.parseSegment = function () {\r\n          var lookahead = this._string[this._currentIndex]\r\n\r\n          var command = this._pathSegTypeFromChar(lookahead)\r\n\r\n          if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {\r\n            // Possibly an implicit command. Not allowed if this is the first command.\r\n            if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null\r\n            command = this._nextCommandHelper(lookahead, this._previousCommand)\r\n            if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) return null\r\n          } else {\r\n            this._currentIndex++\r\n          }\r\n\r\n          this._previousCommand = command\r\n\r\n          switch (command) {\r\n            case window.SVGPathSeg.PATHSEG_MOVETO_REL:\r\n              return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_MOVETO_ABS:\r\n              return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_LINETO_REL:\r\n              return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_LINETO_ABS:\r\n              return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\r\n              return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\r\n              return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\r\n              return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\r\n              return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber())\r\n\r\n            case window.SVGPathSeg.PATHSEG_CLOSEPATH:\r\n              this._skipOptionalSpaces()\r\n\r\n              return new window.SVGPathSegClosePath(owningPathSegList)\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\r\n              var points = {\r\n                x1: this._parseNumber(),\r\n                y1: this._parseNumber(),\r\n                x2: this._parseNumber(),\r\n                y2: this._parseNumber(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegCurvetoCubicRel(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x1,\r\n                points.y1,\r\n                points.x2,\r\n                points.y2\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\r\n              var points = {\r\n                x1: this._parseNumber(),\r\n                y1: this._parseNumber(),\r\n                x2: this._parseNumber(),\r\n                y2: this._parseNumber(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegCurvetoCubicAbs(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x1,\r\n                points.y1,\r\n                points.x2,\r\n                points.y2\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\r\n              var points = {\r\n                x2: this._parseNumber(),\r\n                y2: this._parseNumber(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegCurvetoCubicSmoothRel(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x2,\r\n                points.y2\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\r\n              var points = {\r\n                x2: this._parseNumber(),\r\n                y2: this._parseNumber(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegCurvetoCubicSmoothAbs(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x2,\r\n                points.y2\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\r\n              var points = {\r\n                x1: this._parseNumber(),\r\n                y1: this._parseNumber(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegCurvetoQuadraticRel(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x1,\r\n                points.y1\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\r\n              var points = {\r\n                x1: this._parseNumber(),\r\n                y1: this._parseNumber(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegCurvetoQuadraticAbs(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x1,\r\n                points.y1\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\r\n              return new window.SVGPathSegCurvetoQuadraticSmoothRel(\r\n                owningPathSegList,\r\n                this._parseNumber(),\r\n                this._parseNumber()\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\r\n              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(\r\n                owningPathSegList,\r\n                this._parseNumber(),\r\n                this._parseNumber()\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_ARC_REL:\r\n              var points = {\r\n                x1: this._parseNumber(),\r\n                y1: this._parseNumber(),\r\n                arcAngle: this._parseNumber(),\r\n                arcLarge: this._parseArcFlag(),\r\n                arcSweep: this._parseArcFlag(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegArcRel(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x1,\r\n                points.y1,\r\n                points.arcAngle,\r\n                points.arcLarge,\r\n                points.arcSweep\r\n              )\r\n\r\n            case window.SVGPathSeg.PATHSEG_ARC_ABS:\r\n              var points = {\r\n                x1: this._parseNumber(),\r\n                y1: this._parseNumber(),\r\n                arcAngle: this._parseNumber(),\r\n                arcLarge: this._parseArcFlag(),\r\n                arcSweep: this._parseArcFlag(),\r\n                x: this._parseNumber(),\r\n                y: this._parseNumber()\r\n              }\r\n              return new window.SVGPathSegArcAbs(\r\n                owningPathSegList,\r\n                points.x,\r\n                points.y,\r\n                points.x1,\r\n                points.y1,\r\n                points.arcAngle,\r\n                points.arcLarge,\r\n                points.arcSweep\r\n              )\r\n\r\n            default:\r\n              throw 'Unknown path seg type.'\r\n          }\r\n        }\r\n\r\n        var builder = new Builder()\r\n        var source = new Source(string)\r\n        if (!source.initialCommandIsMoveTo()) return []\r\n\r\n        while (source.hasMoreData()) {\r\n          var pathSeg = source.parseSegment()\r\n          if (!pathSeg) return []\r\n          builder.appendSegment(pathSeg)\r\n        }\r\n\r\n        return builder.pathSegList\r\n      }\r\n    }\r\n  })() // String.padEnd polyfill for IE11\r\n  //\r\n  // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd\r\n\r\n  if (!String.prototype.padEnd) {\r\n    String.prototype.padEnd = function padEnd (targetLength, padString) {\r\n      targetLength = targetLength >> 0 //floor if number or convert non-number to 0;\r\n\r\n      padString = String(typeof padString !== 'undefined' ? padString : ' ')\r\n\r\n      if (this.length > targetLength) {\r\n        return String(this)\r\n      } else {\r\n        targetLength = targetLength - this.length\r\n\r\n        if (targetLength > padString.length) {\r\n          padString += padString.repeat(targetLength / padString.length) //append to original to ensure we are longer than needed\r\n        }\r\n\r\n        return String(this) + padString.slice(0, targetLength)\r\n      }\r\n    }\r\n  }\r\n  /* jshint ignore:end */\r\n\r\n  Chart.prototype.axis = function () {}\r\n\r\n  Chart.prototype.axis.labels = function (labels) {\r\n    var $$ = this.internal\r\n\r\n    if (arguments.length) {\r\n      Object.keys(labels).forEach(function (axisId) {\r\n        $$.axis.setLabelText(axisId, labels[axisId])\r\n      })\r\n      $$.axis.updateLabels()\r\n    } // TODO: return some values?\r\n  }\r\n\r\n  Chart.prototype.axis.max = function (max) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (arguments.length) {\r\n      if (_typeof(max) === 'object') {\r\n        if (isValue(max.x)) {\r\n          config.axis_x_max = max.x\r\n        }\r\n\r\n        if (isValue(max.y)) {\r\n          config.axis_y_max = max.y\r\n        }\r\n\r\n        if (isValue(max.y2)) {\r\n          config.axis_y2_max = max.y2\r\n        }\r\n      } else {\r\n        config.axis_y_max = config.axis_y2_max = max\r\n      }\r\n\r\n      $$.redraw({\r\n        withUpdateOrgXDomain: true,\r\n        withUpdateXDomain: true\r\n      })\r\n    } else {\r\n      return {\r\n        x: config.axis_x_max,\r\n        y: config.axis_y_max,\r\n        y2: config.axis_y2_max\r\n      }\r\n    }\r\n  }\r\n\r\n  Chart.prototype.axis.min = function (min) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (arguments.length) {\r\n      if (_typeof(min) === 'object') {\r\n        if (isValue(min.x)) {\r\n          config.axis_x_min = min.x\r\n        }\r\n\r\n        if (isValue(min.y)) {\r\n          config.axis_y_min = min.y\r\n        }\r\n\r\n        if (isValue(min.y2)) {\r\n          config.axis_y2_min = min.y2\r\n        }\r\n      } else {\r\n        config.axis_y_min = config.axis_y2_min = min\r\n      }\r\n\r\n      $$.redraw({\r\n        withUpdateOrgXDomain: true,\r\n        withUpdateXDomain: true\r\n      })\r\n    } else {\r\n      return {\r\n        x: config.axis_x_min,\r\n        y: config.axis_y_min,\r\n        y2: config.axis_y2_min\r\n      }\r\n    }\r\n  }\r\n\r\n  Chart.prototype.axis.range = function (range) {\r\n    if (arguments.length) {\r\n      if (isDefined(range.max)) {\r\n        this.axis.max(range.max)\r\n      }\r\n\r\n      if (isDefined(range.min)) {\r\n        this.axis.min(range.min)\r\n      }\r\n    } else {\r\n      return {\r\n        max: this.axis.max(),\r\n        min: this.axis.min()\r\n      }\r\n    }\r\n  }\r\n\r\n  Chart.prototype.category = function (i, category) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (arguments.length > 1) {\r\n      config.axis_x_categories[i] = category\r\n      $$.redraw()\r\n    }\r\n\r\n    return config.axis_x_categories[i]\r\n  }\r\n\r\n  Chart.prototype.categories = function (categories) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (!arguments.length) {\r\n      return config.axis_x_categories\r\n    }\r\n\r\n    config.axis_x_categories = categories\r\n    $$.redraw()\r\n    return config.axis_x_categories\r\n  }\r\n\r\n  Chart.prototype.resize = function (size) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n    config.size_width = size ? size.width : null\r\n    config.size_height = size ? size.height : null\r\n    this.flush()\r\n  }\r\n\r\n  Chart.prototype.flush = function () {\r\n    var $$ = this.internal\r\n    $$.updateAndRedraw({\r\n      withLegend: true,\r\n      withTransition: false,\r\n      withTransitionForTransform: false\r\n    })\r\n  }\r\n\r\n  Chart.prototype.destroy = function () {\r\n    var $$ = this.internal\r\n    window.clearInterval($$.intervalForObserveInserted)\r\n\r\n    if ($$.resizeTimeout !== undefined) {\r\n      window.clearTimeout($$.resizeTimeout)\r\n    }\r\n\r\n    if (window.detachEvent) {\r\n      window.detachEvent('onresize', $$.resizeIfElementDisplayed)\r\n    } else if (window.removeEventListener) {\r\n      window.removeEventListener('resize', $$.resizeIfElementDisplayed)\r\n    } else {\r\n      var wrapper = window.onresize // check if no one else removed our wrapper and remove our resizeFunction from it\r\n\r\n      if (wrapper && wrapper.add && wrapper.remove) {\r\n        wrapper.remove($$.resizeFunction)\r\n      }\r\n    } // Removes the inner resize functions\r\n\r\n    $$.resizeFunction.remove() // Unbinds from the window focus event\r\n\r\n    $$.unbindWindowFocus()\r\n    $$.selectChart.classed('c3', false).html('') // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.\r\n\r\n    Object.keys($$).forEach(function (key) {\r\n      $$[key] = null\r\n    })\r\n    return null\r\n  }\r\n\r\n  Chart.prototype.color = function (id) {\r\n    var $$ = this.internal\r\n    return $$.color(id) // more patterns\r\n  }\r\n\r\n  Chart.prototype.data = function (targetIds) {\r\n    var targets = this.internal.data.targets\r\n    return typeof targetIds === 'undefined'\r\n      ? targets\r\n      : targets.filter(function (t) {\r\n          return [].concat(targetIds).indexOf(t.id) >= 0\r\n        })\r\n  }\r\n\r\n  Chart.prototype.data.shown = function (targetIds) {\r\n    return this.internal.filterTargetsToShow(this.data(targetIds))\r\n  }\r\n\r\n  Chart.prototype.data.values = function (targetId) {\r\n    var targets,\r\n      values = null\r\n\r\n    if (targetId) {\r\n      targets = this.data(targetId)\r\n      values = targets[0]\r\n        ? targets[0].values.map(function (d) {\r\n            return d.value\r\n          })\r\n        : null\r\n    }\r\n\r\n    return values\r\n  }\r\n\r\n  Chart.prototype.data.names = function (names) {\r\n    this.internal.clearLegendItemTextBoxCache()\r\n    return this.internal.updateDataAttributes('names', names)\r\n  }\r\n\r\n  Chart.prototype.data.colors = function (colors) {\r\n    return this.internal.updateDataAttributes('colors', colors)\r\n  }\r\n\r\n  Chart.prototype.data.axes = function (axes) {\r\n    return this.internal.updateDataAttributes('axes', axes)\r\n  }\r\n\r\n  Chart.prototype.flow = function (args) {\r\n    var $$ = this.internal,\r\n      targets,\r\n      data,\r\n      notfoundIds = [],\r\n      orgDataCount = $$.getMaxDataCount(),\r\n      dataCount,\r\n      domain,\r\n      baseTarget,\r\n      baseValue,\r\n      length = 0,\r\n      tail = 0,\r\n      diff,\r\n      to\r\n\r\n    if (args.json) {\r\n      data = $$.convertJsonToData(args.json, args.keys)\r\n    } else if (args.rows) {\r\n      data = $$.convertRowsToData(args.rows)\r\n    } else if (args.columns) {\r\n      data = $$.convertColumnsToData(args.columns)\r\n    } else {\r\n      return\r\n    }\r\n\r\n    targets = $$.convertDataToTargets(data, true) // Update/Add data\r\n\r\n    $$.data.targets.forEach(function (t) {\r\n      var found = false,\r\n        i,\r\n        j\r\n\r\n      for (i = 0; i < targets.length; i++) {\r\n        if (t.id === targets[i].id) {\r\n          found = true\r\n\r\n          if (t.values[t.values.length - 1]) {\r\n            tail = t.values[t.values.length - 1].index + 1\r\n          }\r\n\r\n          length = targets[i].values.length\r\n\r\n          for (j = 0; j < length; j++) {\r\n            targets[i].values[j].index = tail + j\r\n\r\n            if (!$$.isTimeSeries()) {\r\n              targets[i].values[j].x = tail + j\r\n            }\r\n          }\r\n\r\n          t.values = t.values.concat(targets[i].values)\r\n          targets.splice(i, 1)\r\n          break\r\n        }\r\n      }\r\n\r\n      if (!found) {\r\n        notfoundIds.push(t.id)\r\n      }\r\n    }) // Append null for not found targets\r\n\r\n    $$.data.targets.forEach(function (t) {\r\n      var i, j\r\n\r\n      for (i = 0; i < notfoundIds.length; i++) {\r\n        if (t.id === notfoundIds[i]) {\r\n          tail = t.values[t.values.length - 1].index + 1\r\n\r\n          for (j = 0; j < length; j++) {\r\n            t.values.push({\r\n              id: t.id,\r\n              index: tail + j,\r\n              x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,\r\n              value: null\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }) // Generate null values for new target\r\n\r\n    if ($$.data.targets.length) {\r\n      targets.forEach(function (t) {\r\n        var i,\r\n          missing = []\r\n\r\n        for (i = $$.data.targets[0].values[0].index; i < tail; i++) {\r\n          missing.push({\r\n            id: t.id,\r\n            index: i,\r\n            x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,\r\n            value: null\r\n          })\r\n        }\r\n\r\n        t.values.forEach(function (v) {\r\n          v.index += tail\r\n\r\n          if (!$$.isTimeSeries()) {\r\n            v.x += tail\r\n          }\r\n        })\r\n        t.values = missing.concat(t.values)\r\n      })\r\n    }\r\n\r\n    $$.data.targets = $$.data.targets.concat(targets) // add remained\r\n    // check data count because behavior needs to change when it's only one\r\n\r\n    dataCount = $$.getMaxDataCount()\r\n    baseTarget = $$.data.targets[0]\r\n    baseValue = baseTarget.values[0] // Update length to flow if needed\r\n\r\n    if (isDefined(args.to)) {\r\n      length = 0\r\n      to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to\r\n      baseTarget.values.forEach(function (v) {\r\n        if (v.x < to) {\r\n          length++\r\n        }\r\n      })\r\n    } else if (isDefined(args.length)) {\r\n      length = args.length\r\n    } // If only one data, update the domain to flow from left edge of the chart\r\n\r\n    if (!orgDataCount) {\r\n      if ($$.isTimeSeries()) {\r\n        if (baseTarget.values.length > 1) {\r\n          diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x\r\n        } else {\r\n          diff = baseValue.x - $$.getXDomain($$.data.targets)[0]\r\n        }\r\n      } else {\r\n        diff = 1\r\n      }\r\n\r\n      domain = [baseValue.x - diff, baseValue.x]\r\n      $$.updateXDomain(null, true, true, false, domain)\r\n    } else if (orgDataCount === 1) {\r\n      if ($$.isTimeSeries()) {\r\n        diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2\r\n        domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]\r\n        $$.updateXDomain(null, true, true, false, domain)\r\n      }\r\n    } // Set targets\r\n\r\n    $$.updateTargets($$.data.targets) // Redraw with new targets\r\n\r\n    $$.redraw({\r\n      flow: {\r\n        index: baseValue.index,\r\n        length: length,\r\n        duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,\r\n        done: args.done,\r\n        orgDataCount: orgDataCount\r\n      },\r\n      withLegend: true,\r\n      withTransition: orgDataCount > 1,\r\n      withTrimXDomain: false,\r\n      withUpdateXAxis: true\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.generateFlow = function (args) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      d3 = $$.d3\r\n    return function () {\r\n      var targets = args.targets,\r\n        flow = args.flow,\r\n        drawBar = args.drawBar,\r\n        drawLine = args.drawLine,\r\n        drawArea = args.drawArea,\r\n        cx = args.cx,\r\n        cy = args.cy,\r\n        xv = args.xv,\r\n        xForText = args.xForText,\r\n        yForText = args.yForText,\r\n        duration = args.duration\r\n\r\n      var translateX,\r\n        scaleX = 1,\r\n        transform,\r\n        flowIndex = flow.index,\r\n        flowLength = flow.length,\r\n        flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),\r\n        flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),\r\n        orgDomain = $$.x.domain(),\r\n        domain,\r\n        durationForFlow = flow.duration || duration,\r\n        done = flow.done || function () {},\r\n        wait = $$.generateWait()\r\n\r\n      var xgrid, xgridLines, mainRegion, mainText, mainBar, mainLine, mainArea, mainCircle // set flag\r\n\r\n      $$.flowing = true // remove head data after rendered\r\n\r\n      $$.data.targets.forEach(function (d) {\r\n        d.values.splice(0, flowLength)\r\n      }) // update x domain to generate axis elements for flow\r\n\r\n      domain = $$.updateXDomain(targets, true, true) // update elements related to x scale\r\n\r\n      if ($$.updateXGrid) {\r\n        $$.updateXGrid(true)\r\n      }\r\n\r\n      xgrid = $$.xgrid || d3.selectAll([]) // xgrid needs to be obtained after updateXGrid\r\n\r\n      xgridLines = $$.xgridLines || d3.selectAll([])\r\n      mainRegion = $$.mainRegion || d3.selectAll([])\r\n      mainText = $$.mainText || d3.selectAll([])\r\n      mainBar = $$.mainBar || d3.selectAll([])\r\n      mainLine = $$.mainLine || d3.selectAll([])\r\n      mainArea = $$.mainArea || d3.selectAll([])\r\n      mainCircle = $$.mainCircle || d3.selectAll([]) // generate transform to flow\r\n\r\n      if (!flow.orgDataCount) {\r\n        // if empty\r\n        if ($$.data.targets[0].values.length !== 1) {\r\n          translateX = $$.x(orgDomain[0]) - $$.x(domain[0])\r\n        } else {\r\n          if ($$.isTimeSeries()) {\r\n            flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0)\r\n            flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1)\r\n            translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)\r\n          } else {\r\n            translateX = diffDomain(domain) / 2\r\n          }\r\n        }\r\n      } else if (flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {\r\n        translateX = $$.x(orgDomain[0]) - $$.x(domain[0])\r\n      } else {\r\n        if ($$.isTimeSeries()) {\r\n          translateX = $$.x(orgDomain[0]) - $$.x(domain[0])\r\n        } else {\r\n          translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)\r\n        }\r\n      }\r\n\r\n      scaleX = diffDomain(orgDomain) / diffDomain(domain)\r\n      transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)'\r\n      $$.hideXGridFocus()\r\n      var flowTransition = d3\r\n        .transition()\r\n        .ease(d3.easeLinear)\r\n        .duration(durationForFlow)\r\n      wait.add($$.xAxis($$.axes.x, flowTransition))\r\n      wait.add(mainBar.transition(flowTransition).attr('transform', transform))\r\n      wait.add(mainLine.transition(flowTransition).attr('transform', transform))\r\n      wait.add(mainArea.transition(flowTransition).attr('transform', transform))\r\n      wait.add(mainCircle.transition(flowTransition).attr('transform', transform))\r\n      wait.add(mainText.transition(flowTransition).attr('transform', transform))\r\n      wait.add(\r\n        mainRegion\r\n          .filter($$.isRegionOnX)\r\n          .transition(flowTransition)\r\n          .attr('transform', transform)\r\n      )\r\n      wait.add(xgrid.transition(flowTransition).attr('transform', transform))\r\n      wait.add(xgridLines.transition(flowTransition).attr('transform', transform))\r\n      wait(function () {\r\n        var i,\r\n          shapes = [],\r\n          texts = [] // remove flowed elements\r\n\r\n        if (flowLength) {\r\n          for (i = 0; i < flowLength; i++) {\r\n            shapes.push('.' + CLASS.shape + '-' + (flowIndex + i))\r\n            texts.push('.' + CLASS.text + '-' + (flowIndex + i))\r\n          }\r\n\r\n          $$.svg\r\n            .selectAll('.' + CLASS.shapes)\r\n            .selectAll(shapes)\r\n            .remove()\r\n          $$.svg\r\n            .selectAll('.' + CLASS.texts)\r\n            .selectAll(texts)\r\n            .remove()\r\n          $$.svg.select('.' + CLASS.xgrid).remove()\r\n        } // draw again for removing flowed elements and reverting attr\r\n\r\n        xgrid\r\n          .attr('transform', null)\r\n          .attr('x1', $$.xgridAttr.x1)\r\n          .attr('x2', $$.xgridAttr.x2)\r\n          .attr('y1', $$.xgridAttr.y1)\r\n          .attr('y2', $$.xgridAttr.y2)\r\n          .style('opacity', $$.xgridAttr.opacity)\r\n        xgridLines.attr('transform', null)\r\n        xgridLines\r\n          .select('line')\r\n          .attr('x1', config.axis_rotated ? 0 : xv)\r\n          .attr('x2', config.axis_rotated ? $$.width : xv)\r\n        xgridLines\r\n          .select('text')\r\n          .attr('x', config.axis_rotated ? $$.width : 0)\r\n          .attr('y', xv)\r\n        mainBar.attr('transform', null).attr('d', drawBar)\r\n        mainLine.attr('transform', null).attr('d', drawLine)\r\n        mainArea.attr('transform', null).attr('d', drawArea)\r\n        mainCircle\r\n          .attr('transform', null)\r\n          .attr('cx', cx)\r\n          .attr('cy', cy)\r\n        mainText\r\n          .attr('transform', null)\r\n          .attr('x', xForText)\r\n          .attr('y', yForText)\r\n          .style('fill-opacity', $$.opacityForText.bind($$))\r\n        mainRegion.attr('transform', null)\r\n        mainRegion\r\n          .filter($$.isRegionOnX)\r\n          .attr('x', $$.regionX.bind($$))\r\n          .attr('width', $$.regionWidth.bind($$)) // callback for end of flow\r\n\r\n        done()\r\n        $$.flowing = false\r\n      })\r\n    }\r\n  }\r\n\r\n  Chart.prototype.focus = function (targetIds) {\r\n    var $$ = this.internal,\r\n      candidates\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    ;(candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))), this.revert()\r\n    this.defocus()\r\n    candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false)\r\n\r\n    if ($$.hasArcType()) {\r\n      $$.expandArc(targetIds)\r\n    }\r\n\r\n    $$.toggleFocusLegend(targetIds, true)\r\n    $$.focusedTargetIds = targetIds\r\n    $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {\r\n      return targetIds.indexOf(id) < 0\r\n    })\r\n  }\r\n\r\n  Chart.prototype.defocus = function (targetIds) {\r\n    var $$ = this.internal,\r\n      candidates\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    ;(candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))),\r\n      candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true)\r\n\r\n    if ($$.hasArcType()) {\r\n      $$.unexpandArc(targetIds)\r\n    }\r\n\r\n    $$.toggleFocusLegend(targetIds, false)\r\n    $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {\r\n      return targetIds.indexOf(id) < 0\r\n    })\r\n    $$.defocusedTargetIds = targetIds\r\n  }\r\n\r\n  Chart.prototype.revert = function (targetIds) {\r\n    var $$ = this.internal,\r\n      candidates\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    candidates = $$.svg.selectAll($$.selectorTargets(targetIds)) // should be for all targets\r\n\r\n    candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false)\r\n\r\n    if ($$.hasArcType()) {\r\n      $$.unexpandArc(targetIds)\r\n    }\r\n\r\n    if ($$.config.legend_show) {\r\n      $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)))\r\n      $$.legend\r\n        .selectAll($$.selectorLegends(targetIds))\r\n        .filter(function () {\r\n          return $$.d3.select(this).classed(CLASS.legendItemFocused)\r\n        })\r\n        .classed(CLASS.legendItemFocused, false)\r\n    }\r\n\r\n    $$.focusedTargetIds = []\r\n    $$.defocusedTargetIds = []\r\n  }\r\n\r\n  Chart.prototype.xgrids = function (grids) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (!grids) {\r\n      return config.grid_x_lines\r\n    }\r\n\r\n    config.grid_x_lines = grids\r\n    $$.redrawWithoutRescale()\r\n    return config.grid_x_lines\r\n  }\r\n\r\n  Chart.prototype.xgrids.add = function (grids) {\r\n    var $$ = this.internal\r\n    return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []))\r\n  }\r\n\r\n  Chart.prototype.xgrids.remove = function (params) {\r\n    // TODO: multiple\r\n    var $$ = this.internal\r\n    $$.removeGridLines(params, true)\r\n  }\r\n\r\n  Chart.prototype.ygrids = function (grids) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (!grids) {\r\n      return config.grid_y_lines\r\n    }\r\n\r\n    config.grid_y_lines = grids\r\n    $$.redrawWithoutRescale()\r\n    return config.grid_y_lines\r\n  }\r\n\r\n  Chart.prototype.ygrids.add = function (grids) {\r\n    var $$ = this.internal\r\n    return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []))\r\n  }\r\n\r\n  Chart.prototype.ygrids.remove = function (params) {\r\n    // TODO: multiple\r\n    var $$ = this.internal\r\n    $$.removeGridLines(params, false)\r\n  }\r\n\r\n  Chart.prototype.groups = function (groups) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (isUndefined(groups)) {\r\n      return config.data_groups\r\n    }\r\n\r\n    config.data_groups = groups\r\n    $$.redraw()\r\n    return config.data_groups\r\n  }\r\n\r\n  Chart.prototype.legend = function () {}\r\n\r\n  Chart.prototype.legend.show = function (targetIds) {\r\n    var $$ = this.internal\r\n    $$.showLegend($$.mapToTargetIds(targetIds))\r\n    $$.updateAndRedraw({\r\n      withLegend: true\r\n    })\r\n  }\r\n\r\n  Chart.prototype.legend.hide = function (targetIds) {\r\n    var $$ = this.internal\r\n    $$.hideLegend($$.mapToTargetIds(targetIds))\r\n    $$.updateAndRedraw({\r\n      withLegend: false\r\n    })\r\n  }\r\n\r\n  Chart.prototype.load = function (args) {\r\n    var $$ = this.internal,\r\n      config = $$.config // update xs if specified\r\n\r\n    if (args.xs) {\r\n      $$.addXs(args.xs)\r\n    } // update names if exists\r\n\r\n    if ('names' in args) {\r\n      Chart.prototype.data.names.bind(this)(args.names)\r\n    } // update classes if exists\r\n\r\n    if ('classes' in args) {\r\n      Object.keys(args.classes).forEach(function (id) {\r\n        config.data_classes[id] = args.classes[id]\r\n      })\r\n    } // update categories if exists\r\n\r\n    if ('categories' in args && $$.isCategorized()) {\r\n      config.axis_x_categories = args.categories\r\n    } // update axes if exists\r\n\r\n    if ('axes' in args) {\r\n      Object.keys(args.axes).forEach(function (id) {\r\n        config.data_axes[id] = args.axes[id]\r\n      })\r\n    } // update colors if exists\r\n\r\n    if ('colors' in args) {\r\n      Object.keys(args.colors).forEach(function (id) {\r\n        config.data_colors[id] = args.colors[id]\r\n      })\r\n    } // use cache if exists\r\n\r\n    if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {\r\n      $$.load($$.getCaches(args.cacheIds), args.done)\r\n      return\r\n    } // unload if needed\r\n\r\n    if ('unload' in args) {\r\n      // TODO: do not unload if target will load (included in url/rows/columns)\r\n      $$.unload($$.mapToTargetIds(typeof args.unload === 'boolean' && args.unload ? null : args.unload), function () {\r\n        $$.loadFromArgs(args)\r\n      })\r\n    } else {\r\n      $$.loadFromArgs(args)\r\n    }\r\n  }\r\n\r\n  Chart.prototype.unload = function (args) {\r\n    var $$ = this.internal\r\n    args = args || {}\r\n\r\n    if (args instanceof Array) {\r\n      args = {\r\n        ids: args\r\n      }\r\n    } else if (typeof args === 'string') {\r\n      args = {\r\n        ids: [args]\r\n      }\r\n    }\r\n\r\n    $$.unload($$.mapToTargetIds(args.ids), function () {\r\n      $$.redraw({\r\n        withUpdateOrgXDomain: true,\r\n        withUpdateXDomain: true,\r\n        withLegend: true\r\n      })\r\n\r\n      if (args.done) {\r\n        args.done()\r\n      }\r\n    })\r\n  }\r\n\r\n  Chart.prototype.regions = function (regions) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (!regions) {\r\n      return config.regions\r\n    }\r\n\r\n    config.regions = regions\r\n    $$.redrawWithoutRescale()\r\n    return config.regions\r\n  }\r\n\r\n  Chart.prototype.regions.add = function (regions) {\r\n    var $$ = this.internal,\r\n      config = $$.config\r\n\r\n    if (!regions) {\r\n      return config.regions\r\n    }\r\n\r\n    config.regions = config.regions.concat(regions)\r\n    $$.redrawWithoutRescale()\r\n    return config.regions\r\n  }\r\n\r\n  Chart.prototype.regions.remove = function (options) {\r\n    var $$ = this.internal,\r\n      config = $$.config,\r\n      duration,\r\n      classes,\r\n      regions\r\n    options = options || {}\r\n    duration = getOption(options, 'duration', config.transition_duration)\r\n    classes = getOption(options, 'classes', [CLASS.region])\r\n    regions = $$.main.select('.' + CLASS.regions).selectAll(\r\n      classes.map(function (c) {\r\n        return '.' + c\r\n      })\r\n    )\r\n    ;(duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove()\r\n    config.regions = config.regions.filter(function (region) {\r\n      var found = false\r\n\r\n      if (!region['class']) {\r\n        return true\r\n      }\r\n\r\n      region['class'].split(' ').forEach(function (c) {\r\n        if (classes.indexOf(c) >= 0) {\r\n          found = true\r\n        }\r\n      })\r\n      return !found\r\n    })\r\n    return config.regions\r\n  }\r\n\r\n  Chart.prototype.selected = function (targetId) {\r\n    var $$ = this.internal,\r\n      d3 = $$.d3\r\n    return d3.merge(\r\n      $$.main\r\n        .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId))\r\n        .selectAll('.' + CLASS.shape)\r\n        .filter(function () {\r\n          return d3.select(this).classed(CLASS.SELECTED)\r\n        })\r\n        .map(function (d) {\r\n          return d.map(function (d) {\r\n            var data = d.__data__\r\n            return data.data ? data.data : data\r\n          })\r\n        })\r\n    )\r\n  }\r\n\r\n  Chart.prototype.select = function (ids, indices, resetOther) {\r\n    var $$ = this.internal,\r\n      d3 = $$.d3,\r\n      config = $$.config\r\n\r\n    if (!config.data_selection_enabled) {\r\n      return\r\n    }\r\n\r\n    $$.main\r\n      .selectAll('.' + CLASS.shapes)\r\n      .selectAll('.' + CLASS.shape)\r\n      .each(function (d, i) {\r\n        var shape = d3.select(this),\r\n          id = d.data ? d.data.id : d.id,\r\n          toggle = $$.getToggle(this, d).bind($$),\r\n          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,\r\n          isTargetIndex = !indices || indices.indexOf(i) >= 0,\r\n          isSelected = shape.classed(CLASS.SELECTED) // line/area selection not supported yet\r\n\r\n        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {\r\n          return\r\n        }\r\n\r\n        if (isTargetId && isTargetIndex) {\r\n          if (config.data_selection_isselectable(d) && !isSelected) {\r\n            toggle(true, shape.classed(CLASS.SELECTED, true), d, i)\r\n          }\r\n        } else if (isDefined(resetOther) && resetOther) {\r\n          if (isSelected) {\r\n            toggle(false, shape.classed(CLASS.SELECTED, false), d, i)\r\n          }\r\n        }\r\n      })\r\n  }\r\n\r\n  Chart.prototype.unselect = function (ids, indices) {\r\n    var $$ = this.internal,\r\n      d3 = $$.d3,\r\n      config = $$.config\r\n\r\n    if (!config.data_selection_enabled) {\r\n      return\r\n    }\r\n\r\n    $$.main\r\n      .selectAll('.' + CLASS.shapes)\r\n      .selectAll('.' + CLASS.shape)\r\n      .each(function (d, i) {\r\n        var shape = d3.select(this),\r\n          id = d.data ? d.data.id : d.id,\r\n          toggle = $$.getToggle(this, d).bind($$),\r\n          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,\r\n          isTargetIndex = !indices || indices.indexOf(i) >= 0,\r\n          isSelected = shape.classed(CLASS.SELECTED) // line/area selection not supported yet\r\n\r\n        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {\r\n          return\r\n        }\r\n\r\n        if (isTargetId && isTargetIndex) {\r\n          if (config.data_selection_isselectable(d)) {\r\n            if (isSelected) {\r\n              toggle(false, shape.classed(CLASS.SELECTED, false), d, i)\r\n            }\r\n          }\r\n        }\r\n      })\r\n  }\r\n\r\n  Chart.prototype.show = function (targetIds, options) {\r\n    var $$ = this.internal,\r\n      targets\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    options = options || {}\r\n    $$.removeHiddenTargetIds(targetIds)\r\n    targets = $$.svg.selectAll($$.selectorTargets(targetIds))\r\n    targets\r\n      .transition()\r\n      .style('display', 'initial', 'important')\r\n      .style('opacity', 1, 'important')\r\n      .call($$.endall, function () {\r\n        targets.style('opacity', null).style('opacity', 1)\r\n      })\r\n\r\n    if (options.withLegend) {\r\n      $$.showLegend(targetIds)\r\n    }\r\n\r\n    $$.redraw({\r\n      withUpdateOrgXDomain: true,\r\n      withUpdateXDomain: true,\r\n      withLegend: true\r\n    })\r\n  }\r\n\r\n  Chart.prototype.hide = function (targetIds, options) {\r\n    var $$ = this.internal,\r\n      targets\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    options = options || {}\r\n    $$.addHiddenTargetIds(targetIds)\r\n    targets = $$.svg.selectAll($$.selectorTargets(targetIds))\r\n    targets\r\n      .transition()\r\n      .style('opacity', 0, 'important')\r\n      .call($$.endall, function () {\r\n        targets.style('opacity', null).style('opacity', 0)\r\n        targets.style('display', 'none')\r\n      })\r\n\r\n    if (options.withLegend) {\r\n      $$.hideLegend(targetIds)\r\n    }\r\n\r\n    $$.redraw({\r\n      withUpdateOrgXDomain: true,\r\n      withUpdateXDomain: true,\r\n      withLegend: true\r\n    })\r\n  }\r\n\r\n  Chart.prototype.toggle = function (targetIds, options) {\r\n    var that = this,\r\n      $$ = this.internal\r\n    $$.mapToTargetIds(targetIds).forEach(function (targetId) {\r\n      $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options)\r\n    })\r\n  }\r\n\r\n  Chart.prototype.tooltip = function () {}\r\n\r\n  Chart.prototype.tooltip.show = function (args) {\r\n    var $$ = this.internal,\r\n      targets,\r\n      data,\r\n      mouse = {} // determine mouse position on the chart\r\n\r\n    if (args.mouse) {\r\n      mouse = args.mouse\r\n    } else {\r\n      // determine focus data\r\n      if (args.data) {\r\n        data = args.data\r\n      } else if (typeof args.x !== 'undefined') {\r\n        if (args.id) {\r\n          targets = $$.data.targets.filter(function (t) {\r\n            return t.id === args.id\r\n          })\r\n        } else {\r\n          targets = $$.data.targets\r\n        }\r\n\r\n        data = $$.filterByX(targets, args.x).slice(0, 1)[0]\r\n      }\r\n\r\n      mouse = data ? $$.getMousePosition(data) : null\r\n    } // emulate mouse events to show\r\n\r\n    $$.dispatchEvent('mousemove', mouse)\r\n    $$.config.tooltip_onshow.call($$, data)\r\n  }\r\n\r\n  Chart.prototype.tooltip.hide = function () {\r\n    // TODO: get target data by checking the state of focus\r\n    this.internal.dispatchEvent('mouseout', 0)\r\n    this.internal.config.tooltip_onhide.call(this)\r\n  }\r\n\r\n  Chart.prototype.transform = function (type, targetIds) {\r\n    var $$ = this.internal,\r\n      options =\r\n        ['pie', 'donut'].indexOf(type) >= 0\r\n          ? {\r\n              withTransform: true\r\n            }\r\n          : null\r\n    $$.transformTo(targetIds, type, options)\r\n  }\r\n\r\n  ChartInternal.prototype.transformTo = function (targetIds, type, optionsForRedraw) {\r\n    var $$ = this,\r\n      withTransitionForAxis = !$$.hasArcType(),\r\n      options = optionsForRedraw || {\r\n        withTransitionForAxis: withTransitionForAxis\r\n      }\r\n    options.withTransitionForTransform = false\r\n    $$.transiting = false\r\n    $$.setTargetType(targetIds, type)\r\n    $$.updateTargets($$.data.targets) // this is needed when transforming to arc\r\n\r\n    $$.updateAndRedraw(options)\r\n  }\r\n\r\n  Chart.prototype.x = function (x) {\r\n    var $$ = this.internal\r\n\r\n    if (arguments.length) {\r\n      $$.updateTargetX($$.data.targets, x)\r\n      $$.redraw({\r\n        withUpdateOrgXDomain: true,\r\n        withUpdateXDomain: true\r\n      })\r\n    }\r\n\r\n    return $$.data.xs\r\n  }\r\n\r\n  Chart.prototype.xs = function (xs) {\r\n    var $$ = this.internal\r\n\r\n    if (arguments.length) {\r\n      $$.updateTargetXs($$.data.targets, xs)\r\n      $$.redraw({\r\n        withUpdateOrgXDomain: true,\r\n        withUpdateXDomain: true\r\n      })\r\n    }\r\n\r\n    return $$.data.xs\r\n  }\r\n\r\n  Chart.prototype.zoom = function (domain) {\r\n    var $$ = this.internal\r\n\r\n    if (domain) {\r\n      if ($$.isTimeSeries()) {\r\n        domain = domain.map(function (x) {\r\n          return $$.parseDate(x)\r\n        })\r\n      }\r\n\r\n      if ($$.config.subchart_show) {\r\n        $$.brush.selectionAsValue(domain, true)\r\n      } else {\r\n        $$.updateXDomain(null, true, false, false, domain)\r\n        $$.redraw({\r\n          withY: $$.config.zoom_rescale,\r\n          withSubchart: false\r\n        })\r\n      }\r\n\r\n      $$.config.zoom_onzoom.call(this, $$.x.orgDomain())\r\n      return domain\r\n    } else {\r\n      return $$.x.domain()\r\n    }\r\n  }\r\n\r\n  Chart.prototype.zoom.enable = function (enabled) {\r\n    var $$ = this.internal\r\n    $$.config.zoom_enabled = enabled\r\n    $$.updateAndRedraw()\r\n  }\r\n\r\n  Chart.prototype.unzoom = function () {\r\n    var $$ = this.internal\r\n\r\n    if ($$.config.subchart_show) {\r\n      $$.brush.clear()\r\n    } else {\r\n      $$.updateXDomain(null, true, false, false, $$.subX.domain())\r\n      $$.redraw({\r\n        withY: $$.config.zoom_rescale,\r\n        withSubchart: false\r\n      })\r\n    }\r\n  }\r\n\r\n  Chart.prototype.zoom.max = function (max) {\r\n    var $$ = this.internal,\r\n      config = $$.config,\r\n      d3 = $$.d3\r\n\r\n    if (max === 0 || max) {\r\n      config.zoom_x_max = d3.max([$$.orgXDomain[1], max])\r\n    } else {\r\n      return config.zoom_x_max\r\n    }\r\n  }\r\n\r\n  Chart.prototype.zoom.min = function (min) {\r\n    var $$ = this.internal,\r\n      config = $$.config,\r\n      d3 = $$.d3\r\n\r\n    if (min === 0 || min) {\r\n      config.zoom_x_min = d3.min([$$.orgXDomain[0], min])\r\n    } else {\r\n      return config.zoom_x_min\r\n    }\r\n  }\r\n\r\n  Chart.prototype.zoom.range = function (range) {\r\n    if (arguments.length) {\r\n      if (isDefined(range.max)) {\r\n        this.domain.max(range.max)\r\n      }\r\n\r\n      if (isDefined(range.min)) {\r\n        this.domain.min(range.min)\r\n      }\r\n    } else {\r\n      return {\r\n        max: this.domain.max(),\r\n        min: this.domain.min()\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initPie = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3\r\n    $$.pie = d3.pie().value(function (d) {\r\n      return d.values.reduce(function (a, b) {\r\n        return a + b.value\r\n      }, 0)\r\n    })\r\n    var orderFct = $$.getOrderFunction() // we need to reverse the returned order if asc or desc to have the slice in expected order.\r\n\r\n    if (orderFct && ($$.isOrderAsc() || $$.isOrderDesc())) {\r\n      var defaultSort = orderFct\r\n\r\n      orderFct = function orderFct (t1, t2) {\r\n        return defaultSort(t1, t2) * -1\r\n      }\r\n    }\r\n\r\n    $$.pie.sort(orderFct || null)\r\n  }\r\n\r\n  ChartInternal.prototype.updateRadius = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      w = config.gauge_width || config.donut_width,\r\n      gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * $$.config.gauge_arcs_minWidth\r\n    $$.radiusExpanded = (Math.min($$.arcWidth, $$.arcHeight) / 2) * ($$.hasType('gauge') ? 0.85 : 1)\r\n    $$.radius = $$.radiusExpanded * 0.95\r\n    $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6\r\n    $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0\r\n    $$.gaugeArcWidth = w\r\n      ? w\r\n      : gaugeArcWidth <= $$.radius - $$.innerRadius\r\n      ? $$.radius - $$.innerRadius\r\n      : gaugeArcWidth <= $$.radius\r\n      ? gaugeArcWidth\r\n      : $$.radius\r\n  }\r\n\r\n  ChartInternal.prototype.updateArc = function () {\r\n    var $$ = this\r\n    $$.svgArc = $$.getSvgArc()\r\n    $$.svgArcExpanded = $$.getSvgArcExpanded()\r\n    $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98)\r\n  }\r\n\r\n  ChartInternal.prototype.updateAngle = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      found = false,\r\n      index = 0,\r\n      gMin,\r\n      gMax,\r\n      gTic,\r\n      gValue\r\n\r\n    if (!config) {\r\n      return null\r\n    }\r\n\r\n    $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {\r\n      if (!found && t.data.id === d.data.id) {\r\n        found = true\r\n        d = t\r\n        d.index = index\r\n      }\r\n\r\n      index++\r\n    })\r\n\r\n    if (isNaN(d.startAngle)) {\r\n      d.startAngle = 0\r\n    }\r\n\r\n    if (isNaN(d.endAngle)) {\r\n      d.endAngle = d.startAngle\r\n    }\r\n\r\n    if ($$.isGaugeType(d.data)) {\r\n      gMin = config.gauge_min\r\n      gMax = config.gauge_max\r\n      gTic = (Math.PI * (config.gauge_fullCircle ? 2 : 1)) / (gMax - gMin)\r\n      gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin\r\n      d.startAngle = config.gauge_startingAngle\r\n      d.endAngle = d.startAngle + gTic * gValue\r\n    }\r\n\r\n    return found ? d : null\r\n  }\r\n\r\n  ChartInternal.prototype.getSvgArc = function () {\r\n    var $$ = this,\r\n      hasGaugeType = $$.hasType('gauge'),\r\n      singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,\r\n      arc = $$.d3\r\n        .arc()\r\n        .outerRadius(function (d) {\r\n          return hasGaugeType ? $$.radius - singleArcWidth * d.index : $$.radius\r\n        })\r\n        .innerRadius(function (d) {\r\n          return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius\r\n        }),\r\n      newArc = function newArc (d, withoutUpdate) {\r\n        var updated\r\n\r\n        if (withoutUpdate) {\r\n          return arc(d)\r\n        } // for interpolate\r\n\r\n        updated = $$.updateAngle(d)\r\n        return updated ? arc(updated) : 'M 0 0'\r\n      } // TODO: extends all function\r\n\r\n    newArc.centroid = arc.centroid\r\n    return newArc\r\n  }\r\n\r\n  ChartInternal.prototype.getSvgArcExpanded = function (rate) {\r\n    rate = rate || 1\r\n    var $$ = this,\r\n      hasGaugeType = $$.hasType('gauge'),\r\n      singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,\r\n      expandWidth = Math.min($$.radiusExpanded * rate - $$.radius, singleArcWidth * 0.8 - (1 - rate) * 100),\r\n      arc = $$.d3\r\n        .arc()\r\n        .outerRadius(function (d) {\r\n          return hasGaugeType ? $$.radius - singleArcWidth * d.index + expandWidth : $$.radiusExpanded * rate\r\n        })\r\n        .innerRadius(function (d) {\r\n          return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius\r\n        })\r\n    return function (d) {\r\n      var updated = $$.updateAngle(d)\r\n      return updated ? arc(updated) : 'M 0 0'\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getArc = function (d, withoutUpdate, force) {\r\n    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : 'M 0 0'\r\n  }\r\n\r\n  ChartInternal.prototype.transformForArcLabel = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      updated = $$.updateAngle(d),\r\n      c,\r\n      x,\r\n      y,\r\n      h,\r\n      ratio,\r\n      translate = '',\r\n      hasGauge = $$.hasType('gauge')\r\n\r\n    if (updated && !hasGauge) {\r\n      c = this.svgArc.centroid(updated)\r\n      x = isNaN(c[0]) ? 0 : c[0]\r\n      y = isNaN(c[1]) ? 0 : c[1]\r\n      h = Math.sqrt(x * x + y * y)\r\n\r\n      if ($$.hasType('donut') && config.donut_label_ratio) {\r\n        ratio = isFunction(config.donut_label_ratio)\r\n          ? config.donut_label_ratio(d, $$.radius, h)\r\n          : config.donut_label_ratio\r\n      } else if ($$.hasType('pie') && config.pie_label_ratio) {\r\n        ratio = isFunction(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio\r\n      } else {\r\n        ratio = $$.radius && h ? ((36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius) / h : 0\r\n      }\r\n\r\n      translate = 'translate(' + x * ratio + ',' + y * ratio + ')'\r\n    } else if (updated && hasGauge && $$.filterTargetsToShow($$.data.targets).length > 1) {\r\n      var y1 = Math.sin(updated.endAngle - Math.PI / 2)\r\n      x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25)\r\n      y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3\r\n      translate = 'translate(' + x + ',' + y + ')'\r\n    }\r\n\r\n    return translate\r\n  }\r\n\r\n  ChartInternal.prototype.getArcRatio = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      whole = Math.PI * ($$.hasType('gauge') && !config.gauge_fullCircle ? 1 : 2)\r\n    return d ? (d.endAngle - d.startAngle) / whole : null\r\n  }\r\n\r\n  ChartInternal.prototype.convertToArcData = function (d) {\r\n    return this.addName({\r\n      id: d.data.id,\r\n      value: d.value,\r\n      ratio: this.getArcRatio(d),\r\n      index: d.index\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.textForArcLabel = function (d) {\r\n    var $$ = this,\r\n      updated,\r\n      value,\r\n      ratio,\r\n      id,\r\n      format\r\n\r\n    if (!$$.shouldShowArcLabel()) {\r\n      return ''\r\n    }\r\n\r\n    updated = $$.updateAngle(d)\r\n    value = updated ? updated.value : null\r\n    ratio = $$.getArcRatio(updated)\r\n    id = d.data.id\r\n\r\n    if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {\r\n      return ''\r\n    }\r\n\r\n    format = $$.getArcLabelFormat()\r\n    return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio)\r\n  }\r\n\r\n  ChartInternal.prototype.textForGaugeMinMax = function (value, isMax) {\r\n    var $$ = this,\r\n      format = $$.getGaugeLabelExtents()\r\n    return format ? format(value, isMax) : value\r\n  }\r\n\r\n  ChartInternal.prototype.expandArc = function (targetIds) {\r\n    var $$ = this,\r\n      interval // MEMO: avoid to cancel transition\r\n\r\n    if ($$.transiting) {\r\n      interval = window.setInterval(function () {\r\n        if (!$$.transiting) {\r\n          window.clearInterval(interval)\r\n\r\n          if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {\r\n            $$.expandArc(targetIds)\r\n          }\r\n        }\r\n      }, 10)\r\n      return\r\n    }\r\n\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function (d) {\r\n      if (!$$.shouldExpand(d.data.id)) {\r\n        return\r\n      }\r\n\r\n      $$.d3\r\n        .select(this)\r\n        .selectAll('path')\r\n        .transition()\r\n        .duration($$.expandDuration(d.data.id))\r\n        .attr('d', $$.svgArcExpanded)\r\n        .transition()\r\n        .duration($$.expandDuration(d.data.id) * 2)\r\n        .attr('d', $$.svgArcExpandedSub)\r\n        .each(function (d) {\r\n          if ($$.isDonutType(d.data));\r\n        })\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.unexpandArc = function (targetIds) {\r\n    var $$ = this\r\n\r\n    if ($$.transiting) {\r\n      return\r\n    }\r\n\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    $$.svg\r\n      .selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc))\r\n      .selectAll('path')\r\n      .transition()\r\n      .duration(function (d) {\r\n        return $$.expandDuration(d.data.id)\r\n      })\r\n      .attr('d', $$.svgArc)\r\n    $$.svg.selectAll('.' + CLASS.arc)\r\n  }\r\n\r\n  ChartInternal.prototype.expandDuration = function (id) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if ($$.isDonutType(id)) {\r\n      return config.donut_expand_duration\r\n    } else if ($$.isGaugeType(id)) {\r\n      return config.gauge_expand_duration\r\n    } else if ($$.isPieType(id)) {\r\n      return config.pie_expand_duration\r\n    } else {\r\n      return 50\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.shouldExpand = function (id) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return (\r\n      ($$.isDonutType(id) && config.donut_expand) ||\r\n      ($$.isGaugeType(id) && config.gauge_expand) ||\r\n      ($$.isPieType(id) && config.pie_expand)\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.shouldShowArcLabel = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      shouldShow = true\r\n\r\n    if ($$.hasType('donut')) {\r\n      shouldShow = config.donut_label_show\r\n    } else if ($$.hasType('pie')) {\r\n      shouldShow = config.pie_label_show\r\n    } // when gauge, always true\r\n\r\n    return shouldShow\r\n  }\r\n\r\n  ChartInternal.prototype.meetsArcLabelThreshold = function (ratio) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold\r\n    return ratio >= threshold\r\n  }\r\n\r\n  ChartInternal.prototype.getArcLabelFormat = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      format = config.pie_label_format\r\n\r\n    if ($$.hasType('gauge')) {\r\n      format = config.gauge_label_format\r\n    } else if ($$.hasType('donut')) {\r\n      format = config.donut_label_format\r\n    }\r\n\r\n    return format\r\n  }\r\n\r\n  ChartInternal.prototype.getGaugeLabelExtents = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return config.gauge_label_extents\r\n  }\r\n\r\n  ChartInternal.prototype.getArcTitle = function () {\r\n    var $$ = this\r\n    return $$.hasType('donut') ? $$.config.donut_title : ''\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetsForArc = function (targets) {\r\n    var $$ = this,\r\n      main = $$.main,\r\n      mainPies,\r\n      mainPieEnter,\r\n      classChartArc = $$.classChartArc.bind($$),\r\n      classArcs = $$.classArcs.bind($$),\r\n      classFocus = $$.classFocus.bind($$)\r\n    mainPies = main\r\n      .select('.' + CLASS.chartArcs)\r\n      .selectAll('.' + CLASS.chartArc)\r\n      .data($$.pie(targets))\r\n      .attr('class', function (d) {\r\n        return classChartArc(d) + classFocus(d.data)\r\n      })\r\n    mainPieEnter = mainPies\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', classChartArc)\r\n    mainPieEnter.append('g').attr('class', classArcs)\r\n    mainPieEnter\r\n      .append('text')\r\n      .attr('dy', $$.hasType('gauge') ? '-.1em' : '.35em')\r\n      .style('opacity', 0)\r\n      .style('text-anchor', 'middle')\r\n      .style('pointer-events', 'none') // MEMO: can not keep same color..., but not bad to update color in redraw\r\n    //mainPieUpdate.exit().remove();\r\n  }\r\n\r\n  ChartInternal.prototype.initArc = function () {\r\n    var $$ = this\r\n    $$.arcs = $$.main\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.chartArcs)\r\n      .attr('transform', $$.getTranslate('arc'))\r\n    $$.arcs\r\n      .append('text')\r\n      .attr('class', CLASS.chartArcsTitle)\r\n      .style('text-anchor', 'middle')\r\n      .text($$.getArcTitle())\r\n  }\r\n\r\n  ChartInternal.prototype.redrawArc = function (duration, durationForExit, withTransform) {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config,\r\n      main = $$.main,\r\n      arcs,\r\n      mainArc,\r\n      arcLabelLines,\r\n      mainArcLabelLine,\r\n      hasGaugeType = $$.hasType('gauge')\r\n    arcs = main\r\n      .selectAll('.' + CLASS.arcs)\r\n      .selectAll('.' + CLASS.arc)\r\n      .data($$.arcData.bind($$))\r\n    mainArc = arcs\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', $$.classArc.bind($$))\r\n      .style('fill', function (d) {\r\n        return $$.color(d.data)\r\n      })\r\n      .style('cursor', function (d) {\r\n        return config.interaction_enabled && config.data_selection_isselectable(d) ? 'pointer' : null\r\n      })\r\n      .each(function (d) {\r\n        if ($$.isGaugeType(d.data)) {\r\n          d.startAngle = d.endAngle = config.gauge_startingAngle\r\n        }\r\n\r\n        this._current = d\r\n      })\r\n      .merge(arcs)\r\n\r\n    if (hasGaugeType) {\r\n      arcLabelLines = main\r\n        .selectAll('.' + CLASS.arcs)\r\n        .selectAll('.' + CLASS.arcLabelLine)\r\n        .data($$.arcData.bind($$))\r\n      mainArcLabelLine = arcLabelLines\r\n        .enter()\r\n        .append('rect')\r\n        .attr('class', function (d) {\r\n          return CLASS.arcLabelLine + ' ' + CLASS.target + ' ' + CLASS.target + '-' + d.data.id\r\n        })\r\n        .merge(arcLabelLines)\r\n\r\n      if ($$.filterTargetsToShow($$.data.targets).length === 1) {\r\n        mainArcLabelLine.style('display', 'none')\r\n      } else {\r\n        mainArcLabelLine\r\n          .style('fill', function (d) {\r\n            return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data)\r\n          })\r\n          .style('display', config.gauge_labelLine_show ? '' : 'none')\r\n          .each(function (d) {\r\n            var lineLength = 0,\r\n              lineThickness = 2,\r\n              x = 0,\r\n              y = 0,\r\n              transform = ''\r\n\r\n            if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {\r\n              var updated = $$.updateAngle(d),\r\n                innerLineLength =\r\n                  ($$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length) * (updated.index + 1),\r\n                lineAngle = updated.endAngle - Math.PI / 2,\r\n                arcInnerRadius = $$.radius - innerLineLength,\r\n                linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius)\r\n              lineLength = $$.radiusExpanded - $$.radius + innerLineLength\r\n              x = Math.cos(linePositioningAngle) * arcInnerRadius\r\n              y = Math.sin(linePositioningAngle) * arcInnerRadius\r\n              transform = 'rotate(' + (lineAngle * 180) / Math.PI + ', ' + x + ', ' + y + ')'\r\n            }\r\n\r\n            d3.select(this)\r\n              .attr('x', x)\r\n              .attr('y', y)\r\n              .attr('width', lineLength)\r\n              .attr('height', lineThickness)\r\n              .attr('transform', transform)\r\n              .style('stroke-dasharray', '0, ' + (lineLength + lineThickness) + ', 0')\r\n          })\r\n      }\r\n    }\r\n\r\n    mainArc\r\n      .attr('transform', function (d) {\r\n        return !$$.isGaugeType(d.data) && withTransform ? 'scale(0)' : ''\r\n      })\r\n      .on(\r\n        'mouseover',\r\n        config.interaction_enabled\r\n          ? function (d) {\r\n              var updated, arcData\r\n\r\n              if ($$.transiting) {\r\n                // skip while transiting\r\n                return\r\n              }\r\n\r\n              updated = $$.updateAngle(d)\r\n\r\n              if (updated) {\r\n                arcData = $$.convertToArcData(updated) // transitions\r\n\r\n                $$.expandArc(updated.data.id)\r\n                $$.api.focus(updated.data.id)\r\n                $$.toggleFocusLegend(updated.data.id, true)\r\n                $$.config.data_onmouseover(arcData, this)\r\n              }\r\n            }\r\n          : null\r\n      )\r\n      .on(\r\n        'mousemove',\r\n        config.interaction_enabled\r\n          ? function (d) {\r\n              var updated = $$.updateAngle(d),\r\n                arcData,\r\n                selectedData\r\n\r\n              if (updated) {\r\n                ;(arcData = $$.convertToArcData(updated)), (selectedData = [arcData])\r\n                $$.showTooltip(selectedData, this)\r\n              }\r\n            }\r\n          : null\r\n      )\r\n      .on(\r\n        'mouseout',\r\n        config.interaction_enabled\r\n          ? function (d) {\r\n              var updated, arcData\r\n\r\n              if ($$.transiting) {\r\n                // skip while transiting\r\n                return\r\n              }\r\n\r\n              updated = $$.updateAngle(d)\r\n\r\n              if (updated) {\r\n                arcData = $$.convertToArcData(updated) // transitions\r\n\r\n                $$.unexpandArc(updated.data.id)\r\n                $$.api.revert()\r\n                $$.revertLegend()\r\n                $$.hideTooltip()\r\n                $$.config.data_onmouseout(arcData, this)\r\n              }\r\n            }\r\n          : null\r\n      )\r\n      .on(\r\n        'click',\r\n        config.interaction_enabled\r\n          ? function (d, i) {\r\n              var updated = $$.updateAngle(d),\r\n                arcData\r\n\r\n              if (updated) {\r\n                arcData = $$.convertToArcData(updated)\r\n\r\n                if ($$.toggleShape) {\r\n                  $$.toggleShape(this, arcData, i)\r\n                }\r\n\r\n                $$.config.data_onclick.call($$.api, arcData, this)\r\n              }\r\n            }\r\n          : null\r\n      )\r\n      .each(function () {\r\n        $$.transiting = true\r\n      })\r\n      .transition()\r\n      .duration(duration)\r\n      .attrTween('d', function (d) {\r\n        var updated = $$.updateAngle(d),\r\n          interpolate\r\n\r\n        if (!updated) {\r\n          return function () {\r\n            return 'M 0 0'\r\n          }\r\n        } //                if (this._current === d) {\r\n        //                    this._current = {\r\n        //                        startAngle: Math.PI*2,\r\n        //                        endAngle: Math.PI*2,\r\n        //                    };\r\n        //                }\r\n\r\n        if (isNaN(this._current.startAngle)) {\r\n          this._current.startAngle = 0\r\n        }\r\n\r\n        if (isNaN(this._current.endAngle)) {\r\n          this._current.endAngle = this._current.startAngle\r\n        }\r\n\r\n        interpolate = d3.interpolate(this._current, updated)\r\n        this._current = interpolate(0)\r\n        return function (t) {\r\n          var interpolated = interpolate(t)\r\n          interpolated.data = d.data // data.id will be updated by interporator\r\n\r\n          return $$.getArc(interpolated, true)\r\n        }\r\n      })\r\n      .attr('transform', withTransform ? 'scale(1)' : '')\r\n      .style('fill', function (d) {\r\n        return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id)\r\n      }) // Where gauge reading color would receive customization.\r\n      .call($$.endall, function () {\r\n        $$.transiting = false\r\n      })\r\n    arcs\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n      .remove()\r\n    main\r\n      .selectAll('.' + CLASS.chartArc)\r\n      .select('text')\r\n      .style('opacity', 0)\r\n      .attr('class', function (d) {\r\n        return $$.isGaugeType(d.data) ? CLASS.gaugeValue : ''\r\n      })\r\n      .text($$.textForArcLabel.bind($$))\r\n      .attr('transform', $$.transformForArcLabel.bind($$))\r\n      .style('font-size', function (d) {\r\n        return $$.isGaugeType(d.data) && $$.filterTargetsToShow($$.data.targets).length === 1\r\n          ? Math.round($$.radius / 5) + 'px'\r\n          : ''\r\n      })\r\n      .transition()\r\n      .duration(duration)\r\n      .style('opacity', function (d) {\r\n        return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0\r\n      })\r\n    main.select('.' + CLASS.chartArcsTitle).style('opacity', $$.hasType('donut') || hasGaugeType ? 1 : 0)\r\n\r\n    if (hasGaugeType) {\r\n      var index = 0\r\n      var backgroundArc = $$.arcs\r\n        .select('g.' + CLASS.chartArcsBackground)\r\n        .selectAll('path.' + CLASS.chartArcsBackground)\r\n        .data($$.data.targets)\r\n      backgroundArc\r\n        .enter()\r\n        .append('path')\r\n        .attr('class', function (d, i) {\r\n          return CLASS.chartArcsBackground + ' ' + CLASS.chartArcsBackground + '-' + i\r\n        })\r\n        .merge(backgroundArc)\r\n        .attr('d', function (d1) {\r\n          if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) {\r\n            return 'M 0 0'\r\n          }\r\n\r\n          var d = {\r\n            data: [\r\n              {\r\n                value: config.gauge_max\r\n              }\r\n            ],\r\n            startAngle: config.gauge_startingAngle,\r\n            endAngle: -1 * config.gauge_startingAngle * (config.gauge_fullCircle ? Math.PI : 1),\r\n            index: index++\r\n          }\r\n          return $$.getArc(d, true, true)\r\n        })\r\n      backgroundArc.exit().remove()\r\n      $$.arcs\r\n        .select('.' + CLASS.chartArcsGaugeUnit)\r\n        .attr('dy', '.75em')\r\n        .text(config.gauge_label_show ? config.gauge_units : '')\r\n      $$.arcs\r\n        .select('.' + CLASS.chartArcsGaugeMin)\r\n        .attr('dx', -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + 'px')\r\n        .attr('dy', '1.2em')\r\n        .text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_min, false) : '')\r\n      $$.arcs\r\n        .select('.' + CLASS.chartArcsGaugeMax)\r\n        .attr('dx', $$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) + 'px')\r\n        .attr('dy', '1.2em')\r\n        .text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_max, true) : '')\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initGauge = function () {\r\n    var arcs = this.arcs\r\n\r\n    if (this.hasType('gauge')) {\r\n      arcs.append('g').attr('class', CLASS.chartArcsBackground)\r\n      arcs\r\n        .append('text')\r\n        .attr('class', CLASS.chartArcsGaugeUnit)\r\n        .style('text-anchor', 'middle')\r\n        .style('pointer-events', 'none')\r\n      arcs\r\n        .append('text')\r\n        .attr('class', CLASS.chartArcsGaugeMin)\r\n        .style('text-anchor', 'middle')\r\n        .style('pointer-events', 'none')\r\n      arcs\r\n        .append('text')\r\n        .attr('class', CLASS.chartArcsGaugeMax)\r\n        .style('text-anchor', 'middle')\r\n        .style('pointer-events', 'none')\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getGaugeLabelHeight = function () {\r\n    return this.config.gauge_label_show ? 20 : 0\r\n  }\r\n\r\n  ChartInternal.prototype.hasCaches = function (ids) {\r\n    for (var i = 0; i < ids.length; i++) {\r\n      if (!(ids[i] in this.cache)) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  ChartInternal.prototype.addCache = function (id, target) {\r\n    this.cache[id] = this.cloneTarget(target)\r\n  }\r\n\r\n  ChartInternal.prototype.getCaches = function (ids) {\r\n    var targets = [],\r\n      i\r\n\r\n    for (i = 0; i < ids.length; i++) {\r\n      if (ids[i] in this.cache) {\r\n        targets.push(this.cloneTarget(this.cache[ids[i]]))\r\n      }\r\n    }\r\n\r\n    return targets\r\n  }\r\n\r\n  ChartInternal.prototype.categoryName = function (i) {\r\n    var config = this.config\r\n    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i\r\n  }\r\n\r\n  ChartInternal.prototype.generateTargetClass = function (targetId) {\r\n    return targetId || targetId === 0 ? ('-' + targetId).replace(/\\s/g, '-') : ''\r\n  }\r\n\r\n  ChartInternal.prototype.generateClass = function (prefix, targetId) {\r\n    return ' ' + prefix + ' ' + prefix + this.generateTargetClass(targetId)\r\n  }\r\n\r\n  ChartInternal.prototype.classText = function (d) {\r\n    return this.generateClass(CLASS.text, d.index)\r\n  }\r\n\r\n  ChartInternal.prototype.classTexts = function (d) {\r\n    return this.generateClass(CLASS.texts, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classShape = function (d) {\r\n    return this.generateClass(CLASS.shape, d.index)\r\n  }\r\n\r\n  ChartInternal.prototype.classShapes = function (d) {\r\n    return this.generateClass(CLASS.shapes, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classLine = function (d) {\r\n    return this.classShape(d) + this.generateClass(CLASS.line, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classLines = function (d) {\r\n    return this.classShapes(d) + this.generateClass(CLASS.lines, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classCircle = function (d) {\r\n    return this.classShape(d) + this.generateClass(CLASS.circle, d.index)\r\n  }\r\n\r\n  ChartInternal.prototype.classCircles = function (d) {\r\n    return this.classShapes(d) + this.generateClass(CLASS.circles, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classBar = function (d) {\r\n    return this.classShape(d) + this.generateClass(CLASS.bar, d.index)\r\n  }\r\n\r\n  ChartInternal.prototype.classBars = function (d) {\r\n    return this.classShapes(d) + this.generateClass(CLASS.bars, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classArc = function (d) {\r\n    return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classArcs = function (d) {\r\n    return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classArea = function (d) {\r\n    return this.classShape(d) + this.generateClass(CLASS.area, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classAreas = function (d) {\r\n    return this.classShapes(d) + this.generateClass(CLASS.areas, d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classRegion = function (d, i) {\r\n    return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '')\r\n  }\r\n\r\n  ChartInternal.prototype.classEvent = function (d) {\r\n    return this.generateClass(CLASS.eventRect, d.index)\r\n  }\r\n\r\n  ChartInternal.prototype.classTarget = function (id) {\r\n    var $$ = this\r\n    var additionalClassSuffix = $$.config.data_classes[id],\r\n      additionalClass = ''\r\n\r\n    if (additionalClassSuffix) {\r\n      additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix\r\n    }\r\n\r\n    return $$.generateClass(CLASS.target, id) + additionalClass\r\n  }\r\n\r\n  ChartInternal.prototype.classFocus = function (d) {\r\n    return this.classFocused(d) + this.classDefocused(d)\r\n  }\r\n\r\n  ChartInternal.prototype.classFocused = function (d) {\r\n    return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '')\r\n  }\r\n\r\n  ChartInternal.prototype.classDefocused = function (d) {\r\n    return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '')\r\n  }\r\n\r\n  ChartInternal.prototype.classChartText = function (d) {\r\n    return CLASS.chartText + this.classTarget(d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classChartLine = function (d) {\r\n    return CLASS.chartLine + this.classTarget(d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classChartBar = function (d) {\r\n    return CLASS.chartBar + this.classTarget(d.id)\r\n  }\r\n\r\n  ChartInternal.prototype.classChartArc = function (d) {\r\n    return CLASS.chartArc + this.classTarget(d.data.id)\r\n  }\r\n\r\n  ChartInternal.prototype.getTargetSelectorSuffix = function (targetId) {\r\n    return this.generateTargetClass(targetId).replace(/([?!@#$%^&*()_=+,.<>'\":;\\[\\]\\/|~`{}\\\\])/g, '\\\\$1')\r\n  }\r\n\r\n  ChartInternal.prototype.selectorTarget = function (id, prefix) {\r\n    return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id)\r\n  }\r\n\r\n  ChartInternal.prototype.selectorTargets = function (ids, prefix) {\r\n    var $$ = this\r\n    ids = ids || []\r\n    return ids.length\r\n      ? ids.map(function (id) {\r\n          return $$.selectorTarget(id, prefix)\r\n        })\r\n      : null\r\n  }\r\n\r\n  ChartInternal.prototype.selectorLegend = function (id) {\r\n    return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id)\r\n  }\r\n\r\n  ChartInternal.prototype.selectorLegends = function (ids) {\r\n    var $$ = this\r\n    return ids && ids.length\r\n      ? ids.map(function (id) {\r\n          return $$.selectorLegend(id)\r\n        })\r\n      : null\r\n  }\r\n\r\n  ChartInternal.prototype.getClipPath = function (id) {\r\n    var isIE9 = window.navigator.appVersion.toLowerCase().indexOf('msie 9.') >= 0\r\n    return 'url(' + (isIE9 ? '' : document.URL.split('#')[0]) + '#' + id + ')'\r\n  }\r\n\r\n  ChartInternal.prototype.appendClip = function (parent, id) {\r\n    return parent\r\n      .append('clipPath')\r\n      .attr('id', id)\r\n      .append('rect')\r\n  }\r\n\r\n  ChartInternal.prototype.getAxisClipX = function (forHorizontal) {\r\n    // axis line width + padding for left\r\n    var left = Math.max(30, this.margin.left)\r\n    return forHorizontal ? -(1 + left) : -(left - 1)\r\n  }\r\n\r\n  ChartInternal.prototype.getAxisClipY = function (forHorizontal) {\r\n    return forHorizontal ? -20 : -this.margin.top\r\n  }\r\n\r\n  ChartInternal.prototype.getXAxisClipX = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipX(!$$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.getXAxisClipY = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipY(!$$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.getYAxisClipX = function () {\r\n    var $$ = this\r\n    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.getYAxisClipY = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipY($$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.getAxisClipWidth = function (forHorizontal) {\r\n    var $$ = this,\r\n      left = Math.max(30, $$.margin.left),\r\n      right = Math.max(30, $$.margin.right) // width + axis line width + padding for left/right\r\n\r\n    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20\r\n  }\r\n\r\n  ChartInternal.prototype.getAxisClipHeight = function (forHorizontal) {\r\n    // less than 20 is not enough to show the axis label 'outer' without legend\r\n    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20\r\n  }\r\n\r\n  ChartInternal.prototype.getXAxisClipWidth = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipWidth(!$$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.getXAxisClipHeight = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipHeight(!$$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.getYAxisClipWidth = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0)\r\n  }\r\n\r\n  ChartInternal.prototype.getYAxisClipHeight = function () {\r\n    var $$ = this\r\n    return $$.getAxisClipHeight($$.config.axis_rotated)\r\n  }\r\n\r\n  ChartInternal.prototype.generateColor = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      d3 = $$.d3,\r\n      colors = config.data_colors,\r\n      pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.schemeCategory10,\r\n      callback = config.data_color,\r\n      ids = []\r\n    return function (d) {\r\n      var id = d.id || (d.data && d.data.id) || d,\r\n        color // if callback function is provided\r\n\r\n      if (colors[id] instanceof Function) {\r\n        color = colors[id](d)\r\n      } // if specified, choose that color\r\n      else if (colors[id]) {\r\n        color = colors[id]\r\n      } // if not specified, choose from pattern\r\n      else {\r\n        if (ids.indexOf(id) < 0) {\r\n          ids.push(id)\r\n        }\r\n\r\n        color = pattern[ids.indexOf(id) % pattern.length]\r\n        colors[id] = color\r\n      }\r\n\r\n      return callback instanceof Function ? callback(color, d) : color\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.generateLevelColor = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      colors = config.color_pattern,\r\n      threshold = config.color_threshold,\r\n      asValue = threshold.unit === 'value',\r\n      values = threshold.values && threshold.values.length ? threshold.values : [],\r\n      max = threshold.max || 100\r\n    return notEmpty(threshold) && notEmpty(colors)\r\n      ? function (value) {\r\n          var i,\r\n            v,\r\n            color = colors[colors.length - 1]\r\n\r\n          for (i = 0; i < values.length; i++) {\r\n            v = asValue ? value : (value * 100) / max\r\n\r\n            if (v < values[i]) {\r\n              color = colors[i]\r\n              break\r\n            }\r\n          }\r\n\r\n          return color\r\n        }\r\n      : null\r\n  }\r\n\r\n  ChartInternal.prototype.getDefaultConfig = function () {\r\n    var config = {\r\n      bindto: '#chart',\r\n      svg_classname: undefined,\r\n      size_width: undefined,\r\n      size_height: undefined,\r\n      padding_left: undefined,\r\n      padding_right: undefined,\r\n      padding_top: undefined,\r\n      padding_bottom: undefined,\r\n      resize_auto: true,\r\n      zoom_enabled: false,\r\n      zoom_initialRange: undefined,\r\n      zoom_type: 'scroll',\r\n      zoom_disableDefaultBehavior: false,\r\n      zoom_privileged: false,\r\n      zoom_rescale: false,\r\n      zoom_onzoom: function zoom_onzoom () {},\r\n      zoom_onzoomstart: function zoom_onzoomstart () {},\r\n      zoom_onzoomend: function zoom_onzoomend () {},\r\n      zoom_x_min: undefined,\r\n      zoom_x_max: undefined,\r\n      interaction_brighten: true,\r\n      interaction_enabled: true,\r\n      onmouseover: function onmouseover () {},\r\n      onmouseout: function onmouseout () {},\r\n      onresize: function onresize () {},\r\n      onresized: function onresized () {},\r\n      oninit: function oninit () {},\r\n      onrendered: function onrendered () {},\r\n      transition_duration: 350,\r\n      data_x: undefined,\r\n      data_xs: {},\r\n      data_xFormat: '%Y-%m-%d',\r\n      data_xLocaltime: true,\r\n      data_xSort: true,\r\n      data_idConverter: function data_idConverter (id) {\r\n        return id\r\n      },\r\n      data_names: {},\r\n      data_classes: {},\r\n      data_groups: [],\r\n      data_axes: {},\r\n      data_type: undefined,\r\n      data_types: {},\r\n      data_labels: {},\r\n      data_order: 'desc',\r\n      data_regions: {},\r\n      data_color: undefined,\r\n      data_colors: {},\r\n      data_hide: false,\r\n      data_filter: undefined,\r\n      data_selection_enabled: false,\r\n      data_selection_grouped: false,\r\n      data_selection_isselectable: function data_selection_isselectable () {\r\n        return true\r\n      },\r\n      data_selection_multiple: true,\r\n      data_selection_draggable: false,\r\n      data_onclick: function data_onclick () {},\r\n      data_onmouseover: function data_onmouseover () {},\r\n      data_onmouseout: function data_onmouseout () {},\r\n      data_onselected: function data_onselected () {},\r\n      data_onunselected: function data_onunselected () {},\r\n      data_url: undefined,\r\n      data_headers: undefined,\r\n      data_json: undefined,\r\n      data_rows: undefined,\r\n      data_columns: undefined,\r\n      data_mimeType: undefined,\r\n      data_keys: undefined,\r\n      // configuration for no plot-able data supplied.\r\n      data_empty_label_text: '',\r\n      // subchart\r\n      subchart_show: false,\r\n      subchart_size_height: 60,\r\n      subchart_axis_x_show: true,\r\n      subchart_onbrush: function subchart_onbrush () {},\r\n      // color\r\n      color_pattern: [],\r\n      color_threshold: {},\r\n      // legend\r\n      legend_show: true,\r\n      legend_hide: false,\r\n      legend_position: 'bottom',\r\n      legend_inset_anchor: 'top-left',\r\n      legend_inset_x: 10,\r\n      legend_inset_y: 0,\r\n      legend_inset_step: undefined,\r\n      legend_item_onclick: undefined,\r\n      legend_item_onmouseover: undefined,\r\n      legend_item_onmouseout: undefined,\r\n      legend_equally: false,\r\n      legend_padding: 0,\r\n      legend_item_tile_width: 10,\r\n      legend_item_tile_height: 10,\r\n      // axis\r\n      axis_rotated: false,\r\n      axis_x_show: true,\r\n      axis_x_type: 'indexed',\r\n      axis_x_localtime: true,\r\n      axis_x_categories: [],\r\n      axis_x_tick_centered: false,\r\n      axis_x_tick_format: undefined,\r\n      axis_x_tick_culling: {},\r\n      axis_x_tick_culling_max: 10,\r\n      axis_x_tick_count: undefined,\r\n      axis_x_tick_fit: true,\r\n      axis_x_tick_values: null,\r\n      axis_x_tick_rotate: 0,\r\n      axis_x_tick_outer: true,\r\n      axis_x_tick_multiline: true,\r\n      axis_x_tick_multilineMax: 0,\r\n      axis_x_tick_width: null,\r\n      axis_x_max: undefined,\r\n      axis_x_min: undefined,\r\n      axis_x_padding: {},\r\n      axis_x_height: undefined,\r\n      axis_x_selection: undefined,\r\n      axis_x_label: {},\r\n      axis_x_inner: undefined,\r\n      axis_y_show: true,\r\n      axis_y_type: undefined,\r\n      axis_y_max: undefined,\r\n      axis_y_min: undefined,\r\n      axis_y_inverted: false,\r\n      axis_y_center: undefined,\r\n      axis_y_inner: undefined,\r\n      axis_y_label: {},\r\n      axis_y_tick_format: undefined,\r\n      axis_y_tick_outer: true,\r\n      axis_y_tick_values: null,\r\n      axis_y_tick_rotate: 0,\r\n      axis_y_tick_count: undefined,\r\n      axis_y_tick_time_type: undefined,\r\n      axis_y_tick_time_interval: undefined,\r\n      axis_y_padding: {},\r\n      axis_y_default: undefined,\r\n      axis_y2_show: false,\r\n      axis_y2_max: undefined,\r\n      axis_y2_min: undefined,\r\n      axis_y2_inverted: false,\r\n      axis_y2_center: undefined,\r\n      axis_y2_inner: undefined,\r\n      axis_y2_label: {},\r\n      axis_y2_tick_format: undefined,\r\n      axis_y2_tick_outer: true,\r\n      axis_y2_tick_values: null,\r\n      axis_y2_tick_count: undefined,\r\n      axis_y2_padding: {},\r\n      axis_y2_default: undefined,\r\n      // grid\r\n      grid_x_show: false,\r\n      grid_x_type: 'tick',\r\n      grid_x_lines: [],\r\n      grid_y_show: false,\r\n      // not used\r\n      // grid_y_type: 'tick',\r\n      grid_y_lines: [],\r\n      grid_y_ticks: 10,\r\n      grid_focus_show: true,\r\n      grid_lines_front: true,\r\n      // point - point of each data\r\n      point_show: true,\r\n      point_r: 2.5,\r\n      point_sensitivity: 10,\r\n      point_focus_expand_enabled: true,\r\n      point_focus_expand_r: undefined,\r\n      point_select_r: undefined,\r\n      // line\r\n      line_connectNull: false,\r\n      line_step_type: 'step',\r\n      // bar\r\n      bar_width: undefined,\r\n      bar_width_ratio: 0.6,\r\n      bar_width_max: undefined,\r\n      bar_zerobased: true,\r\n      bar_space: 0,\r\n      // area\r\n      area_zerobased: true,\r\n      area_above: false,\r\n      // pie\r\n      pie_label_show: true,\r\n      pie_label_format: undefined,\r\n      pie_label_threshold: 0.05,\r\n      pie_label_ratio: undefined,\r\n      pie_expand: {},\r\n      pie_expand_duration: 50,\r\n      // gauge\r\n      gauge_fullCircle: false,\r\n      gauge_label_show: true,\r\n      gauge_labelLine_show: true,\r\n      gauge_label_format: undefined,\r\n      gauge_min: 0,\r\n      gauge_max: 100,\r\n      gauge_startingAngle: (-1 * Math.PI) / 2,\r\n      gauge_label_extents: undefined,\r\n      gauge_units: undefined,\r\n      gauge_width: undefined,\r\n      gauge_arcs_minWidth: 5,\r\n      gauge_expand: {},\r\n      gauge_expand_duration: 50,\r\n      // donut\r\n      donut_label_show: true,\r\n      donut_label_format: undefined,\r\n      donut_label_threshold: 0.05,\r\n      donut_label_ratio: undefined,\r\n      donut_width: undefined,\r\n      donut_title: '',\r\n      donut_expand: {},\r\n      donut_expand_duration: 50,\r\n      // spline\r\n      spline_interpolation_type: 'cardinal',\r\n      // region - region to change style\r\n      regions: [],\r\n      // tooltip - show when mouseover on each data\r\n      tooltip_show: true,\r\n      tooltip_grouped: true,\r\n      tooltip_order: undefined,\r\n      tooltip_format_title: undefined,\r\n      tooltip_format_name: undefined,\r\n      tooltip_format_value: undefined,\r\n      tooltip_position: undefined,\r\n      tooltip_contents: function tooltip_contents (d, defaultTitleFormat, defaultValueFormat, color) {\r\n        return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : ''\r\n      },\r\n      tooltip_init_show: false,\r\n      tooltip_init_x: 0,\r\n      tooltip_init_position: {\r\n        top: '0px',\r\n        left: '50px'\r\n      },\r\n      tooltip_onshow: function tooltip_onshow () {},\r\n      tooltip_onhide: function tooltip_onhide () {},\r\n      // title\r\n      title_text: undefined,\r\n      title_padding: {\r\n        top: 0,\r\n        right: 0,\r\n        bottom: 0,\r\n        left: 0\r\n      },\r\n      title_position: 'top-center'\r\n    }\r\n    Object.keys(this.additionalConfig).forEach(function (key) {\r\n      config[key] = this.additionalConfig[key]\r\n    }, this)\r\n    return config\r\n  }\r\n\r\n  ChartInternal.prototype.additionalConfig = {}\r\n\r\n  ChartInternal.prototype.loadConfig = function (config) {\r\n    var this_config = this.config,\r\n      target,\r\n      keys,\r\n      read\r\n\r\n    function find () {\r\n      var key = keys.shift() //        console.log(\"key =>\", key, \", target =>\", target);\r\n\r\n      if (key && target && _typeof(target) === 'object' && key in target) {\r\n        target = target[key]\r\n        return find()\r\n      } else if (!key) {\r\n        return target\r\n      } else {\r\n        return undefined\r\n      }\r\n    }\r\n\r\n    Object.keys(this_config).forEach(function (key) {\r\n      target = config\r\n      keys = key.split('_')\r\n      read = find() //        console.log(\"CONFIG : \", key, read);\r\n\r\n      if (isDefined(read)) {\r\n        this_config[key] = read\r\n      }\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.convertUrlToData = function (url, mimeType, headers, keys, done) {\r\n    var $$ = this,\r\n      type = mimeType ? mimeType : 'csv',\r\n      f,\r\n      converter\r\n\r\n    if (type === 'json') {\r\n      f = $$.d3.json\r\n      converter = $$.convertJsonToData\r\n    } else if (type === 'tsv') {\r\n      f = $$.d3.tsv\r\n      converter = $$.convertXsvToData\r\n    } else {\r\n      f = $$.d3.csv\r\n      converter = $$.convertXsvToData\r\n    }\r\n\r\n    f(url, headers)\r\n      .then(function (data) {\r\n        done.call($$, converter.call($$, data, keys))\r\n      })\r\n      .catch(function (error) {\r\n        throw error\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.convertXsvToData = function (xsv) {\r\n    var keys = xsv.columns,\r\n      rows = xsv\r\n\r\n    if (rows.length === 0) {\r\n      return {\r\n        keys: keys,\r\n        rows: [\r\n          keys.reduce(function (row, key) {\r\n            return Object.assign(row, _defineProperty({}, key, null))\r\n          }, {})\r\n        ]\r\n      }\r\n    } else {\r\n      // [].concat() is to convert result into a plain array otherwise\r\n      // test is not happy because rows have properties.\r\n      return {\r\n        keys: keys,\r\n        rows: [].concat(xsv)\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.convertJsonToData = function (json, keys) {\r\n    var $$ = this,\r\n      new_rows = [],\r\n      targetKeys,\r\n      data\r\n\r\n    if (keys) {\r\n      // when keys specified, json would be an array that includes objects\r\n      if (keys.x) {\r\n        targetKeys = keys.value.concat(keys.x)\r\n        $$.config.data_x = keys.x\r\n      } else {\r\n        targetKeys = keys.value\r\n      }\r\n\r\n      new_rows.push(targetKeys)\r\n      json.forEach(function (o) {\r\n        var new_row = []\r\n        targetKeys.forEach(function (key) {\r\n          // convert undefined to null because undefined data will be removed in convertDataToTargets()\r\n          var v = $$.findValueInJson(o, key)\r\n\r\n          if (isUndefined(v)) {\r\n            v = null\r\n          }\r\n\r\n          new_row.push(v)\r\n        })\r\n        new_rows.push(new_row)\r\n      })\r\n      data = $$.convertRowsToData(new_rows)\r\n    } else {\r\n      Object.keys(json).forEach(function (key) {\r\n        new_rows.push([key].concat(json[key]))\r\n      })\r\n      data = $$.convertColumnsToData(new_rows)\r\n    }\r\n\r\n    return data\r\n  }\r\n\r\n  ChartInternal.prototype.findValueInJson = function (object, path) {\r\n    path = path.replace(/\\[(\\w+)\\]/g, '.$1') // convert indexes to properties (replace [] with .)\r\n\r\n    path = path.replace(/^\\./, '') // strip a leading dot\r\n\r\n    var pathArray = path.split('.')\r\n\r\n    for (var i = 0; i < pathArray.length; ++i) {\r\n      var k = pathArray[i]\r\n\r\n      if (k in object) {\r\n        object = object[k]\r\n      } else {\r\n        return\r\n      }\r\n    }\r\n\r\n    return object\r\n  }\r\n  /**\r\n   * Converts the rows to normalized data.\r\n   * @param {any[][]} rows The row data\r\n   * @return {Object}\r\n   */\r\n\r\n  ChartInternal.prototype.convertRowsToData = function (rows) {\r\n    var newRows = []\r\n    var keys = rows[0]\r\n\r\n    for (var i = 1; i < rows.length; i++) {\r\n      var newRow = {}\r\n\r\n      for (var j = 0; j < rows[i].length; j++) {\r\n        if (isUndefined(rows[i][j])) {\r\n          throw new Error('Source data is missing a component at (' + i + ',' + j + ')!')\r\n        }\r\n\r\n        newRow[keys[j]] = rows[i][j]\r\n      }\r\n\r\n      newRows.push(newRow)\r\n    }\r\n\r\n    return {\r\n      keys: keys,\r\n      rows: newRows\r\n    }\r\n  }\r\n  /**\r\n   * Converts the columns to normalized data.\r\n   * @param {any[][]} columns The column data\r\n   * @return {Object}\r\n   */\r\n\r\n  ChartInternal.prototype.convertColumnsToData = function (columns) {\r\n    var newRows = []\r\n    var keys = []\r\n\r\n    for (var i = 0; i < columns.length; i++) {\r\n      var key = columns[i][0]\r\n\r\n      for (var j = 1; j < columns[i].length; j++) {\r\n        if (isUndefined(newRows[j - 1])) {\r\n          newRows[j - 1] = {}\r\n        }\r\n\r\n        if (isUndefined(columns[i][j])) {\r\n          throw new Error('Source data is missing a component at (' + i + ',' + j + ')!')\r\n        }\r\n\r\n        newRows[j - 1][key] = columns[i][j]\r\n      }\r\n\r\n      keys.push(key)\r\n    }\r\n\r\n    return {\r\n      keys: keys,\r\n      rows: newRows\r\n    }\r\n  }\r\n  /**\r\n   * Converts the data format into the target format.\r\n   * @param {!Object} data\r\n   * @param {!Array} data.keys Ordered list of target IDs.\r\n   * @param {!Array} data.rows Rows of data to convert.\r\n   * @param {boolean} appendXs True to append to $$.data.xs, False to replace.\r\n   * @return {!Array}\r\n   */\r\n\r\n  ChartInternal.prototype.convertDataToTargets = function (data, appendXs) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      targets,\r\n      ids,\r\n      xs,\r\n      keys // handles format where keys are not orderly provided\r\n\r\n    if (isArray(data)) {\r\n      keys = Object.keys(data[0])\r\n    } else {\r\n      keys = data.keys\r\n      data = data.rows\r\n    }\r\n\r\n    ids = keys.filter($$.isNotX, $$)\r\n    xs = keys.filter($$.isX, $$) // save x for update data by load when custom x and c3.x API\r\n\r\n    ids.forEach(function (id) {\r\n      var xKey = $$.getXKey(id)\r\n\r\n      if ($$.isCustomX() || $$.isTimeSeries()) {\r\n        // if included in input data\r\n        if (xs.indexOf(xKey) >= 0) {\r\n          $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(\r\n            data\r\n              .map(function (d) {\r\n                return d[xKey]\r\n              })\r\n              .filter(isValue)\r\n              .map(function (rawX, i) {\r\n                return $$.generateTargetX(rawX, id, i)\r\n              })\r\n          )\r\n        } // if not included in input data, find from preloaded data of other id's x\r\n        else if (config.data_x) {\r\n          $$.data.xs[id] = $$.getOtherTargetXs()\r\n        } // if not included in input data, find from preloaded data\r\n        else if (notEmpty(config.data_xs)) {\r\n          $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets)\r\n        } // MEMO: if no x included, use same x of current will be used\r\n      } else {\r\n        $$.data.xs[id] = data.map(function (d, i) {\r\n          return i\r\n        })\r\n      }\r\n    }) // check x is defined\r\n\r\n    ids.forEach(function (id) {\r\n      if (!$$.data.xs[id]) {\r\n        throw new Error('x is not defined for id = \"' + id + '\".')\r\n      }\r\n    }) // convert to target\r\n\r\n    targets = ids.map(function (id, index) {\r\n      var convertedId = config.data_idConverter(id)\r\n      return {\r\n        id: convertedId,\r\n        id_org: id,\r\n        values: data\r\n          .map(function (d, i) {\r\n            var xKey = $$.getXKey(id),\r\n              rawX = d[xKey],\r\n              value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null,\r\n              x // use x as categories if custom x and categorized\r\n\r\n            if ($$.isCustomX() && $$.isCategorized() && !isUndefined(rawX)) {\r\n              if (index === 0 && i === 0) {\r\n                config.axis_x_categories = []\r\n              }\r\n\r\n              x = config.axis_x_categories.indexOf(rawX)\r\n\r\n              if (x === -1) {\r\n                x = config.axis_x_categories.length\r\n                config.axis_x_categories.push(rawX)\r\n              }\r\n            } else {\r\n              x = $$.generateTargetX(rawX, id, i)\r\n            } // mark as x = undefined if value is undefined and filter to remove after mapped\r\n\r\n            if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {\r\n              x = undefined\r\n            }\r\n\r\n            return {\r\n              x: x,\r\n              value: value,\r\n              id: convertedId\r\n            }\r\n          })\r\n          .filter(function (v) {\r\n            return isDefined(v.x)\r\n          })\r\n      }\r\n    }) // finish targets\r\n\r\n    targets.forEach(function (t) {\r\n      var i // sort values by its x\r\n\r\n      if (config.data_xSort) {\r\n        t.values = t.values.sort(function (v1, v2) {\r\n          var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,\r\n            x2 = v2.x || v2.x === 0 ? v2.x : Infinity\r\n          return x1 - x2\r\n        })\r\n      } // indexing each value\r\n\r\n      i = 0\r\n      t.values.forEach(function (v) {\r\n        v.index = i++\r\n      }) // this needs to be sorted because its index and value.index is identical\r\n\r\n      $$.data.xs[t.id].sort(function (v1, v2) {\r\n        return v1 - v2\r\n      })\r\n    }) // cache information about values\r\n\r\n    $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets)\r\n    $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets) // set target types\r\n\r\n    if (config.data_type) {\r\n      $$.setTargetType(\r\n        $$.mapToIds(targets).filter(function (id) {\r\n          return !(id in config.data_types)\r\n        }),\r\n        config.data_type\r\n      )\r\n    } // cache as original id keyed\r\n\r\n    targets.forEach(function (d) {\r\n      $$.addCache(d.id_org, d)\r\n    })\r\n    return targets\r\n  }\r\n\r\n  ChartInternal.prototype.isX = function (key) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return (config.data_x && key === config.data_x) || (notEmpty(config.data_xs) && hasValue(config.data_xs, key))\r\n  }\r\n\r\n  ChartInternal.prototype.isNotX = function (key) {\r\n    return !this.isX(key)\r\n  }\r\n\r\n  ChartInternal.prototype.getXKey = function (id) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null\r\n  }\r\n\r\n  ChartInternal.prototype.getXValuesOfXKey = function (key, targets) {\r\n    var $$ = this,\r\n      xValues,\r\n      ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : []\r\n    ids.forEach(function (id) {\r\n      if ($$.getXKey(id) === key) {\r\n        xValues = $$.data.xs[id]\r\n      }\r\n    })\r\n    return xValues\r\n  }\r\n\r\n  ChartInternal.prototype.getXValue = function (id, i) {\r\n    var $$ = this\r\n    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i\r\n  }\r\n\r\n  ChartInternal.prototype.getOtherTargetXs = function () {\r\n    var $$ = this,\r\n      idsForX = Object.keys($$.data.xs)\r\n    return idsForX.length ? $$.data.xs[idsForX[0]] : null\r\n  }\r\n\r\n  ChartInternal.prototype.getOtherTargetX = function (index) {\r\n    var xs = this.getOtherTargetXs()\r\n    return xs && index < xs.length ? xs[index] : null\r\n  }\r\n\r\n  ChartInternal.prototype.addXs = function (xs) {\r\n    var $$ = this\r\n    Object.keys(xs).forEach(function (id) {\r\n      $$.config.data_xs[id] = xs[id]\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.addName = function (data) {\r\n    var $$ = this,\r\n      name\r\n\r\n    if (data) {\r\n      name = $$.config.data_names[data.id]\r\n      data.name = name !== undefined ? name : data.id\r\n    }\r\n\r\n    return data\r\n  }\r\n\r\n  ChartInternal.prototype.getValueOnIndex = function (values, index) {\r\n    var valueOnIndex = values.filter(function (v) {\r\n      return v.index === index\r\n    })\r\n    return valueOnIndex.length ? valueOnIndex[0] : null\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetX = function (targets, x) {\r\n    var $$ = this\r\n    targets.forEach(function (t) {\r\n      t.values.forEach(function (v, i) {\r\n        v.x = $$.generateTargetX(x[i], t.id, i)\r\n      })\r\n      $$.data.xs[t.id] = x\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetXs = function (targets, xs) {\r\n    var $$ = this\r\n    targets.forEach(function (t) {\r\n      if (xs[t.id]) {\r\n        $$.updateTargetX([t], xs[t.id])\r\n      }\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.generateTargetX = function (rawX, id, index) {\r\n    var $$ = this,\r\n      x\r\n\r\n    if ($$.isTimeSeries()) {\r\n      x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index))\r\n    } else if ($$.isCustomX() && !$$.isCategorized()) {\r\n      x = isValue(rawX) ? +rawX : $$.getXValue(id, index)\r\n    } else {\r\n      x = index\r\n    }\r\n\r\n    return x\r\n  }\r\n\r\n  ChartInternal.prototype.cloneTarget = function (target) {\r\n    return {\r\n      id: target.id,\r\n      id_org: target.id_org,\r\n      values: target.values.map(function (d) {\r\n        return {\r\n          x: d.x,\r\n          value: d.value,\r\n          id: d.id\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getMaxDataCount = function () {\r\n    var $$ = this\r\n    return $$.d3.max($$.data.targets, function (t) {\r\n      return t.values.length\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.mapToIds = function (targets) {\r\n    return targets.map(function (d) {\r\n      return d.id\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.mapToTargetIds = function (ids) {\r\n    var $$ = this\r\n    return ids ? [].concat(ids) : $$.mapToIds($$.data.targets)\r\n  }\r\n\r\n  ChartInternal.prototype.hasTarget = function (targets, id) {\r\n    var ids = this.mapToIds(targets),\r\n      i\r\n\r\n    for (i = 0; i < ids.length; i++) {\r\n      if (ids[i] === id) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  ChartInternal.prototype.isTargetToShow = function (targetId) {\r\n    return this.hiddenTargetIds.indexOf(targetId) < 0\r\n  }\r\n\r\n  ChartInternal.prototype.isLegendToShow = function (targetId) {\r\n    return this.hiddenLegendIds.indexOf(targetId) < 0\r\n  }\r\n\r\n  ChartInternal.prototype.filterTargetsToShow = function (targets) {\r\n    var $$ = this\r\n    return targets.filter(function (t) {\r\n      return $$.isTargetToShow(t.id)\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.mapTargetsToUniqueXs = function (targets) {\r\n    var $$ = this\r\n    var xs = $$.d3\r\n      .set(\r\n        $$.d3.merge(\r\n          targets.map(function (t) {\r\n            return t.values.map(function (v) {\r\n              return +v.x\r\n            })\r\n          })\r\n        )\r\n      )\r\n      .values()\r\n    xs = $$.isTimeSeries()\r\n      ? xs.map(function (x) {\r\n          return new Date(+x)\r\n        })\r\n      : xs.map(function (x) {\r\n          return +x\r\n        })\r\n    return xs.sort(function (a, b) {\r\n      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.addHiddenTargetIds = function (targetIds) {\r\n    targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds)\r\n\r\n    for (var i = 0; i < targetIds.length; i++) {\r\n      if (this.hiddenTargetIds.indexOf(targetIds[i]) < 0) {\r\n        this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds[i])\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.removeHiddenTargetIds = function (targetIds) {\r\n    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {\r\n      return targetIds.indexOf(id) < 0\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.addHiddenLegendIds = function (targetIds) {\r\n    targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds)\r\n\r\n    for (var i = 0; i < targetIds.length; i++) {\r\n      if (this.hiddenLegendIds.indexOf(targetIds[i]) < 0) {\r\n        this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds[i])\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.removeHiddenLegendIds = function (targetIds) {\r\n    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {\r\n      return targetIds.indexOf(id) < 0\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.getValuesAsIdKeyed = function (targets) {\r\n    var ys = {}\r\n    targets.forEach(function (t) {\r\n      ys[t.id] = []\r\n      t.values.forEach(function (v) {\r\n        ys[t.id].push(v.value)\r\n      })\r\n    })\r\n    return ys\r\n  }\r\n\r\n  ChartInternal.prototype.checkValueInTargets = function (targets, checker) {\r\n    var ids = Object.keys(targets),\r\n      i,\r\n      j,\r\n      values\r\n\r\n    for (i = 0; i < ids.length; i++) {\r\n      values = targets[ids[i]].values\r\n\r\n      for (j = 0; j < values.length; j++) {\r\n        if (checker(values[j].value)) {\r\n          return true\r\n        }\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  ChartInternal.prototype.hasNegativeValueInTargets = function (targets) {\r\n    return this.checkValueInTargets(targets, function (v) {\r\n      return v < 0\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.hasPositiveValueInTargets = function (targets) {\r\n    return this.checkValueInTargets(targets, function (v) {\r\n      return v > 0\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.isOrderDesc = function () {\r\n    var config = this.config\r\n    return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'desc'\r\n  }\r\n\r\n  ChartInternal.prototype.isOrderAsc = function () {\r\n    var config = this.config\r\n    return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'asc'\r\n  }\r\n\r\n  ChartInternal.prototype.getOrderFunction = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      orderAsc = $$.isOrderAsc(),\r\n      orderDesc = $$.isOrderDesc()\r\n\r\n    if (orderAsc || orderDesc) {\r\n      var reducer = function reducer (p, c) {\r\n        return p + Math.abs(c.value)\r\n      }\r\n\r\n      return function (t1, t2) {\r\n        var t1Sum = t1.values.reduce(reducer, 0),\r\n          t2Sum = t2.values.reduce(reducer, 0)\r\n        return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum\r\n      }\r\n    } else if (isFunction(config.data_order)) {\r\n      return config.data_order\r\n    } else if (isArray(config.data_order)) {\r\n      var order = config.data_order\r\n      return function (t1, t2) {\r\n        return order.indexOf(t1.id) - order.indexOf(t2.id)\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.orderTargets = function (targets) {\r\n    var fct = this.getOrderFunction()\r\n\r\n    if (fct) {\r\n      targets.sort(fct)\r\n    }\r\n\r\n    return targets\r\n  }\r\n\r\n  ChartInternal.prototype.filterByX = function (targets, x) {\r\n    return this.d3\r\n      .merge(\r\n        targets.map(function (t) {\r\n          return t.values\r\n        })\r\n      )\r\n      .filter(function (v) {\r\n        return v.x - x === 0\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.filterRemoveNull = function (data) {\r\n    return data.filter(function (d) {\r\n      return isValue(d.value)\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.filterByXDomain = function (targets, xDomain) {\r\n    return targets.map(function (t) {\r\n      return {\r\n        id: t.id,\r\n        id_org: t.id_org,\r\n        values: t.values.filter(function (v) {\r\n          return xDomain[0] <= v.x && v.x <= xDomain[1]\r\n        })\r\n      }\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.hasDataLabel = function () {\r\n    var config = this.config\r\n\r\n    if (typeof config.data_labels === 'boolean' && config.data_labels) {\r\n      return true\r\n    } else if (_typeof(config.data_labels) === 'object' && notEmpty(config.data_labels)) {\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  ChartInternal.prototype.getDataLabelLength = function (min, max, key) {\r\n    var $$ = this,\r\n      lengths = [0, 0],\r\n      paddingCoef = 1.3\r\n    $$.selectChart\r\n      .select('svg')\r\n      .selectAll('.dummy')\r\n      .data([min, max])\r\n      .enter()\r\n      .append('text')\r\n      .text(function (d) {\r\n        return $$.dataLabelFormat(d.id)(d)\r\n      })\r\n      .each(function (d, i) {\r\n        lengths[i] = this.getBoundingClientRect()[key] * paddingCoef\r\n      })\r\n      .remove()\r\n    return lengths\r\n  }\r\n  /**\r\n   * Returns true if the given data point is not arc type, otherwise false.\r\n   * @param {Object} d The data point\r\n   * @return {boolean}\r\n   */\r\n\r\n  ChartInternal.prototype.isNoneArc = function (d) {\r\n    return this.hasTarget(this.data.targets, d.id)\r\n  }\r\n  /**\r\n   * Returns true if the given data point is arc type, otherwise false.\r\n   * @param {Object} d The data point\r\n   * @return {boolean}\r\n   */\r\n\r\n  ChartInternal.prototype.isArc = function (d) {\r\n    return 'data' in d && this.hasTarget(this.data.targets, d.data.id)\r\n  }\r\n\r\n  ChartInternal.prototype.findClosestFromTargets = function (targets, pos) {\r\n    var $$ = this,\r\n      candidates // map to array of closest points of each target\r\n\r\n    candidates = targets.map(function (target) {\r\n      return $$.findClosest(target.values, pos)\r\n    }) // decide closest point and return\r\n\r\n    return $$.findClosest(candidates, pos)\r\n  }\r\n\r\n  ChartInternal.prototype.findClosest = function (values, pos) {\r\n    var $$ = this,\r\n      minDist = $$.config.point_sensitivity,\r\n      closest // find mouseovering bar\r\n\r\n    values\r\n      .filter(function (v) {\r\n        return v && $$.isBarType(v.id)\r\n      })\r\n      .forEach(function (v) {\r\n        var shape = $$.main\r\n          .select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index)\r\n          .node()\r\n\r\n        if (!closest && $$.isWithinBar($$.d3.mouse(shape), shape)) {\r\n          closest = v\r\n        }\r\n      }) // find closest point from non-bar\r\n\r\n    values\r\n      .filter(function (v) {\r\n        return v && !$$.isBarType(v.id)\r\n      })\r\n      .forEach(function (v) {\r\n        var d = $$.dist(v, pos)\r\n\r\n        if (d < minDist) {\r\n          minDist = d\r\n          closest = v\r\n        }\r\n      })\r\n    return closest\r\n  }\r\n\r\n  ChartInternal.prototype.dist = function (data, pos) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      xIndex = config.axis_rotated ? 1 : 0,\r\n      yIndex = config.axis_rotated ? 0 : 1,\r\n      y = $$.circleY(data, data.index),\r\n      x = $$.x(data.x)\r\n    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2))\r\n  }\r\n\r\n  ChartInternal.prototype.convertValuesToStep = function (values) {\r\n    var converted = [].concat(values),\r\n      i\r\n\r\n    if (!this.isCategorized()) {\r\n      return values\r\n    }\r\n\r\n    for (i = values.length + 1; 0 < i; i--) {\r\n      converted[i] = converted[i - 1]\r\n    }\r\n\r\n    converted[0] = {\r\n      x: converted[0].x - 1,\r\n      value: converted[0].value,\r\n      id: converted[0].id\r\n    }\r\n    converted[values.length + 1] = {\r\n      x: converted[values.length].x + 1,\r\n      value: converted[values.length].value,\r\n      id: converted[values.length].id\r\n    }\r\n    return converted\r\n  }\r\n\r\n  ChartInternal.prototype.updateDataAttributes = function (name, attrs) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      current = config['data_' + name]\r\n\r\n    if (typeof attrs === 'undefined') {\r\n      return current\r\n    }\r\n\r\n    Object.keys(attrs).forEach(function (id) {\r\n      current[id] = attrs[id]\r\n    })\r\n    $$.redraw({\r\n      withLegend: true\r\n    })\r\n    return current\r\n  }\r\n\r\n  ChartInternal.prototype.load = function (targets, args) {\r\n    var $$ = this\r\n\r\n    if (targets) {\r\n      // filter loading targets if needed\r\n      if (args.filter) {\r\n        targets = targets.filter(args.filter)\r\n      } // set type if args.types || args.type specified\r\n\r\n      if (args.type || args.types) {\r\n        targets.forEach(function (t) {\r\n          var type = args.types && args.types[t.id] ? args.types[t.id] : args.type\r\n          $$.setTargetType(t.id, type)\r\n        })\r\n      } // Update/Add data\r\n\r\n      $$.data.targets.forEach(function (d) {\r\n        for (var i = 0; i < targets.length; i++) {\r\n          if (d.id === targets[i].id) {\r\n            d.values = targets[i].values\r\n            targets.splice(i, 1)\r\n            break\r\n          }\r\n        }\r\n      })\r\n      $$.data.targets = $$.data.targets.concat(targets) // add remained\r\n    } // Set targets\r\n\r\n    $$.updateTargets($$.data.targets) // Redraw with new targets\r\n\r\n    $$.redraw({\r\n      withUpdateOrgXDomain: true,\r\n      withUpdateXDomain: true,\r\n      withLegend: true\r\n    })\r\n\r\n    if (args.done) {\r\n      args.done()\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.loadFromArgs = function (args) {\r\n    var $$ = this\r\n\r\n    if (args.data) {\r\n      $$.load($$.convertDataToTargets(args.data), args)\r\n    } else if (args.url) {\r\n      $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {\r\n        $$.load($$.convertDataToTargets(data), args)\r\n      })\r\n    } else if (args.json) {\r\n      $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args)\r\n    } else if (args.rows) {\r\n      $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args)\r\n    } else if (args.columns) {\r\n      $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args)\r\n    } else {\r\n      $$.load(null, args)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.unload = function (targetIds, done) {\r\n    var $$ = this\r\n\r\n    if (!done) {\r\n      done = function done () {}\r\n    } // filter existing target\r\n\r\n    targetIds = targetIds.filter(function (id) {\r\n      return $$.hasTarget($$.data.targets, id)\r\n    }) // If no target, call done and return\r\n\r\n    if (!targetIds || targetIds.length === 0) {\r\n      done()\r\n      return\r\n    }\r\n\r\n    $$.svg\r\n      .selectAll(\r\n        targetIds.map(function (id) {\r\n          return $$.selectorTarget(id)\r\n        })\r\n      )\r\n      .transition()\r\n      .style('opacity', 0)\r\n      .remove()\r\n      .call($$.endall, done)\r\n    targetIds.forEach(function (id) {\r\n      // Reset fadein for future load\r\n      $$.withoutFadeIn[id] = false // Remove target's elements\r\n\r\n      if ($$.legend) {\r\n        $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove()\r\n      } // Remove target\r\n\r\n      $$.data.targets = $$.data.targets.filter(function (t) {\r\n        return t.id !== id\r\n      })\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.getYDomainMin = function (targets) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      ids = $$.mapToIds(targets),\r\n      ys = $$.getValuesAsIdKeyed(targets),\r\n      j,\r\n      k,\r\n      baseId,\r\n      idsInGroup,\r\n      id,\r\n      hasNegativeValue\r\n\r\n    if (config.data_groups.length > 0) {\r\n      hasNegativeValue = $$.hasNegativeValueInTargets(targets)\r\n\r\n      for (j = 0; j < config.data_groups.length; j++) {\r\n        // Determine baseId\r\n        idsInGroup = config.data_groups[j].filter(function (id) {\r\n          return ids.indexOf(id) >= 0\r\n        })\r\n\r\n        if (idsInGroup.length === 0) {\r\n          continue\r\n        }\r\n\r\n        baseId = idsInGroup[0] // Consider negative values\r\n\r\n        if (hasNegativeValue && ys[baseId]) {\r\n          ys[baseId].forEach(function (v, i) {\r\n            ys[baseId][i] = v < 0 ? v : 0\r\n          })\r\n        } // Compute min\r\n\r\n        for (k = 1; k < idsInGroup.length; k++) {\r\n          id = idsInGroup[k]\r\n\r\n          if (!ys[id]) {\r\n            continue\r\n          }\r\n\r\n          ys[id].forEach(function (v, i) {\r\n            if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {\r\n              ys[baseId][i] += +v\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    return $$.d3.min(\r\n      Object.keys(ys).map(function (key) {\r\n        return $$.d3.min(ys[key])\r\n      })\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.getYDomainMax = function (targets) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      ids = $$.mapToIds(targets),\r\n      ys = $$.getValuesAsIdKeyed(targets),\r\n      j,\r\n      k,\r\n      baseId,\r\n      idsInGroup,\r\n      id,\r\n      hasPositiveValue\r\n\r\n    if (config.data_groups.length > 0) {\r\n      hasPositiveValue = $$.hasPositiveValueInTargets(targets)\r\n\r\n      for (j = 0; j < config.data_groups.length; j++) {\r\n        // Determine baseId\r\n        idsInGroup = config.data_groups[j].filter(function (id) {\r\n          return ids.indexOf(id) >= 0\r\n        })\r\n\r\n        if (idsInGroup.length === 0) {\r\n          continue\r\n        }\r\n\r\n        baseId = idsInGroup[0] // Consider positive values\r\n\r\n        if (hasPositiveValue && ys[baseId]) {\r\n          ys[baseId].forEach(function (v, i) {\r\n            ys[baseId][i] = v > 0 ? v : 0\r\n          })\r\n        } // Compute max\r\n\r\n        for (k = 1; k < idsInGroup.length; k++) {\r\n          id = idsInGroup[k]\r\n\r\n          if (!ys[id]) {\r\n            continue\r\n          }\r\n\r\n          ys[id].forEach(function (v, i) {\r\n            if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {\r\n              ys[baseId][i] += +v\r\n            }\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    return $$.d3.max(\r\n      Object.keys(ys).map(function (key) {\r\n        return $$.d3.max(ys[key])\r\n      })\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.getYDomain = function (targets, axisId, xDomain) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      targetsByAxisId = targets.filter(function (t) {\r\n        return $$.axis.getId(t.id) === axisId\r\n      }),\r\n      yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,\r\n      yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,\r\n      yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,\r\n      yDomainMin = $$.getYDomainMin(yTargets),\r\n      yDomainMax = $$.getYDomainMax(yTargets),\r\n      domain,\r\n      domainLength,\r\n      padding,\r\n      padding_top,\r\n      padding_bottom,\r\n      center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,\r\n      yDomainAbs,\r\n      lengths,\r\n      diff,\r\n      ratio,\r\n      isAllPositive,\r\n      isAllNegative,\r\n      isZeroBased =\r\n        ($$.hasType('bar', yTargets) && config.bar_zerobased) ||\r\n        ($$.hasType('area', yTargets) && config.area_zerobased),\r\n      isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,\r\n      showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,\r\n      showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated // MEMO: avoid inverting domain unexpectedly\r\n\r\n    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? (yDomainMin < yMax ? yDomainMin : yMax - 10) : yDomainMin\r\n    yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? (yMin < yDomainMax ? yDomainMax : yMin + 10) : yDomainMax\r\n\r\n    if (yTargets.length === 0) {\r\n      // use current domain if target of axisId is none\r\n      return axisId === 'y2' ? $$.y2.domain() : $$.y.domain()\r\n    }\r\n\r\n    if (isNaN(yDomainMin)) {\r\n      // set minimum to zero when not number\r\n      yDomainMin = 0\r\n    }\r\n\r\n    if (isNaN(yDomainMax)) {\r\n      // set maximum to have same value as yDomainMin\r\n      yDomainMax = yDomainMin\r\n    }\r\n\r\n    if (yDomainMin === yDomainMax) {\r\n      yDomainMin < 0 ? (yDomainMax = 0) : (yDomainMin = 0)\r\n    }\r\n\r\n    isAllPositive = yDomainMin >= 0 && yDomainMax >= 0\r\n    isAllNegative = yDomainMin <= 0 && yDomainMax <= 0 // Cancel zerobased if axis_*_min / axis_*_max specified\r\n\r\n    if ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {\r\n      isZeroBased = false\r\n    } // Bar/Area chart should be 0-based if all positive|negative\r\n\r\n    if (isZeroBased) {\r\n      if (isAllPositive) {\r\n        yDomainMin = 0\r\n      }\r\n\r\n      if (isAllNegative) {\r\n        yDomainMax = 0\r\n      }\r\n    }\r\n\r\n    domainLength = Math.abs(yDomainMax - yDomainMin)\r\n    padding = padding_top = padding_bottom = domainLength * 0.1\r\n\r\n    if (typeof center !== 'undefined') {\r\n      yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax))\r\n      yDomainMax = center + yDomainAbs\r\n      yDomainMin = center - yDomainAbs\r\n    } // add padding for data label\r\n\r\n    if (showHorizontalDataLabel) {\r\n      lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width')\r\n      diff = diffDomain($$.y.range())\r\n      ratio = [lengths[0] / diff, lengths[1] / diff]\r\n      padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]))\r\n      padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]))\r\n    } else if (showVerticalDataLabel) {\r\n      lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height')\r\n      padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength)\r\n      padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength)\r\n    }\r\n\r\n    if (axisId === 'y' && notEmpty(config.axis_y_padding)) {\r\n      padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength)\r\n      padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength)\r\n    }\r\n\r\n    if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {\r\n      padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength)\r\n      padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength)\r\n    } // Bar/Area chart should be 0-based if all positive|negative\r\n\r\n    if (isZeroBased) {\r\n      if (isAllPositive) {\r\n        padding_bottom = yDomainMin\r\n      }\r\n\r\n      if (isAllNegative) {\r\n        padding_top = -yDomainMax\r\n      }\r\n    }\r\n\r\n    domain = [yDomainMin - padding_bottom, yDomainMax + padding_top]\r\n    return isInverted ? domain.reverse() : domain\r\n  }\r\n\r\n  ChartInternal.prototype.getXDomainMin = function (targets) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return isDefined(config.axis_x_min)\r\n      ? $$.isTimeSeries()\r\n        ? this.parseDate(config.axis_x_min)\r\n        : config.axis_x_min\r\n      : $$.d3.min(targets, function (t) {\r\n          return $$.d3.min(t.values, function (v) {\r\n            return v.x\r\n          })\r\n        })\r\n  }\r\n\r\n  ChartInternal.prototype.getXDomainMax = function (targets) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return isDefined(config.axis_x_max)\r\n      ? $$.isTimeSeries()\r\n        ? this.parseDate(config.axis_x_max)\r\n        : config.axis_x_max\r\n      : $$.d3.max(targets, function (t) {\r\n          return $$.d3.max(t.values, function (v) {\r\n            return v.x\r\n          })\r\n        })\r\n  }\r\n\r\n  ChartInternal.prototype.getXDomainPadding = function (domain) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      diff = domain[1] - domain[0],\r\n      maxDataCount,\r\n      padding,\r\n      paddingLeft,\r\n      paddingRight\r\n\r\n    if ($$.isCategorized()) {\r\n      padding = 0\r\n    } else if ($$.hasType('bar')) {\r\n      maxDataCount = $$.getMaxDataCount()\r\n      padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5\r\n    } else {\r\n      padding = diff * 0.01\r\n    }\r\n\r\n    if (_typeof(config.axis_x_padding) === 'object' && notEmpty(config.axis_x_padding)) {\r\n      paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding\r\n      paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding\r\n    } else if (typeof config.axis_x_padding === 'number') {\r\n      paddingLeft = paddingRight = config.axis_x_padding\r\n    } else {\r\n      paddingLeft = paddingRight = padding\r\n    }\r\n\r\n    return {\r\n      left: paddingLeft,\r\n      right: paddingRight\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getXDomain = function (targets) {\r\n    var $$ = this,\r\n      xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],\r\n      firstX = xDomain[0],\r\n      lastX = xDomain[1],\r\n      padding = $$.getXDomainPadding(xDomain),\r\n      min = 0,\r\n      max = 0 // show center of x domain if min and max are the same\r\n\r\n    if (firstX - lastX === 0 && !$$.isCategorized()) {\r\n      if ($$.isTimeSeries()) {\r\n        firstX = new Date(firstX.getTime() * 0.5)\r\n        lastX = new Date(lastX.getTime() * 1.5)\r\n      } else {\r\n        firstX = firstX === 0 ? 1 : firstX * 0.5\r\n        lastX = lastX === 0 ? -1 : lastX * 1.5\r\n      }\r\n    }\r\n\r\n    if (firstX || firstX === 0) {\r\n      min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left\r\n    }\r\n\r\n    if (lastX || lastX === 0) {\r\n      max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right\r\n    }\r\n\r\n    return [min, max]\r\n  }\r\n\r\n  ChartInternal.prototype.updateXDomain = function (\r\n    targets,\r\n    withUpdateXDomain,\r\n    withUpdateOrgXDomain,\r\n    withTrim,\r\n    domain\r\n  ) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if (withUpdateOrgXDomain) {\r\n      $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)))\r\n      $$.orgXDomain = $$.x.domain()\r\n\r\n      if (config.zoom_enabled) {\r\n        $$.zoom.update()\r\n      }\r\n\r\n      $$.subX.domain($$.x.domain())\r\n\r\n      if ($$.brush) {\r\n        $$.brush.updateScale($$.subX)\r\n      }\r\n    }\r\n\r\n    if (withUpdateXDomain) {\r\n      $$.x.domain(domain ? domain : !$$.brush || $$.brush.empty() ? $$.orgXDomain : $$.brush.selectionAsValue())\r\n    } // Trim domain when too big by zoom mousemove event\r\n\r\n    if (withTrim) {\r\n      $$.x.domain($$.trimXDomain($$.x.orgDomain()))\r\n    }\r\n\r\n    return $$.x.domain()\r\n  }\r\n\r\n  ChartInternal.prototype.trimXDomain = function (domain) {\r\n    var zoomDomain = this.getZoomDomain(),\r\n      min = zoomDomain[0],\r\n      max = zoomDomain[1]\r\n\r\n    if (domain[0] <= min) {\r\n      domain[1] = +domain[1] + (min - domain[0])\r\n      domain[0] = min\r\n    }\r\n\r\n    if (max <= domain[1]) {\r\n      domain[0] = +domain[0] - (domain[1] - max)\r\n      domain[1] = max\r\n    }\r\n\r\n    return domain\r\n  }\r\n\r\n  ChartInternal.prototype.drag = function (mouse) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      main = $$.main,\r\n      d3 = $$.d3\r\n    var sx, sy, mx, my, minX, maxX, minY, maxY\r\n\r\n    if ($$.hasArcType()) {\r\n      return\r\n    }\r\n\r\n    if (!config.data_selection_enabled) {\r\n      return\r\n    } // do nothing if not selectable\r\n\r\n    if (!config.data_selection_multiple) {\r\n      return\r\n    } // skip when single selection because drag is used for multiple selection\r\n\r\n    sx = $$.dragStart[0]\r\n    sy = $$.dragStart[1]\r\n    mx = mouse[0]\r\n    my = mouse[1]\r\n    minX = Math.min(sx, mx)\r\n    maxX = Math.max(sx, mx)\r\n    minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my)\r\n    maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my)\r\n    main\r\n      .select('.' + CLASS.dragarea)\r\n      .attr('x', minX)\r\n      .attr('y', minY)\r\n      .attr('width', maxX - minX)\r\n      .attr('height', maxY - minY) // TODO: binary search when multiple xs\r\n\r\n    main\r\n      .selectAll('.' + CLASS.shapes)\r\n      .selectAll('.' + CLASS.shape)\r\n      .filter(function (d) {\r\n        return config.data_selection_isselectable(d)\r\n      })\r\n      .each(function (d, i) {\r\n        var shape = d3.select(this),\r\n          isSelected = shape.classed(CLASS.SELECTED),\r\n          isIncluded = shape.classed(CLASS.INCLUDED),\r\n          _x,\r\n          _y,\r\n          _w,\r\n          _h,\r\n          toggle,\r\n          isWithin = false,\r\n          box\r\n\r\n        if (shape.classed(CLASS.circle)) {\r\n          _x = shape.attr('cx') * 1\r\n          _y = shape.attr('cy') * 1\r\n          toggle = $$.togglePoint\r\n          isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY\r\n        } else if (shape.classed(CLASS.bar)) {\r\n          box = getPathBox(this)\r\n          _x = box.x\r\n          _y = box.y\r\n          _w = box.width\r\n          _h = box.height\r\n          toggle = $$.togglePath\r\n          isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY)\r\n        } else {\r\n          // line/area selection not supported yet\r\n          return\r\n        }\r\n\r\n        if (isWithin ^ isIncluded) {\r\n          shape.classed(CLASS.INCLUDED, !isIncluded) // TODO: included/unincluded callback here\r\n\r\n          shape.classed(CLASS.SELECTED, !isSelected)\r\n          toggle.call($$, !isSelected, shape, d, i)\r\n        }\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.dragstart = function (mouse) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if ($$.hasArcType()) {\r\n      return\r\n    }\r\n\r\n    if (!config.data_selection_enabled) {\r\n      return\r\n    } // do nothing if not selectable\r\n\r\n    $$.dragStart = mouse\r\n    $$.main\r\n      .select('.' + CLASS.chart)\r\n      .append('rect')\r\n      .attr('class', CLASS.dragarea)\r\n      .style('opacity', 0.1)\r\n    $$.dragging = true\r\n  }\r\n\r\n  ChartInternal.prototype.dragend = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if ($$.hasArcType()) {\r\n      return\r\n    }\r\n\r\n    if (!config.data_selection_enabled) {\r\n      return\r\n    } // do nothing if not selectable\r\n\r\n    $$.main\r\n      .select('.' + CLASS.dragarea)\r\n      .transition()\r\n      .duration(100)\r\n      .style('opacity', 0)\r\n      .remove()\r\n    $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false)\r\n    $$.dragging = false\r\n  }\r\n\r\n  ChartInternal.prototype.getYFormat = function (forArc) {\r\n    var $$ = this,\r\n      formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,\r\n      formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format\r\n    return function (v, ratio, id) {\r\n      var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY\r\n      return format.call($$, v, ratio)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.yFormat = function (v) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat\r\n    return format(v)\r\n  }\r\n\r\n  ChartInternal.prototype.y2Format = function (v) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat\r\n    return format(v)\r\n  }\r\n\r\n  ChartInternal.prototype.defaultValueFormat = function (v) {\r\n    return isValue(v) ? +v : ''\r\n  }\r\n\r\n  ChartInternal.prototype.defaultArcValueFormat = function (v, ratio) {\r\n    return (ratio * 100).toFixed(1) + '%'\r\n  }\r\n\r\n  ChartInternal.prototype.dataLabelFormat = function (targetId) {\r\n    var $$ = this,\r\n      data_labels = $$.config.data_labels,\r\n      format,\r\n      defaultFormat = function defaultFormat (v) {\r\n        return isValue(v) ? +v : ''\r\n      } // find format according to axis id\r\n\r\n    if (typeof data_labels.format === 'function') {\r\n      format = data_labels.format\r\n    } else if (_typeof(data_labels.format) === 'object') {\r\n      if (data_labels.format[targetId]) {\r\n        format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId]\r\n      } else {\r\n        format = function format () {\r\n          return ''\r\n        }\r\n      }\r\n    } else {\r\n      format = defaultFormat\r\n    }\r\n\r\n    return format\r\n  }\r\n\r\n  ChartInternal.prototype.initGrid = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      d3 = $$.d3\r\n    $$.grid = $$.main\r\n      .append('g')\r\n      .attr('clip-path', $$.clipPathForGrid)\r\n      .attr('class', CLASS.grid)\r\n\r\n    if (config.grid_x_show) {\r\n      $$.grid.append('g').attr('class', CLASS.xgrids)\r\n    }\r\n\r\n    if (config.grid_y_show) {\r\n      $$.grid.append('g').attr('class', CLASS.ygrids)\r\n    }\r\n\r\n    if (config.grid_focus_show) {\r\n      $$.grid\r\n        .append('g')\r\n        .attr('class', CLASS.xgridFocus)\r\n        .append('line')\r\n        .attr('class', CLASS.xgridFocus)\r\n    }\r\n\r\n    $$.xgrid = d3.selectAll([])\r\n\r\n    if (!config.grid_lines_front) {\r\n      $$.initGridLines()\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initGridLines = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3\r\n    $$.gridLines = $$.main\r\n      .append('g')\r\n      .attr('clip-path', $$.clipPathForGrid)\r\n      .attr('class', CLASS.grid + ' ' + CLASS.gridLines)\r\n    $$.gridLines.append('g').attr('class', CLASS.xgridLines)\r\n    $$.gridLines.append('g').attr('class', CLASS.ygridLines)\r\n    $$.xgridLines = d3.selectAll([])\r\n  }\r\n\r\n  ChartInternal.prototype.updateXGrid = function (withoutUpdate) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      d3 = $$.d3,\r\n      xgridData = $$.generateGridData(config.grid_x_type, $$.x),\r\n      tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0\r\n    $$.xgridAttr = config.axis_rotated\r\n      ? {\r\n          x1: 0,\r\n          x2: $$.width,\r\n          y1: function y1 (d) {\r\n            return $$.x(d) - tickOffset\r\n          },\r\n          y2: function y2 (d) {\r\n            return $$.x(d) - tickOffset\r\n          }\r\n        }\r\n      : {\r\n          x1: function x1 (d) {\r\n            return $$.x(d) + tickOffset\r\n          },\r\n          x2: function x2 (d) {\r\n            return $$.x(d) + tickOffset\r\n          },\r\n          y1: 0,\r\n          y2: $$.height\r\n        }\r\n\r\n    $$.xgridAttr.opacity = function () {\r\n      var pos = +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1')\r\n      return pos === (config.axis_rotated ? $$.height : 0) ? 0 : 1\r\n    }\r\n\r\n    var xgrid = $$.main\r\n      .select('.' + CLASS.xgrids)\r\n      .selectAll('.' + CLASS.xgrid)\r\n      .data(xgridData)\r\n    var xgridEnter = xgrid\r\n      .enter()\r\n      .append('line')\r\n      .attr('class', CLASS.xgrid)\r\n      .attr('x1', $$.xgridAttr.x1)\r\n      .attr('x2', $$.xgridAttr.x2)\r\n      .attr('y1', $$.xgridAttr.y1)\r\n      .attr('y2', $$.xgridAttr.y2)\r\n      .style('opacity', 0)\r\n    $$.xgrid = xgridEnter.merge(xgrid)\r\n\r\n    if (!withoutUpdate) {\r\n      $$.xgrid\r\n        .attr('x1', $$.xgridAttr.x1)\r\n        .attr('x2', $$.xgridAttr.x2)\r\n        .attr('y1', $$.xgridAttr.y1)\r\n        .attr('y2', $$.xgridAttr.y2)\r\n        .style('opacity', $$.xgridAttr.opacity)\r\n    }\r\n\r\n    xgrid.exit().remove()\r\n  }\r\n\r\n  ChartInternal.prototype.updateYGrid = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks)\r\n    var ygrid = $$.main\r\n      .select('.' + CLASS.ygrids)\r\n      .selectAll('.' + CLASS.ygrid)\r\n      .data(gridValues)\r\n    var ygridEnter = ygrid\r\n      .enter()\r\n      .append('line') // TODO: x1, x2, y1, y2, opacity need to be set here maybe\r\n      .attr('class', CLASS.ygrid)\r\n    $$.ygrid = ygridEnter.merge(ygrid)\r\n    $$.ygrid\r\n      .attr('x1', config.axis_rotated ? $$.y : 0)\r\n      .attr('x2', config.axis_rotated ? $$.y : $$.width)\r\n      .attr('y1', config.axis_rotated ? 0 : $$.y)\r\n      .attr('y2', config.axis_rotated ? $$.height : $$.y)\r\n    ygrid.exit().remove()\r\n    $$.smoothLines($$.ygrid, 'grid')\r\n  }\r\n\r\n  ChartInternal.prototype.gridTextAnchor = function (d) {\r\n    return d.position ? d.position : 'end'\r\n  }\r\n\r\n  ChartInternal.prototype.gridTextDx = function (d) {\r\n    return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4\r\n  }\r\n\r\n  ChartInternal.prototype.xGridTextX = function (d) {\r\n    return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0\r\n  }\r\n\r\n  ChartInternal.prototype.yGridTextX = function (d) {\r\n    return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width\r\n  }\r\n\r\n  ChartInternal.prototype.updateGrid = function (duration) {\r\n    var $$ = this,\r\n      main = $$.main,\r\n      config = $$.config,\r\n      xgridLine,\r\n      xgridLineEnter,\r\n      ygridLine,\r\n      ygridLineEnter,\r\n      xv = $$.xv.bind($$),\r\n      yv = $$.yv.bind($$),\r\n      xGridTextX = $$.xGridTextX.bind($$),\r\n      yGridTextX = $$.yGridTextX.bind($$) // hide if arc type\r\n\r\n    $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible')\r\n    main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden')\r\n\r\n    if (config.grid_x_show) {\r\n      $$.updateXGrid()\r\n    }\r\n\r\n    xgridLine = main\r\n      .select('.' + CLASS.xgridLines)\r\n      .selectAll('.' + CLASS.xgridLine)\r\n      .data(config.grid_x_lines) // enter\r\n\r\n    xgridLineEnter = xgridLine\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', function (d) {\r\n        return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '')\r\n      })\r\n    xgridLineEnter\r\n      .append('line')\r\n      .attr('x1', config.axis_rotated ? 0 : xv)\r\n      .attr('x2', config.axis_rotated ? $$.width : xv)\r\n      .attr('y1', config.axis_rotated ? xv : 0)\r\n      .attr('y2', config.axis_rotated ? xv : $$.height)\r\n      .style('opacity', 0)\r\n    xgridLineEnter\r\n      .append('text')\r\n      .attr('text-anchor', $$.gridTextAnchor)\r\n      .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')\r\n      .attr('x', config.axis_rotated ? yGridTextX : xGridTextX)\r\n      .attr('y', xv)\r\n      .attr('dx', $$.gridTextDx)\r\n      .attr('dy', -5)\r\n      .style('opacity', 0) // udpate\r\n\r\n    $$.xgridLines = xgridLineEnter.merge(xgridLine) // done in d3.transition() of the end of this function\r\n    // exit\r\n\r\n    xgridLine\r\n      .exit()\r\n      .transition()\r\n      .duration(duration)\r\n      .style('opacity', 0)\r\n      .remove() // Y-Grid\r\n\r\n    if (config.grid_y_show) {\r\n      $$.updateYGrid()\r\n    }\r\n\r\n    ygridLine = main\r\n      .select('.' + CLASS.ygridLines)\r\n      .selectAll('.' + CLASS.ygridLine)\r\n      .data(config.grid_y_lines) // enter\r\n\r\n    ygridLineEnter = ygridLine\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', function (d) {\r\n        return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '')\r\n      })\r\n    ygridLineEnter\r\n      .append('line')\r\n      .attr('x1', config.axis_rotated ? yv : 0)\r\n      .attr('x2', config.axis_rotated ? yv : $$.width)\r\n      .attr('y1', config.axis_rotated ? 0 : yv)\r\n      .attr('y2', config.axis_rotated ? $$.height : yv)\r\n      .style('opacity', 0)\r\n    ygridLineEnter\r\n      .append('text')\r\n      .attr('text-anchor', $$.gridTextAnchor)\r\n      .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')\r\n      .attr('x', config.axis_rotated ? xGridTextX : yGridTextX)\r\n      .attr('y', yv)\r\n      .attr('dx', $$.gridTextDx)\r\n      .attr('dy', -5)\r\n      .style('opacity', 0) // update\r\n\r\n    $$.ygridLines = ygridLineEnter.merge(ygridLine)\r\n    $$.ygridLines\r\n      .select('line')\r\n      .transition()\r\n      .duration(duration)\r\n      .attr('x1', config.axis_rotated ? yv : 0)\r\n      .attr('x2', config.axis_rotated ? yv : $$.width)\r\n      .attr('y1', config.axis_rotated ? 0 : yv)\r\n      .attr('y2', config.axis_rotated ? $$.height : yv)\r\n      .style('opacity', 1)\r\n    $$.ygridLines\r\n      .select('text')\r\n      .transition()\r\n      .duration(duration)\r\n      .attr('x', config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$))\r\n      .attr('y', yv)\r\n      .text(function (d) {\r\n        return d.text\r\n      })\r\n      .style('opacity', 1) // exit\r\n\r\n    ygridLine\r\n      .exit()\r\n      .transition()\r\n      .duration(duration)\r\n      .style('opacity', 0)\r\n      .remove()\r\n  }\r\n\r\n  ChartInternal.prototype.redrawGrid = function (withTransition, transition) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      xv = $$.xv.bind($$),\r\n      lines = $$.xgridLines.select('line'),\r\n      texts = $$.xgridLines.select('text')\r\n    return [\r\n      (withTransition ? lines.transition(transition) : lines)\r\n        .attr('x1', config.axis_rotated ? 0 : xv)\r\n        .attr('x2', config.axis_rotated ? $$.width : xv)\r\n        .attr('y1', config.axis_rotated ? xv : 0)\r\n        .attr('y2', config.axis_rotated ? xv : $$.height)\r\n        .style('opacity', 1),\r\n      (withTransition ? texts.transition(transition) : texts)\r\n        .attr('x', config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$))\r\n        .attr('y', xv)\r\n        .text(function (d) {\r\n          return d.text\r\n        })\r\n        .style('opacity', 1)\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.showXGridFocus = function (selectedData) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      dataToShow = selectedData.filter(function (d) {\r\n        return d && isValue(d.value)\r\n      }),\r\n      focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),\r\n      xx = $$.xx.bind($$)\r\n\r\n    if (!config.tooltip_show) {\r\n      return\r\n    } // Hide when scatter plot exists\r\n\r\n    if ($$.hasType('scatter') || $$.hasArcType()) {\r\n      return\r\n    }\r\n\r\n    focusEl\r\n      .style('visibility', 'visible')\r\n      .data([dataToShow[0]])\r\n      .attr(config.axis_rotated ? 'y1' : 'x1', xx)\r\n      .attr(config.axis_rotated ? 'y2' : 'x2', xx)\r\n    $$.smoothLines(focusEl, 'grid')\r\n  }\r\n\r\n  ChartInternal.prototype.hideXGridFocus = function () {\r\n    this.main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden')\r\n  }\r\n\r\n  ChartInternal.prototype.updateXgridFocus = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    $$.main\r\n      .select('line.' + CLASS.xgridFocus)\r\n      .attr('x1', config.axis_rotated ? 0 : -10)\r\n      .attr('x2', config.axis_rotated ? $$.width : -10)\r\n      .attr('y1', config.axis_rotated ? -10 : 0)\r\n      .attr('y2', config.axis_rotated ? -10 : $$.height)\r\n  }\r\n\r\n  ChartInternal.prototype.generateGridData = function (type, scale) {\r\n    var $$ = this,\r\n      gridData = [],\r\n      xDomain,\r\n      firstYear,\r\n      lastYear,\r\n      i,\r\n      tickNum = $$.main\r\n        .select('.' + CLASS.axisX)\r\n        .selectAll('.tick')\r\n        .size()\r\n\r\n    if (type === 'year') {\r\n      xDomain = $$.getXDomain()\r\n      firstYear = xDomain[0].getFullYear()\r\n      lastYear = xDomain[1].getFullYear()\r\n\r\n      for (i = firstYear; i <= lastYear; i++) {\r\n        gridData.push(new Date(i + '-01-01 00:00:00'))\r\n      }\r\n    } else {\r\n      gridData = scale.ticks(10)\r\n\r\n      if (gridData.length > tickNum) {\r\n        // use only int\r\n        gridData = gridData.filter(function (d) {\r\n          return ('' + d).indexOf('.') < 0\r\n        })\r\n      }\r\n    }\r\n\r\n    return gridData\r\n  }\r\n\r\n  ChartInternal.prototype.getGridFilterToRemove = function (params) {\r\n    return params\r\n      ? function (line) {\r\n          var found = false\r\n          ;[].concat(params).forEach(function (param) {\r\n            if (\r\n              ('value' in param && line.value === param.value) ||\r\n              ('class' in param && line['class'] === param['class'])\r\n            ) {\r\n              found = true\r\n            }\r\n          })\r\n          return found\r\n        }\r\n      : function () {\r\n          return true\r\n        }\r\n  }\r\n\r\n  ChartInternal.prototype.removeGridLines = function (params, forX) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      toRemove = $$.getGridFilterToRemove(params),\r\n      toShow = function toShow (line) {\r\n        return !toRemove(line)\r\n      },\r\n      classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,\r\n      classLine = forX ? CLASS.xgridLine : CLASS.ygridLine\r\n\r\n    $$.main\r\n      .select('.' + classLines)\r\n      .selectAll('.' + classLine)\r\n      .filter(toRemove)\r\n      .transition()\r\n      .duration(config.transition_duration)\r\n      .style('opacity', 0)\r\n      .remove()\r\n\r\n    if (forX) {\r\n      config.grid_x_lines = config.grid_x_lines.filter(toShow)\r\n    } else {\r\n      config.grid_y_lines = config.grid_y_lines.filter(toShow)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initEventRect = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    $$.main\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.eventRects)\r\n      .style('fill-opacity', 0)\r\n    $$.eventRect = $$.main\r\n      .select('.' + CLASS.eventRects)\r\n      .append('rect')\r\n      .attr('class', CLASS.eventRect) // event rect handle zoom event as well\r\n\r\n    if (config.zoom_enabled && $$.zoom) {\r\n      $$.eventRect.call($$.zoom).on('dblclick.zoom', null)\r\n\r\n      if (config.zoom_initialRange) {\r\n        // WORKAROUND: Add transition to apply transform immediately when no subchart\r\n        $$.eventRect\r\n          .transition()\r\n          .duration(0)\r\n          .call($$.zoom.transform, $$.zoomTransform(config.zoom_initialRange))\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.redrawEventRect = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config,\r\n      x,\r\n      y,\r\n      w,\r\n      h // TODO: rotated not supported yet\r\n\r\n    x = 0\r\n    y = 0\r\n    w = $$.width\r\n    h = $$.height\r\n\r\n    function mouseout () {\r\n      $$.svg.select('.' + CLASS.eventRect).style('cursor', null)\r\n      $$.hideXGridFocus()\r\n      $$.hideTooltip()\r\n      $$.unexpandCircles()\r\n      $$.unexpandBars()\r\n    } // rects for mouseover\r\n\r\n    $$.main\r\n      .select('.' + CLASS.eventRects)\r\n      .style('cursor', config.zoom_enabled ? (config.axis_rotated ? 'ns-resize' : 'ew-resize') : null)\r\n    $$.eventRect\r\n      .attr('x', x)\r\n      .attr('y', y)\r\n      .attr('width', w)\r\n      .attr('height', h)\r\n      .on(\r\n        'mouseout',\r\n        config.interaction_enabled\r\n          ? function () {\r\n              if (!config) {\r\n                return\r\n              } // chart is destroyed\r\n\r\n              if ($$.hasArcType()) {\r\n                return\r\n              }\r\n\r\n              mouseout()\r\n            }\r\n          : null\r\n      )\r\n      .on(\r\n        'mousemove',\r\n        config.interaction_enabled\r\n          ? function () {\r\n              var targetsToShow, mouse, closest, sameXData, selectedData\r\n\r\n              if ($$.dragging) {\r\n                return\r\n              } // do nothing when dragging\r\n\r\n              if ($$.hasArcType(targetsToShow)) {\r\n                return\r\n              }\r\n\r\n              targetsToShow = $$.filterTargetsToShow($$.data.targets)\r\n              mouse = d3.mouse(this)\r\n              closest = $$.findClosestFromTargets(targetsToShow, mouse)\r\n\r\n              if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {\r\n                config.data_onmouseout.call($$.api, $$.mouseover)\r\n                $$.mouseover = undefined\r\n              }\r\n\r\n              if (!closest) {\r\n                mouseout()\r\n                return\r\n              }\r\n\r\n              if ($$.isScatterType(closest) || !config.tooltip_grouped) {\r\n                sameXData = [closest]\r\n              } else {\r\n                sameXData = $$.filterByX(targetsToShow, closest.x)\r\n              } // show tooltip when cursor is close to some point\r\n\r\n              selectedData = sameXData.map(function (d) {\r\n                return $$.addName(d)\r\n              })\r\n              $$.showTooltip(selectedData, this) // expand points\r\n\r\n              if (config.point_focus_expand_enabled) {\r\n                $$.unexpandCircles()\r\n                selectedData.forEach(function (d) {\r\n                  $$.expandCircles(d.index, d.id, false)\r\n                })\r\n              }\r\n\r\n              $$.expandBars(closest.index, closest.id, true) // Show xgrid focus line\r\n\r\n              $$.showXGridFocus(selectedData) // Show cursor as pointer if point is close to mouse position\r\n\r\n              if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {\r\n                $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer')\r\n\r\n                if (!$$.mouseover) {\r\n                  config.data_onmouseover.call($$.api, closest)\r\n                  $$.mouseover = closest\r\n                }\r\n              }\r\n            }\r\n          : null\r\n      )\r\n      .on(\r\n        'click',\r\n        config.interaction_enabled\r\n          ? function () {\r\n              var targetsToShow, mouse, closest, sameXData\r\n\r\n              if ($$.hasArcType(targetsToShow)) {\r\n                return\r\n              }\r\n\r\n              targetsToShow = $$.filterTargetsToShow($$.data.targets)\r\n              mouse = d3.mouse(this)\r\n              closest = $$.findClosestFromTargets(targetsToShow, mouse)\r\n\r\n              if (!closest) {\r\n                return\r\n              } // select if selection enabled\r\n\r\n              if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {\r\n                if ($$.isScatterType(closest) || !config.data_selection_grouped) {\r\n                  sameXData = [closest]\r\n                } else {\r\n                  sameXData = $$.filterByX(targetsToShow, closest.x)\r\n                }\r\n\r\n                sameXData.forEach(function (d) {\r\n                  $$.main\r\n                    .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(d.id))\r\n                    .selectAll('.' + CLASS.shape + '-' + d.index)\r\n                    .each(function () {\r\n                      if (config.data_selection_grouped || $$.isWithinShape(this, d)) {\r\n                        $$.toggleShape(this, d, d.index)\r\n                        config.data_onclick.call($$.api, d, this)\r\n                      }\r\n                    })\r\n                })\r\n              }\r\n            }\r\n          : null\r\n      )\r\n      .call(\r\n        config.interaction_enabled && config.data_selection_draggable && $$.drag\r\n          ? d3\r\n              .drag()\r\n              .on('drag', function () {\r\n                $$.drag(d3.mouse(this))\r\n              })\r\n              .on('start', function () {\r\n                $$.dragstart(d3.mouse(this))\r\n              })\r\n              .on('end', function () {\r\n                $$.dragend()\r\n              })\r\n          : function () {}\r\n      )\r\n  }\r\n\r\n  ChartInternal.prototype.getMousePosition = function (data) {\r\n    var $$ = this\r\n    return [$$.x(data.x), $$.getYScale(data.id)(data.value)]\r\n  }\r\n\r\n  ChartInternal.prototype.dispatchEvent = function (type, mouse) {\r\n    var $$ = this,\r\n      selector = '.' + CLASS.eventRect,\r\n      eventRect = $$.main.select(selector).node(),\r\n      box = eventRect.getBoundingClientRect(),\r\n      x = box.left + (mouse ? mouse[0] : 0),\r\n      y = box.top + (mouse ? mouse[1] : 0),\r\n      event = document.createEvent('MouseEvents')\r\n    event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null)\r\n    eventRect.dispatchEvent(event)\r\n  }\r\n\r\n  ChartInternal.prototype.initLegend = function () {\r\n    var $$ = this\r\n    $$.legendItemTextBox = {}\r\n    $$.legendHasRendered = false\r\n    $$.legend = $$.svg.append('g').attr('transform', $$.getTranslate('legend'))\r\n\r\n    if (!$$.config.legend_show) {\r\n      $$.legend.style('visibility', 'hidden')\r\n      $$.hiddenLegendIds = $$.mapToIds($$.data.targets)\r\n      return\r\n    } // MEMO: call here to update legend box and tranlate for all\r\n    // MEMO: translate will be upated by this, so transform not needed in updateLegend()\r\n\r\n    $$.updateLegendWithDefaults()\r\n  }\r\n\r\n  ChartInternal.prototype.updateLegendWithDefaults = function () {\r\n    var $$ = this\r\n    $$.updateLegend($$.mapToIds($$.data.targets), {\r\n      withTransform: false,\r\n      withTransitionForTransform: false,\r\n      withTransition: false\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.updateSizeForLegend = function (legendHeight, legendWidth) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      insetLegendPosition = {\r\n        top: $$.isLegendTop\r\n          ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5\r\n          : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,\r\n        left: $$.isLegendLeft\r\n          ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5\r\n          : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5\r\n      }\r\n    $$.margin3 = {\r\n      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,\r\n      right: NaN,\r\n      bottom: 0,\r\n      left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.transformLegend = function (withTransition) {\r\n    var $$ = this\r\n    ;(withTransition ? $$.legend.transition() : $$.legend).attr('transform', $$.getTranslate('legend'))\r\n  }\r\n\r\n  ChartInternal.prototype.updateLegendStep = function (step) {\r\n    this.legendStep = step\r\n  }\r\n\r\n  ChartInternal.prototype.updateLegendItemWidth = function (w) {\r\n    this.legendItemWidth = w\r\n  }\r\n\r\n  ChartInternal.prototype.updateLegendItemHeight = function (h) {\r\n    this.legendItemHeight = h\r\n  }\r\n\r\n  ChartInternal.prototype.getLegendWidth = function () {\r\n    var $$ = this\r\n    return $$.config.legend_show\r\n      ? $$.isLegendRight || $$.isLegendInset\r\n        ? $$.legendItemWidth * ($$.legendStep + 1)\r\n        : $$.currentWidth\r\n      : 0\r\n  }\r\n\r\n  ChartInternal.prototype.getLegendHeight = function () {\r\n    var $$ = this,\r\n      h = 0\r\n\r\n    if ($$.config.legend_show) {\r\n      if ($$.isLegendRight) {\r\n        h = $$.currentHeight\r\n      } else {\r\n        h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1)\r\n      }\r\n    }\r\n\r\n    return h\r\n  }\r\n\r\n  ChartInternal.prototype.opacityForLegend = function (legendItem) {\r\n    return legendItem.classed(CLASS.legendItemHidden) ? null : 1\r\n  }\r\n\r\n  ChartInternal.prototype.opacityForUnfocusedLegend = function (legendItem) {\r\n    return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3\r\n  }\r\n\r\n  ChartInternal.prototype.toggleFocusLegend = function (targetIds, focus) {\r\n    var $$ = this\r\n    targetIds = $$.mapToTargetIds(targetIds)\r\n    $$.legend\r\n      .selectAll('.' + CLASS.legendItem)\r\n      .filter(function (id) {\r\n        return targetIds.indexOf(id) >= 0\r\n      })\r\n      .classed(CLASS.legendItemFocused, focus)\r\n      .transition()\r\n      .duration(100)\r\n      .style('opacity', function () {\r\n        var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend\r\n        return opacity.call($$, $$.d3.select(this))\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.revertLegend = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3\r\n    $$.legend\r\n      .selectAll('.' + CLASS.legendItem)\r\n      .classed(CLASS.legendItemFocused, false)\r\n      .transition()\r\n      .duration(100)\r\n      .style('opacity', function () {\r\n        return $$.opacityForLegend(d3.select(this))\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.showLegend = function (targetIds) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if (!config.legend_show) {\r\n      config.legend_show = true\r\n      $$.legend.style('visibility', 'visible')\r\n\r\n      if (!$$.legendHasRendered) {\r\n        $$.updateLegendWithDefaults()\r\n      }\r\n    }\r\n\r\n    $$.removeHiddenLegendIds(targetIds)\r\n    $$.legend\r\n      .selectAll($$.selectorLegends(targetIds))\r\n      .style('visibility', 'visible')\r\n      .transition()\r\n      .style('opacity', function () {\r\n        return $$.opacityForLegend($$.d3.select(this))\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.hideLegend = function (targetIds) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if (config.legend_show && isEmpty(targetIds)) {\r\n      config.legend_show = false\r\n      $$.legend.style('visibility', 'hidden')\r\n    }\r\n\r\n    $$.addHiddenLegendIds(targetIds)\r\n    $$.legend\r\n      .selectAll($$.selectorLegends(targetIds))\r\n      .style('opacity', 0)\r\n      .style('visibility', 'hidden')\r\n  }\r\n\r\n  ChartInternal.prototype.clearLegendItemTextBoxCache = function () {\r\n    this.legendItemTextBox = {}\r\n  }\r\n\r\n  ChartInternal.prototype.updateLegend = function (targetIds, options, transitions) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    var xForLegend,\r\n      xForLegendText,\r\n      xForLegendRect,\r\n      yForLegend,\r\n      yForLegendText,\r\n      yForLegendRect,\r\n      x1ForLegendTile,\r\n      x2ForLegendTile,\r\n      yForLegendTile\r\n    var paddingTop = 4,\r\n      paddingRight = 10,\r\n      maxWidth = 0,\r\n      maxHeight = 0,\r\n      posMin = 10,\r\n      tileWidth = config.legend_item_tile_width + 5\r\n    var l,\r\n      totalLength = 0,\r\n      offsets = {},\r\n      widths = {},\r\n      heights = {},\r\n      margins = [0],\r\n      steps = {},\r\n      step = 0\r\n    var withTransition, withTransitionForTransform\r\n    var texts, rects, tiles, background // Skip elements when their name is set to null\r\n\r\n    targetIds = targetIds.filter(function (id) {\r\n      return !isDefined(config.data_names[id]) || config.data_names[id] !== null\r\n    })\r\n    options = options || {}\r\n    withTransition = getOption(options, 'withTransition', true)\r\n    withTransitionForTransform = getOption(options, 'withTransitionForTransform', true)\r\n\r\n    function getTextBox (textElement, id) {\r\n      if (!$$.legendItemTextBox[id]) {\r\n        $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement)\r\n      }\r\n\r\n      return $$.legendItemTextBox[id]\r\n    }\r\n\r\n    function updatePositions (textElement, id, index) {\r\n      var reset = index === 0,\r\n        isLast = index === targetIds.length - 1,\r\n        box = getTextBox(textElement, id),\r\n        itemWidth =\r\n          box.width +\r\n          tileWidth +\r\n          (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) +\r\n          config.legend_padding,\r\n        itemHeight = box.height + paddingTop,\r\n        itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,\r\n        areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),\r\n        margin,\r\n        maxLength // MEMO: care about condifion of step, totalLength\r\n\r\n      function updateValues (id, withoutStep) {\r\n        if (!withoutStep) {\r\n          margin = (areaLength - totalLength - itemLength) / 2\r\n\r\n          if (margin < posMin) {\r\n            margin = (areaLength - itemLength) / 2\r\n            totalLength = 0\r\n            step++\r\n          }\r\n        }\r\n\r\n        steps[id] = step\r\n        margins[step] = $$.isLegendInset ? 10 : margin\r\n        offsets[id] = totalLength\r\n        totalLength += itemLength\r\n      }\r\n\r\n      if (reset) {\r\n        totalLength = 0\r\n        step = 0\r\n        maxWidth = 0\r\n        maxHeight = 0\r\n      }\r\n\r\n      if (config.legend_show && !$$.isLegendToShow(id)) {\r\n        widths[id] = heights[id] = steps[id] = offsets[id] = 0\r\n        return\r\n      }\r\n\r\n      widths[id] = itemWidth\r\n      heights[id] = itemHeight\r\n\r\n      if (!maxWidth || itemWidth >= maxWidth) {\r\n        maxWidth = itemWidth\r\n      }\r\n\r\n      if (!maxHeight || itemHeight >= maxHeight) {\r\n        maxHeight = itemHeight\r\n      }\r\n\r\n      maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth\r\n\r\n      if (config.legend_equally) {\r\n        Object.keys(widths).forEach(function (id) {\r\n          widths[id] = maxWidth\r\n        })\r\n        Object.keys(heights).forEach(function (id) {\r\n          heights[id] = maxHeight\r\n        })\r\n        margin = (areaLength - maxLength * targetIds.length) / 2\r\n\r\n        if (margin < posMin) {\r\n          totalLength = 0\r\n          step = 0\r\n          targetIds.forEach(function (id) {\r\n            updateValues(id)\r\n          })\r\n        } else {\r\n          updateValues(id, true)\r\n        }\r\n      } else {\r\n        updateValues(id)\r\n      }\r\n    }\r\n\r\n    if ($$.isLegendInset) {\r\n      step = config.legend_inset_step ? config.legend_inset_step : targetIds.length\r\n      $$.updateLegendStep(step)\r\n    }\r\n\r\n    if ($$.isLegendRight) {\r\n      xForLegend = function xForLegend (id) {\r\n        return maxWidth * steps[id]\r\n      }\r\n\r\n      yForLegend = function yForLegend (id) {\r\n        return margins[steps[id]] + offsets[id]\r\n      }\r\n    } else if ($$.isLegendInset) {\r\n      xForLegend = function xForLegend (id) {\r\n        return maxWidth * steps[id] + 10\r\n      }\r\n\r\n      yForLegend = function yForLegend (id) {\r\n        return margins[steps[id]] + offsets[id]\r\n      }\r\n    } else {\r\n      xForLegend = function xForLegend (id) {\r\n        return margins[steps[id]] + offsets[id]\r\n      }\r\n\r\n      yForLegend = function yForLegend (id) {\r\n        return maxHeight * steps[id]\r\n      }\r\n    }\r\n\r\n    xForLegendText = function xForLegendText (id, i) {\r\n      return xForLegend(id, i) + 4 + config.legend_item_tile_width\r\n    }\r\n\r\n    yForLegendText = function yForLegendText (id, i) {\r\n      return yForLegend(id, i) + 9\r\n    }\r\n\r\n    xForLegendRect = function xForLegendRect (id, i) {\r\n      return xForLegend(id, i)\r\n    }\r\n\r\n    yForLegendRect = function yForLegendRect (id, i) {\r\n      return yForLegend(id, i) - 5\r\n    }\r\n\r\n    x1ForLegendTile = function x1ForLegendTile (id, i) {\r\n      return xForLegend(id, i) - 2\r\n    }\r\n\r\n    x2ForLegendTile = function x2ForLegendTile (id, i) {\r\n      return xForLegend(id, i) - 2 + config.legend_item_tile_width\r\n    }\r\n\r\n    yForLegendTile = function yForLegendTile (id, i) {\r\n      return yForLegend(id, i) + 4\r\n    } // Define g for legend area\r\n\r\n    l = $$.legend\r\n      .selectAll('.' + CLASS.legendItem)\r\n      .data(targetIds)\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', function (id) {\r\n        return $$.generateClass(CLASS.legendItem, id)\r\n      })\r\n      .style('visibility', function (id) {\r\n        return $$.isLegendToShow(id) ? 'visible' : 'hidden'\r\n      })\r\n      .style('cursor', 'pointer')\r\n      .on('click', function (id) {\r\n        if (config.legend_item_onclick) {\r\n          config.legend_item_onclick.call($$, id)\r\n        } else {\r\n          if ($$.d3.event.altKey) {\r\n            $$.api.hide()\r\n            $$.api.show(id)\r\n          } else {\r\n            $$.api.toggle(id)\r\n            $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert()\r\n          }\r\n        }\r\n      })\r\n      .on('mouseover', function (id) {\r\n        if (config.legend_item_onmouseover) {\r\n          config.legend_item_onmouseover.call($$, id)\r\n        } else {\r\n          $$.d3.select(this).classed(CLASS.legendItemFocused, true)\r\n\r\n          if (!$$.transiting && $$.isTargetToShow(id)) {\r\n            $$.api.focus(id)\r\n          }\r\n        }\r\n      })\r\n      .on('mouseout', function (id) {\r\n        if (config.legend_item_onmouseout) {\r\n          config.legend_item_onmouseout.call($$, id)\r\n        } else {\r\n          $$.d3.select(this).classed(CLASS.legendItemFocused, false)\r\n          $$.api.revert()\r\n        }\r\n      })\r\n    l.append('text')\r\n      .text(function (id) {\r\n        return isDefined(config.data_names[id]) ? config.data_names[id] : id\r\n      })\r\n      .each(function (id, i) {\r\n        updatePositions(this, id, i)\r\n      })\r\n      .style('pointer-events', 'none')\r\n      .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200)\r\n      .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText)\r\n    l.append('rect')\r\n      .attr('class', CLASS.legendItemEvent)\r\n      .style('fill-opacity', 0)\r\n      .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200)\r\n      .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect)\r\n    l.append('line')\r\n      .attr('class', CLASS.legendItemTile)\r\n      .style('stroke', $$.color)\r\n      .style('pointer-events', 'none')\r\n      .attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200)\r\n      .attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)\r\n      .attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200)\r\n      .attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)\r\n      .attr('stroke-width', config.legend_item_tile_height) // Set background for inset legend\r\n\r\n    background = $$.legend.select('.' + CLASS.legendBackground + ' rect')\r\n\r\n    if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {\r\n      background = $$.legend\r\n        .insert('g', '.' + CLASS.legendItem)\r\n        .attr('class', CLASS.legendBackground)\r\n        .append('rect')\r\n    }\r\n\r\n    texts = $$.legend\r\n      .selectAll('text')\r\n      .data(targetIds)\r\n      .text(function (id) {\r\n        return isDefined(config.data_names[id]) ? config.data_names[id] : id\r\n      }) // MEMO: needed for update\r\n      .each(function (id, i) {\r\n        updatePositions(this, id, i)\r\n      })\r\n    ;(withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText)\r\n    rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds)\r\n    ;(withTransition ? rects.transition() : rects)\r\n      .attr('width', function (id) {\r\n        return widths[id]\r\n      })\r\n      .attr('height', function (id) {\r\n        return heights[id]\r\n      })\r\n      .attr('x', xForLegendRect)\r\n      .attr('y', yForLegendRect)\r\n    tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds)\r\n    ;(withTransition ? tiles.transition() : tiles)\r\n      .style(\r\n        'stroke',\r\n        $$.levelColor\r\n          ? function (id) {\r\n              return $$.levelColor($$.cache[id].values[0].value)\r\n            }\r\n          : $$.color\r\n      )\r\n      .attr('x1', x1ForLegendTile)\r\n      .attr('y1', yForLegendTile)\r\n      .attr('x2', x2ForLegendTile)\r\n      .attr('y2', yForLegendTile)\r\n\r\n    if (background) {\r\n      ;(withTransition ? background.transition() : background)\r\n        .attr('height', $$.getLegendHeight() - 12)\r\n        .attr('width', maxWidth * (step + 1) + 10)\r\n    } // toggle legend state\r\n\r\n    $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function (id) {\r\n      return !$$.isTargetToShow(id)\r\n    }) // Update all to reflect change of legend\r\n\r\n    $$.updateLegendItemWidth(maxWidth)\r\n    $$.updateLegendItemHeight(maxHeight)\r\n    $$.updateLegendStep(step) // Update size and scale\r\n\r\n    $$.updateSizes()\r\n    $$.updateScales()\r\n    $$.updateSvgSize() // Update g positions\r\n\r\n    $$.transformAll(withTransitionForTransform, transitions)\r\n    $$.legendHasRendered = true\r\n  }\r\n\r\n  ChartInternal.prototype.initRegion = function () {\r\n    var $$ = this\r\n    $$.region = $$.main\r\n      .append('g')\r\n      .attr('clip-path', $$.clipPath)\r\n      .attr('class', CLASS.regions)\r\n  }\r\n\r\n  ChartInternal.prototype.updateRegion = function (duration) {\r\n    var $$ = this,\r\n      config = $$.config // hide if arc type\r\n\r\n    $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible')\r\n    var mainRegion = $$.main\r\n      .select('.' + CLASS.regions)\r\n      .selectAll('.' + CLASS.region)\r\n      .data(config.regions)\r\n    var mainRegionEnter = mainRegion\r\n      .enter()\r\n      .append('rect')\r\n      .attr('x', $$.regionX.bind($$))\r\n      .attr('y', $$.regionY.bind($$))\r\n      .attr('width', $$.regionWidth.bind($$))\r\n      .attr('height', $$.regionHeight.bind($$))\r\n      .style('fill-opacity', 0)\r\n    $$.mainRegion = mainRegionEnter.merge(mainRegion).attr('class', $$.classRegion.bind($$))\r\n    mainRegion\r\n      .exit()\r\n      .transition()\r\n      .duration(duration)\r\n      .style('opacity', 0)\r\n      .remove()\r\n  }\r\n\r\n  ChartInternal.prototype.redrawRegion = function (withTransition, transition) {\r\n    var $$ = this,\r\n      regions = $$.mainRegion\r\n    return [\r\n      (withTransition ? regions.transition(transition) : regions)\r\n        .attr('x', $$.regionX.bind($$))\r\n        .attr('y', $$.regionY.bind($$))\r\n        .attr('width', $$.regionWidth.bind($$))\r\n        .attr('height', $$.regionHeight.bind($$))\r\n        .style('fill-opacity', function (d) {\r\n          return isValue(d.opacity) ? d.opacity : 0.1\r\n        })\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.regionX = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      xPos,\r\n      yScale = d.axis === 'y' ? $$.y : $$.y2\r\n\r\n    if (d.axis === 'y' || d.axis === 'y2') {\r\n      xPos = config.axis_rotated ? ('start' in d ? yScale(d.start) : 0) : 0\r\n    } else {\r\n      xPos = config.axis_rotated ? 0 : 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0\r\n    }\r\n\r\n    return xPos\r\n  }\r\n\r\n  ChartInternal.prototype.regionY = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      yPos,\r\n      yScale = d.axis === 'y' ? $$.y : $$.y2\r\n\r\n    if (d.axis === 'y' || d.axis === 'y2') {\r\n      yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0\r\n    } else {\r\n      yPos = config.axis_rotated ? ('start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0) : 0\r\n    }\r\n\r\n    return yPos\r\n  }\r\n\r\n  ChartInternal.prototype.regionWidth = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      start = $$.regionX(d),\r\n      end,\r\n      yScale = d.axis === 'y' ? $$.y : $$.y2\r\n\r\n    if (d.axis === 'y' || d.axis === 'y2') {\r\n      end = config.axis_rotated ? ('end' in d ? yScale(d.end) : $$.width) : $$.width\r\n    } else {\r\n      end = config.axis_rotated\r\n        ? $$.width\r\n        : 'end' in d\r\n        ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)\r\n        : $$.width\r\n    }\r\n\r\n    return end < start ? 0 : end - start\r\n  }\r\n\r\n  ChartInternal.prototype.regionHeight = function (d) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      start = this.regionY(d),\r\n      end,\r\n      yScale = d.axis === 'y' ? $$.y : $$.y2\r\n\r\n    if (d.axis === 'y' || d.axis === 'y2') {\r\n      end = config.axis_rotated ? $$.height : 'start' in d ? yScale(d.start) : $$.height\r\n    } else {\r\n      end = config.axis_rotated\r\n        ? 'end' in d\r\n          ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)\r\n          : $$.height\r\n        : $$.height\r\n    }\r\n\r\n    return end < start ? 0 : end - start\r\n  }\r\n\r\n  ChartInternal.prototype.isRegionOnX = function (d) {\r\n    return !d.axis || d.axis === 'x'\r\n  }\r\n\r\n  ChartInternal.prototype.getScale = function (min, max, forTimeseries) {\r\n    return (forTimeseries ? this.d3.scaleTime() : this.d3.scaleLinear()).range([min, max])\r\n  }\r\n\r\n  ChartInternal.prototype.getX = function (min, max, domain, offset) {\r\n    var $$ = this,\r\n      scale = $$.getScale(min, max, $$.isTimeSeries()),\r\n      _scale = domain ? scale.domain(domain) : scale,\r\n      key // Define customized scale if categorized axis\r\n\r\n    if ($$.isCategorized()) {\r\n      offset =\r\n        offset ||\r\n        function () {\r\n          return 0\r\n        }\r\n\r\n      scale = function scale (d, raw) {\r\n        var v = _scale(d) + offset(d)\r\n        return raw ? v : Math.ceil(v)\r\n      }\r\n    } else {\r\n      scale = function scale (d, raw) {\r\n        var v = _scale(d)\r\n\r\n        return raw ? v : Math.ceil(v)\r\n      }\r\n    } // define functions\r\n\r\n    for (key in _scale) {\r\n      scale[key] = _scale[key]\r\n    }\r\n\r\n    scale.orgDomain = function () {\r\n      return _scale.domain()\r\n    } // define custom domain() for categorized axis\r\n\r\n    if ($$.isCategorized()) {\r\n      scale.domain = function (domain) {\r\n        if (!arguments.length) {\r\n          domain = this.orgDomain()\r\n          return [domain[0], domain[1] + 1]\r\n        }\r\n\r\n        _scale.domain(domain)\r\n\r\n        return scale\r\n      }\r\n    }\r\n\r\n    return scale\r\n  }\r\n\r\n  ChartInternal.prototype.getY = function (min, max, domain) {\r\n    var scale = this.getScale(min, max, this.isTimeSeriesY())\r\n\r\n    if (domain) {\r\n      scale.domain(domain)\r\n    }\r\n\r\n    return scale\r\n  }\r\n\r\n  ChartInternal.prototype.getYScale = function (id) {\r\n    return this.axis.getId(id) === 'y2' ? this.y2 : this.y\r\n  }\r\n\r\n  ChartInternal.prototype.getSubYScale = function (id) {\r\n    return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY\r\n  }\r\n\r\n  ChartInternal.prototype.updateScales = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      forInit = !$$.x // update edges\r\n\r\n    $$.xMin = config.axis_rotated ? 1 : 0\r\n    $$.xMax = config.axis_rotated ? $$.height : $$.width\r\n    $$.yMin = config.axis_rotated ? 0 : $$.height\r\n    $$.yMax = config.axis_rotated ? $$.width : 1\r\n    $$.subXMin = $$.xMin\r\n    $$.subXMax = $$.xMax\r\n    $$.subYMin = config.axis_rotated ? 0 : $$.height2\r\n    $$.subYMax = config.axis_rotated ? $$.width2 : 1 // update scales\r\n\r\n    $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {\r\n      return $$.xAxis.tickOffset()\r\n    })\r\n    $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain())\r\n    $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain())\r\n    $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {\r\n      return d % 1 ? 0 : $$.subXAxis.tickOffset()\r\n    })\r\n    $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain())\r\n    $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain()) // update axes\r\n\r\n    $$.xAxisTickFormat = $$.axis.getXAxisTickFormat()\r\n    $$.xAxisTickValues = $$.axis.getXAxisTickValues()\r\n    $$.yAxisTickValues = $$.axis.getYAxisTickValues()\r\n    $$.y2AxisTickValues = $$.axis.getY2AxisTickValues()\r\n    $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer)\r\n    $$.subXAxis = $$.axis.getXAxis(\r\n      $$.subX,\r\n      $$.subXOrient,\r\n      $$.xAxisTickFormat,\r\n      $$.xAxisTickValues,\r\n      config.axis_x_tick_outer\r\n    )\r\n    $$.yAxis = $$.axis.getYAxis(\r\n      $$.y,\r\n      $$.yOrient,\r\n      config.axis_y_tick_format,\r\n      $$.yAxisTickValues,\r\n      config.axis_y_tick_outer\r\n    )\r\n    $$.y2Axis = $$.axis.getYAxis(\r\n      $$.y2,\r\n      $$.y2Orient,\r\n      config.axis_y2_tick_format,\r\n      $$.y2AxisTickValues,\r\n      config.axis_y2_tick_outer\r\n    ) // Set initialized scales to brush and zoom\r\n\r\n    if (!forInit) {\r\n      if ($$.brush) {\r\n        $$.brush.updateScale($$.subX)\r\n      }\r\n    } // update for arc\r\n\r\n    if ($$.updateArc) {\r\n      $$.updateArc()\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.selectPoint = function (target, d, i) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),\r\n      cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),\r\n      r = $$.pointSelectR.bind($$)\r\n    config.data_onselected.call($$.api, d, target.node()) // add selected-circle on low layer g\r\n\r\n    $$.main\r\n      .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))\r\n      .selectAll('.' + CLASS.selectedCircle + '-' + i)\r\n      .data([d])\r\n      .enter()\r\n      .append('circle')\r\n      .attr('class', function () {\r\n        return $$.generateClass(CLASS.selectedCircle, i)\r\n      })\r\n      .attr('cx', cx)\r\n      .attr('cy', cy)\r\n      .attr('stroke', function () {\r\n        return $$.color(d)\r\n      })\r\n      .attr('r', function (d) {\r\n        return $$.pointSelectR(d) * 1.4\r\n      })\r\n      .transition()\r\n      .duration(100)\r\n      .attr('r', r)\r\n  }\r\n\r\n  ChartInternal.prototype.unselectPoint = function (target, d, i) {\r\n    var $$ = this\r\n    $$.config.data_onunselected.call($$.api, d, target.node()) // remove selected-circle from low layer g\r\n\r\n    $$.main\r\n      .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))\r\n      .selectAll('.' + CLASS.selectedCircle + '-' + i)\r\n      .transition()\r\n      .duration(100)\r\n      .attr('r', 0)\r\n      .remove()\r\n  }\r\n\r\n  ChartInternal.prototype.togglePoint = function (selected, target, d, i) {\r\n    selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i)\r\n  }\r\n\r\n  ChartInternal.prototype.selectPath = function (target, d) {\r\n    var $$ = this\r\n    $$.config.data_onselected.call($$, d, target.node())\r\n\r\n    if ($$.config.interaction_brighten) {\r\n      target\r\n        .transition()\r\n        .duration(100)\r\n        .style('fill', function () {\r\n          return $$.d3.rgb($$.color(d)).brighter(0.75)\r\n        })\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.unselectPath = function (target, d) {\r\n    var $$ = this\r\n    $$.config.data_onunselected.call($$, d, target.node())\r\n\r\n    if ($$.config.interaction_brighten) {\r\n      target\r\n        .transition()\r\n        .duration(100)\r\n        .style('fill', function () {\r\n          return $$.color(d)\r\n        })\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.togglePath = function (selected, target, d, i) {\r\n    selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i)\r\n  }\r\n\r\n  ChartInternal.prototype.getToggle = function (that, d) {\r\n    var $$ = this,\r\n      toggle\r\n\r\n    if (that.nodeName === 'circle') {\r\n      if ($$.isStepType(d)) {\r\n        // circle is hidden in step chart, so treat as within the click area\r\n        toggle = function toggle () {} // TODO: how to select step chart?\r\n      } else {\r\n        toggle = $$.togglePoint\r\n      }\r\n    } else if (that.nodeName === 'path') {\r\n      toggle = $$.togglePath\r\n    }\r\n\r\n    return toggle\r\n  }\r\n\r\n  ChartInternal.prototype.toggleShape = function (that, d, i) {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config,\r\n      shape = d3.select(that),\r\n      isSelected = shape.classed(CLASS.SELECTED),\r\n      toggle = $$.getToggle(that, d).bind($$)\r\n\r\n    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {\r\n      if (!config.data_selection_multiple) {\r\n        $$.main\r\n          .selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : ''))\r\n          .selectAll('.' + CLASS.shape)\r\n          .each(function (d, i) {\r\n            var shape = d3.select(this)\r\n\r\n            if (shape.classed(CLASS.SELECTED)) {\r\n              toggle(false, shape.classed(CLASS.SELECTED, false), d, i)\r\n            }\r\n          })\r\n      }\r\n\r\n      shape.classed(CLASS.SELECTED, !isSelected)\r\n      toggle(!isSelected, shape, d, i)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.initBar = function () {\r\n    var $$ = this\r\n    $$.main\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.chartBars)\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetsForBar = function (targets) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      mainBars,\r\n      mainBarEnter,\r\n      classChartBar = $$.classChartBar.bind($$),\r\n      classBars = $$.classBars.bind($$),\r\n      classFocus = $$.classFocus.bind($$)\r\n    mainBars = $$.main\r\n      .select('.' + CLASS.chartBars)\r\n      .selectAll('.' + CLASS.chartBar)\r\n      .data(targets)\r\n      .attr('class', function (d) {\r\n        return classChartBar(d) + classFocus(d)\r\n      })\r\n    mainBarEnter = mainBars\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', classChartBar)\r\n      .style('pointer-events', 'none') // Bars for each data\r\n\r\n    mainBarEnter\r\n      .append('g')\r\n      .attr('class', classBars)\r\n      .style('cursor', function (d) {\r\n        return config.data_selection_isselectable(d) ? 'pointer' : null\r\n      })\r\n  }\r\n\r\n  ChartInternal.prototype.updateBar = function (durationForExit) {\r\n    var $$ = this,\r\n      barData = $$.barData.bind($$),\r\n      classBar = $$.classBar.bind($$),\r\n      initialOpacity = $$.initialOpacity.bind($$),\r\n      color = function color (d) {\r\n        return $$.color(d.id)\r\n      }\r\n\r\n    var mainBar = $$.main\r\n      .selectAll('.' + CLASS.bars)\r\n      .selectAll('.' + CLASS.bar)\r\n      .data(barData)\r\n    var mainBarEnter = mainBar\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', classBar)\r\n      .style('stroke', color)\r\n      .style('fill', color)\r\n    $$.mainBar = mainBarEnter.merge(mainBar).style('opacity', initialOpacity)\r\n    mainBar\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawBar = function (drawBar, withTransition, transition) {\r\n    return [\r\n      (withTransition ? this.mainBar.transition(transition) : this.mainBar)\r\n        .attr('d', drawBar)\r\n        .style('stroke', this.color)\r\n        .style('fill', this.color)\r\n        .style('opacity', 1)\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.getBarW = function (axis, barTargetsNum) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      w =\r\n        typeof config.bar_width === 'number'\r\n          ? config.bar_width\r\n          : barTargetsNum\r\n          ? (axis.tickInterval() * config.bar_width_ratio) / barTargetsNum\r\n          : 0\r\n    return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w\r\n  }\r\n\r\n  ChartInternal.prototype.getBars = function (i, id) {\r\n    var $$ = this\r\n    return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll(\r\n      '.' + CLASS.bar + (isValue(i) ? '-' + i : '')\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.expandBars = function (i, id, reset) {\r\n    var $$ = this\r\n\r\n    if (reset) {\r\n      $$.unexpandBars()\r\n    }\r\n\r\n    $$.getBars(i, id).classed(CLASS.EXPANDED, true)\r\n  }\r\n\r\n  ChartInternal.prototype.unexpandBars = function (i) {\r\n    var $$ = this\r\n    $$.getBars(i).classed(CLASS.EXPANDED, false)\r\n  }\r\n\r\n  ChartInternal.prototype.generateDrawBar = function (barIndices, isSub) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      getPoints = $$.generateGetBarPoints(barIndices, isSub)\r\n    return function (d, i) {\r\n      // 4 points that make a bar\r\n      var points = getPoints(d, i) // switch points if axis is rotated, not applicable for sub chart\r\n\r\n      var indexX = config.axis_rotated ? 1 : 0\r\n      var indexY = config.axis_rotated ? 0 : 1\r\n      var path =\r\n        'M ' +\r\n        points[0][indexX] +\r\n        ',' +\r\n        points[0][indexY] +\r\n        ' ' +\r\n        'L' +\r\n        points[1][indexX] +\r\n        ',' +\r\n        points[1][indexY] +\r\n        ' ' +\r\n        'L' +\r\n        points[2][indexX] +\r\n        ',' +\r\n        points[2][indexY] +\r\n        ' ' +\r\n        'L' +\r\n        points[3][indexX] +\r\n        ',' +\r\n        points[3][indexY] +\r\n        ' ' +\r\n        'z'\r\n      return path\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.generateGetBarPoints = function (barIndices, isSub) {\r\n    var $$ = this,\r\n      axis = isSub ? $$.subXAxis : $$.xAxis,\r\n      barTargetsNum = barIndices.__max__ + 1,\r\n      barW = $$.getBarW(axis, barTargetsNum),\r\n      barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),\r\n      barY = $$.getShapeY(!!isSub),\r\n      barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),\r\n      barSpaceOffset = barW * ($$.config.bar_space / 2),\r\n      yScale = isSub ? $$.getSubYScale : $$.getYScale\r\n    return function (d, i) {\r\n      var y0 = yScale.call($$, d.id)(0),\r\n        offset = barOffset(d, i) || y0,\r\n        // offset is for stacked bar chart\r\n        posX = barX(d),\r\n        posY = barY(d) // fix posY not to overflow opposite quadrant\r\n\r\n      if ($$.config.axis_rotated) {\r\n        if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {\r\n          posY = y0\r\n        }\r\n      } // 4 points that make a bar\r\n\r\n      return [\r\n        [posX + barSpaceOffset, offset],\r\n        [posX + barSpaceOffset, posY - (y0 - offset)],\r\n        [posX + barW - barSpaceOffset, posY - (y0 - offset)],\r\n        [posX + barW - barSpaceOffset, offset]\r\n      ]\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.isWithinBar = function (mouse, that) {\r\n    var box = that.getBoundingClientRect(),\r\n      seg0 = that.pathSegList.getItem(0),\r\n      seg1 = that.pathSegList.getItem(1),\r\n      x = Math.min(seg0.x, seg1.x),\r\n      y = Math.min(seg0.y, seg1.y),\r\n      w = box.width,\r\n      h = box.height,\r\n      offset = 2,\r\n      sx = x - offset,\r\n      ex = x + w + offset,\r\n      sy = y + h + offset,\r\n      ey = y - offset\r\n    return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy\r\n  }\r\n\r\n  ChartInternal.prototype.getShapeIndices = function (typeFilter) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      indices = {},\r\n      i = 0,\r\n      j,\r\n      k\r\n    $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {\r\n      for (j = 0; j < config.data_groups.length; j++) {\r\n        if (config.data_groups[j].indexOf(d.id) < 0) {\r\n          continue\r\n        }\r\n\r\n        for (k = 0; k < config.data_groups[j].length; k++) {\r\n          if (config.data_groups[j][k] in indices) {\r\n            indices[d.id] = indices[config.data_groups[j][k]]\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      if (isUndefined(indices[d.id])) {\r\n        indices[d.id] = i++\r\n      }\r\n    })\r\n    indices.__max__ = i - 1\r\n    return indices\r\n  }\r\n\r\n  ChartInternal.prototype.getShapeX = function (offset, targetsNum, indices, isSub) {\r\n    var $$ = this,\r\n      scale = isSub ? $$.subX : $$.x\r\n    return function (d) {\r\n      var index = d.id in indices ? indices[d.id] : 0\r\n      return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getShapeY = function (isSub) {\r\n    var $$ = this\r\n    return function (d) {\r\n      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id)\r\n      return scale(d.value)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getShapeOffset = function (typeFilter, indices, isSub) {\r\n    var $$ = this,\r\n      targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),\r\n      targetIds = targets.map(function (t) {\r\n        return t.id\r\n      })\r\n    return function (d, i) {\r\n      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),\r\n        y0 = scale(0),\r\n        offset = y0\r\n      targets.forEach(function (t) {\r\n        var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values\r\n\r\n        if (t.id === d.id || indices[t.id] !== indices[d.id]) {\r\n          return\r\n        }\r\n\r\n        if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {\r\n          // check if the x values line up\r\n          if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {\r\n            // \"+\" for timeseries\r\n            // if not, try to find the value that does line up\r\n            i = -1\r\n            values.forEach(function (v, j) {\r\n              if (v.x === d.x) {\r\n                i = j\r\n              }\r\n            })\r\n          }\r\n\r\n          if (i in values && values[i].value * d.value >= 0) {\r\n            offset += scale(values[i].value) - y0\r\n          }\r\n        }\r\n      })\r\n      return offset\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.isWithinShape = function (that, d) {\r\n    var $$ = this,\r\n      shape = $$.d3.select(that),\r\n      isWithin\r\n\r\n    if (!$$.isTargetToShow(d.id)) {\r\n      isWithin = false\r\n    } else if (that.nodeName === 'circle') {\r\n      isWithin = $$.isStepType(d)\r\n        ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value))\r\n        : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5)\r\n    } else if (that.nodeName === 'path') {\r\n      isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar($$.d3.mouse(that), that) : true\r\n    }\r\n\r\n    return isWithin\r\n  }\r\n\r\n  ChartInternal.prototype.getInterpolate = function (d) {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      types = {\r\n        linear: d3.curveLinear,\r\n        'linear-closed': d3.curveLinearClosed,\r\n        basis: d3.curveBasis,\r\n        'basis-open': d3.curveBasisOpen,\r\n        'basis-closed': d3.curveBasisClosed,\r\n        bundle: d3.curveBundle,\r\n        cardinal: d3.curveCardinal,\r\n        'cardinal-open': d3.curveCardinalOpen,\r\n        'cardinal-closed': d3.curveCardinalClosed,\r\n        monotone: d3.curveMonotoneX,\r\n        step: d3.curveStep,\r\n        'step-before': d3.curveStepBefore,\r\n        'step-after': d3.curveStepAfter\r\n      },\r\n      type\r\n\r\n    if ($$.isSplineType(d)) {\r\n      type = types[$$.config.spline_interpolation_type] || types.cardinal\r\n    } else if ($$.isStepType(d)) {\r\n      type = types[$$.config.line_step_type]\r\n    } else {\r\n      type = types.linear\r\n    }\r\n\r\n    return type\r\n  }\r\n\r\n  ChartInternal.prototype.initLine = function () {\r\n    var $$ = this\r\n    $$.main\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.chartLines)\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetsForLine = function (targets) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      mainLines,\r\n      mainLineEnter,\r\n      classChartLine = $$.classChartLine.bind($$),\r\n      classLines = $$.classLines.bind($$),\r\n      classAreas = $$.classAreas.bind($$),\r\n      classCircles = $$.classCircles.bind($$),\r\n      classFocus = $$.classFocus.bind($$)\r\n    mainLines = $$.main\r\n      .select('.' + CLASS.chartLines)\r\n      .selectAll('.' + CLASS.chartLine)\r\n      .data(targets)\r\n      .attr('class', function (d) {\r\n        return classChartLine(d) + classFocus(d)\r\n      })\r\n    mainLineEnter = mainLines\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', classChartLine)\r\n      .style('opacity', 0)\r\n      .style('pointer-events', 'none') // Lines for each data\r\n\r\n    mainLineEnter.append('g').attr('class', classLines) // Areas\r\n\r\n    mainLineEnter.append('g').attr('class', classAreas) // Circles for each data point on lines\r\n\r\n    mainLineEnter.append('g').attr('class', function (d) {\r\n      return $$.generateClass(CLASS.selectedCircles, d.id)\r\n    })\r\n    mainLineEnter\r\n      .append('g')\r\n      .attr('class', classCircles)\r\n      .style('cursor', function (d) {\r\n        return config.data_selection_isselectable(d) ? 'pointer' : null\r\n      }) // Update date for selected circles\r\n\r\n    targets.forEach(function (t) {\r\n      $$.main\r\n        .selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id))\r\n        .selectAll('.' + CLASS.selectedCircle)\r\n        .each(function (d) {\r\n          d.value = t.values[d.index].value\r\n        })\r\n    }) // MEMO: can not keep same color...\r\n    //mainLineUpdate.exit().remove();\r\n  }\r\n\r\n  ChartInternal.prototype.updateLine = function (durationForExit) {\r\n    var $$ = this\r\n    var mainLine = $$.main\r\n      .selectAll('.' + CLASS.lines)\r\n      .selectAll('.' + CLASS.line)\r\n      .data($$.lineData.bind($$))\r\n    var mainLineEnter = mainLine\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', $$.classLine.bind($$))\r\n      .style('stroke', $$.color)\r\n    $$.mainLine = mainLineEnter\r\n      .merge(mainLine)\r\n      .style('opacity', $$.initialOpacity.bind($$))\r\n      .style('shape-rendering', function (d) {\r\n        return $$.isStepType(d) ? 'crispEdges' : ''\r\n      })\r\n      .attr('transform', null)\r\n    mainLine\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawLine = function (drawLine, withTransition, transition) {\r\n    return [\r\n      (withTransition ? this.mainLine.transition(transition) : this.mainLine)\r\n        .attr('d', drawLine)\r\n        .style('stroke', this.color)\r\n        .style('opacity', 1)\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.generateDrawLine = function (lineIndices, isSub) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      line = $$.d3.line(),\r\n      getPoints = $$.generateGetLinePoints(lineIndices, isSub),\r\n      yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,\r\n      xValue = function xValue (d) {\r\n        return (isSub ? $$.subxx : $$.xx).call($$, d)\r\n      },\r\n      yValue = function yValue (d, i) {\r\n        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value)\r\n      }\r\n\r\n    line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue)\r\n\r\n    if (!config.line_connectNull) {\r\n      line = line.defined(function (d) {\r\n        return d.value != null\r\n      })\r\n    }\r\n\r\n    return function (d) {\r\n      var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,\r\n        x = isSub ? $$.subX : $$.x,\r\n        y = yScaleGetter.call($$, d.id),\r\n        x0 = 0,\r\n        y0 = 0,\r\n        path\r\n\r\n      if ($$.isLineType(d)) {\r\n        if (config.data_regions[d.id]) {\r\n          path = $$.lineWithRegions(values, x, y, config.data_regions[d.id])\r\n        } else {\r\n          if ($$.isStepType(d)) {\r\n            values = $$.convertValuesToStep(values)\r\n          }\r\n\r\n          path = line.curve($$.getInterpolate(d))(values)\r\n        }\r\n      } else {\r\n        if (values[0]) {\r\n          x0 = x(values[0].x)\r\n          y0 = y(values[0].value)\r\n        }\r\n\r\n        path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0\r\n      }\r\n\r\n      return path ? path : 'M 0 0'\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.generateGetLinePoints = function (lineIndices, isSub) {\r\n    // partial duplication of generateGetBarPoints\r\n    var $$ = this,\r\n      config = $$.config,\r\n      lineTargetsNum = lineIndices.__max__ + 1,\r\n      x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),\r\n      y = $$.getShapeY(!!isSub),\r\n      lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),\r\n      yScale = isSub ? $$.getSubYScale : $$.getYScale\r\n    return function (d, i) {\r\n      var y0 = yScale.call($$, d.id)(0),\r\n        offset = lineOffset(d, i) || y0,\r\n        // offset is for stacked area chart\r\n        posX = x(d),\r\n        posY = y(d) // fix posY not to overflow opposite quadrant\r\n\r\n      if (config.axis_rotated) {\r\n        if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {\r\n          posY = y0\r\n        }\r\n      } // 1 point that marks the line position\r\n\r\n      return [\r\n        [posX, posY - (y0 - offset)],\r\n        [posX, posY - (y0 - offset)], // needed for compatibility\r\n        [posX, posY - (y0 - offset)], // needed for compatibility\r\n        [posX, posY - (y0 - offset)] // needed for compatibility\r\n      ]\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.lineWithRegions = function (d, x, y, _regions) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      prev = -1,\r\n      i,\r\n      j,\r\n      s = 'M',\r\n      sWithRegion,\r\n      xp,\r\n      yp,\r\n      dx,\r\n      dy,\r\n      dd,\r\n      diff,\r\n      diffx2,\r\n      xOffset = $$.isCategorized() ? 0.5 : 0,\r\n      xValue,\r\n      yValue,\r\n      regions = []\r\n\r\n    function isWithinRegions (x, regions) {\r\n      var i\r\n\r\n      for (i = 0; i < regions.length; i++) {\r\n        if (regions[i].start < x && x <= regions[i].end) {\r\n          return true\r\n        }\r\n      }\r\n\r\n      return false\r\n    } // Check start/end of regions\r\n\r\n    if (isDefined(_regions)) {\r\n      for (i = 0; i < _regions.length; i++) {\r\n        regions[i] = {}\r\n\r\n        if (isUndefined(_regions[i].start)) {\r\n          regions[i].start = d[0].x\r\n        } else {\r\n          regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start\r\n        }\r\n\r\n        if (isUndefined(_regions[i].end)) {\r\n          regions[i].end = d[d.length - 1].x\r\n        } else {\r\n          regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end\r\n        }\r\n      }\r\n    } // Set scales\r\n\r\n    xValue = config.axis_rotated\r\n      ? function (d) {\r\n          return y(d.value)\r\n        }\r\n      : function (d) {\r\n          return x(d.x)\r\n        }\r\n    yValue = config.axis_rotated\r\n      ? function (d) {\r\n          return x(d.x)\r\n        }\r\n      : function (d) {\r\n          return y(d.value)\r\n        } // Define svg generator function for region\r\n\r\n    function generateM (points) {\r\n      return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1]\r\n    }\r\n\r\n    if ($$.isTimeSeries()) {\r\n      sWithRegion = function sWithRegion (d0, d1, j, diff) {\r\n        var x0 = d0.x.getTime(),\r\n          x_diff = d1.x - d0.x,\r\n          xv0 = new Date(x0 + x_diff * j),\r\n          xv1 = new Date(x0 + x_diff * (j + diff)),\r\n          points\r\n\r\n        if (config.axis_rotated) {\r\n          points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]]\r\n        } else {\r\n          points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]]\r\n        }\r\n\r\n        return generateM(points)\r\n      }\r\n    } else {\r\n      sWithRegion = function sWithRegion (d0, d1, j, diff) {\r\n        var points\r\n\r\n        if (config.axis_rotated) {\r\n          points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]]\r\n        } else {\r\n          points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]]\r\n        }\r\n\r\n        return generateM(points)\r\n      }\r\n    } // Generate\r\n\r\n    for (i = 0; i < d.length; i++) {\r\n      // Draw as normal\r\n      if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {\r\n        s += ' ' + xValue(d[i]) + ' ' + yValue(d[i])\r\n      } // Draw with region // TODO: Fix for horizotal charts\r\n      else {\r\n        xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries())\r\n        yp = $$.getScale(d[i - 1].value, d[i].value)\r\n        dx = x(d[i].x) - x(d[i - 1].x)\r\n        dy = y(d[i].value) - y(d[i - 1].value)\r\n        dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2))\r\n        diff = 2 / dd\r\n        diffx2 = diff * 2\r\n\r\n        for (j = diff; j <= 1; j += diffx2) {\r\n          s += sWithRegion(d[i - 1], d[i], j, diff)\r\n        }\r\n      }\r\n\r\n      prev = d[i].x\r\n    }\r\n\r\n    return s\r\n  }\r\n\r\n  ChartInternal.prototype.updateArea = function (durationForExit) {\r\n    var $$ = this,\r\n      d3 = $$.d3\r\n    var mainArea = $$.main\r\n      .selectAll('.' + CLASS.areas)\r\n      .selectAll('.' + CLASS.area)\r\n      .data($$.lineData.bind($$))\r\n    var mainAreaEnter = mainArea\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', $$.classArea.bind($$))\r\n      .style('fill', $$.color)\r\n      .style('opacity', function () {\r\n        $$.orgAreaOpacity = +d3.select(this).style('opacity')\r\n        return 0\r\n      })\r\n    $$.mainArea = mainAreaEnter.merge(mainArea).style('opacity', $$.orgAreaOpacity)\r\n    mainArea\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawArea = function (drawArea, withTransition, transition) {\r\n    return [\r\n      (withTransition ? this.mainArea.transition(transition) : this.mainArea)\r\n        .attr('d', drawArea)\r\n        .style('fill', this.color)\r\n        .style('opacity', this.orgAreaOpacity)\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.generateDrawArea = function (areaIndices, isSub) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      area = $$.d3.area(),\r\n      getPoints = $$.generateGetAreaPoints(areaIndices, isSub),\r\n      yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,\r\n      xValue = function xValue (d) {\r\n        return (isSub ? $$.subxx : $$.xx).call($$, d)\r\n      },\r\n      value0 = function value0 (d, i) {\r\n        return config.data_groups.length > 0\r\n          ? getPoints(d, i)[0][1]\r\n          : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id))\r\n      },\r\n      value1 = function value1 (d, i) {\r\n        return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value)\r\n      }\r\n\r\n    area = config.axis_rotated\r\n      ? area\r\n          .x0(value0)\r\n          .x1(value1)\r\n          .y(xValue)\r\n      : area\r\n          .x(xValue)\r\n          .y0(config.area_above ? 0 : value0)\r\n          .y1(value1)\r\n\r\n    if (!config.line_connectNull) {\r\n      area = area.defined(function (d) {\r\n        return d.value !== null\r\n      })\r\n    }\r\n\r\n    return function (d) {\r\n      var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,\r\n        x0 = 0,\r\n        y0 = 0,\r\n        path\r\n\r\n      if ($$.isAreaType(d)) {\r\n        if ($$.isStepType(d)) {\r\n          values = $$.convertValuesToStep(values)\r\n        }\r\n\r\n        path = area.curve($$.getInterpolate(d))(values)\r\n      } else {\r\n        if (values[0]) {\r\n          x0 = $$.x(values[0].x)\r\n          y0 = $$.getYScale(d.id)(values[0].value)\r\n        }\r\n\r\n        path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0\r\n      }\r\n\r\n      return path ? path : 'M 0 0'\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getAreaBaseValue = function () {\r\n    return 0\r\n  }\r\n\r\n  ChartInternal.prototype.generateGetAreaPoints = function (areaIndices, isSub) {\r\n    // partial duplication of generateGetBarPoints\r\n    var $$ = this,\r\n      config = $$.config,\r\n      areaTargetsNum = areaIndices.__max__ + 1,\r\n      x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),\r\n      y = $$.getShapeY(!!isSub),\r\n      areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),\r\n      yScale = isSub ? $$.getSubYScale : $$.getYScale\r\n    return function (d, i) {\r\n      var y0 = yScale.call($$, d.id)(0),\r\n        offset = areaOffset(d, i) || y0,\r\n        // offset is for stacked area chart\r\n        posX = x(d),\r\n        posY = y(d) // fix posY not to overflow opposite quadrant\r\n\r\n      if (config.axis_rotated) {\r\n        if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {\r\n          posY = y0\r\n        }\r\n      } // 1 point that marks the area position\r\n\r\n      return [\r\n        [posX, offset],\r\n        [posX, posY - (y0 - offset)],\r\n        [posX, posY - (y0 - offset)], // needed for compatibility\r\n        [posX, offset] // needed for compatibility\r\n      ]\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.updateCircle = function (cx, cy) {\r\n    var $$ = this\r\n    var mainCircle = $$.main\r\n      .selectAll('.' + CLASS.circles)\r\n      .selectAll('.' + CLASS.circle)\r\n      .data($$.lineOrScatterData.bind($$))\r\n    var mainCircleEnter = mainCircle\r\n      .enter()\r\n      .append('circle')\r\n      .attr('class', $$.classCircle.bind($$))\r\n      .attr('cx', cx)\r\n      .attr('cy', cy)\r\n      .attr('r', $$.pointR.bind($$))\r\n      .style('fill', $$.color)\r\n    $$.mainCircle = mainCircleEnter.merge(mainCircle).style('opacity', $$.initialOpacityForCircle.bind($$))\r\n    mainCircle.exit().style('opacity', 0)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawCircle = function (cx, cy, withTransition, transition) {\r\n    var $$ = this,\r\n      selectedCircles = $$.main.selectAll('.' + CLASS.selectedCircle)\r\n    return [\r\n      (withTransition ? $$.mainCircle.transition(transition) : $$.mainCircle)\r\n        .style('opacity', this.opacityForCircle.bind($$))\r\n        .style('fill', $$.color)\r\n        .attr('cx', cx)\r\n        .attr('cy', cy),\r\n      (withTransition ? selectedCircles.transition(transition) : selectedCircles).attr('cx', cx).attr('cy', cy)\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.circleX = function (d) {\r\n    return d.x || d.x === 0 ? this.x(d.x) : null\r\n  }\r\n\r\n  ChartInternal.prototype.updateCircleY = function () {\r\n    var $$ = this,\r\n      lineIndices,\r\n      getPoints\r\n\r\n    if ($$.config.data_groups.length > 0) {\r\n      ;(lineIndices = $$.getShapeIndices($$.isLineType)), (getPoints = $$.generateGetLinePoints(lineIndices))\r\n\r\n      $$.circleY = function (d, i) {\r\n        return getPoints(d, i)[0][1]\r\n      }\r\n    } else {\r\n      $$.circleY = function (d) {\r\n        return $$.getYScale(d.id)(d.value)\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getCircles = function (i, id) {\r\n    var $$ = this\r\n    return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll(\r\n      '.' + CLASS.circle + (isValue(i) ? '-' + i : '')\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.expandCircles = function (i, id, reset) {\r\n    var $$ = this,\r\n      r = $$.pointExpandedR.bind($$)\r\n\r\n    if (reset) {\r\n      $$.unexpandCircles()\r\n    }\r\n\r\n    $$.getCircles(i, id)\r\n      .classed(CLASS.EXPANDED, true)\r\n      .attr('r', r)\r\n  }\r\n\r\n  ChartInternal.prototype.unexpandCircles = function (i) {\r\n    var $$ = this,\r\n      r = $$.pointR.bind($$)\r\n    $$.getCircles(i)\r\n      .filter(function () {\r\n        return $$.d3.select(this).classed(CLASS.EXPANDED)\r\n      })\r\n      .classed(CLASS.EXPANDED, false)\r\n      .attr('r', r)\r\n  }\r\n\r\n  ChartInternal.prototype.pointR = function (d) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return $$.isStepType(d) ? 0 : isFunction(config.point_r) ? config.point_r(d) : config.point_r\r\n  }\r\n\r\n  ChartInternal.prototype.pointExpandedR = function (d) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if (config.point_focus_expand_enabled) {\r\n      return isFunction(config.point_focus_expand_r)\r\n        ? config.point_focus_expand_r(d)\r\n        : config.point_focus_expand_r\r\n        ? config.point_focus_expand_r\r\n        : $$.pointR(d) * 1.75\r\n    } else {\r\n      return $$.pointR(d)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.pointSelectR = function (d) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return isFunction(config.point_select_r)\r\n      ? config.point_select_r(d)\r\n      : config.point_select_r\r\n      ? config.point_select_r\r\n      : $$.pointR(d) * 4\r\n  }\r\n\r\n  ChartInternal.prototype.isWithinCircle = function (that, r) {\r\n    var d3 = this.d3,\r\n      mouse = d3.mouse(that),\r\n      d3_this = d3.select(that),\r\n      cx = +d3_this.attr('cx'),\r\n      cy = +d3_this.attr('cy')\r\n    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r\r\n  }\r\n\r\n  ChartInternal.prototype.isWithinStep = function (that, y) {\r\n    return Math.abs(y - this.d3.mouse(that)[1]) < 30\r\n  }\r\n\r\n  ChartInternal.prototype.getCurrentWidth = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n    return config.size_width ? config.size_width : $$.getParentWidth()\r\n  }\r\n\r\n  ChartInternal.prototype.getCurrentHeight = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      h = config.size_height ? config.size_height : $$.getParentHeight()\r\n    return h > 0 ? h : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1)\r\n  }\r\n\r\n  ChartInternal.prototype.getCurrentPaddingTop = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      padding = isValue(config.padding_top) ? config.padding_top : 0\r\n\r\n    if ($$.title && $$.title.node()) {\r\n      padding += $$.getTitlePadding()\r\n    }\r\n\r\n    return padding\r\n  }\r\n\r\n  ChartInternal.prototype.getCurrentPaddingBottom = function () {\r\n    var config = this.config\r\n    return isValue(config.padding_bottom) ? config.padding_bottom : 0\r\n  }\r\n\r\n  ChartInternal.prototype.getCurrentPaddingLeft = function (withoutRecompute) {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if (isValue(config.padding_left)) {\r\n      return config.padding_left\r\n    } else if (config.axis_rotated) {\r\n      return !config.axis_x_show || config.axis_x_inner\r\n        ? 1\r\n        : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40)\r\n    } else if (!config.axis_y_show || config.axis_y_inner) {\r\n      // && !config.axis_rotated\r\n      return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1\r\n    } else {\r\n      return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute))\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getCurrentPaddingRight = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      defaultPadding = 10,\r\n      legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0\r\n\r\n    if (isValue(config.padding_right)) {\r\n      return config.padding_right + 1 // 1 is needed not to hide tick line\r\n    } else if (config.axis_rotated) {\r\n      return defaultPadding + legendWidthOnRight\r\n    } else if (!config.axis_y2_show || config.axis_y2_inner) {\r\n      // && !config.axis_rotated\r\n      return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0)\r\n    } else {\r\n      return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getParentRectValue = function (key) {\r\n    var parent = this.selectChart.node(),\r\n      v\r\n\r\n    while (parent && parent.tagName !== 'BODY') {\r\n      try {\r\n        v = parent.getBoundingClientRect()[key]\r\n      } catch (e) {\r\n        if (key === 'width') {\r\n          // In IE in certain cases getBoundingClientRect\r\n          // will cause an \"unspecified error\"\r\n          v = parent.offsetWidth\r\n        }\r\n      }\r\n\r\n      if (v) {\r\n        break\r\n      }\r\n\r\n      parent = parent.parentNode\r\n    }\r\n\r\n    return v\r\n  }\r\n\r\n  ChartInternal.prototype.getParentWidth = function () {\r\n    return this.getParentRectValue('width')\r\n  }\r\n\r\n  ChartInternal.prototype.getParentHeight = function () {\r\n    return this.getParentRectValue('height')\r\n  }\r\n\r\n  ChartInternal.prototype.getSvgLeft = function (withoutRecompute) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      hasLeftAxisRect = config.axis_rotated || (!config.axis_rotated && !config.axis_y_inner),\r\n      leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,\r\n      leftAxis = $$.main.select('.' + leftAxisClass).node(),\r\n      svgRect =\r\n        leftAxis && hasLeftAxisRect\r\n          ? leftAxis.getBoundingClientRect()\r\n          : {\r\n              right: 0\r\n            },\r\n      chartRect = $$.selectChart.node().getBoundingClientRect(),\r\n      hasArc = $$.hasArcType(),\r\n      svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute))\r\n    return svgLeft > 0 ? svgLeft : 0\r\n  }\r\n\r\n  ChartInternal.prototype.getAxisWidthByAxisId = function (id, withoutRecompute) {\r\n    var $$ = this,\r\n      position = $$.axis.getLabelPositionById(id)\r\n    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40)\r\n  }\r\n\r\n  ChartInternal.prototype.getHorizontalAxisHeight = function (axisId) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      h = 30\r\n\r\n    if (axisId === 'x' && !config.axis_x_show) {\r\n      return 8\r\n    }\r\n\r\n    if (axisId === 'x' && config.axis_x_height) {\r\n      return config.axis_x_height\r\n    }\r\n\r\n    if (axisId === 'y' && !config.axis_y_show) {\r\n      return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1\r\n    }\r\n\r\n    if (axisId === 'y2' && !config.axis_y2_show) {\r\n      return $$.rotated_padding_top\r\n    } // Calculate x axis height when tick rotated\r\n\r\n    if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {\r\n      h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos((Math.PI * (90 - Math.abs(config.axis_x_tick_rotate))) / 180)\r\n    } // Calculate y axis height when tick rotated\r\n\r\n    if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {\r\n      h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos((Math.PI * (90 - Math.abs(config.axis_y_tick_rotate))) / 180)\r\n    }\r\n\r\n    return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0)\r\n  }\r\n\r\n  ChartInternal.prototype.initBrush = function (scale) {\r\n    var $$ = this,\r\n      d3 = $$.d3 // TODO: dynamically change brushY/brushX according to axis_rotated.\r\n\r\n    $$.brush = ($$.config.axis_rotated ? d3.brushY() : d3.brushX())\r\n      .on('brush', function () {\r\n        var event = d3.event.sourceEvent\r\n\r\n        if (event && event.type === 'zoom') {\r\n          return\r\n        }\r\n\r\n        $$.redrawForBrush()\r\n      })\r\n      .on('end', function () {\r\n        var event = d3.event.sourceEvent\r\n\r\n        if (event && event.type === 'zoom') {\r\n          return\r\n        }\r\n\r\n        if ($$.brush.empty() && event && event.type !== 'end') {\r\n          $$.brush.clear()\r\n        }\r\n      })\r\n\r\n    $$.brush.updateExtent = function () {\r\n      var range = this.scale.range(),\r\n        extent\r\n\r\n      if ($$.config.axis_rotated) {\r\n        extent = [[0, range[0]], [$$.width2, range[1]]]\r\n      } else {\r\n        extent = [[range[0], 0], [range[1], $$.height2]]\r\n      }\r\n\r\n      this.extent(extent)\r\n      return this\r\n    }\r\n\r\n    $$.brush.updateScale = function (scale) {\r\n      this.scale = scale\r\n      return this\r\n    }\r\n\r\n    $$.brush.update = function (scale) {\r\n      this.updateScale(scale || $$.subX).updateExtent()\r\n      $$.context.select('.' + CLASS.brush).call(this)\r\n    }\r\n\r\n    $$.brush.clear = function () {\r\n      $$.context.select('.' + CLASS.brush).call($$.brush.move, null)\r\n    }\r\n\r\n    $$.brush.selection = function () {\r\n      return d3.brushSelection($$.context.select('.' + CLASS.brush).node())\r\n    }\r\n\r\n    $$.brush.selectionAsValue = function (selectionAsValue, withTransition) {\r\n      var selection, brush\r\n\r\n      if (selectionAsValue) {\r\n        if ($$.context) {\r\n          selection = [this.scale(selectionAsValue[0]), this.scale(selectionAsValue[1])]\r\n          brush = $$.context.select('.' + CLASS.brush)\r\n\r\n          if (withTransition) {\r\n            brush = brush.transition()\r\n          }\r\n\r\n          $$.brush.move(brush, selection)\r\n        }\r\n\r\n        return []\r\n      }\r\n\r\n      selection = $$.brush.selection() || [0, 0]\r\n      return [this.scale.invert(selection[0]), this.scale.invert(selection[1])]\r\n    }\r\n\r\n    $$.brush.empty = function () {\r\n      var selection = $$.brush.selection()\r\n      return !selection || selection[0] === selection[1]\r\n    }\r\n\r\n    return $$.brush.updateScale(scale)\r\n  }\r\n\r\n  ChartInternal.prototype.initSubchart = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      context = ($$.context = $$.svg.append('g').attr('transform', $$.getTranslate('context'))),\r\n      visibility = config.subchart_show ? 'visible' : 'hidden' // set style\r\n\r\n    context.style('visibility', visibility) // Define g for chart area\r\n\r\n    context\r\n      .append('g')\r\n      .attr('clip-path', $$.clipPathForSubchart)\r\n      .attr('class', CLASS.chart) // Define g for bar chart area\r\n\r\n    context\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.chartBars) // Define g for line chart area\r\n\r\n    context\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.chartLines) // Add extent rect for Brush\r\n\r\n    context\r\n      .append('g')\r\n      .attr('clip-path', $$.clipPath)\r\n      .attr('class', CLASS.brush) // ATTENTION: This must be called AFTER chart added\r\n    // Add Axis\r\n\r\n    $$.axes.subx = context\r\n      .append('g')\r\n      .attr('class', CLASS.axisX)\r\n      .attr('transform', $$.getTranslate('subx'))\r\n      .attr('clip-path', config.axis_rotated ? '' : $$.clipPathForXAxis)\r\n  }\r\n\r\n  ChartInternal.prototype.initSubchartBrush = function () {\r\n    var $$ = this // Add extent rect for Brush\r\n\r\n    $$.initBrush($$.subX).updateExtent()\r\n    $$.context.select('.' + CLASS.brush).call($$.brush)\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetsForSubchart = function (targets) {\r\n    var $$ = this,\r\n      context = $$.context,\r\n      config = $$.config,\r\n      contextLineEnter,\r\n      contextLine,\r\n      contextBarEnter,\r\n      contextBar,\r\n      classChartBar = $$.classChartBar.bind($$),\r\n      classBars = $$.classBars.bind($$),\r\n      classChartLine = $$.classChartLine.bind($$),\r\n      classLines = $$.classLines.bind($$),\r\n      classAreas = $$.classAreas.bind($$)\r\n\r\n    if (config.subchart_show) {\r\n      //-- Bar --//\r\n      contextBar = context\r\n        .select('.' + CLASS.chartBars)\r\n        .selectAll('.' + CLASS.chartBar)\r\n        .data(targets)\r\n      contextBarEnter = contextBar\r\n        .enter()\r\n        .append('g')\r\n        .style('opacity', 0)\r\n      contextBarEnter.merge(contextBar).attr('class', classChartBar) // Bars for each data\r\n\r\n      contextBarEnter.append('g').attr('class', classBars) //-- Line --//\r\n\r\n      contextLine = context\r\n        .select('.' + CLASS.chartLines)\r\n        .selectAll('.' + CLASS.chartLine)\r\n        .data(targets)\r\n      contextLineEnter = contextLine\r\n        .enter()\r\n        .append('g')\r\n        .style('opacity', 0)\r\n      contextLineEnter.merge(contextLine).attr('class', classChartLine) // Lines for each data\r\n\r\n      contextLineEnter.append('g').attr('class', classLines) // Area\r\n\r\n      contextLineEnter.append('g').attr('class', classAreas) //-- Brush --//\r\n\r\n      context\r\n        .selectAll('.' + CLASS.brush + ' rect')\r\n        .attr(config.axis_rotated ? 'width' : 'height', config.axis_rotated ? $$.width2 : $$.height2)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.updateBarForSubchart = function (durationForExit) {\r\n    var $$ = this\r\n    var contextBar = $$.context\r\n      .selectAll('.' + CLASS.bars)\r\n      .selectAll('.' + CLASS.bar)\r\n      .data($$.barData.bind($$))\r\n    var contextBarEnter = contextBar\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', $$.classBar.bind($$))\r\n      .style('stroke', 'none')\r\n      .style('fill', $$.color)\r\n    contextBar\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n      .remove()\r\n    $$.contextBar = contextBarEnter.merge(contextBar).style('opacity', $$.initialOpacity.bind($$))\r\n  }\r\n\r\n  ChartInternal.prototype.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {\r\n    ;(withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar)\r\n      .attr('d', drawBarOnSub)\r\n      .style('opacity', 1)\r\n  }\r\n\r\n  ChartInternal.prototype.updateLineForSubchart = function (durationForExit) {\r\n    var $$ = this\r\n    var contextLine = $$.context\r\n      .selectAll('.' + CLASS.lines)\r\n      .selectAll('.' + CLASS.line)\r\n      .data($$.lineData.bind($$))\r\n    var contextLineEnter = contextLine\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', $$.classLine.bind($$))\r\n      .style('stroke', $$.color)\r\n    contextLine\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n      .remove()\r\n    $$.contextLine = contextLineEnter.merge(contextLine).style('opacity', $$.initialOpacity.bind($$))\r\n  }\r\n\r\n  ChartInternal.prototype.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {\r\n    ;(withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine)\r\n      .attr('d', drawLineOnSub)\r\n      .style('opacity', 1)\r\n  }\r\n\r\n  ChartInternal.prototype.updateAreaForSubchart = function (durationForExit) {\r\n    var $$ = this,\r\n      d3 = $$.d3\r\n    var contextArea = $$.context\r\n      .selectAll('.' + CLASS.areas)\r\n      .selectAll('.' + CLASS.area)\r\n      .data($$.lineData.bind($$))\r\n    var contextAreaEnter = contextArea\r\n      .enter()\r\n      .append('path')\r\n      .attr('class', $$.classArea.bind($$))\r\n      .style('fill', $$.color)\r\n      .style('opacity', function () {\r\n        $$.orgAreaOpacity = +d3.select(this).style('opacity')\r\n        return 0\r\n      })\r\n    contextArea\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('opacity', 0)\r\n      .remove()\r\n    $$.contextArea = contextAreaEnter.merge(contextArea).style('opacity', 0)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {\r\n    ;(withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea)\r\n      .attr('d', drawAreaOnSub)\r\n      .style('fill', this.color)\r\n      .style('opacity', this.orgAreaOpacity)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawSubchart = function (\r\n    withSubchart,\r\n    transitions,\r\n    duration,\r\n    durationForExit,\r\n    areaIndices,\r\n    barIndices,\r\n    lineIndices\r\n  ) {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config,\r\n      drawAreaOnSub,\r\n      drawBarOnSub,\r\n      drawLineOnSub\r\n    $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden') // subchart\r\n\r\n    if (config.subchart_show) {\r\n      // reflect main chart to extent on subchart if zoomed\r\n      if (d3.event && d3.event.type === 'zoom') {\r\n        $$.brush.selectionAsValue($$.x.orgDomain())\r\n      } // update subchart elements if needed\r\n\r\n      if (withSubchart) {\r\n        // extent rect\r\n        if (!$$.brush.empty()) {\r\n          $$.brush.selectionAsValue($$.x.orgDomain())\r\n        } // setup drawer - MEMO: this must be called after axis updated\r\n\r\n        drawAreaOnSub = $$.generateDrawArea(areaIndices, true)\r\n        drawBarOnSub = $$.generateDrawBar(barIndices, true)\r\n        drawLineOnSub = $$.generateDrawLine(lineIndices, true)\r\n        $$.updateBarForSubchart(duration)\r\n        $$.updateLineForSubchart(duration)\r\n        $$.updateAreaForSubchart(duration)\r\n        $$.redrawBarForSubchart(drawBarOnSub, duration, duration)\r\n        $$.redrawLineForSubchart(drawLineOnSub, duration, duration)\r\n        $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration)\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.redrawForBrush = function () {\r\n    var $$ = this,\r\n      x = $$.x,\r\n      d3 = $$.d3,\r\n      s\r\n    $$.redraw({\r\n      withTransition: false,\r\n      withY: $$.config.zoom_rescale,\r\n      withSubchart: false,\r\n      withUpdateXDomain: true,\r\n      withEventRect: false,\r\n      withDimension: false\r\n    }) // update zoom transation binded to event rect\r\n\r\n    s = d3.event.selection || $$.brush.scale.range()\r\n    $$.main\r\n      .select('.' + CLASS.eventRect)\r\n      .call($$.zoom.transform, d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0))\r\n    $$.config.subchart_onbrush.call($$.api, x.orgDomain())\r\n  }\r\n\r\n  ChartInternal.prototype.transformContext = function (withTransition, transitions) {\r\n    var $$ = this,\r\n      subXAxis\r\n\r\n    if (transitions && transitions.axisSubX) {\r\n      subXAxis = transitions.axisSubX\r\n    } else {\r\n      subXAxis = $$.context.select('.' + CLASS.axisX)\r\n\r\n      if (withTransition) {\r\n        subXAxis = subXAxis.transition()\r\n      }\r\n    }\r\n\r\n    $$.context.attr('transform', $$.getTranslate('context'))\r\n    subXAxis.attr('transform', $$.getTranslate('subx'))\r\n  }\r\n\r\n  ChartInternal.prototype.getDefaultSelection = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      selection = isFunction(config.axis_x_selection)\r\n        ? config.axis_x_selection($$.getXDomain($$.data.targets))\r\n        : config.axis_x_selection\r\n\r\n    if ($$.isTimeSeries()) {\r\n      selection = [$$.parseDate(selection[0]), $$.parseDate(selection[1])]\r\n    }\r\n\r\n    return selection\r\n  }\r\n\r\n  ChartInternal.prototype.initText = function () {\r\n    var $$ = this\r\n    $$.main\r\n      .select('.' + CLASS.chart)\r\n      .append('g')\r\n      .attr('class', CLASS.chartTexts)\r\n    $$.mainText = $$.d3.selectAll([])\r\n  }\r\n\r\n  ChartInternal.prototype.updateTargetsForText = function (targets) {\r\n    var $$ = this,\r\n      classChartText = $$.classChartText.bind($$),\r\n      classTexts = $$.classTexts.bind($$),\r\n      classFocus = $$.classFocus.bind($$)\r\n    var mainText = $$.main\r\n      .select('.' + CLASS.chartTexts)\r\n      .selectAll('.' + CLASS.chartText)\r\n      .data(targets)\r\n    var mainTextEnter = mainText\r\n      .enter()\r\n      .append('g')\r\n      .attr('class', classChartText)\r\n      .style('opacity', 0)\r\n      .style('pointer-events', 'none')\r\n    mainTextEnter.append('g').attr('class', classTexts)\r\n    mainTextEnter.merge(mainText).attr('class', function (d) {\r\n      return classChartText(d) + classFocus(d)\r\n    })\r\n  }\r\n\r\n  ChartInternal.prototype.updateText = function (xForText, yForText, durationForExit) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      barOrLineData = $$.barOrLineData.bind($$),\r\n      classText = $$.classText.bind($$)\r\n    var mainText = $$.main\r\n      .selectAll('.' + CLASS.texts)\r\n      .selectAll('.' + CLASS.text)\r\n      .data(barOrLineData)\r\n    var mainTextEnter = mainText\r\n      .enter()\r\n      .append('text')\r\n      .attr('class', classText)\r\n      .attr('text-anchor', function (d) {\r\n        return config.axis_rotated ? (d.value < 0 ? 'end' : 'start') : 'middle'\r\n      })\r\n      .style('stroke', 'none')\r\n      .attr('x', xForText)\r\n      .attr('y', yForText)\r\n      .style('fill', function (d) {\r\n        return $$.color(d)\r\n      })\r\n      .style('fill-opacity', 0)\r\n    $$.mainText = mainTextEnter.merge(mainText).text(function (d, i, j) {\r\n      return $$.dataLabelFormat(d.id)(d.value, d.id, i, j)\r\n    })\r\n    mainText\r\n      .exit()\r\n      .transition()\r\n      .duration(durationForExit)\r\n      .style('fill-opacity', 0)\r\n      .remove()\r\n  }\r\n\r\n  ChartInternal.prototype.redrawText = function (xForText, yForText, forFlow, withTransition, transition) {\r\n    return [\r\n      (withTransition ? this.mainText.transition(transition) : this.mainText)\r\n        .attr('x', xForText)\r\n        .attr('y', yForText)\r\n        .style('fill', this.color)\r\n        .style('fill-opacity', forFlow ? 0 : this.opacityForText.bind(this))\r\n    ]\r\n  }\r\n\r\n  ChartInternal.prototype.getTextRect = function (text, cls, element) {\r\n    var dummy = this.d3\r\n        .select('body')\r\n        .append('div')\r\n        .classed('c3', true),\r\n      svg = dummy\r\n        .append('svg')\r\n        .style('visibility', 'hidden')\r\n        .style('position', 'fixed')\r\n        .style('top', 0)\r\n        .style('left', 0),\r\n      font = this.d3.select(element).style('font'),\r\n      rect\r\n    svg\r\n      .selectAll('.dummy')\r\n      .data([text])\r\n      .enter()\r\n      .append('text')\r\n      .classed(cls ? cls : '', true)\r\n      .style('font', font)\r\n      .text(text)\r\n      .each(function () {\r\n        rect = this.getBoundingClientRect()\r\n      })\r\n    dummy.remove()\r\n    return rect\r\n  }\r\n\r\n  ChartInternal.prototype.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {\r\n    var $$ = this,\r\n      getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),\r\n      getBarPoints = $$.generateGetBarPoints(barIndices, false),\r\n      getLinePoints = $$.generateGetLinePoints(lineIndices, false),\r\n      getter = forX ? $$.getXForText : $$.getYForText\r\n    return function (d, i) {\r\n      var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints\r\n      return getter.call($$, getPoints(d, i), d, this)\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getXForText = function (points, d, textElement) {\r\n    var $$ = this,\r\n      box = textElement.getBoundingClientRect(),\r\n      xPos,\r\n      padding\r\n\r\n    if ($$.config.axis_rotated) {\r\n      padding = $$.isBarType(d) ? 4 : 6\r\n      xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)\r\n    } else {\r\n      xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0]\r\n    } // show labels regardless of the domain if value is null\r\n\r\n    if (d.value === null) {\r\n      if (xPos > $$.width) {\r\n        xPos = $$.width - box.width\r\n      } else if (xPos < 0) {\r\n        xPos = 4\r\n      }\r\n    }\r\n\r\n    return xPos\r\n  }\r\n\r\n  ChartInternal.prototype.getYForText = function (points, d, textElement) {\r\n    var $$ = this,\r\n      box = textElement.getBoundingClientRect(),\r\n      yPos\r\n\r\n    if ($$.config.axis_rotated) {\r\n      yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2\r\n    } else {\r\n      yPos = points[2][1]\r\n\r\n      if (d.value < 0 || (d.value === 0 && !$$.hasPositiveValue)) {\r\n        yPos += box.height\r\n\r\n        if ($$.isBarType(d) && $$.isSafari()) {\r\n          yPos -= 3\r\n        } else if (!$$.isBarType(d) && $$.isChrome()) {\r\n          yPos += 3\r\n        }\r\n      } else {\r\n        yPos += $$.isBarType(d) ? -3 : -6\r\n      }\r\n    } // show labels regardless of the domain if value is null\r\n\r\n    if (d.value === null && !$$.config.axis_rotated) {\r\n      if (yPos < box.height) {\r\n        yPos = box.height\r\n      } else if (yPos > this.height) {\r\n        yPos = this.height - 4\r\n      }\r\n    }\r\n\r\n    return yPos\r\n  }\r\n\r\n  ChartInternal.prototype.initTitle = function () {\r\n    var $$ = this\r\n    $$.title = $$.svg\r\n      .append('text')\r\n      .text($$.config.title_text)\r\n      .attr('class', $$.CLASS.title)\r\n  }\r\n\r\n  ChartInternal.prototype.redrawTitle = function () {\r\n    var $$ = this\r\n    $$.title.attr('x', $$.xForTitle.bind($$)).attr('y', $$.yForTitle.bind($$))\r\n  }\r\n\r\n  ChartInternal.prototype.xForTitle = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      position = config.title_position || 'left',\r\n      x\r\n\r\n    if (position.indexOf('right') >= 0) {\r\n      x =\r\n        $$.currentWidth -\r\n        $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width -\r\n        config.title_padding.right\r\n    } else if (position.indexOf('center') >= 0) {\r\n      x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2\r\n    } else {\r\n      // left\r\n      x = config.title_padding.left\r\n    }\r\n\r\n    return x\r\n  }\r\n\r\n  ChartInternal.prototype.yForTitle = function () {\r\n    var $$ = this\r\n    return (\r\n      $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.getTitlePadding = function () {\r\n    var $$ = this\r\n    return $$.yForTitle() + $$.config.title_padding.bottom\r\n  }\r\n\r\n  ChartInternal.prototype.initTooltip = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      i\r\n    $$.tooltip = $$.selectChart\r\n      .style('position', 'relative')\r\n      .append('div')\r\n      .attr('class', CLASS.tooltipContainer)\r\n      .style('position', 'absolute')\r\n      .style('pointer-events', 'none')\r\n      .style('display', 'none') // Show tooltip if needed\r\n\r\n    if (config.tooltip_init_show) {\r\n      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {\r\n        config.tooltip_init_x = $$.parseDate(config.tooltip_init_x)\r\n\r\n        for (i = 0; i < $$.data.targets[0].values.length; i++) {\r\n          if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {\r\n            break\r\n          }\r\n        }\r\n\r\n        config.tooltip_init_x = i\r\n      }\r\n\r\n      $$.tooltip.html(\r\n        config.tooltip_contents.call(\r\n          $$,\r\n          $$.data.targets.map(function (d) {\r\n            return $$.addName(d.values[config.tooltip_init_x])\r\n          }),\r\n          $$.axis.getXAxisTickFormat(),\r\n          $$.getYFormat($$.hasArcType()),\r\n          $$.color\r\n        )\r\n      )\r\n      $$.tooltip\r\n        .style('top', config.tooltip_init_position.top)\r\n        .style('left', config.tooltip_init_position.left)\r\n        .style('display', 'block')\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getTooltipSortFunction = function () {\r\n    var $$ = this,\r\n      config = $$.config\r\n\r\n    if (config.data_groups.length === 0 || config.tooltip_order !== undefined) {\r\n      // if data are not grouped or if an order is specified\r\n      // for the tooltip values we sort them by their values\r\n      var order = config.tooltip_order\r\n\r\n      if (order === undefined) {\r\n        order = config.data_order\r\n      }\r\n\r\n      var valueOf = function valueOf (obj) {\r\n        return obj ? obj.value : null\r\n      } // if data are not grouped, we sort them by their value\r\n\r\n      if (isString(order) && order.toLowerCase() === 'asc') {\r\n        return function (a, b) {\r\n          return valueOf(a) - valueOf(b)\r\n        }\r\n      } else if (isString(order) && order.toLowerCase() === 'desc') {\r\n        return function (a, b) {\r\n          return valueOf(b) - valueOf(a)\r\n        }\r\n      } else if (isFunction(order)) {\r\n        // if the function is from data_order we need\r\n        // to wrap the returned function in order to format\r\n        // the sorted value to the expected format\r\n        var sortFunction = order\r\n\r\n        if (config.tooltip_order === undefined) {\r\n          sortFunction = function sortFunction (a, b) {\r\n            return order(\r\n              a\r\n                ? {\r\n                    id: a.id,\r\n                    values: [a]\r\n                  }\r\n                : null,\r\n              b\r\n                ? {\r\n                    id: b.id,\r\n                    values: [b]\r\n                  }\r\n                : null\r\n            )\r\n          }\r\n        }\r\n\r\n        return sortFunction\r\n      } else if (isArray(order)) {\r\n        return function (a, b) {\r\n          return order.indexOf(a.id) - order.indexOf(b.id)\r\n        }\r\n      }\r\n    } else {\r\n      // if data are grouped, we follow the order of grouped targets\r\n      var ids = $$.orderTargets($$.data.targets).map(function (i) {\r\n        return i.id\r\n      }) // if it was either asc or desc we need to invert the order\r\n      // returned by orderTargets\r\n\r\n      if ($$.isOrderAsc() || $$.isOrderDesc()) {\r\n        ids = ids.reverse()\r\n      }\r\n\r\n      return function (a, b) {\r\n        return ids.indexOf(a.id) - ids.indexOf(b.id)\r\n      }\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      titleFormat = config.tooltip_format_title || defaultTitleFormat,\r\n      nameFormat =\r\n        config.tooltip_format_name ||\r\n        function (name) {\r\n          return name\r\n        },\r\n      valueFormat = config.tooltip_format_value || defaultValueFormat,\r\n      text,\r\n      i,\r\n      title,\r\n      value,\r\n      name,\r\n      bgcolor\r\n\r\n    var tooltipSortFunction = this.getTooltipSortFunction()\r\n\r\n    if (tooltipSortFunction) {\r\n      d.sort(tooltipSortFunction)\r\n    }\r\n\r\n    for (i = 0; i < d.length; i++) {\r\n      if (!(d[i] && (d[i].value || d[i].value === 0))) {\r\n        continue\r\n      }\r\n\r\n      if (!text) {\r\n        title = sanitise(titleFormat ? titleFormat(d[i].x, d[i].index) : d[i].x)\r\n        text =\r\n          \"<table class='\" +\r\n          $$.CLASS.tooltip +\r\n          \"'>\" +\r\n          (title || title === 0 ? \"<tr><th colspan='2'>\" + title + '</th></tr>' : '')\r\n      }\r\n\r\n      value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d))\r\n\r\n      if (value !== undefined) {\r\n        // Skip elements when their name is set to null\r\n        if (d[i].name === null) {\r\n          continue\r\n        }\r\n\r\n        name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index))\r\n        bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id)\r\n        text += \"<tr class='\" + $$.CLASS.tooltipName + '-' + $$.getTargetSelectorSuffix(d[i].id) + \"'>\"\r\n        text += \"<td class='name'><span style='background-color:\" + bgcolor + \"'></span>\" + name + '</td>'\r\n        text += \"<td class='value'>\" + value + '</td>'\r\n        text += '</tr>'\r\n      }\r\n    }\r\n\r\n    return text + '</table>'\r\n  }\r\n\r\n  ChartInternal.prototype.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      d3 = $$.d3\r\n    var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight\r\n    var forArc = $$.hasArcType(),\r\n      mouse = d3.mouse(element) // Determin tooltip position\r\n\r\n    if (forArc) {\r\n      tooltipLeft = ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0]\r\n      tooltipTop = ($$.hasType('gauge') ? $$.height : $$.height / 2) + mouse[1] + 20\r\n    } else {\r\n      svgLeft = $$.getSvgLeft(true)\r\n\r\n      if (config.axis_rotated) {\r\n        tooltipLeft = svgLeft + mouse[0] + 100\r\n        tooltipRight = tooltipLeft + tWidth\r\n        chartRight = $$.currentWidth - $$.getCurrentPaddingRight()\r\n        tooltipTop = $$.x(dataToShow[0].x) + 20\r\n      } else {\r\n        tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20\r\n        tooltipRight = tooltipLeft + tWidth\r\n        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight()\r\n        tooltipTop = mouse[1] + 15\r\n      }\r\n\r\n      if (tooltipRight > chartRight) {\r\n        // 20 is needed for Firefox to keep tooltip width\r\n        tooltipLeft -= tooltipRight - chartRight + 20\r\n      }\r\n\r\n      if (tooltipTop + tHeight > $$.currentHeight) {\r\n        tooltipTop -= tHeight + 30\r\n      }\r\n    }\r\n\r\n    if (tooltipTop < 0) {\r\n      tooltipTop = 0\r\n    }\r\n\r\n    return {\r\n      top: tooltipTop,\r\n      left: tooltipLeft\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.showTooltip = function (selectedData, element) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    var tWidth, tHeight, position\r\n    var forArc = $$.hasArcType(),\r\n      dataToShow = selectedData.filter(function (d) {\r\n        return d && isValue(d.value)\r\n      }),\r\n      positionFunction = config.tooltip_position || ChartInternal.prototype.tooltipPosition\r\n\r\n    if (dataToShow.length === 0 || !config.tooltip_show) {\r\n      return\r\n    }\r\n\r\n    $$.tooltip\r\n      .html(\r\n        config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)\r\n      )\r\n      .style('display', 'block') // Get tooltip dimensions\r\n\r\n    tWidth = $$.tooltip.property('offsetWidth')\r\n    tHeight = $$.tooltip.property('offsetHeight')\r\n    position = positionFunction.call(this, dataToShow, tWidth, tHeight, element) // Set tooltip\r\n\r\n    $$.tooltip.style('top', position.top + 'px').style('left', position.left + 'px')\r\n  }\r\n\r\n  ChartInternal.prototype.hideTooltip = function () {\r\n    this.tooltip.style('display', 'none')\r\n  }\r\n\r\n  ChartInternal.prototype.setTargetType = function (targetIds, type) {\r\n    var $$ = this,\r\n      config = $$.config\r\n    $$.mapToTargetIds(targetIds).forEach(function (id) {\r\n      $$.withoutFadeIn[id] = type === config.data_types[id]\r\n      config.data_types[id] = type\r\n    })\r\n\r\n    if (!targetIds) {\r\n      config.data_type = type\r\n    }\r\n  }\r\n\r\n  ChartInternal.prototype.hasType = function (type, targets) {\r\n    var $$ = this,\r\n      types = $$.config.data_types,\r\n      has = false\r\n    targets = targets || $$.data.targets\r\n\r\n    if (targets && targets.length) {\r\n      targets.forEach(function (target) {\r\n        var t = types[target.id]\r\n\r\n        if ((t && t.indexOf(type) >= 0) || (!t && type === 'line')) {\r\n          has = true\r\n        }\r\n      })\r\n    } else if (Object.keys(types).length) {\r\n      Object.keys(types).forEach(function (id) {\r\n        if (types[id] === type) {\r\n          has = true\r\n        }\r\n      })\r\n    } else {\r\n      has = $$.config.data_type === type\r\n    }\r\n\r\n    return has\r\n  }\r\n\r\n  ChartInternal.prototype.hasArcType = function (targets) {\r\n    return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets)\r\n  }\r\n\r\n  ChartInternal.prototype.isLineType = function (d) {\r\n    var config = this.config,\r\n      id = isString(d) ? d : d.id\r\n    return (\r\n      !config.data_types[id] ||\r\n      ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0\r\n    )\r\n  }\r\n\r\n  ChartInternal.prototype.isStepType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0\r\n  }\r\n\r\n  ChartInternal.prototype.isSplineType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0\r\n  }\r\n\r\n  ChartInternal.prototype.isAreaType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0\r\n  }\r\n\r\n  ChartInternal.prototype.isBarType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return this.config.data_types[id] === 'bar'\r\n  }\r\n\r\n  ChartInternal.prototype.isScatterType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return this.config.data_types[id] === 'scatter'\r\n  }\r\n\r\n  ChartInternal.prototype.isPieType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return this.config.data_types[id] === 'pie'\r\n  }\r\n\r\n  ChartInternal.prototype.isGaugeType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return this.config.data_types[id] === 'gauge'\r\n  }\r\n\r\n  ChartInternal.prototype.isDonutType = function (d) {\r\n    var id = isString(d) ? d : d.id\r\n    return this.config.data_types[id] === 'donut'\r\n  }\r\n\r\n  ChartInternal.prototype.isArcType = function (d) {\r\n    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d)\r\n  }\r\n\r\n  ChartInternal.prototype.lineData = function (d) {\r\n    return this.isLineType(d) ? [d] : []\r\n  }\r\n\r\n  ChartInternal.prototype.arcData = function (d) {\r\n    return this.isArcType(d.data) ? [d] : []\r\n  }\r\n  /* not used\r\n   function scatterData(d) {\r\n   return isScatterType(d) ? d.values : [];\r\n   }\r\n   */\r\n\r\n  ChartInternal.prototype.barData = function (d) {\r\n    return this.isBarType(d) ? d.values : []\r\n  }\r\n\r\n  ChartInternal.prototype.lineOrScatterData = function (d) {\r\n    return this.isLineType(d) || this.isScatterType(d) ? d.values : []\r\n  }\r\n\r\n  ChartInternal.prototype.barOrLineData = function (d) {\r\n    return this.isBarType(d) || this.isLineType(d) ? d.values : []\r\n  }\r\n\r\n  ChartInternal.prototype.isSafari = function () {\r\n    var ua = window.navigator.userAgent\r\n    return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0\r\n  }\r\n\r\n  ChartInternal.prototype.isChrome = function () {\r\n    var ua = window.navigator.userAgent\r\n    return ua.indexOf('Chrome') >= 0\r\n  }\r\n\r\n  ChartInternal.prototype.initZoom = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config,\r\n      startEvent\r\n    $$.zoom = d3\r\n      .zoom()\r\n      .on('start', function () {\r\n        if (config.zoom_type !== 'scroll') {\r\n          return\r\n        }\r\n\r\n        var e = d3.event.sourceEvent\r\n\r\n        if (e && e.type === 'brush') {\r\n          return\r\n        }\r\n\r\n        startEvent = e\r\n        config.zoom_onzoomstart.call($$.api, e)\r\n      })\r\n      .on('zoom', function () {\r\n        if (config.zoom_type !== 'scroll') {\r\n          return\r\n        }\r\n\r\n        var e = d3.event.sourceEvent\r\n\r\n        if (e && e.type === 'brush') {\r\n          return\r\n        }\r\n\r\n        $$.redrawForZoom()\r\n        config.zoom_onzoom.call($$.api, $$.x.orgDomain())\r\n      })\r\n      .on('end', function () {\r\n        if (config.zoom_type !== 'scroll') {\r\n          return\r\n        }\r\n\r\n        var e = d3.event.sourceEvent\r\n\r\n        if (e && e.type === 'brush') {\r\n          return\r\n        } // if click, do nothing. otherwise, click interaction will be canceled.\r\n\r\n        if (e && startEvent.clientX === e.clientX && startEvent.clientY === e.clientY) {\r\n          return\r\n        }\r\n\r\n        config.zoom_onzoomend.call($$.api, $$.x.orgDomain())\r\n      })\r\n\r\n    $$.zoom.updateDomain = function () {\r\n      if (d3.event && d3.event.transform) {\r\n        $$.x.domain(d3.event.transform.rescaleX($$.subX).domain())\r\n      }\r\n\r\n      return this\r\n    }\r\n\r\n    $$.zoom.updateExtent = function () {\r\n      this.scaleExtent([1, Infinity])\r\n        .translateExtent([[0, 0], [$$.width, $$.height]])\r\n        .extent([[0, 0], [$$.width, $$.height]])\r\n      return this\r\n    }\r\n\r\n    $$.zoom.update = function () {\r\n      return this.updateExtent().updateDomain()\r\n    }\r\n\r\n    return $$.zoom.updateExtent()\r\n  }\r\n\r\n  ChartInternal.prototype.zoomTransform = function (range) {\r\n    var $$ = this,\r\n      s = [$$.x(range[0]), $$.x(range[1])]\r\n    return $$.d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0)\r\n  }\r\n\r\n  ChartInternal.prototype.initDragZoom = function () {\r\n    var $$ = this\r\n    var d3 = $$.d3\r\n    var config = $$.config\r\n    var context = ($$.context = $$.svg)\r\n    var brushXPos = $$.margin.left + 20.5\r\n    var brushYPos = $$.margin.top + 0.5\r\n\r\n    if (!(config.zoom_type === 'drag' && config.zoom_enabled)) {\r\n      return\r\n    }\r\n\r\n    var getZoomedDomain = function getZoomedDomain (selection) {\r\n      return (\r\n        selection &&\r\n        selection.map(function (x) {\r\n          return $$.x.invert(x)\r\n        })\r\n      )\r\n    }\r\n\r\n    var brush = ($$.dragZoomBrush = d3\r\n      .brushX()\r\n      .on('start', function () {\r\n        $$.api.unzoom()\r\n        $$.svg.select('.' + CLASS.dragZoom).classed('disabled', false)\r\n        config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent)\r\n      })\r\n      .on('brush', function () {\r\n        config.zoom_onzoom.call($$.api, getZoomedDomain(d3.event.selection))\r\n      })\r\n      .on('end', function () {\r\n        if (d3.event.selection == null) {\r\n          return\r\n        }\r\n\r\n        var zoomedDomain = getZoomedDomain(d3.event.selection)\r\n\r\n        if (!config.zoom_disableDefaultBehavior) {\r\n          $$.api.zoom(zoomedDomain)\r\n        }\r\n\r\n        $$.svg.select('.' + CLASS.dragZoom).classed('disabled', true)\r\n        config.zoom_onzoomend.call($$.api, zoomedDomain)\r\n      }))\r\n    context\r\n      .append('g')\r\n      .classed(CLASS.dragZoom, true)\r\n      .attr('clip-path', $$.clipPath)\r\n      .attr('transform', 'translate(' + brushXPos + ',' + brushYPos + ')')\r\n      .call(brush)\r\n  }\r\n\r\n  ChartInternal.prototype.getZoomDomain = function () {\r\n    var $$ = this,\r\n      config = $$.config,\r\n      d3 = $$.d3,\r\n      min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),\r\n      max = d3.max([$$.orgXDomain[1], config.zoom_x_max])\r\n    return [min, max]\r\n  }\r\n\r\n  ChartInternal.prototype.redrawForZoom = function () {\r\n    var $$ = this,\r\n      d3 = $$.d3,\r\n      config = $$.config,\r\n      zoom = $$.zoom,\r\n      x = $$.x\r\n\r\n    if (!config.zoom_enabled) {\r\n      return\r\n    }\r\n\r\n    if ($$.filterTargetsToShow($$.data.targets).length === 0) {\r\n      return\r\n    }\r\n\r\n    zoom.update()\r\n\r\n    if (config.zoom_disableDefaultBehavior) {\r\n      return\r\n    }\r\n\r\n    if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {\r\n      x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]])\r\n    }\r\n\r\n    $$.redraw({\r\n      withTransition: false,\r\n      withY: config.zoom_rescale,\r\n      withSubchart: false,\r\n      withEventRect: false,\r\n      withDimension: false\r\n    })\r\n\r\n    if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousemove') {\r\n      $$.cancelClick = true\r\n    }\r\n  }\r\n\r\n  return c3\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/c3/c3.js?");

/***/ }),

/***/ 165:
/*!*******************************************!*\
  !*** ./src/public/js/vendor/d3/d3.min.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("// https://d3js.org v5.9.0 Copyright 2019 Mike Bostock\r\n!(function (t, n) {\r\n   true\r\n    ? n(exports)\r\n    : 0\r\n})(this, function (t) {\r\n  'use strict'\r\n  function n (t, n) {\r\n    return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN\r\n  }\r\n  function e (t) {\r\n    var e\r\n    return (\r\n      1 === t.length &&\r\n        ((e = t),\r\n        (t = function (t, r) {\r\n          return n(e(t), r)\r\n        })),\r\n      {\r\n        left: function (n, e, r, i) {\r\n          for (null == r && (r = 0), null == i && (i = n.length); r < i; ) {\r\n            var o = (r + i) >>> 1\r\n            t(n[o], e) < 0 ? (r = o + 1) : (i = o)\r\n          }\r\n          return r\r\n        },\r\n        right: function (n, e, r, i) {\r\n          for (null == r && (r = 0), null == i && (i = n.length); r < i; ) {\r\n            var o = (r + i) >>> 1\r\n            t(n[o], e) > 0 ? (i = o) : (r = o + 1)\r\n          }\r\n          return r\r\n        }\r\n      }\r\n    )\r\n  }\r\n  var r = e(n),\r\n    i = r.right,\r\n    o = r.left\r\n  function a (t, n) {\r\n    return [t, n]\r\n  }\r\n  function u (t) {\r\n    return null === t ? NaN : +t\r\n  }\r\n  function c (t, n) {\r\n    var e,\r\n      r,\r\n      i = t.length,\r\n      o = 0,\r\n      a = -1,\r\n      c = 0,\r\n      f = 0\r\n    if (null == n) for (; ++a < i; ) isNaN((e = u(t[a]))) || (f += (r = e - c) * (e - (c += r / ++o)))\r\n    else for (; ++a < i; ) isNaN((e = u(n(t[a], a, t)))) || (f += (r = e - c) * (e - (c += r / ++o)))\r\n    if (o > 1) return f / (o - 1)\r\n  }\r\n  function f (t, n) {\r\n    var e = c(t, n)\r\n    return e ? Math.sqrt(e) : e\r\n  }\r\n  function s (t, n) {\r\n    var e,\r\n      r,\r\n      i,\r\n      o = t.length,\r\n      a = -1\r\n    if (null == n) {\r\n      for (; ++a < o; )\r\n        if (null != (e = t[a]) && e >= e)\r\n          for (r = i = e; ++a < o; ) null != (e = t[a]) && (r > e && (r = e), i < e && (i = e))\r\n    } else for (; ++a < o; ) if (null != (e = n(t[a], a, t)) && e >= e) for (r = i = e; ++a < o; ) null != (e = n(t[a], a, t)) && (r > e && (r = e), i < e && (i = e))\r\n    return [r, i]\r\n  }\r\n  var l = Array.prototype,\r\n    h = l.slice,\r\n    d = l.map\r\n  function p (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function v (t) {\r\n    return t\r\n  }\r\n  function g (t, n, e) {\r\n    ;(t = +t), (n = +n), (e = (i = arguments.length) < 2 ? ((n = t), (t = 0), 1) : i < 3 ? 1 : +e)\r\n    for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(i); ++r < i; ) o[r] = t + r * e\r\n    return o\r\n  }\r\n  var y = Math.sqrt(50),\r\n    _ = Math.sqrt(10),\r\n    b = Math.sqrt(2)\r\n  function m (t, n, e) {\r\n    var r,\r\n      i,\r\n      o,\r\n      a,\r\n      u = -1\r\n    if (((e = +e), (t = +t) === (n = +n) && e > 0)) return [t]\r\n    if (((r = n < t) && ((i = t), (t = n), (n = i)), 0 === (a = x(t, n, e)) || !isFinite(a))) return []\r\n    if (a > 0)\r\n      for (t = Math.ceil(t / a), n = Math.floor(n / a), o = new Array((i = Math.ceil(n - t + 1))); ++u < i; )\r\n        o[u] = (t + u) * a\r\n    else\r\n      for (t = Math.floor(t * a), n = Math.ceil(n * a), o = new Array((i = Math.ceil(t - n + 1))); ++u < i; )\r\n        o[u] = (t - u) / a\r\n    return r && o.reverse(), o\r\n  }\r\n  function x (t, n, e) {\r\n    var r = (n - t) / Math.max(0, e),\r\n      i = Math.floor(Math.log(r) / Math.LN10),\r\n      o = r / Math.pow(10, i)\r\n    return i >= 0\r\n      ? (o >= y ? 10 : o >= _ ? 5 : o >= b ? 2 : 1) * Math.pow(10, i)\r\n      : -Math.pow(10, -i) / (o >= y ? 10 : o >= _ ? 5 : o >= b ? 2 : 1)\r\n  }\r\n  function w (t, n, e) {\r\n    var r = Math.abs(n - t) / Math.max(0, e),\r\n      i = Math.pow(10, Math.floor(Math.log(r) / Math.LN10)),\r\n      o = r / i\r\n    return o >= y ? (i *= 10) : o >= _ ? (i *= 5) : o >= b && (i *= 2), n < t ? -i : i\r\n  }\r\n  function M (t) {\r\n    return Math.ceil(Math.log(t.length) / Math.LN2) + 1\r\n  }\r\n  function N (t, n, e) {\r\n    if ((null == e && (e = u), (r = t.length))) {\r\n      if ((n = +n) <= 0 || r < 2) return +e(t[0], 0, t)\r\n      if (n >= 1) return +e(t[r - 1], r - 1, t)\r\n      var r,\r\n        i = (r - 1) * n,\r\n        o = Math.floor(i),\r\n        a = +e(t[o], o, t)\r\n      return a + (+e(t[o + 1], o + 1, t) - a) * (i - o)\r\n    }\r\n  }\r\n  function A (t, n) {\r\n    var e,\r\n      r,\r\n      i = t.length,\r\n      o = -1\r\n    if (null == n) {\r\n      for (; ++o < i; ) if (null != (e = t[o]) && e >= e) for (r = e; ++o < i; ) null != (e = t[o]) && e > r && (r = e)\r\n    } else for (; ++o < i; ) if (null != (e = n(t[o], o, t)) && e >= e) for (r = e; ++o < i; ) null != (e = n(t[o], o, t)) && e > r && (r = e)\r\n    return r\r\n  }\r\n  function S (t) {\r\n    for (var n, e, r, i = t.length, o = -1, a = 0; ++o < i; ) a += t[o].length\r\n    for (e = new Array(a); --i >= 0; ) for (n = (r = t[i]).length; --n >= 0; ) e[--a] = r[n]\r\n    return e\r\n  }\r\n  function k (t, n) {\r\n    var e,\r\n      r,\r\n      i = t.length,\r\n      o = -1\r\n    if (null == n) {\r\n      for (; ++o < i; ) if (null != (e = t[o]) && e >= e) for (r = e; ++o < i; ) null != (e = t[o]) && r > e && (r = e)\r\n    } else for (; ++o < i; ) if (null != (e = n(t[o], o, t)) && e >= e) for (r = e; ++o < i; ) null != (e = n(t[o], o, t)) && r > e && (r = e)\r\n    return r\r\n  }\r\n  function T (t) {\r\n    if (!(i = t.length)) return []\r\n    for (var n = -1, e = k(t, E), r = new Array(e); ++n < e; )\r\n      for (var i, o = -1, a = (r[n] = new Array(i)); ++o < i; ) a[o] = t[o][n]\r\n    return r\r\n  }\r\n  function E (t) {\r\n    return t.length\r\n  }\r\n  var C = Array.prototype.slice\r\n  function P (t) {\r\n    return t\r\n  }\r\n  var z = 1,\r\n    R = 2,\r\n    D = 3,\r\n    q = 4,\r\n    L = 1e-6\r\n  function U (t) {\r\n    return 'translate(' + (t + 0.5) + ',0)'\r\n  }\r\n  function O (t) {\r\n    return 'translate(0,' + (t + 0.5) + ')'\r\n  }\r\n  function B () {\r\n    return !this.__axis\r\n  }\r\n  function Y (t, n) {\r\n    var e = [],\r\n      r = null,\r\n      i = null,\r\n      o = 6,\r\n      a = 6,\r\n      u = 3,\r\n      c = t === z || t === q ? -1 : 1,\r\n      f = t === q || t === R ? 'x' : 'y',\r\n      s = t === z || t === D ? U : O\r\n    function l (l) {\r\n      var h = null == r ? (n.ticks ? n.ticks.apply(n, e) : n.domain()) : r,\r\n        d = null == i ? (n.tickFormat ? n.tickFormat.apply(n, e) : P) : i,\r\n        p = Math.max(o, 0) + u,\r\n        v = n.range(),\r\n        g = +v[0] + 0.5,\r\n        y = +v[v.length - 1] + 0.5,\r\n        _ = (n.bandwidth\r\n          ? function (t) {\r\n              var n = Math.max(0, t.bandwidth() - 1) / 2\r\n              return (\r\n                t.round() && (n = Math.round(n)),\r\n                function (e) {\r\n                  return +t(e) + n\r\n                }\r\n              )\r\n            }\r\n          : function (t) {\r\n              return function (n) {\r\n                return +t(n)\r\n              }\r\n            })(n.copy()),\r\n        b = l.selection ? l.selection() : l,\r\n        m = b.selectAll('.domain').data([null]),\r\n        x = b\r\n          .selectAll('.tick')\r\n          .data(h, n)\r\n          .order(),\r\n        w = x.exit(),\r\n        M = x\r\n          .enter()\r\n          .append('g')\r\n          .attr('class', 'tick'),\r\n        N = x.select('line'),\r\n        A = x.select('text')\r\n      ;(m = m.merge(\r\n        m\r\n          .enter()\r\n          .insert('path', '.tick')\r\n          .attr('class', 'domain')\r\n          .attr('stroke', 'currentColor')\r\n      )),\r\n        (x = x.merge(M)),\r\n        (N = N.merge(\r\n          M.append('line')\r\n            .attr('stroke', 'currentColor')\r\n            .attr(f + '2', c * o)\r\n        )),\r\n        (A = A.merge(\r\n          M.append('text')\r\n            .attr('fill', 'currentColor')\r\n            .attr(f, c * p)\r\n            .attr('dy', t === z ? '0em' : t === D ? '0.71em' : '0.32em')\r\n        )),\r\n        l !== b &&\r\n          ((m = m.transition(l)),\r\n          (x = x.transition(l)),\r\n          (N = N.transition(l)),\r\n          (A = A.transition(l)),\r\n          (w = w\r\n            .transition(l)\r\n            .attr('opacity', L)\r\n            .attr('transform', function (t) {\r\n              return isFinite((t = _(t))) ? s(t) : this.getAttribute('transform')\r\n            })),\r\n          M.attr('opacity', L).attr('transform', function (t) {\r\n            var n = this.parentNode.__axis\r\n            return s(n && isFinite((n = n(t))) ? n : _(t))\r\n          })),\r\n        w.remove(),\r\n        m.attr(\r\n          'd',\r\n          t === q || t == R\r\n            ? a\r\n              ? 'M' + c * a + ',' + g + 'H0.5V' + y + 'H' + c * a\r\n              : 'M0.5,' + g + 'V' + y\r\n            : a\r\n            ? 'M' + g + ',' + c * a + 'V0.5H' + y + 'V' + c * a\r\n            : 'M' + g + ',0.5H' + y\r\n        ),\r\n        x.attr('opacity', 1).attr('transform', function (t) {\r\n          return s(_(t))\r\n        }),\r\n        N.attr(f + '2', c * o),\r\n        A.attr(f, c * p).text(d),\r\n        b\r\n          .filter(B)\r\n          .attr('fill', 'none')\r\n          .attr('font-size', 10)\r\n          .attr('font-family', 'sans-serif')\r\n          .attr('text-anchor', t === R ? 'start' : t === q ? 'end' : 'middle'),\r\n        b.each(function () {\r\n          this.__axis = _\r\n        })\r\n    }\r\n    return (\r\n      (l.scale = function (t) {\r\n        return arguments.length ? ((n = t), l) : n\r\n      }),\r\n      (l.ticks = function () {\r\n        return (e = C.call(arguments)), l\r\n      }),\r\n      (l.tickArguments = function (t) {\r\n        return arguments.length ? ((e = null == t ? [] : C.call(t)), l) : e.slice()\r\n      }),\r\n      (l.tickValues = function (t) {\r\n        return arguments.length ? ((r = null == t ? null : C.call(t)), l) : r && r.slice()\r\n      }),\r\n      (l.tickFormat = function (t) {\r\n        return arguments.length ? ((i = t), l) : i\r\n      }),\r\n      (l.tickSize = function (t) {\r\n        return arguments.length ? ((o = a = +t), l) : o\r\n      }),\r\n      (l.tickSizeInner = function (t) {\r\n        return arguments.length ? ((o = +t), l) : o\r\n      }),\r\n      (l.tickSizeOuter = function (t) {\r\n        return arguments.length ? ((a = +t), l) : a\r\n      }),\r\n      (l.tickPadding = function (t) {\r\n        return arguments.length ? ((u = +t), l) : u\r\n      }),\r\n      l\r\n    )\r\n  }\r\n  var F = { value: function () {} }\r\n  function I () {\r\n    for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) {\r\n      if (!(t = arguments[n] + '') || t in r) throw new Error('illegal type: ' + t)\r\n      r[t] = []\r\n    }\r\n    return new j(r)\r\n  }\r\n  function j (t) {\r\n    this._ = t\r\n  }\r\n  function H (t, n) {\r\n    for (var e, r = 0, i = t.length; r < i; ++r) if ((e = t[r]).name === n) return e.value\r\n  }\r\n  function X (t, n, e) {\r\n    for (var r = 0, i = t.length; r < i; ++r)\r\n      if (t[r].name === n) {\r\n        ;(t[r] = F), (t = t.slice(0, r).concat(t.slice(r + 1)))\r\n        break\r\n      }\r\n    return null != e && t.push({ name: n, value: e }), t\r\n  }\r\n  j.prototype = I.prototype = {\r\n    constructor: j,\r\n    on: function (t, n) {\r\n      var e,\r\n        r,\r\n        i = this._,\r\n        o = ((r = i),\r\n        (t + '')\r\n          .trim()\r\n          .split(/^|\\s+/)\r\n          .map(function (t) {\r\n            var n = '',\r\n              e = t.indexOf('.')\r\n            if ((e >= 0 && ((n = t.slice(e + 1)), (t = t.slice(0, e))), t && !r.hasOwnProperty(t)))\r\n              throw new Error('unknown type: ' + t)\r\n            return { type: t, name: n }\r\n          })),\r\n        a = -1,\r\n        u = o.length\r\n      if (!(arguments.length < 2)) {\r\n        if (null != n && 'function' != typeof n) throw new Error('invalid callback: ' + n)\r\n        for (; ++a < u; )\r\n          if ((e = (t = o[a]).type)) i[e] = X(i[e], t.name, n)\r\n          else if (null == n) for (e in i) i[e] = X(i[e], t.name, null)\r\n        return this\r\n      }\r\n      for (; ++a < u; ) if ((e = (t = o[a]).type) && (e = H(i[e], t.name))) return e\r\n    },\r\n    copy: function () {\r\n      var t = {},\r\n        n = this._\r\n      for (var e in n) t[e] = n[e].slice()\r\n      return new j(t)\r\n    },\r\n    call: function (t, n) {\r\n      if ((e = arguments.length - 2) > 0) for (var e, r, i = new Array(e), o = 0; o < e; ++o) i[o] = arguments[o + 2]\r\n      if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t)\r\n      for (o = 0, e = (r = this._[t]).length; o < e; ++o) r[o].value.apply(n, i)\r\n    },\r\n    apply: function (t, n, e) {\r\n      if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t)\r\n      for (var r = this._[t], i = 0, o = r.length; i < o; ++i) r[i].value.apply(n, e)\r\n    }\r\n  }\r\n  var G = 'http://www.w3.org/1999/xhtml',\r\n    V = {\r\n      svg: 'http://www.w3.org/2000/svg',\r\n      xhtml: G,\r\n      xlink: 'http://www.w3.org/1999/xlink',\r\n      xml: 'http://www.w3.org/XML/1998/namespace',\r\n      xmlns: 'http://www.w3.org/2000/xmlns/'\r\n    }\r\n  function $ (t) {\r\n    var n = (t += ''),\r\n      e = n.indexOf(':')\r\n    return (\r\n      e >= 0 && 'xmlns' !== (n = t.slice(0, e)) && (t = t.slice(e + 1)),\r\n      V.hasOwnProperty(n) ? { space: V[n], local: t } : t\r\n    )\r\n  }\r\n  function W (t) {\r\n    var n = $(t)\r\n    return (n.local\r\n      ? function (t) {\r\n          return function () {\r\n            return this.ownerDocument.createElementNS(t.space, t.local)\r\n          }\r\n        }\r\n      : function (t) {\r\n          return function () {\r\n            var n = this.ownerDocument,\r\n              e = this.namespaceURI\r\n            return e === G && n.documentElement.namespaceURI === G ? n.createElement(t) : n.createElementNS(e, t)\r\n          }\r\n        })(n)\r\n  }\r\n  function Z () {}\r\n  function Q (t) {\r\n    return null == t\r\n      ? Z\r\n      : function () {\r\n          return this.querySelector(t)\r\n        }\r\n  }\r\n  function J () {\r\n    return []\r\n  }\r\n  function K (t) {\r\n    return null == t\r\n      ? J\r\n      : function () {\r\n          return this.querySelectorAll(t)\r\n        }\r\n  }\r\n  function tt (t) {\r\n    return function () {\r\n      return this.matches(t)\r\n    }\r\n  }\r\n  function nt (t) {\r\n    return new Array(t.length)\r\n  }\r\n  function et (t, n) {\r\n    ;(this.ownerDocument = t.ownerDocument),\r\n      (this.namespaceURI = t.namespaceURI),\r\n      (this._next = null),\r\n      (this._parent = t),\r\n      (this.__data__ = n)\r\n  }\r\n  et.prototype = {\r\n    constructor: et,\r\n    appendChild: function (t) {\r\n      return this._parent.insertBefore(t, this._next)\r\n    },\r\n    insertBefore: function (t, n) {\r\n      return this._parent.insertBefore(t, n)\r\n    },\r\n    querySelector: function (t) {\r\n      return this._parent.querySelector(t)\r\n    },\r\n    querySelectorAll: function (t) {\r\n      return this._parent.querySelectorAll(t)\r\n    }\r\n  }\r\n  var rt = '$'\r\n  function it (t, n, e, r, i, o) {\r\n    for (var a, u = 0, c = n.length, f = o.length; u < f; ++u)\r\n      (a = n[u]) ? ((a.__data__ = o[u]), (r[u] = a)) : (e[u] = new et(t, o[u]))\r\n    for (; u < c; ++u) (a = n[u]) && (i[u] = a)\r\n  }\r\n  function ot (t, n, e, r, i, o, a) {\r\n    var u,\r\n      c,\r\n      f,\r\n      s = {},\r\n      l = n.length,\r\n      h = o.length,\r\n      d = new Array(l)\r\n    for (u = 0; u < l; ++u)\r\n      (c = n[u]) && ((d[u] = f = rt + a.call(c, c.__data__, u, n)), f in s ? (i[u] = c) : (s[f] = c))\r\n    for (u = 0; u < h; ++u)\r\n      (c = s[(f = rt + a.call(t, o[u], u, o))])\r\n        ? ((r[u] = c), (c.__data__ = o[u]), (s[f] = null))\r\n        : (e[u] = new et(t, o[u]))\r\n    for (u = 0; u < l; ++u) (c = n[u]) && s[d[u]] === c && (i[u] = c)\r\n  }\r\n  function at (t, n) {\r\n    return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN\r\n  }\r\n  function ut (t) {\r\n    return (t.ownerDocument && t.ownerDocument.defaultView) || (t.document && t) || t.defaultView\r\n  }\r\n  function ct (t, n) {\r\n    return (\r\n      t.style.getPropertyValue(n) ||\r\n      ut(t)\r\n        .getComputedStyle(t, null)\r\n        .getPropertyValue(n)\r\n    )\r\n  }\r\n  function ft (t) {\r\n    return t.trim().split(/^|\\s+/)\r\n  }\r\n  function st (t) {\r\n    return t.classList || new lt(t)\r\n  }\r\n  function lt (t) {\r\n    ;(this._node = t), (this._names = ft(t.getAttribute('class') || ''))\r\n  }\r\n  function ht (t, n) {\r\n    for (var e = st(t), r = -1, i = n.length; ++r < i; ) e.add(n[r])\r\n  }\r\n  function dt (t, n) {\r\n    for (var e = st(t), r = -1, i = n.length; ++r < i; ) e.remove(n[r])\r\n  }\r\n  function pt () {\r\n    this.textContent = ''\r\n  }\r\n  function vt () {\r\n    this.innerHTML = ''\r\n  }\r\n  function gt () {\r\n    this.nextSibling && this.parentNode.appendChild(this)\r\n  }\r\n  function yt () {\r\n    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)\r\n  }\r\n  function _t () {\r\n    return null\r\n  }\r\n  function bt () {\r\n    var t = this.parentNode\r\n    t && t.removeChild(this)\r\n  }\r\n  function mt () {\r\n    return this.parentNode.insertBefore(this.cloneNode(!1), this.nextSibling)\r\n  }\r\n  function xt () {\r\n    return this.parentNode.insertBefore(this.cloneNode(!0), this.nextSibling)\r\n  }\r\n  lt.prototype = {\r\n    add: function (t) {\r\n      this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute('class', this._names.join(' ')))\r\n    },\r\n    remove: function (t) {\r\n      var n = this._names.indexOf(t)\r\n      n >= 0 && (this._names.splice(n, 1), this._node.setAttribute('class', this._names.join(' ')))\r\n    },\r\n    contains: function (t) {\r\n      return this._names.indexOf(t) >= 0\r\n    }\r\n  }\r\n  var wt = {}\r\n  ;((t.event = null), 'undefined' != typeof document) &&\r\n    ('onmouseenter' in document.documentElement || (wt = { mouseenter: 'mouseover', mouseleave: 'mouseout' }))\r\n  function Mt (t, n, e) {\r\n    return (\r\n      (t = Nt(t, n, e)),\r\n      function (n) {\r\n        var e = n.relatedTarget\r\n        ;(e && (e === this || 8 & e.compareDocumentPosition(this))) || t.call(this, n)\r\n      }\r\n    )\r\n  }\r\n  function Nt (n, e, r) {\r\n    return function (i) {\r\n      var o = t.event\r\n      t.event = i\r\n      try {\r\n        n.call(this, this.__data__, e, r)\r\n      } finally {\r\n        t.event = o\r\n      }\r\n    }\r\n  }\r\n  function At (t) {\r\n    return function () {\r\n      var n = this.__on\r\n      if (n) {\r\n        for (var e, r = 0, i = -1, o = n.length; r < o; ++r)\r\n          (e = n[r]),\r\n            (t.type && e.type !== t.type) || e.name !== t.name\r\n              ? (n[++i] = e)\r\n              : this.removeEventListener(e.type, e.listener, e.capture)\r\n        ++i ? (n.length = i) : delete this.__on\r\n      }\r\n    }\r\n  }\r\n  function St (t, n, e) {\r\n    var r = wt.hasOwnProperty(t.type) ? Mt : Nt\r\n    return function (i, o, a) {\r\n      var u,\r\n        c = this.__on,\r\n        f = r(n, o, a)\r\n      if (c)\r\n        for (var s = 0, l = c.length; s < l; ++s)\r\n          if ((u = c[s]).type === t.type && u.name === t.name)\r\n            return (\r\n              this.removeEventListener(u.type, u.listener, u.capture),\r\n              this.addEventListener(u.type, (u.listener = f), (u.capture = e)),\r\n              void (u.value = n)\r\n            )\r\n      this.addEventListener(t.type, f, e),\r\n        (u = { type: t.type, name: t.name, value: n, listener: f, capture: e }),\r\n        c ? c.push(u) : (this.__on = [u])\r\n    }\r\n  }\r\n  function kt (n, e, r, i) {\r\n    var o = t.event\r\n    ;(n.sourceEvent = t.event), (t.event = n)\r\n    try {\r\n      return e.apply(r, i)\r\n    } finally {\r\n      t.event = o\r\n    }\r\n  }\r\n  function Tt (t, n, e) {\r\n    var r = ut(t),\r\n      i = r.CustomEvent\r\n    'function' == typeof i\r\n      ? (i = new i(n, e))\r\n      : ((i = r.document.createEvent('Event')),\r\n        e ? (i.initEvent(n, e.bubbles, e.cancelable), (i.detail = e.detail)) : i.initEvent(n, !1, !1)),\r\n      t.dispatchEvent(i)\r\n  }\r\n  var Et = [null]\r\n  function Ct (t, n) {\r\n    ;(this._groups = t), (this._parents = n)\r\n  }\r\n  function Pt () {\r\n    return new Ct([[document.documentElement]], Et)\r\n  }\r\n  function zt (t) {\r\n    return 'string' == typeof t ? new Ct([[document.querySelector(t)]], [document.documentElement]) : new Ct([[t]], Et)\r\n  }\r\n  Ct.prototype = Pt.prototype = {\r\n    constructor: Ct,\r\n    select: function (t) {\r\n      'function' != typeof t && (t = Q(t))\r\n      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)\r\n        for (var o, a, u = n[i], c = u.length, f = (r[i] = new Array(c)), s = 0; s < c; ++s)\r\n          (o = u[s]) && (a = t.call(o, o.__data__, s, u)) && ('__data__' in o && (a.__data__ = o.__data__), (f[s] = a))\r\n      return new Ct(r, this._parents)\r\n    },\r\n    selectAll: function (t) {\r\n      'function' != typeof t && (t = K(t))\r\n      for (var n = this._groups, e = n.length, r = [], i = [], o = 0; o < e; ++o)\r\n        for (var a, u = n[o], c = u.length, f = 0; f < c; ++f)\r\n          (a = u[f]) && (r.push(t.call(a, a.__data__, f, u)), i.push(a))\r\n      return new Ct(r, i)\r\n    },\r\n    filter: function (t) {\r\n      'function' != typeof t && (t = tt(t))\r\n      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)\r\n        for (var o, a = n[i], u = a.length, c = (r[i] = []), f = 0; f < u; ++f)\r\n          (o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o)\r\n      return new Ct(r, this._parents)\r\n    },\r\n    data: function (t, n) {\r\n      if (!t)\r\n        return (\r\n          (p = new Array(this.size())),\r\n          (s = -1),\r\n          this.each(function (t) {\r\n            p[++s] = t\r\n          }),\r\n          p\r\n        )\r\n      var e,\r\n        r = n ? ot : it,\r\n        i = this._parents,\r\n        o = this._groups\r\n      'function' != typeof t &&\r\n        ((e = t),\r\n        (t = function () {\r\n          return e\r\n        }))\r\n      for (var a = o.length, u = new Array(a), c = new Array(a), f = new Array(a), s = 0; s < a; ++s) {\r\n        var l = i[s],\r\n          h = o[s],\r\n          d = h.length,\r\n          p = t.call(l, l && l.__data__, s, i),\r\n          v = p.length,\r\n          g = (c[s] = new Array(v)),\r\n          y = (u[s] = new Array(v))\r\n        r(l, h, g, y, (f[s] = new Array(d)), p, n)\r\n        for (var _, b, m = 0, x = 0; m < v; ++m)\r\n          if ((_ = g[m])) {\r\n            for (m >= x && (x = m + 1); !(b = y[x]) && ++x < v; );\r\n            _._next = b || null\r\n          }\r\n      }\r\n      return ((u = new Ct(u, i))._enter = c), (u._exit = f), u\r\n    },\r\n    enter: function () {\r\n      return new Ct(this._enter || this._groups.map(nt), this._parents)\r\n    },\r\n    exit: function () {\r\n      return new Ct(this._exit || this._groups.map(nt), this._parents)\r\n    },\r\n    join: function (t, n, e) {\r\n      var r = this.enter(),\r\n        i = this,\r\n        o = this.exit()\r\n      return (\r\n        (r = 'function' == typeof t ? t(r) : r.append(t + '')),\r\n        null != n && (i = n(i)),\r\n        null == e ? o.remove() : e(o),\r\n        r && i ? r.merge(i).order() : i\r\n      )\r\n    },\r\n    merge: function (t) {\r\n      for (\r\n        var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), a = new Array(r), u = 0;\r\n        u < o;\r\n        ++u\r\n      )\r\n        for (var c, f = n[u], s = e[u], l = f.length, h = (a[u] = new Array(l)), d = 0; d < l; ++d)\r\n          (c = f[d] || s[d]) && (h[d] = c)\r\n      for (; u < r; ++u) a[u] = n[u]\r\n      return new Ct(a, this._parents)\r\n    },\r\n    order: function () {\r\n      for (var t = this._groups, n = -1, e = t.length; ++n < e; )\r\n        for (var r, i = t[n], o = i.length - 1, a = i[o]; --o >= 0; )\r\n          (r = i[o]) && (a && 4 ^ r.compareDocumentPosition(a) && a.parentNode.insertBefore(r, a), (a = r))\r\n      return this\r\n    },\r\n    sort: function (t) {\r\n      function n (n, e) {\r\n        return n && e ? t(n.__data__, e.__data__) : !n - !e\r\n      }\r\n      t || (t = at)\r\n      for (var e = this._groups, r = e.length, i = new Array(r), o = 0; o < r; ++o) {\r\n        for (var a, u = e[o], c = u.length, f = (i[o] = new Array(c)), s = 0; s < c; ++s) (a = u[s]) && (f[s] = a)\r\n        f.sort(n)\r\n      }\r\n      return new Ct(i, this._parents).order()\r\n    },\r\n    call: function () {\r\n      var t = arguments[0]\r\n      return (arguments[0] = this), t.apply(null, arguments), this\r\n    },\r\n    nodes: function () {\r\n      var t = new Array(this.size()),\r\n        n = -1\r\n      return (\r\n        this.each(function () {\r\n          t[++n] = this\r\n        }),\r\n        t\r\n      )\r\n    },\r\n    node: function () {\r\n      for (var t = this._groups, n = 0, e = t.length; n < e; ++n)\r\n        for (var r = t[n], i = 0, o = r.length; i < o; ++i) {\r\n          var a = r[i]\r\n          if (a) return a\r\n        }\r\n      return null\r\n    },\r\n    size: function () {\r\n      var t = 0\r\n      return (\r\n        this.each(function () {\r\n          ++t\r\n        }),\r\n        t\r\n      )\r\n    },\r\n    empty: function () {\r\n      return !this.node()\r\n    },\r\n    each: function (t) {\r\n      for (var n = this._groups, e = 0, r = n.length; e < r; ++e)\r\n        for (var i, o = n[e], a = 0, u = o.length; a < u; ++a) (i = o[a]) && t.call(i, i.__data__, a, o)\r\n      return this\r\n    },\r\n    attr: function (t, n) {\r\n      var e = $(t)\r\n      if (arguments.length < 2) {\r\n        var r = this.node()\r\n        return e.local ? r.getAttributeNS(e.space, e.local) : r.getAttribute(e)\r\n      }\r\n      return this.each(\r\n        (null == n\r\n          ? e.local\r\n            ? function (t) {\r\n                return function () {\r\n                  this.removeAttributeNS(t.space, t.local)\r\n                }\r\n              }\r\n            : function (t) {\r\n                return function () {\r\n                  this.removeAttribute(t)\r\n                }\r\n              }\r\n          : 'function' == typeof n\r\n          ? e.local\r\n            ? function (t, n) {\r\n                return function () {\r\n                  var e = n.apply(this, arguments)\r\n                  null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e)\r\n                }\r\n              }\r\n            : function (t, n) {\r\n                return function () {\r\n                  var e = n.apply(this, arguments)\r\n                  null == e ? this.removeAttribute(t) : this.setAttribute(t, e)\r\n                }\r\n              }\r\n          : e.local\r\n          ? function (t, n) {\r\n              return function () {\r\n                this.setAttributeNS(t.space, t.local, n)\r\n              }\r\n            }\r\n          : function (t, n) {\r\n              return function () {\r\n                this.setAttribute(t, n)\r\n              }\r\n            })(e, n)\r\n      )\r\n    },\r\n    style: function (t, n, e) {\r\n      return arguments.length > 1\r\n        ? this.each(\r\n            (null == n\r\n              ? function (t) {\r\n                  return function () {\r\n                    this.style.removeProperty(t)\r\n                  }\r\n                }\r\n              : 'function' == typeof n\r\n              ? function (t, n, e) {\r\n                  return function () {\r\n                    var r = n.apply(this, arguments)\r\n                    null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, e)\r\n                  }\r\n                }\r\n              : function (t, n, e) {\r\n                  return function () {\r\n                    this.style.setProperty(t, n, e)\r\n                  }\r\n                })(t, n, null == e ? '' : e)\r\n          )\r\n        : ct(this.node(), t)\r\n    },\r\n    property: function (t, n) {\r\n      return arguments.length > 1\r\n        ? this.each(\r\n            (null == n\r\n              ? function (t) {\r\n                  return function () {\r\n                    delete this[t]\r\n                  }\r\n                }\r\n              : 'function' == typeof n\r\n              ? function (t, n) {\r\n                  return function () {\r\n                    var e = n.apply(this, arguments)\r\n                    null == e ? delete this[t] : (this[t] = e)\r\n                  }\r\n                }\r\n              : function (t, n) {\r\n                  return function () {\r\n                    this[t] = n\r\n                  }\r\n                })(t, n)\r\n          )\r\n        : this.node()[t]\r\n    },\r\n    classed: function (t, n) {\r\n      var e = ft(t + '')\r\n      if (arguments.length < 2) {\r\n        for (var r = st(this.node()), i = -1, o = e.length; ++i < o; ) if (!r.contains(e[i])) return !1\r\n        return !0\r\n      }\r\n      return this.each(\r\n        ('function' == typeof n\r\n          ? function (t, n) {\r\n              return function () {\r\n                ;(n.apply(this, arguments) ? ht : dt)(this, t)\r\n              }\r\n            }\r\n          : n\r\n          ? function (t) {\r\n              return function () {\r\n                ht(this, t)\r\n              }\r\n            }\r\n          : function (t) {\r\n              return function () {\r\n                dt(this, t)\r\n              }\r\n            })(e, n)\r\n      )\r\n    },\r\n    text: function (t) {\r\n      return arguments.length\r\n        ? this.each(\r\n            null == t\r\n              ? pt\r\n              : ('function' == typeof t\r\n                  ? function (t) {\r\n                      return function () {\r\n                        var n = t.apply(this, arguments)\r\n                        this.textContent = null == n ? '' : n\r\n                      }\r\n                    }\r\n                  : function (t) {\r\n                      return function () {\r\n                        this.textContent = t\r\n                      }\r\n                    })(t)\r\n          )\r\n        : this.node().textContent\r\n    },\r\n    html: function (t) {\r\n      return arguments.length\r\n        ? this.each(\r\n            null == t\r\n              ? vt\r\n              : ('function' == typeof t\r\n                  ? function (t) {\r\n                      return function () {\r\n                        var n = t.apply(this, arguments)\r\n                        this.innerHTML = null == n ? '' : n\r\n                      }\r\n                    }\r\n                  : function (t) {\r\n                      return function () {\r\n                        this.innerHTML = t\r\n                      }\r\n                    })(t)\r\n          )\r\n        : this.node().innerHTML\r\n    },\r\n    raise: function () {\r\n      return this.each(gt)\r\n    },\r\n    lower: function () {\r\n      return this.each(yt)\r\n    },\r\n    append: function (t) {\r\n      var n = 'function' == typeof t ? t : W(t)\r\n      return this.select(function () {\r\n        return this.appendChild(n.apply(this, arguments))\r\n      })\r\n    },\r\n    insert: function (t, n) {\r\n      var e = 'function' == typeof t ? t : W(t),\r\n        r = null == n ? _t : 'function' == typeof n ? n : Q(n)\r\n      return this.select(function () {\r\n        return this.insertBefore(e.apply(this, arguments), r.apply(this, arguments) || null)\r\n      })\r\n    },\r\n    remove: function () {\r\n      return this.each(bt)\r\n    },\r\n    clone: function (t) {\r\n      return this.select(t ? xt : mt)\r\n    },\r\n    datum: function (t) {\r\n      return arguments.length ? this.property('__data__', t) : this.node().__data__\r\n    },\r\n    on: function (t, n, e) {\r\n      var r,\r\n        i,\r\n        o = (function (t) {\r\n          return t\r\n            .trim()\r\n            .split(/^|\\s+/)\r\n            .map(function (t) {\r\n              var n = '',\r\n                e = t.indexOf('.')\r\n              return e >= 0 && ((n = t.slice(e + 1)), (t = t.slice(0, e))), { type: t, name: n }\r\n            })\r\n        })(t + ''),\r\n        a = o.length\r\n      if (!(arguments.length < 2)) {\r\n        for (u = n ? St : At, null == e && (e = !1), r = 0; r < a; ++r) this.each(u(o[r], n, e))\r\n        return this\r\n      }\r\n      var u = this.node().__on\r\n      if (u)\r\n        for (var c, f = 0, s = u.length; f < s; ++f)\r\n          for (r = 0, c = u[f]; r < a; ++r) if ((i = o[r]).type === c.type && i.name === c.name) return c.value\r\n    },\r\n    dispatch: function (t, n) {\r\n      return this.each(\r\n        ('function' == typeof n\r\n          ? function (t, n) {\r\n              return function () {\r\n                return Tt(this, t, n.apply(this, arguments))\r\n              }\r\n            }\r\n          : function (t, n) {\r\n              return function () {\r\n                return Tt(this, t, n)\r\n              }\r\n            })(t, n)\r\n      )\r\n    }\r\n  }\r\n  var Rt = 0\r\n  function Dt () {\r\n    return new qt()\r\n  }\r\n  function qt () {\r\n    this._ = '@' + (++Rt).toString(36)\r\n  }\r\n  function Lt () {\r\n    for (var n, e = t.event; (n = e.sourceEvent); ) e = n\r\n    return e\r\n  }\r\n  function Ut (t, n) {\r\n    var e = t.ownerSVGElement || t\r\n    if (e.createSVGPoint) {\r\n      var r = e.createSVGPoint()\r\n      return (r.x = n.clientX), (r.y = n.clientY), [(r = r.matrixTransform(t.getScreenCTM().inverse())).x, r.y]\r\n    }\r\n    var i = t.getBoundingClientRect()\r\n    return [n.clientX - i.left - t.clientLeft, n.clientY - i.top - t.clientTop]\r\n  }\r\n  function Ot (t) {\r\n    var n = Lt()\r\n    return n.changedTouches && (n = n.changedTouches[0]), Ut(t, n)\r\n  }\r\n  function Bt (t, n, e) {\r\n    arguments.length < 3 && ((e = n), (n = Lt().changedTouches))\r\n    for (var r, i = 0, o = n ? n.length : 0; i < o; ++i) if ((r = n[i]).identifier === e) return Ut(t, r)\r\n    return null\r\n  }\r\n  function Yt () {\r\n    t.event.stopImmediatePropagation()\r\n  }\r\n  function Ft () {\r\n    t.event.preventDefault(), t.event.stopImmediatePropagation()\r\n  }\r\n  function It (t) {\r\n    var n = t.document.documentElement,\r\n      e = zt(t).on('dragstart.drag', Ft, !0)\r\n    'onselectstart' in n\r\n      ? e.on('selectstart.drag', Ft, !0)\r\n      : ((n.__noselect = n.style.MozUserSelect), (n.style.MozUserSelect = 'none'))\r\n  }\r\n  function jt (t, n) {\r\n    var e = t.document.documentElement,\r\n      r = zt(t).on('dragstart.drag', null)\r\n    n &&\r\n      (r.on('click.drag', Ft, !0),\r\n      setTimeout(function () {\r\n        r.on('click.drag', null)\r\n      }, 0)),\r\n      'onselectstart' in e\r\n        ? r.on('selectstart.drag', null)\r\n        : ((e.style.MozUserSelect = e.__noselect), delete e.__noselect)\r\n  }\r\n  function Ht (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function Xt (t, n, e, r, i, o, a, u, c, f) {\r\n    ;(this.target = t),\r\n      (this.type = n),\r\n      (this.subject = e),\r\n      (this.identifier = r),\r\n      (this.active = i),\r\n      (this.x = o),\r\n      (this.y = a),\r\n      (this.dx = u),\r\n      (this.dy = c),\r\n      (this._ = f)\r\n  }\r\n  function Gt () {\r\n    return !t.event.button\r\n  }\r\n  function Vt () {\r\n    return this.parentNode\r\n  }\r\n  function $t (n) {\r\n    return null == n ? { x: t.event.x, y: t.event.y } : n\r\n  }\r\n  function Wt () {\r\n    return 'ontouchstart' in this\r\n  }\r\n  function Zt (t, n, e) {\r\n    ;(t.prototype = n.prototype = e), (e.constructor = t)\r\n  }\r\n  function Qt (t, n) {\r\n    var e = Object.create(t.prototype)\r\n    for (var r in n) e[r] = n[r]\r\n    return e\r\n  }\r\n  function Jt () {}\r\n  ;(qt.prototype = Dt.prototype = {\r\n    constructor: qt,\r\n    get: function (t) {\r\n      for (var n = this._; !(n in t); ) if (!(t = t.parentNode)) return\r\n      return t[n]\r\n    },\r\n    set: function (t, n) {\r\n      return (t[this._] = n)\r\n    },\r\n    remove: function (t) {\r\n      return this._ in t && delete t[this._]\r\n    },\r\n    toString: function () {\r\n      return this._\r\n    }\r\n  }),\r\n    (Xt.prototype.on = function () {\r\n      var t = this._.on.apply(this._, arguments)\r\n      return t === this._ ? this : t\r\n    })\r\n  var Kt = '\\\\s*([+-]?\\\\d+)\\\\s*',\r\n    tn = '\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*',\r\n    nn = '\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*',\r\n    en = /^#([0-9a-f]{3})$/,\r\n    rn = /^#([0-9a-f]{6})$/,\r\n    on = new RegExp('^rgb\\\\(' + [Kt, Kt, Kt] + '\\\\)$'),\r\n    an = new RegExp('^rgb\\\\(' + [nn, nn, nn] + '\\\\)$'),\r\n    un = new RegExp('^rgba\\\\(' + [Kt, Kt, Kt, tn] + '\\\\)$'),\r\n    cn = new RegExp('^rgba\\\\(' + [nn, nn, nn, tn] + '\\\\)$'),\r\n    fn = new RegExp('^hsl\\\\(' + [tn, nn, nn] + '\\\\)$'),\r\n    sn = new RegExp('^hsla\\\\(' + [tn, nn, nn, tn] + '\\\\)$'),\r\n    ln = {\r\n      aliceblue: 15792383,\r\n      antiquewhite: 16444375,\r\n      aqua: 65535,\r\n      aquamarine: 8388564,\r\n      azure: 15794175,\r\n      beige: 16119260,\r\n      bisque: 16770244,\r\n      black: 0,\r\n      blanchedalmond: 16772045,\r\n      blue: 255,\r\n      blueviolet: 9055202,\r\n      brown: 10824234,\r\n      burlywood: 14596231,\r\n      cadetblue: 6266528,\r\n      chartreuse: 8388352,\r\n      chocolate: 13789470,\r\n      coral: 16744272,\r\n      cornflowerblue: 6591981,\r\n      cornsilk: 16775388,\r\n      crimson: 14423100,\r\n      cyan: 65535,\r\n      darkblue: 139,\r\n      darkcyan: 35723,\r\n      darkgoldenrod: 12092939,\r\n      darkgray: 11119017,\r\n      darkgreen: 25600,\r\n      darkgrey: 11119017,\r\n      darkkhaki: 12433259,\r\n      darkmagenta: 9109643,\r\n      darkolivegreen: 5597999,\r\n      darkorange: 16747520,\r\n      darkorchid: 10040012,\r\n      darkred: 9109504,\r\n      darksalmon: 15308410,\r\n      darkseagreen: 9419919,\r\n      darkslateblue: 4734347,\r\n      darkslategray: 3100495,\r\n      darkslategrey: 3100495,\r\n      darkturquoise: 52945,\r\n      darkviolet: 9699539,\r\n      deeppink: 16716947,\r\n      deepskyblue: 49151,\r\n      dimgray: 6908265,\r\n      dimgrey: 6908265,\r\n      dodgerblue: 2003199,\r\n      firebrick: 11674146,\r\n      floralwhite: 16775920,\r\n      forestgreen: 2263842,\r\n      fuchsia: 16711935,\r\n      gainsboro: 14474460,\r\n      ghostwhite: 16316671,\r\n      gold: 16766720,\r\n      goldenrod: 14329120,\r\n      gray: 8421504,\r\n      green: 32768,\r\n      greenyellow: 11403055,\r\n      grey: 8421504,\r\n      honeydew: 15794160,\r\n      hotpink: 16738740,\r\n      indianred: 13458524,\r\n      indigo: 4915330,\r\n      ivory: 16777200,\r\n      khaki: 15787660,\r\n      lavender: 15132410,\r\n      lavenderblush: 16773365,\r\n      lawngreen: 8190976,\r\n      lemonchiffon: 16775885,\r\n      lightblue: 11393254,\r\n      lightcoral: 15761536,\r\n      lightcyan: 14745599,\r\n      lightgoldenrodyellow: 16448210,\r\n      lightgray: 13882323,\r\n      lightgreen: 9498256,\r\n      lightgrey: 13882323,\r\n      lightpink: 16758465,\r\n      lightsalmon: 16752762,\r\n      lightseagreen: 2142890,\r\n      lightskyblue: 8900346,\r\n      lightslategray: 7833753,\r\n      lightslategrey: 7833753,\r\n      lightsteelblue: 11584734,\r\n      lightyellow: 16777184,\r\n      lime: 65280,\r\n      limegreen: 3329330,\r\n      linen: 16445670,\r\n      magenta: 16711935,\r\n      maroon: 8388608,\r\n      mediumaquamarine: 6737322,\r\n      mediumblue: 205,\r\n      mediumorchid: 12211667,\r\n      mediumpurple: 9662683,\r\n      mediumseagreen: 3978097,\r\n      mediumslateblue: 8087790,\r\n      mediumspringgreen: 64154,\r\n      mediumturquoise: 4772300,\r\n      mediumvioletred: 13047173,\r\n      midnightblue: 1644912,\r\n      mintcream: 16121850,\r\n      mistyrose: 16770273,\r\n      moccasin: 16770229,\r\n      navajowhite: 16768685,\r\n      navy: 128,\r\n      oldlace: 16643558,\r\n      olive: 8421376,\r\n      olivedrab: 7048739,\r\n      orange: 16753920,\r\n      orangered: 16729344,\r\n      orchid: 14315734,\r\n      palegoldenrod: 15657130,\r\n      palegreen: 10025880,\r\n      paleturquoise: 11529966,\r\n      palevioletred: 14381203,\r\n      papayawhip: 16773077,\r\n      peachpuff: 16767673,\r\n      peru: 13468991,\r\n      pink: 16761035,\r\n      plum: 14524637,\r\n      powderblue: 11591910,\r\n      purple: 8388736,\r\n      rebeccapurple: 6697881,\r\n      red: 16711680,\r\n      rosybrown: 12357519,\r\n      royalblue: 4286945,\r\n      saddlebrown: 9127187,\r\n      salmon: 16416882,\r\n      sandybrown: 16032864,\r\n      seagreen: 3050327,\r\n      seashell: 16774638,\r\n      sienna: 10506797,\r\n      silver: 12632256,\r\n      skyblue: 8900331,\r\n      slateblue: 6970061,\r\n      slategray: 7372944,\r\n      slategrey: 7372944,\r\n      snow: 16775930,\r\n      springgreen: 65407,\r\n      steelblue: 4620980,\r\n      tan: 13808780,\r\n      teal: 32896,\r\n      thistle: 14204888,\r\n      tomato: 16737095,\r\n      turquoise: 4251856,\r\n      violet: 15631086,\r\n      wheat: 16113331,\r\n      white: 16777215,\r\n      whitesmoke: 16119285,\r\n      yellow: 16776960,\r\n      yellowgreen: 10145074\r\n    }\r\n  function hn (t) {\r\n    var n\r\n    return (\r\n      (t = (t + '').trim().toLowerCase()),\r\n      (n = en.exec(t))\r\n        ? new yn(\r\n            (((n = parseInt(n[1], 16)) >> 8) & 15) | ((n >> 4) & 240),\r\n            ((n >> 4) & 15) | (240 & n),\r\n            ((15 & n) << 4) | (15 & n),\r\n            1\r\n          )\r\n        : (n = rn.exec(t))\r\n        ? dn(parseInt(n[1], 16))\r\n        : (n = on.exec(t))\r\n        ? new yn(n[1], n[2], n[3], 1)\r\n        : (n = an.exec(t))\r\n        ? new yn((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, 1)\r\n        : (n = un.exec(t))\r\n        ? pn(n[1], n[2], n[3], n[4])\r\n        : (n = cn.exec(t))\r\n        ? pn((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, n[4])\r\n        : (n = fn.exec(t))\r\n        ? bn(n[1], n[2] / 100, n[3] / 100, 1)\r\n        : (n = sn.exec(t))\r\n        ? bn(n[1], n[2] / 100, n[3] / 100, n[4])\r\n        : ln.hasOwnProperty(t)\r\n        ? dn(ln[t])\r\n        : 'transparent' === t\r\n        ? new yn(NaN, NaN, NaN, 0)\r\n        : null\r\n    )\r\n  }\r\n  function dn (t) {\r\n    return new yn((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1)\r\n  }\r\n  function pn (t, n, e, r) {\r\n    return r <= 0 && (t = n = e = NaN), new yn(t, n, e, r)\r\n  }\r\n  function vn (t) {\r\n    return t instanceof Jt || (t = hn(t)), t ? new yn((t = t.rgb()).r, t.g, t.b, t.opacity) : new yn()\r\n  }\r\n  function gn (t, n, e, r) {\r\n    return 1 === arguments.length ? vn(t) : new yn(t, n, e, null == r ? 1 : r)\r\n  }\r\n  function yn (t, n, e, r) {\r\n    ;(this.r = +t), (this.g = +n), (this.b = +e), (this.opacity = +r)\r\n  }\r\n  function _n (t) {\r\n    return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? '0' : '') + t.toString(16)\r\n  }\r\n  function bn (t, n, e, r) {\r\n    return r <= 0 ? (t = n = e = NaN) : e <= 0 || e >= 1 ? (t = n = NaN) : n <= 0 && (t = NaN), new xn(t, n, e, r)\r\n  }\r\n  function mn (t, n, e, r) {\r\n    return 1 === arguments.length\r\n      ? (function (t) {\r\n          if (t instanceof xn) return new xn(t.h, t.s, t.l, t.opacity)\r\n          if ((t instanceof Jt || (t = hn(t)), !t)) return new xn()\r\n          if (t instanceof xn) return t\r\n          var n = (t = t.rgb()).r / 255,\r\n            e = t.g / 255,\r\n            r = t.b / 255,\r\n            i = Math.min(n, e, r),\r\n            o = Math.max(n, e, r),\r\n            a = NaN,\r\n            u = o - i,\r\n            c = (o + i) / 2\r\n          return (\r\n            u\r\n              ? ((a = n === o ? (e - r) / u + 6 * (e < r) : e === o ? (r - n) / u + 2 : (n - e) / u + 4),\r\n                (u /= c < 0.5 ? o + i : 2 - o - i),\r\n                (a *= 60))\r\n              : (u = c > 0 && c < 1 ? 0 : a),\r\n            new xn(a, u, c, t.opacity)\r\n          )\r\n        })(t)\r\n      : new xn(t, n, e, null == r ? 1 : r)\r\n  }\r\n  function xn (t, n, e, r) {\r\n    ;(this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +r)\r\n  }\r\n  function wn (t, n, e) {\r\n    return 255 * (t < 60 ? n + ((e - n) * t) / 60 : t < 180 ? e : t < 240 ? n + ((e - n) * (240 - t)) / 60 : n)\r\n  }\r\n  Zt(Jt, hn, {\r\n    displayable: function () {\r\n      return this.rgb().displayable()\r\n    },\r\n    hex: function () {\r\n      return this.rgb().hex()\r\n    },\r\n    toString: function () {\r\n      return this.rgb() + ''\r\n    }\r\n  }),\r\n    Zt(\r\n      yn,\r\n      gn,\r\n      Qt(Jt, {\r\n        brighter: function (t) {\r\n          return (\r\n            (t = null == t ? 1 / 0.7 : Math.pow(1 / 0.7, t)), new yn(this.r * t, this.g * t, this.b * t, this.opacity)\r\n          )\r\n        },\r\n        darker: function (t) {\r\n          return (t = null == t ? 0.7 : Math.pow(0.7, t)), new yn(this.r * t, this.g * t, this.b * t, this.opacity)\r\n        },\r\n        rgb: function () {\r\n          return this\r\n        },\r\n        displayable: function () {\r\n          return (\r\n            0 <= this.r &&\r\n            this.r <= 255 &&\r\n            0 <= this.g &&\r\n            this.g <= 255 &&\r\n            0 <= this.b &&\r\n            this.b <= 255 &&\r\n            0 <= this.opacity &&\r\n            this.opacity <= 1\r\n          )\r\n        },\r\n        hex: function () {\r\n          return '#' + _n(this.r) + _n(this.g) + _n(this.b)\r\n        },\r\n        toString: function () {\r\n          var t = this.opacity\r\n          return (\r\n            (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? 'rgb(' : 'rgba(') +\r\n            Math.max(0, Math.min(255, Math.round(this.r) || 0)) +\r\n            ', ' +\r\n            Math.max(0, Math.min(255, Math.round(this.g) || 0)) +\r\n            ', ' +\r\n            Math.max(0, Math.min(255, Math.round(this.b) || 0)) +\r\n            (1 === t ? ')' : ', ' + t + ')')\r\n          )\r\n        }\r\n      })\r\n    ),\r\n    Zt(\r\n      xn,\r\n      mn,\r\n      Qt(Jt, {\r\n        brighter: function (t) {\r\n          return (t = null == t ? 1 / 0.7 : Math.pow(1 / 0.7, t)), new xn(this.h, this.s, this.l * t, this.opacity)\r\n        },\r\n        darker: function (t) {\r\n          return (t = null == t ? 0.7 : Math.pow(0.7, t)), new xn(this.h, this.s, this.l * t, this.opacity)\r\n        },\r\n        rgb: function () {\r\n          var t = (this.h % 360) + 360 * (this.h < 0),\r\n            n = isNaN(t) || isNaN(this.s) ? 0 : this.s,\r\n            e = this.l,\r\n            r = e + (e < 0.5 ? e : 1 - e) * n,\r\n            i = 2 * e - r\r\n          return new yn(\r\n            wn(t >= 240 ? t - 240 : t + 120, i, r),\r\n            wn(t, i, r),\r\n            wn(t < 120 ? t + 240 : t - 120, i, r),\r\n            this.opacity\r\n          )\r\n        },\r\n        displayable: function () {\r\n          return (\r\n            ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&\r\n            0 <= this.l &&\r\n            this.l <= 1 &&\r\n            0 <= this.opacity &&\r\n            this.opacity <= 1\r\n          )\r\n        }\r\n      })\r\n    )\r\n  var Mn = Math.PI / 180,\r\n    Nn = 180 / Math.PI,\r\n    An = 0.96422,\r\n    Sn = 1,\r\n    kn = 0.82521,\r\n    Tn = 4 / 29,\r\n    En = 6 / 29,\r\n    Cn = 3 * En * En,\r\n    Pn = En * En * En\r\n  function zn (t) {\r\n    if (t instanceof Dn) return new Dn(t.l, t.a, t.b, t.opacity)\r\n    if (t instanceof Fn) {\r\n      if (isNaN(t.h)) return new Dn(t.l, 0, 0, t.opacity)\r\n      var n = t.h * Mn\r\n      return new Dn(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity)\r\n    }\r\n    t instanceof yn || (t = vn(t))\r\n    var e,\r\n      r,\r\n      i = On(t.r),\r\n      o = On(t.g),\r\n      a = On(t.b),\r\n      u = qn((0.2225045 * i + 0.7168786 * o + 0.0606169 * a) / Sn)\r\n    return (\r\n      i === o && o === a\r\n        ? (e = r = u)\r\n        : ((e = qn((0.4360747 * i + 0.3850649 * o + 0.1430804 * a) / An)),\r\n          (r = qn((0.0139322 * i + 0.0971045 * o + 0.7141733 * a) / kn))),\r\n      new Dn(116 * u - 16, 500 * (e - u), 200 * (u - r), t.opacity)\r\n    )\r\n  }\r\n  function Rn (t, n, e, r) {\r\n    return 1 === arguments.length ? zn(t) : new Dn(t, n, e, null == r ? 1 : r)\r\n  }\r\n  function Dn (t, n, e, r) {\r\n    ;(this.l = +t), (this.a = +n), (this.b = +e), (this.opacity = +r)\r\n  }\r\n  function qn (t) {\r\n    return t > Pn ? Math.pow(t, 1 / 3) : t / Cn + Tn\r\n  }\r\n  function Ln (t) {\r\n    return t > En ? t * t * t : Cn * (t - Tn)\r\n  }\r\n  function Un (t) {\r\n    return 255 * (t <= 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055)\r\n  }\r\n  function On (t) {\r\n    return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4)\r\n  }\r\n  function Bn (t) {\r\n    if (t instanceof Fn) return new Fn(t.h, t.c, t.l, t.opacity)\r\n    if ((t instanceof Dn || (t = zn(t)), 0 === t.a && 0 === t.b)) return new Fn(NaN, 0, t.l, t.opacity)\r\n    var n = Math.atan2(t.b, t.a) * Nn\r\n    return new Fn(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity)\r\n  }\r\n  function Yn (t, n, e, r) {\r\n    return 1 === arguments.length ? Bn(t) : new Fn(t, n, e, null == r ? 1 : r)\r\n  }\r\n  function Fn (t, n, e, r) {\r\n    ;(this.h = +t), (this.c = +n), (this.l = +e), (this.opacity = +r)\r\n  }\r\n  Zt(\r\n    Dn,\r\n    Rn,\r\n    Qt(Jt, {\r\n      brighter: function (t) {\r\n        return new Dn(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)\r\n      },\r\n      darker: function (t) {\r\n        return new Dn(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)\r\n      },\r\n      rgb: function () {\r\n        var t = (this.l + 16) / 116,\r\n          n = isNaN(this.a) ? t : t + this.a / 500,\r\n          e = isNaN(this.b) ? t : t - this.b / 200\r\n        return new yn(\r\n          Un(3.1338561 * (n = An * Ln(n)) - 1.6168667 * (t = Sn * Ln(t)) - 0.4906146 * (e = kn * Ln(e))),\r\n          Un(-0.9787684 * n + 1.9161415 * t + 0.033454 * e),\r\n          Un(0.0719453 * n - 0.2289914 * t + 1.4052427 * e),\r\n          this.opacity\r\n        )\r\n      }\r\n    })\r\n  ),\r\n    Zt(\r\n      Fn,\r\n      Yn,\r\n      Qt(Jt, {\r\n        brighter: function (t) {\r\n          return new Fn(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity)\r\n        },\r\n        darker: function (t) {\r\n          return new Fn(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity)\r\n        },\r\n        rgb: function () {\r\n          return zn(this).rgb()\r\n        }\r\n      })\r\n    )\r\n  var In = -0.14861,\r\n    jn = 1.78277,\r\n    Hn = -0.29227,\r\n    Xn = -0.90649,\r\n    Gn = 1.97294,\r\n    Vn = Gn * Xn,\r\n    $n = Gn * jn,\r\n    Wn = jn * Hn - Xn * In\r\n  function Zn (t, n, e, r) {\r\n    return 1 === arguments.length\r\n      ? (function (t) {\r\n          if (t instanceof Qn) return new Qn(t.h, t.s, t.l, t.opacity)\r\n          t instanceof yn || (t = vn(t))\r\n          var n = t.r / 255,\r\n            e = t.g / 255,\r\n            r = t.b / 255,\r\n            i = (Wn * r + Vn * n - $n * e) / (Wn + Vn - $n),\r\n            o = r - i,\r\n            a = (Gn * (e - i) - Hn * o) / Xn,\r\n            u = Math.sqrt(a * a + o * o) / (Gn * i * (1 - i)),\r\n            c = u ? Math.atan2(a, o) * Nn - 120 : NaN\r\n          return new Qn(c < 0 ? c + 360 : c, u, i, t.opacity)\r\n        })(t)\r\n      : new Qn(t, n, e, null == r ? 1 : r)\r\n  }\r\n  function Qn (t, n, e, r) {\r\n    ;(this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +r)\r\n  }\r\n  function Jn (t, n, e, r, i) {\r\n    var o = t * t,\r\n      a = o * t\r\n    return ((1 - 3 * t + 3 * o - a) * n + (4 - 6 * o + 3 * a) * e + (1 + 3 * t + 3 * o - 3 * a) * r + a * i) / 6\r\n  }\r\n  function Kn (t) {\r\n    var n = t.length - 1\r\n    return function (e) {\r\n      var r = e <= 0 ? (e = 0) : e >= 1 ? ((e = 1), n - 1) : Math.floor(e * n),\r\n        i = t[r],\r\n        o = t[r + 1],\r\n        a = r > 0 ? t[r - 1] : 2 * i - o,\r\n        u = r < n - 1 ? t[r + 2] : 2 * o - i\r\n      return Jn((e - r / n) * n, a, i, o, u)\r\n    }\r\n  }\r\n  function te (t) {\r\n    var n = t.length\r\n    return function (e) {\r\n      var r = Math.floor(((e %= 1) < 0 ? ++e : e) * n),\r\n        i = t[(r + n - 1) % n],\r\n        o = t[r % n],\r\n        a = t[(r + 1) % n],\r\n        u = t[(r + 2) % n]\r\n      return Jn((e - r / n) * n, i, o, a, u)\r\n    }\r\n  }\r\n  function ne (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function ee (t, n) {\r\n    return function (e) {\r\n      return t + e * n\r\n    }\r\n  }\r\n  function re (t, n) {\r\n    var e = n - t\r\n    return e ? ee(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : ne(isNaN(t) ? n : t)\r\n  }\r\n  function ie (t) {\r\n    return 1 == (t = +t)\r\n      ? oe\r\n      : function (n, e) {\r\n          return e - n\r\n            ? (function (t, n, e) {\r\n                return (\r\n                  (t = Math.pow(t, e)),\r\n                  (n = Math.pow(n, e) - t),\r\n                  (e = 1 / e),\r\n                  function (r) {\r\n                    return Math.pow(t + r * n, e)\r\n                  }\r\n                )\r\n              })(n, e, t)\r\n            : ne(isNaN(n) ? e : n)\r\n        }\r\n  }\r\n  function oe (t, n) {\r\n    var e = n - t\r\n    return e ? ee(t, e) : ne(isNaN(t) ? n : t)\r\n  }\r\n  Zt(\r\n    Qn,\r\n    Zn,\r\n    Qt(Jt, {\r\n      brighter: function (t) {\r\n        return (t = null == t ? 1 / 0.7 : Math.pow(1 / 0.7, t)), new Qn(this.h, this.s, this.l * t, this.opacity)\r\n      },\r\n      darker: function (t) {\r\n        return (t = null == t ? 0.7 : Math.pow(0.7, t)), new Qn(this.h, this.s, this.l * t, this.opacity)\r\n      },\r\n      rgb: function () {\r\n        var t = isNaN(this.h) ? 0 : (this.h + 120) * Mn,\r\n          n = +this.l,\r\n          e = isNaN(this.s) ? 0 : this.s * n * (1 - n),\r\n          r = Math.cos(t),\r\n          i = Math.sin(t)\r\n        return new yn(\r\n          255 * (n + e * (In * r + jn * i)),\r\n          255 * (n + e * (Hn * r + Xn * i)),\r\n          255 * (n + e * (Gn * r)),\r\n          this.opacity\r\n        )\r\n      }\r\n    })\r\n  )\r\n  var ae = (function t (n) {\r\n    var e = ie(n)\r\n    function r (t, n) {\r\n      var r = e((t = gn(t)).r, (n = gn(n)).r),\r\n        i = e(t.g, n.g),\r\n        o = e(t.b, n.b),\r\n        a = oe(t.opacity, n.opacity)\r\n      return function (n) {\r\n        return (t.r = r(n)), (t.g = i(n)), (t.b = o(n)), (t.opacity = a(n)), t + ''\r\n      }\r\n    }\r\n    return (r.gamma = t), r\r\n  })(1)\r\n  function ue (t) {\r\n    return function (n) {\r\n      var e,\r\n        r,\r\n        i = n.length,\r\n        o = new Array(i),\r\n        a = new Array(i),\r\n        u = new Array(i)\r\n      for (e = 0; e < i; ++e) (r = gn(n[e])), (o[e] = r.r || 0), (a[e] = r.g || 0), (u[e] = r.b || 0)\r\n      return (\r\n        (o = t(o)),\r\n        (a = t(a)),\r\n        (u = t(u)),\r\n        (r.opacity = 1),\r\n        function (t) {\r\n          return (r.r = o(t)), (r.g = a(t)), (r.b = u(t)), r + ''\r\n        }\r\n      )\r\n    }\r\n  }\r\n  var ce = ue(Kn),\r\n    fe = ue(te)\r\n  function se (t, n) {\r\n    var e,\r\n      r = n ? n.length : 0,\r\n      i = t ? Math.min(r, t.length) : 0,\r\n      o = new Array(i),\r\n      a = new Array(r)\r\n    for (e = 0; e < i; ++e) o[e] = ye(t[e], n[e])\r\n    for (; e < r; ++e) a[e] = n[e]\r\n    return function (t) {\r\n      for (e = 0; e < i; ++e) a[e] = o[e](t)\r\n      return a\r\n    }\r\n  }\r\n  function le (t, n) {\r\n    var e = new Date()\r\n    return (\r\n      (n -= t = +t),\r\n      function (r) {\r\n        return e.setTime(t + n * r), e\r\n      }\r\n    )\r\n  }\r\n  function he (t, n) {\r\n    return (\r\n      (n -= t = +t),\r\n      function (e) {\r\n        return t + n * e\r\n      }\r\n    )\r\n  }\r\n  function de (t, n) {\r\n    var e,\r\n      r = {},\r\n      i = {}\r\n    for (e in ((null !== t && 'object' == typeof t) || (t = {}), (null !== n && 'object' == typeof n) || (n = {}), n))\r\n      e in t ? (r[e] = ye(t[e], n[e])) : (i[e] = n[e])\r\n    return function (t) {\r\n      for (e in r) i[e] = r[e](t)\r\n      return i\r\n    }\r\n  }\r\n  var pe = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\r\n    ve = new RegExp(pe.source, 'g')\r\n  function ge (t, n) {\r\n    var e,\r\n      r,\r\n      i,\r\n      o = (pe.lastIndex = ve.lastIndex = 0),\r\n      a = -1,\r\n      u = [],\r\n      c = []\r\n    for (t += '', n += ''; (e = pe.exec(t)) && (r = ve.exec(n)); )\r\n      (i = r.index) > o && ((i = n.slice(o, i)), u[a] ? (u[a] += i) : (u[++a] = i)),\r\n        (e = e[0]) === (r = r[0])\r\n          ? u[a]\r\n            ? (u[a] += r)\r\n            : (u[++a] = r)\r\n          : ((u[++a] = null), c.push({ i: a, x: he(e, r) })),\r\n        (o = ve.lastIndex)\r\n    return (\r\n      o < n.length && ((i = n.slice(o)), u[a] ? (u[a] += i) : (u[++a] = i)),\r\n      u.length < 2\r\n        ? c[0]\r\n          ? (function (t) {\r\n              return function (n) {\r\n                return t(n) + ''\r\n              }\r\n            })(c[0].x)\r\n          : (function (t) {\r\n              return function () {\r\n                return t\r\n              }\r\n            })(n)\r\n        : ((n = c.length),\r\n          function (t) {\r\n            for (var e, r = 0; r < n; ++r) u[(e = c[r]).i] = e.x(t)\r\n            return u.join('')\r\n          })\r\n    )\r\n  }\r\n  function ye (t, n) {\r\n    var e,\r\n      r = typeof n\r\n    return null == n || 'boolean' === r\r\n      ? ne(n)\r\n      : ('number' === r\r\n          ? he\r\n          : 'string' === r\r\n          ? (e = hn(n))\r\n            ? ((n = e), ae)\r\n            : ge\r\n          : n instanceof hn\r\n          ? ae\r\n          : n instanceof Date\r\n          ? le\r\n          : Array.isArray(n)\r\n          ? se\r\n          : ('function' != typeof n.valueOf && 'function' != typeof n.toString) || isNaN(n)\r\n          ? de\r\n          : he)(t, n)\r\n  }\r\n  function _e (t, n) {\r\n    return (\r\n      (n -= t = +t),\r\n      function (e) {\r\n        return Math.round(t + n * e)\r\n      }\r\n    )\r\n  }\r\n  var be,\r\n    me,\r\n    xe,\r\n    we,\r\n    Me = 180 / Math.PI,\r\n    Ne = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }\r\n  function Ae (t, n, e, r, i, o) {\r\n    var a, u, c\r\n    return (\r\n      (a = Math.sqrt(t * t + n * n)) && ((t /= a), (n /= a)),\r\n      (c = t * e + n * r) && ((e -= t * c), (r -= n * c)),\r\n      (u = Math.sqrt(e * e + r * r)) && ((e /= u), (r /= u), (c /= u)),\r\n      t * r < n * e && ((t = -t), (n = -n), (c = -c), (a = -a)),\r\n      { translateX: i, translateY: o, rotate: Math.atan2(n, t) * Me, skewX: Math.atan(c) * Me, scaleX: a, scaleY: u }\r\n    )\r\n  }\r\n  function Se (t, n, e, r) {\r\n    function i (t) {\r\n      return t.length ? t.pop() + ' ' : ''\r\n    }\r\n    return function (o, a) {\r\n      var u = [],\r\n        c = []\r\n      return (\r\n        (o = t(o)),\r\n        (a = t(a)),\r\n        (function (t, r, i, o, a, u) {\r\n          if (t !== i || r !== o) {\r\n            var c = a.push('translate(', null, n, null, e)\r\n            u.push({ i: c - 4, x: he(t, i) }, { i: c - 2, x: he(r, o) })\r\n          } else (i || o) && a.push('translate(' + i + n + o + e)\r\n        })(o.translateX, o.translateY, a.translateX, a.translateY, u, c),\r\n        (function (t, n, e, o) {\r\n          t !== n\r\n            ? (t - n > 180 ? (n += 360) : n - t > 180 && (t += 360),\r\n              o.push({ i: e.push(i(e) + 'rotate(', null, r) - 2, x: he(t, n) }))\r\n            : n && e.push(i(e) + 'rotate(' + n + r)\r\n        })(o.rotate, a.rotate, u, c),\r\n        (function (t, n, e, o) {\r\n          t !== n\r\n            ? o.push({ i: e.push(i(e) + 'skewX(', null, r) - 2, x: he(t, n) })\r\n            : n && e.push(i(e) + 'skewX(' + n + r)\r\n        })(o.skewX, a.skewX, u, c),\r\n        (function (t, n, e, r, o, a) {\r\n          if (t !== e || n !== r) {\r\n            var u = o.push(i(o) + 'scale(', null, ',', null, ')')\r\n            a.push({ i: u - 4, x: he(t, e) }, { i: u - 2, x: he(n, r) })\r\n          } else (1 === e && 1 === r) || o.push(i(o) + 'scale(' + e + ',' + r + ')')\r\n        })(o.scaleX, o.scaleY, a.scaleX, a.scaleY, u, c),\r\n        (o = a = null),\r\n        function (t) {\r\n          for (var n, e = -1, r = c.length; ++e < r; ) u[(n = c[e]).i] = n.x(t)\r\n          return u.join('')\r\n        }\r\n      )\r\n    }\r\n  }\r\n  var ke = Se(\r\n      function (t) {\r\n        return 'none' === t\r\n          ? Ne\r\n          : (be || ((be = document.createElement('DIV')), (me = document.documentElement), (xe = document.defaultView)),\r\n            (be.style.transform = t),\r\n            (t = xe.getComputedStyle(me.appendChild(be), null).getPropertyValue('transform')),\r\n            me.removeChild(be),\r\n            Ae(+(t = t.slice(7, -1).split(','))[0], +t[1], +t[2], +t[3], +t[4], +t[5]))\r\n      },\r\n      'px, ',\r\n      'px)',\r\n      'deg)'\r\n    ),\r\n    Te = Se(\r\n      function (t) {\r\n        return null == t\r\n          ? Ne\r\n          : (we || (we = document.createElementNS('http://www.w3.org/2000/svg', 'g')),\r\n            we.setAttribute('transform', t),\r\n            (t = we.transform.baseVal.consolidate()) ? Ae((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : Ne)\r\n      },\r\n      ', ',\r\n      ')',\r\n      ')'\r\n    ),\r\n    Ee = Math.SQRT2,\r\n    Ce = 2,\r\n    Pe = 4,\r\n    ze = 1e-12\r\n  function Re (t) {\r\n    return ((t = Math.exp(t)) + 1 / t) / 2\r\n  }\r\n  function De (t, n) {\r\n    var e,\r\n      r,\r\n      i = t[0],\r\n      o = t[1],\r\n      a = t[2],\r\n      u = n[0],\r\n      c = n[1],\r\n      f = n[2],\r\n      s = u - i,\r\n      l = c - o,\r\n      h = s * s + l * l\r\n    if (h < ze)\r\n      (r = Math.log(f / a) / Ee),\r\n        (e = function (t) {\r\n          return [i + t * s, o + t * l, a * Math.exp(Ee * t * r)]\r\n        })\r\n    else {\r\n      var d = Math.sqrt(h),\r\n        p = (f * f - a * a + Pe * h) / (2 * a * Ce * d),\r\n        v = (f * f - a * a - Pe * h) / (2 * f * Ce * d),\r\n        g = Math.log(Math.sqrt(p * p + 1) - p),\r\n        y = Math.log(Math.sqrt(v * v + 1) - v)\r\n      ;(r = (y - g) / Ee),\r\n        (e = function (t) {\r\n          var n,\r\n            e = t * r,\r\n            u = Re(g),\r\n            c =\r\n              (a / (Ce * d)) *\r\n              (u * ((n = Ee * e + g), ((n = Math.exp(2 * n)) - 1) / (n + 1)) -\r\n                (function (t) {\r\n                  return ((t = Math.exp(t)) - 1 / t) / 2\r\n                })(g))\r\n          return [i + c * s, o + c * l, (a * u) / Re(Ee * e + g)]\r\n        })\r\n    }\r\n    return (e.duration = 1e3 * r), e\r\n  }\r\n  function qe (t) {\r\n    return function (n, e) {\r\n      var r = t((n = mn(n)).h, (e = mn(e)).h),\r\n        i = oe(n.s, e.s),\r\n        o = oe(n.l, e.l),\r\n        a = oe(n.opacity, e.opacity)\r\n      return function (t) {\r\n        return (n.h = r(t)), (n.s = i(t)), (n.l = o(t)), (n.opacity = a(t)), n + ''\r\n      }\r\n    }\r\n  }\r\n  var Le = qe(re),\r\n    Ue = qe(oe)\r\n  function Oe (t) {\r\n    return function (n, e) {\r\n      var r = t((n = Yn(n)).h, (e = Yn(e)).h),\r\n        i = oe(n.c, e.c),\r\n        o = oe(n.l, e.l),\r\n        a = oe(n.opacity, e.opacity)\r\n      return function (t) {\r\n        return (n.h = r(t)), (n.c = i(t)), (n.l = o(t)), (n.opacity = a(t)), n + ''\r\n      }\r\n    }\r\n  }\r\n  var Be = Oe(re),\r\n    Ye = Oe(oe)\r\n  function Fe (t) {\r\n    return (function n (e) {\r\n      function r (n, r) {\r\n        var i = t((n = Zn(n)).h, (r = Zn(r)).h),\r\n          o = oe(n.s, r.s),\r\n          a = oe(n.l, r.l),\r\n          u = oe(n.opacity, r.opacity)\r\n        return function (t) {\r\n          return (n.h = i(t)), (n.s = o(t)), (n.l = a(Math.pow(t, e))), (n.opacity = u(t)), n + ''\r\n        }\r\n      }\r\n      return (e = +e), (r.gamma = n), r\r\n    })(1)\r\n  }\r\n  var Ie = Fe(re),\r\n    je = Fe(oe)\r\n  var He,\r\n    Xe,\r\n    Ge = 0,\r\n    Ve = 0,\r\n    $e = 0,\r\n    We = 1e3,\r\n    Ze = 0,\r\n    Qe = 0,\r\n    Je = 0,\r\n    Ke = 'object' == typeof performance && performance.now ? performance : Date,\r\n    tr =\r\n      'object' == typeof window && window.requestAnimationFrame\r\n        ? window.requestAnimationFrame.bind(window)\r\n        : function (t) {\r\n            setTimeout(t, 17)\r\n          }\r\n  function nr () {\r\n    return Qe || (tr(er), (Qe = Ke.now() + Je))\r\n  }\r\n  function er () {\r\n    Qe = 0\r\n  }\r\n  function rr () {\r\n    this._call = this._time = this._next = null\r\n  }\r\n  function ir (t, n, e) {\r\n    var r = new rr()\r\n    return r.restart(t, n, e), r\r\n  }\r\n  function or () {\r\n    nr(), ++Ge\r\n    for (var t, n = He; n; ) (t = Qe - n._time) >= 0 && n._call.call(null, t), (n = n._next)\r\n    --Ge\r\n  }\r\n  function ar () {\r\n    ;(Qe = (Ze = Ke.now()) + Je), (Ge = Ve = 0)\r\n    try {\r\n      or()\r\n    } finally {\r\n      ;(Ge = 0),\r\n        (function () {\r\n          var t,\r\n            n,\r\n            e = He,\r\n            r = 1 / 0\r\n          for (; e; )\r\n            e._call\r\n              ? (r > e._time && (r = e._time), (t = e), (e = e._next))\r\n              : ((n = e._next), (e._next = null), (e = t ? (t._next = n) : (He = n)))\r\n          ;(Xe = t), cr(r)\r\n        })(),\r\n        (Qe = 0)\r\n    }\r\n  }\r\n  function ur () {\r\n    var t = Ke.now(),\r\n      n = t - Ze\r\n    n > We && ((Je -= n), (Ze = t))\r\n  }\r\n  function cr (t) {\r\n    Ge ||\r\n      (Ve && (Ve = clearTimeout(Ve)),\r\n      t - Qe > 24\r\n        ? (t < 1 / 0 && (Ve = setTimeout(ar, t - Ke.now() - Je)), $e && ($e = clearInterval($e)))\r\n        : ($e || ((Ze = Ke.now()), ($e = setInterval(ur, We))), (Ge = 1), tr(ar)))\r\n  }\r\n  function fr (t, n, e) {\r\n    var r = new rr()\r\n    return (\r\n      (n = null == n ? 0 : +n),\r\n      r.restart(\r\n        function (e) {\r\n          r.stop(), t(e + n)\r\n        },\r\n        n,\r\n        e\r\n      ),\r\n      r\r\n    )\r\n  }\r\n  rr.prototype = ir.prototype = {\r\n    constructor: rr,\r\n    restart: function (t, n, e) {\r\n      if ('function' != typeof t) throw new TypeError('callback is not a function')\r\n      ;(e = (null == e ? nr() : +e) + (null == n ? 0 : +n)),\r\n        this._next || Xe === this || (Xe ? (Xe._next = this) : (He = this), (Xe = this)),\r\n        (this._call = t),\r\n        (this._time = e),\r\n        cr()\r\n    },\r\n    stop: function () {\r\n      this._call && ((this._call = null), (this._time = 1 / 0), cr())\r\n    }\r\n  }\r\n  var sr = I('start', 'end', 'cancel', 'interrupt'),\r\n    lr = [],\r\n    hr = 0,\r\n    dr = 1,\r\n    pr = 2,\r\n    vr = 3,\r\n    gr = 4,\r\n    yr = 5,\r\n    _r = 6\r\n  function br (t, n, e, r, i, o) {\r\n    var a = t.__transition\r\n    if (a) {\r\n      if (e in a) return\r\n    } else t.__transition = {}\r\n    !(function (t, n, e) {\r\n      var r,\r\n        i = t.__transition\r\n      function o (c) {\r\n        var f, s, l, h\r\n        if (e.state !== dr) return u()\r\n        for (f in i)\r\n          if ((h = i[f]).name === e.name) {\r\n            if (h.state === vr) return fr(o)\r\n            h.state === gr\r\n              ? ((h.state = _r), h.timer.stop(), h.on.call('interrupt', t, t.__data__, h.index, h.group), delete i[f])\r\n              : +f < n &&\r\n                ((h.state = _r), h.timer.stop(), h.on.call('cancel', t, t.__data__, h.index, h.group), delete i[f])\r\n          }\r\n        if (\r\n          (fr(function () {\r\n            e.state === vr && ((e.state = gr), e.timer.restart(a, e.delay, e.time), a(c))\r\n          }),\r\n          (e.state = pr),\r\n          e.on.call('start', t, t.__data__, e.index, e.group),\r\n          e.state === pr)\r\n        ) {\r\n          for (e.state = vr, r = new Array((l = e.tween.length)), f = 0, s = -1; f < l; ++f)\r\n            (h = e.tween[f].value.call(t, t.__data__, e.index, e.group)) && (r[++s] = h)\r\n          r.length = s + 1\r\n        }\r\n      }\r\n      function a (n) {\r\n        for (\r\n          var i = n < e.duration ? e.ease.call(null, n / e.duration) : (e.timer.restart(u), (e.state = yr), 1),\r\n            o = -1,\r\n            a = r.length;\r\n          ++o < a;\r\n\r\n        )\r\n          r[o].call(t, i)\r\n        e.state === yr && (e.on.call('end', t, t.__data__, e.index, e.group), u())\r\n      }\r\n      function u () {\r\n        for (var r in ((e.state = _r), e.timer.stop(), delete i[n], i)) return\r\n        delete t.__transition\r\n      }\r\n      ;(i[n] = e),\r\n        (e.timer = ir(\r\n          function (t) {\r\n            ;(e.state = dr), e.timer.restart(o, e.delay, e.time), e.delay <= t && o(t - e.delay)\r\n          },\r\n          0,\r\n          e.time\r\n        ))\r\n    })(t, e, {\r\n      name: n,\r\n      index: r,\r\n      group: i,\r\n      on: sr,\r\n      tween: lr,\r\n      time: o.time,\r\n      delay: o.delay,\r\n      duration: o.duration,\r\n      ease: o.ease,\r\n      timer: null,\r\n      state: hr\r\n    })\r\n  }\r\n  function mr (t, n) {\r\n    var e = wr(t, n)\r\n    if (e.state > hr) throw new Error('too late; already scheduled')\r\n    return e\r\n  }\r\n  function xr (t, n) {\r\n    var e = wr(t, n)\r\n    if (e.state > vr) throw new Error('too late; already running')\r\n    return e\r\n  }\r\n  function wr (t, n) {\r\n    var e = t.__transition\r\n    if (!e || !(e = e[n])) throw new Error('transition not found')\r\n    return e\r\n  }\r\n  function Mr (t, n) {\r\n    var e,\r\n      r,\r\n      i,\r\n      o = t.__transition,\r\n      a = !0\r\n    if (o) {\r\n      for (i in ((n = null == n ? null : n + ''), o))\r\n        (e = o[i]).name === n\r\n          ? ((r = e.state > pr && e.state < yr),\r\n            (e.state = _r),\r\n            e.timer.stop(),\r\n            e.on.call(r ? 'interrupt' : 'cancel', t, t.__data__, e.index, e.group),\r\n            delete o[i])\r\n          : (a = !1)\r\n      a && delete t.__transition\r\n    }\r\n  }\r\n  function Nr (t, n, e) {\r\n    var r = t._id\r\n    return (\r\n      t.each(function () {\r\n        var t = xr(this, r)\r\n        ;(t.value || (t.value = {}))[n] = e.apply(this, arguments)\r\n      }),\r\n      function (t) {\r\n        return wr(t, r).value[n]\r\n      }\r\n    )\r\n  }\r\n  function Ar (t, n) {\r\n    var e\r\n    return ('number' == typeof n ? he : n instanceof hn ? ae : (e = hn(n)) ? ((n = e), ae) : ge)(t, n)\r\n  }\r\n  var Sr = Pt.prototype.constructor\r\n  function kr (t) {\r\n    return function () {\r\n      this.style.removeProperty(t)\r\n    }\r\n  }\r\n  var Tr = 0\r\n  function Er (t, n, e, r) {\r\n    ;(this._groups = t), (this._parents = n), (this._name = e), (this._id = r)\r\n  }\r\n  function Cr (t) {\r\n    return Pt().transition(t)\r\n  }\r\n  function Pr () {\r\n    return ++Tr\r\n  }\r\n  var zr = Pt.prototype\r\n  function Rr (t) {\r\n    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2\r\n  }\r\n  function Dr (t) {\r\n    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2\r\n  }\r\n  Er.prototype = Cr.prototype = {\r\n    constructor: Er,\r\n    select: function (t) {\r\n      var n = this._name,\r\n        e = this._id\r\n      'function' != typeof t && (t = Q(t))\r\n      for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a)\r\n        for (var u, c, f = r[a], s = f.length, l = (o[a] = new Array(s)), h = 0; h < s; ++h)\r\n          (u = f[h]) &&\r\n            (c = t.call(u, u.__data__, h, f)) &&\r\n            ('__data__' in u && (c.__data__ = u.__data__), (l[h] = c), br(l[h], n, e, h, l, wr(u, e)))\r\n      return new Er(o, this._parents, n, e)\r\n    },\r\n    selectAll: function (t) {\r\n      var n = this._name,\r\n        e = this._id\r\n      'function' != typeof t && (t = K(t))\r\n      for (var r = this._groups, i = r.length, o = [], a = [], u = 0; u < i; ++u)\r\n        for (var c, f = r[u], s = f.length, l = 0; l < s; ++l)\r\n          if ((c = f[l])) {\r\n            for (var h, d = t.call(c, c.__data__, l, f), p = wr(c, e), v = 0, g = d.length; v < g; ++v)\r\n              (h = d[v]) && br(h, n, e, v, d, p)\r\n            o.push(d), a.push(c)\r\n          }\r\n      return new Er(o, a, n, e)\r\n    },\r\n    filter: function (t) {\r\n      'function' != typeof t && (t = tt(t))\r\n      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)\r\n        for (var o, a = n[i], u = a.length, c = (r[i] = []), f = 0; f < u; ++f)\r\n          (o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o)\r\n      return new Er(r, this._parents, this._name, this._id)\r\n    },\r\n    merge: function (t) {\r\n      if (t._id !== this._id) throw new Error()\r\n      for (\r\n        var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), a = new Array(r), u = 0;\r\n        u < o;\r\n        ++u\r\n      )\r\n        for (var c, f = n[u], s = e[u], l = f.length, h = (a[u] = new Array(l)), d = 0; d < l; ++d)\r\n          (c = f[d] || s[d]) && (h[d] = c)\r\n      for (; u < r; ++u) a[u] = n[u]\r\n      return new Er(a, this._parents, this._name, this._id)\r\n    },\r\n    selection: function () {\r\n      return new Sr(this._groups, this._parents)\r\n    },\r\n    transition: function () {\r\n      for (var t = this._name, n = this._id, e = Pr(), r = this._groups, i = r.length, o = 0; o < i; ++o)\r\n        for (var a, u = r[o], c = u.length, f = 0; f < c; ++f)\r\n          if ((a = u[f])) {\r\n            var s = wr(a, n)\r\n            br(a, t, e, f, u, { time: s.time + s.delay + s.duration, delay: 0, duration: s.duration, ease: s.ease })\r\n          }\r\n      return new Er(r, this._parents, t, e)\r\n    },\r\n    call: zr.call,\r\n    nodes: zr.nodes,\r\n    node: zr.node,\r\n    size: zr.size,\r\n    empty: zr.empty,\r\n    each: zr.each,\r\n    on: function (t, n) {\r\n      var e = this._id\r\n      return arguments.length < 2\r\n        ? wr(this.node(), e).on.on(t)\r\n        : this.each(\r\n            (function (t, n, e) {\r\n              var r,\r\n                i,\r\n                o = (function (t) {\r\n                  return (t + '')\r\n                    .trim()\r\n                    .split(/^|\\s+/)\r\n                    .every(function (t) {\r\n                      var n = t.indexOf('.')\r\n                      return n >= 0 && (t = t.slice(0, n)), !t || 'start' === t\r\n                    })\r\n                })(n)\r\n                  ? mr\r\n                  : xr\r\n              return function () {\r\n                var a = o(this, t),\r\n                  u = a.on\r\n                u !== r && (i = (r = u).copy()).on(n, e), (a.on = i)\r\n              }\r\n            })(e, t, n)\r\n          )\r\n    },\r\n    attr: function (t, n) {\r\n      var e = $(t),\r\n        r = 'transform' === e ? Te : Ar\r\n      return this.attrTween(\r\n        t,\r\n        'function' == typeof n\r\n          ? (e.local\r\n              ? function (t, n, e) {\r\n                  var r, i, o\r\n                  return function () {\r\n                    var a,\r\n                      u,\r\n                      c = e(this)\r\n                    if (null != c)\r\n                      return (a = this.getAttributeNS(t.space, t.local)) === (u = c + '')\r\n                        ? null\r\n                        : a === r && u === i\r\n                        ? o\r\n                        : ((i = u), (o = n((r = a), c)))\r\n                    this.removeAttributeNS(t.space, t.local)\r\n                  }\r\n                }\r\n              : function (t, n, e) {\r\n                  var r, i, o\r\n                  return function () {\r\n                    var a,\r\n                      u,\r\n                      c = e(this)\r\n                    if (null != c)\r\n                      return (a = this.getAttribute(t)) === (u = c + '')\r\n                        ? null\r\n                        : a === r && u === i\r\n                        ? o\r\n                        : ((i = u), (o = n((r = a), c)))\r\n                    this.removeAttribute(t)\r\n                  }\r\n                })(e, r, Nr(this, 'attr.' + t, n))\r\n          : null == n\r\n          ? (e.local\r\n              ? function (t) {\r\n                  return function () {\r\n                    this.removeAttributeNS(t.space, t.local)\r\n                  }\r\n                }\r\n              : function (t) {\r\n                  return function () {\r\n                    this.removeAttribute(t)\r\n                  }\r\n                })(e)\r\n          : (e.local\r\n              ? function (t, n, e) {\r\n                  var r,\r\n                    i,\r\n                    o = e + ''\r\n                  return function () {\r\n                    var a = this.getAttributeNS(t.space, t.local)\r\n                    return a === o ? null : a === r ? i : (i = n((r = a), e))\r\n                  }\r\n                }\r\n              : function (t, n, e) {\r\n                  var r,\r\n                    i,\r\n                    o = e + ''\r\n                  return function () {\r\n                    var a = this.getAttribute(t)\r\n                    return a === o ? null : a === r ? i : (i = n((r = a), e))\r\n                  }\r\n                })(e, r, n)\r\n      )\r\n    },\r\n    attrTween: function (t, n) {\r\n      var e = 'attr.' + t\r\n      if (arguments.length < 2) return (e = this.tween(e)) && e._value\r\n      if (null == n) return this.tween(e, null)\r\n      if ('function' != typeof n) throw new Error()\r\n      var r = $(t)\r\n      return this.tween(\r\n        e,\r\n        (r.local\r\n          ? function (t, n) {\r\n              var e, r\r\n              function i () {\r\n                var i = n.apply(this, arguments)\r\n                return (\r\n                  i !== r &&\r\n                    (e =\r\n                      (r = i) &&\r\n                      (function (t, n) {\r\n                        return function (e) {\r\n                          this.setAttributeNS(t.space, t.local, n(e))\r\n                        }\r\n                      })(t, i)),\r\n                  e\r\n                )\r\n              }\r\n              return (i._value = n), i\r\n            }\r\n          : function (t, n) {\r\n              var e, r\r\n              function i () {\r\n                var i = n.apply(this, arguments)\r\n                return (\r\n                  i !== r &&\r\n                    (e =\r\n                      (r = i) &&\r\n                      (function (t, n) {\r\n                        return function (e) {\r\n                          this.setAttribute(t, n(e))\r\n                        }\r\n                      })(t, i)),\r\n                  e\r\n                )\r\n              }\r\n              return (i._value = n), i\r\n            })(r, n)\r\n      )\r\n    },\r\n    style: function (t, n, e) {\r\n      var r = 'transform' == (t += '') ? ke : Ar\r\n      return null == n\r\n        ? this.styleTween(\r\n            t,\r\n            (function (t, n) {\r\n              var e, r, i\r\n              return function () {\r\n                var o = ct(this, t),\r\n                  a = (this.style.removeProperty(t), ct(this, t))\r\n                return o === a ? null : o === e && a === r ? i : (i = n((e = o), (r = a)))\r\n              }\r\n            })(t, r)\r\n          ).on('end.style.' + t, kr(t))\r\n        : 'function' == typeof n\r\n        ? this.styleTween(\r\n            t,\r\n            (function (t, n, e) {\r\n              var r, i, o\r\n              return function () {\r\n                var a = ct(this, t),\r\n                  u = e(this),\r\n                  c = u + ''\r\n                return (\r\n                  null == u && (this.style.removeProperty(t), (c = u = ct(this, t))),\r\n                  a === c ? null : a === r && c === i ? o : ((i = c), (o = n((r = a), u)))\r\n                )\r\n              }\r\n            })(t, r, Nr(this, 'style.' + t, n))\r\n          ).each(\r\n            (function (t, n) {\r\n              var e,\r\n                r,\r\n                i,\r\n                o,\r\n                a = 'style.' + n,\r\n                u = 'end.' + a\r\n              return function () {\r\n                var c = xr(this, t),\r\n                  f = c.on,\r\n                  s = null == c.value[a] ? o || (o = kr(n)) : void 0\r\n                ;(f === e && i === s) || (r = (e = f).copy()).on(u, (i = s)), (c.on = r)\r\n              }\r\n            })(this._id, t)\r\n          )\r\n        : this.styleTween(\r\n            t,\r\n            (function (t, n, e) {\r\n              var r,\r\n                i,\r\n                o = e + ''\r\n              return function () {\r\n                var a = ct(this, t)\r\n                return a === o ? null : a === r ? i : (i = n((r = a), e))\r\n              }\r\n            })(t, r, n),\r\n            e\r\n          ).on('end.style.' + t, null)\r\n    },\r\n    styleTween: function (t, n, e) {\r\n      var r = 'style.' + (t += '')\r\n      if (arguments.length < 2) return (r = this.tween(r)) && r._value\r\n      if (null == n) return this.tween(r, null)\r\n      if ('function' != typeof n) throw new Error()\r\n      return this.tween(\r\n        r,\r\n        (function (t, n, e) {\r\n          var r, i\r\n          function o () {\r\n            var o = n.apply(this, arguments)\r\n            return (\r\n              o !== i &&\r\n                (r =\r\n                  (i = o) &&\r\n                  (function (t, n, e) {\r\n                    return function (r) {\r\n                      this.style.setProperty(t, n(r), e)\r\n                    }\r\n                  })(t, o, e)),\r\n              r\r\n            )\r\n          }\r\n          return (o._value = n), o\r\n        })(t, n, null == e ? '' : e)\r\n      )\r\n    },\r\n    text: function (t) {\r\n      return this.tween(\r\n        'text',\r\n        'function' == typeof t\r\n          ? (function (t) {\r\n              return function () {\r\n                var n = t(this)\r\n                this.textContent = null == n ? '' : n\r\n              }\r\n            })(Nr(this, 'text', t))\r\n          : (function (t) {\r\n              return function () {\r\n                this.textContent = t\r\n              }\r\n            })(null == t ? '' : t + '')\r\n      )\r\n    },\r\n    remove: function () {\r\n      return this.on(\r\n        'end.remove',\r\n        ((t = this._id),\r\n        function () {\r\n          var n = this.parentNode\r\n          for (var e in this.__transition) if (+e !== t) return\r\n          n && n.removeChild(this)\r\n        })\r\n      )\r\n      var t\r\n    },\r\n    tween: function (t, n) {\r\n      var e = this._id\r\n      if (((t += ''), arguments.length < 2)) {\r\n        for (var r, i = wr(this.node(), e).tween, o = 0, a = i.length; o < a; ++o)\r\n          if ((r = i[o]).name === t) return r.value\r\n        return null\r\n      }\r\n      return this.each(\r\n        (null == n\r\n          ? function (t, n) {\r\n              var e, r\r\n              return function () {\r\n                var i = xr(this, t),\r\n                  o = i.tween\r\n                if (o !== e)\r\n                  for (var a = 0, u = (r = e = o).length; a < u; ++a)\r\n                    if (r[a].name === n) {\r\n                      ;(r = r.slice()).splice(a, 1)\r\n                      break\r\n                    }\r\n                i.tween = r\r\n              }\r\n            }\r\n          : function (t, n, e) {\r\n              var r, i\r\n              if ('function' != typeof e) throw new Error()\r\n              return function () {\r\n                var o = xr(this, t),\r\n                  a = o.tween\r\n                if (a !== r) {\r\n                  i = (r = a).slice()\r\n                  for (var u = { name: n, value: e }, c = 0, f = i.length; c < f; ++c)\r\n                    if (i[c].name === n) {\r\n                      i[c] = u\r\n                      break\r\n                    }\r\n                  c === f && i.push(u)\r\n                }\r\n                o.tween = i\r\n              }\r\n            })(e, t, n)\r\n      )\r\n    },\r\n    delay: function (t) {\r\n      var n = this._id\r\n      return arguments.length\r\n        ? this.each(\r\n            ('function' == typeof t\r\n              ? function (t, n) {\r\n                  return function () {\r\n                    mr(this, t).delay = +n.apply(this, arguments)\r\n                  }\r\n                }\r\n              : function (t, n) {\r\n                  return (\r\n                    (n = +n),\r\n                    function () {\r\n                      mr(this, t).delay = n\r\n                    }\r\n                  )\r\n                })(n, t)\r\n          )\r\n        : wr(this.node(), n).delay\r\n    },\r\n    duration: function (t) {\r\n      var n = this._id\r\n      return arguments.length\r\n        ? this.each(\r\n            ('function' == typeof t\r\n              ? function (t, n) {\r\n                  return function () {\r\n                    xr(this, t).duration = +n.apply(this, arguments)\r\n                  }\r\n                }\r\n              : function (t, n) {\r\n                  return (\r\n                    (n = +n),\r\n                    function () {\r\n                      xr(this, t).duration = n\r\n                    }\r\n                  )\r\n                })(n, t)\r\n          )\r\n        : wr(this.node(), n).duration\r\n    },\r\n    ease: function (t) {\r\n      var n = this._id\r\n      return arguments.length\r\n        ? this.each(\r\n            (function (t, n) {\r\n              if ('function' != typeof n) throw new Error()\r\n              return function () {\r\n                xr(this, t).ease = n\r\n              }\r\n            })(n, t)\r\n          )\r\n        : wr(this.node(), n).ease\r\n    },\r\n    end: function () {\r\n      var t,\r\n        n,\r\n        e = this,\r\n        r = e._id,\r\n        i = e.size()\r\n      return new Promise(function (o, a) {\r\n        var u = { value: a },\r\n          c = {\r\n            value: function () {\r\n              0 == --i && o()\r\n            }\r\n          }\r\n        e.each(function () {\r\n          var e = xr(this, r),\r\n            i = e.on\r\n          i !== t && ((n = (t = i).copy())._.cancel.push(u), n._.interrupt.push(u), n._.end.push(c)), (e.on = n)\r\n        })\r\n      })\r\n    }\r\n  }\r\n  var qr = (function t (n) {\r\n      function e (t) {\r\n        return Math.pow(t, n)\r\n      }\r\n      return (n = +n), (e.exponent = t), e\r\n    })(3),\r\n    Lr = (function t (n) {\r\n      function e (t) {\r\n        return 1 - Math.pow(1 - t, n)\r\n      }\r\n      return (n = +n), (e.exponent = t), e\r\n    })(3),\r\n    Ur = (function t (n) {\r\n      function e (t) {\r\n        return ((t *= 2) <= 1 ? Math.pow(t, n) : 2 - Math.pow(2 - t, n)) / 2\r\n      }\r\n      return (n = +n), (e.exponent = t), e\r\n    })(3),\r\n    Or = Math.PI,\r\n    Br = Or / 2\r\n  function Yr (t) {\r\n    return (1 - Math.cos(Or * t)) / 2\r\n  }\r\n  function Fr (t) {\r\n    return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2\r\n  }\r\n  function Ir (t) {\r\n    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2\r\n  }\r\n  var jr = 4 / 11,\r\n    Hr = 6 / 11,\r\n    Xr = 8 / 11,\r\n    Gr = 0.75,\r\n    Vr = 9 / 11,\r\n    $r = 10 / 11,\r\n    Wr = 0.9375,\r\n    Zr = 21 / 22,\r\n    Qr = 63 / 64,\r\n    Jr = 1 / jr / jr\r\n  function Kr (t) {\r\n    return (t = +t) < jr\r\n      ? Jr * t * t\r\n      : t < Xr\r\n      ? Jr * (t -= Hr) * t + Gr\r\n      : t < $r\r\n      ? Jr * (t -= Vr) * t + Wr\r\n      : Jr * (t -= Zr) * t + Qr\r\n  }\r\n  var ti = (function t (n) {\r\n      function e (t) {\r\n        return t * t * ((n + 1) * t - n)\r\n      }\r\n      return (n = +n), (e.overshoot = t), e\r\n    })(1.70158),\r\n    ni = (function t (n) {\r\n      function e (t) {\r\n        return --t * t * ((n + 1) * t + n) + 1\r\n      }\r\n      return (n = +n), (e.overshoot = t), e\r\n    })(1.70158),\r\n    ei = (function t (n) {\r\n      function e (t) {\r\n        return ((t *= 2) < 1 ? t * t * ((n + 1) * t - n) : (t -= 2) * t * ((n + 1) * t + n) + 2) / 2\r\n      }\r\n      return (n = +n), (e.overshoot = t), e\r\n    })(1.70158),\r\n    ri = 2 * Math.PI,\r\n    ii = (function t (n, e) {\r\n      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= ri)\r\n      function i (t) {\r\n        return n * Math.pow(2, 10 * --t) * Math.sin((r - t) / e)\r\n      }\r\n      return (\r\n        (i.amplitude = function (n) {\r\n          return t(n, e * ri)\r\n        }),\r\n        (i.period = function (e) {\r\n          return t(n, e)\r\n        }),\r\n        i\r\n      )\r\n    })(1, 0.3),\r\n    oi = (function t (n, e) {\r\n      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= ri)\r\n      function i (t) {\r\n        return 1 - n * Math.pow(2, -10 * (t = +t)) * Math.sin((t + r) / e)\r\n      }\r\n      return (\r\n        (i.amplitude = function (n) {\r\n          return t(n, e * ri)\r\n        }),\r\n        (i.period = function (e) {\r\n          return t(n, e)\r\n        }),\r\n        i\r\n      )\r\n    })(1, 0.3),\r\n    ai = (function t (n, e) {\r\n      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= ri)\r\n      function i (t) {\r\n        return (\r\n          ((t = 2 * t - 1) < 0\r\n            ? n * Math.pow(2, 10 * t) * Math.sin((r - t) / e)\r\n            : 2 - n * Math.pow(2, -10 * t) * Math.sin((r + t) / e)) / 2\r\n        )\r\n      }\r\n      return (\r\n        (i.amplitude = function (n) {\r\n          return t(n, e * ri)\r\n        }),\r\n        (i.period = function (e) {\r\n          return t(n, e)\r\n        }),\r\n        i\r\n      )\r\n    })(1, 0.3),\r\n    ui = { time: null, delay: 0, duration: 250, ease: Dr }\r\n  function ci (t, n) {\r\n    for (var e; !(e = t.__transition) || !(e = e[n]); ) if (!(t = t.parentNode)) return (ui.time = nr()), ui\r\n    return e\r\n  }\r\n  ;(Pt.prototype.interrupt = function (t) {\r\n    return this.each(function () {\r\n      Mr(this, t)\r\n    })\r\n  }),\r\n    (Pt.prototype.transition = function (t) {\r\n      var n, e\r\n      t instanceof Er\r\n        ? ((n = t._id), (t = t._name))\r\n        : ((n = Pr()), ((e = ui).time = nr()), (t = null == t ? null : t + ''))\r\n      for (var r = this._groups, i = r.length, o = 0; o < i; ++o)\r\n        for (var a, u = r[o], c = u.length, f = 0; f < c; ++f) (a = u[f]) && br(a, t, n, f, u, e || ci(a, n))\r\n      return new Er(r, this._parents, t, n)\r\n    })\r\n  var fi = [null]\r\n  function si (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function li (t, n, e) {\r\n    ;(this.target = t), (this.type = n), (this.selection = e)\r\n  }\r\n  function hi () {\r\n    t.event.stopImmediatePropagation()\r\n  }\r\n  function di () {\r\n    t.event.preventDefault(), t.event.stopImmediatePropagation()\r\n  }\r\n  var pi = { name: 'drag' },\r\n    vi = { name: 'space' },\r\n    gi = { name: 'handle' },\r\n    yi = { name: 'center' },\r\n    _i = {\r\n      name: 'x',\r\n      handles: ['e', 'w'].map(Si),\r\n      input: function (t, n) {\r\n        return t && [[t[0], n[0][1]], [t[1], n[1][1]]]\r\n      },\r\n      output: function (t) {\r\n        return t && [t[0][0], t[1][0]]\r\n      }\r\n    },\r\n    bi = {\r\n      name: 'y',\r\n      handles: ['n', 's'].map(Si),\r\n      input: function (t, n) {\r\n        return t && [[n[0][0], t[0]], [n[1][0], t[1]]]\r\n      },\r\n      output: function (t) {\r\n        return t && [t[0][1], t[1][1]]\r\n      }\r\n    },\r\n    mi = {\r\n      name: 'xy',\r\n      handles: ['n', 'e', 's', 'w', 'nw', 'ne', 'se', 'sw'].map(Si),\r\n      input: function (t) {\r\n        return t\r\n      },\r\n      output: function (t) {\r\n        return t\r\n      }\r\n    },\r\n    xi = {\r\n      overlay: 'crosshair',\r\n      selection: 'move',\r\n      n: 'ns-resize',\r\n      e: 'ew-resize',\r\n      s: 'ns-resize',\r\n      w: 'ew-resize',\r\n      nw: 'nwse-resize',\r\n      ne: 'nesw-resize',\r\n      se: 'nwse-resize',\r\n      sw: 'nesw-resize'\r\n    },\r\n    wi = { e: 'w', w: 'e', nw: 'ne', ne: 'nw', se: 'sw', sw: 'se' },\r\n    Mi = { n: 's', s: 'n', nw: 'sw', ne: 'se', se: 'ne', sw: 'nw' },\r\n    Ni = { overlay: 1, selection: 1, n: null, e: 1, s: null, w: -1, nw: -1, ne: 1, se: 1, sw: -1 },\r\n    Ai = { overlay: 1, selection: 1, n: -1, e: null, s: 1, w: null, nw: -1, ne: -1, se: 1, sw: 1 }\r\n  function Si (t) {\r\n    return { type: t }\r\n  }\r\n  function ki () {\r\n    return !t.event.button\r\n  }\r\n  function Ti () {\r\n    var t = this.ownerSVGElement || this\r\n    return [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]]\r\n  }\r\n  function Ei (t) {\r\n    for (; !t.__brush; ) if (!(t = t.parentNode)) return\r\n    return t.__brush\r\n  }\r\n  function Ci (t) {\r\n    return t[0][0] === t[1][0] || t[0][1] === t[1][1]\r\n  }\r\n  function Pi (n) {\r\n    var e,\r\n      r = Ti,\r\n      i = ki,\r\n      o = I(u, 'start', 'brush', 'end'),\r\n      a = 6\r\n    function u (t) {\r\n      var e = t\r\n        .property('__brush', h)\r\n        .selectAll('.overlay')\r\n        .data([Si('overlay')])\r\n      e\r\n        .enter()\r\n        .append('rect')\r\n        .attr('class', 'overlay')\r\n        .attr('pointer-events', 'all')\r\n        .attr('cursor', xi.overlay)\r\n        .merge(e)\r\n        .each(function () {\r\n          var t = Ei(this).extent\r\n          zt(this)\r\n            .attr('x', t[0][0])\r\n            .attr('y', t[0][1])\r\n            .attr('width', t[1][0] - t[0][0])\r\n            .attr('height', t[1][1] - t[0][1])\r\n        }),\r\n        t\r\n          .selectAll('.selection')\r\n          .data([Si('selection')])\r\n          .enter()\r\n          .append('rect')\r\n          .attr('class', 'selection')\r\n          .attr('cursor', xi.selection)\r\n          .attr('fill', '#777')\r\n          .attr('fill-opacity', 0.3)\r\n          .attr('stroke', '#fff')\r\n          .attr('shape-rendering', 'crispEdges')\r\n      var r = t.selectAll('.handle').data(n.handles, function (t) {\r\n        return t.type\r\n      })\r\n      r.exit().remove(),\r\n        r\r\n          .enter()\r\n          .append('rect')\r\n          .attr('class', function (t) {\r\n            return 'handle handle--' + t.type\r\n          })\r\n          .attr('cursor', function (t) {\r\n            return xi[t.type]\r\n          }),\r\n        t\r\n          .each(c)\r\n          .attr('fill', 'none')\r\n          .attr('pointer-events', 'all')\r\n          .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')\r\n          .on('mousedown.brush touchstart.brush', l)\r\n    }\r\n    function c () {\r\n      var t = zt(this),\r\n        n = Ei(this).selection\r\n      n\r\n        ? (t\r\n            .selectAll('.selection')\r\n            .style('display', null)\r\n            .attr('x', n[0][0])\r\n            .attr('y', n[0][1])\r\n            .attr('width', n[1][0] - n[0][0])\r\n            .attr('height', n[1][1] - n[0][1]),\r\n          t\r\n            .selectAll('.handle')\r\n            .style('display', null)\r\n            .attr('x', function (t) {\r\n              return 'e' === t.type[t.type.length - 1] ? n[1][0] - a / 2 : n[0][0] - a / 2\r\n            })\r\n            .attr('y', function (t) {\r\n              return 's' === t.type[0] ? n[1][1] - a / 2 : n[0][1] - a / 2\r\n            })\r\n            .attr('width', function (t) {\r\n              return 'n' === t.type || 's' === t.type ? n[1][0] - n[0][0] + a : a\r\n            })\r\n            .attr('height', function (t) {\r\n              return 'e' === t.type || 'w' === t.type ? n[1][1] - n[0][1] + a : a\r\n            }))\r\n        : t\r\n            .selectAll('.selection,.handle')\r\n            .style('display', 'none')\r\n            .attr('x', null)\r\n            .attr('y', null)\r\n            .attr('width', null)\r\n            .attr('height', null)\r\n    }\r\n    function f (t, n) {\r\n      return t.__brush.emitter || new s(t, n)\r\n    }\r\n    function s (t, n) {\r\n      ;(this.that = t), (this.args = n), (this.state = t.__brush), (this.active = 0)\r\n    }\r\n    function l () {\r\n      if (t.event.touches) {\r\n        if (t.event.changedTouches.length < t.event.touches.length) return di()\r\n      } else if (e) return\r\n      if (i.apply(this, arguments)) {\r\n        var r,\r\n          o,\r\n          a,\r\n          u,\r\n          s,\r\n          l,\r\n          h,\r\n          d,\r\n          p,\r\n          v,\r\n          g,\r\n          y,\r\n          _,\r\n          b = this,\r\n          m = t.event.target.__data__.type,\r\n          x = 'selection' === (t.event.metaKey ? (m = 'overlay') : m) ? pi : t.event.altKey ? yi : gi,\r\n          w = n === bi ? null : Ni[m],\r\n          M = n === _i ? null : Ai[m],\r\n          N = Ei(b),\r\n          A = N.extent,\r\n          S = N.selection,\r\n          k = A[0][0],\r\n          T = A[0][1],\r\n          E = A[1][0],\r\n          C = A[1][1],\r\n          P = w && M && t.event.shiftKey,\r\n          z = Ot(b),\r\n          R = z,\r\n          D = f(b, arguments).beforestart()\r\n        'overlay' === m\r\n          ? (N.selection = S = [\r\n              [(r = n === bi ? k : z[0]), (a = n === _i ? T : z[1])],\r\n              [(s = n === bi ? E : r), (h = n === _i ? C : a)]\r\n            ])\r\n          : ((r = S[0][0]), (a = S[0][1]), (s = S[1][0]), (h = S[1][1])),\r\n          (o = r),\r\n          (u = a),\r\n          (l = s),\r\n          (d = h)\r\n        var q = zt(b).attr('pointer-events', 'none'),\r\n          L = q.selectAll('.overlay').attr('cursor', xi[m])\r\n        if (t.event.touches) q.on('touchmove.brush', O, !0).on('touchend.brush touchcancel.brush', Y, !0)\r\n        else {\r\n          var U = zt(t.event.view)\r\n            .on(\r\n              'keydown.brush',\r\n              function () {\r\n                switch (t.event.keyCode) {\r\n                  case 16:\r\n                    P = w && M\r\n                    break\r\n                  case 18:\r\n                    x === gi &&\r\n                      (w && ((s = l - p * w), (r = o + p * w)), M && ((h = d - v * M), (a = u + v * M)), (x = yi), B())\r\n                    break\r\n                  case 32:\r\n                    ;(x !== gi && x !== yi) ||\r\n                      (w < 0 ? (s = l - p) : w > 0 && (r = o - p),\r\n                      M < 0 ? (h = d - v) : M > 0 && (a = u - v),\r\n                      (x = vi),\r\n                      L.attr('cursor', xi.selection),\r\n                      B())\r\n                    break\r\n                  default:\r\n                    return\r\n                }\r\n                di()\r\n              },\r\n              !0\r\n            )\r\n            .on(\r\n              'keyup.brush',\r\n              function () {\r\n                switch (t.event.keyCode) {\r\n                  case 16:\r\n                    P && ((y = _ = P = !1), B())\r\n                    break\r\n                  case 18:\r\n                    x === yi && (w < 0 ? (s = l) : w > 0 && (r = o), M < 0 ? (h = d) : M > 0 && (a = u), (x = gi), B())\r\n                    break\r\n                  case 32:\r\n                    x === vi &&\r\n                      (t.event.altKey\r\n                        ? (w && ((s = l - p * w), (r = o + p * w)), M && ((h = d - v * M), (a = u + v * M)), (x = yi))\r\n                        : (w < 0 ? (s = l) : w > 0 && (r = o), M < 0 ? (h = d) : M > 0 && (a = u), (x = gi)),\r\n                      L.attr('cursor', xi[m]),\r\n                      B())\r\n                    break\r\n                  default:\r\n                    return\r\n                }\r\n                di()\r\n              },\r\n              !0\r\n            )\r\n            .on('mousemove.brush', O, !0)\r\n            .on('mouseup.brush', Y, !0)\r\n          It(t.event.view)\r\n        }\r\n        hi(), Mr(b), c.call(b), D.start()\r\n      }\r\n      function O () {\r\n        var t = Ot(b)\r\n        !P || y || _ || (Math.abs(t[0] - R[0]) > Math.abs(t[1] - R[1]) ? (_ = !0) : (y = !0)),\r\n          (R = t),\r\n          (g = !0),\r\n          di(),\r\n          B()\r\n      }\r\n      function B () {\r\n        var t\r\n        switch (((p = R[0] - z[0]), (v = R[1] - z[1]), x)) {\r\n          case vi:\r\n          case pi:\r\n            w && ((p = Math.max(k - r, Math.min(E - s, p))), (o = r + p), (l = s + p)),\r\n              M && ((v = Math.max(T - a, Math.min(C - h, v))), (u = a + v), (d = h + v))\r\n            break\r\n          case gi:\r\n            w < 0\r\n              ? ((p = Math.max(k - r, Math.min(E - r, p))), (o = r + p), (l = s))\r\n              : w > 0 && ((p = Math.max(k - s, Math.min(E - s, p))), (o = r), (l = s + p)),\r\n              M < 0\r\n                ? ((v = Math.max(T - a, Math.min(C - a, v))), (u = a + v), (d = h))\r\n                : M > 0 && ((v = Math.max(T - h, Math.min(C - h, v))), (u = a), (d = h + v))\r\n            break\r\n          case yi:\r\n            w && ((o = Math.max(k, Math.min(E, r - p * w))), (l = Math.max(k, Math.min(E, s + p * w)))),\r\n              M && ((u = Math.max(T, Math.min(C, a - v * M))), (d = Math.max(T, Math.min(C, h + v * M))))\r\n        }\r\n        l < o &&\r\n          ((w *= -1),\r\n          (t = r),\r\n          (r = s),\r\n          (s = t),\r\n          (t = o),\r\n          (o = l),\r\n          (l = t),\r\n          m in wi && L.attr('cursor', xi[(m = wi[m])])),\r\n          d < u &&\r\n            ((M *= -1),\r\n            (t = a),\r\n            (a = h),\r\n            (h = t),\r\n            (t = u),\r\n            (u = d),\r\n            (d = t),\r\n            m in Mi && L.attr('cursor', xi[(m = Mi[m])])),\r\n          N.selection && (S = N.selection),\r\n          y && ((o = S[0][0]), (l = S[1][0])),\r\n          _ && ((u = S[0][1]), (d = S[1][1])),\r\n          (S[0][0] === o && S[0][1] === u && S[1][0] === l && S[1][1] === d) ||\r\n            ((N.selection = [[o, u], [l, d]]), c.call(b), D.brush())\r\n      }\r\n      function Y () {\r\n        if ((hi(), t.event.touches)) {\r\n          if (t.event.touches.length) return\r\n          e && clearTimeout(e),\r\n            (e = setTimeout(function () {\r\n              e = null\r\n            }, 500)),\r\n            q.on('touchmove.brush touchend.brush touchcancel.brush', null)\r\n        } else jt(t.event.view, g), U.on('keydown.brush keyup.brush mousemove.brush mouseup.brush', null)\r\n        q.attr('pointer-events', 'all'),\r\n          L.attr('cursor', xi.overlay),\r\n          N.selection && (S = N.selection),\r\n          Ci(S) && ((N.selection = null), c.call(b)),\r\n          D.end()\r\n      }\r\n    }\r\n    function h () {\r\n      var t = this.__brush || { selection: null }\r\n      return (t.extent = r.apply(this, arguments)), (t.dim = n), t\r\n    }\r\n    return (\r\n      (u.move = function (t, e) {\r\n        t.selection\r\n          ? t\r\n              .on('start.brush', function () {\r\n                f(this, arguments)\r\n                  .beforestart()\r\n                  .start()\r\n              })\r\n              .on('interrupt.brush end.brush', function () {\r\n                f(this, arguments).end()\r\n              })\r\n              .tween('brush', function () {\r\n                var t = this,\r\n                  r = t.__brush,\r\n                  i = f(t, arguments),\r\n                  o = r.selection,\r\n                  a = n.input('function' == typeof e ? e.apply(this, arguments) : e, r.extent),\r\n                  u = ye(o, a)\r\n                function s (n) {\r\n                  ;(r.selection = 1 === n && Ci(a) ? null : u(n)), c.call(t), i.brush()\r\n                }\r\n                return o && a ? s : s(1)\r\n              })\r\n          : t.each(function () {\r\n              var t = arguments,\r\n                r = this.__brush,\r\n                i = n.input('function' == typeof e ? e.apply(this, t) : e, r.extent),\r\n                o = f(this, t).beforestart()\r\n              Mr(this),\r\n                (r.selection = null == i || Ci(i) ? null : i),\r\n                c.call(this),\r\n                o\r\n                  .start()\r\n                  .brush()\r\n                  .end()\r\n            })\r\n      }),\r\n      (s.prototype = {\r\n        beforestart: function () {\r\n          return 1 == ++this.active && ((this.state.emitter = this), (this.starting = !0)), this\r\n        },\r\n        start: function () {\r\n          return this.starting && ((this.starting = !1), this.emit('start')), this\r\n        },\r\n        brush: function () {\r\n          return this.emit('brush'), this\r\n        },\r\n        end: function () {\r\n          return 0 == --this.active && (delete this.state.emitter, this.emit('end')), this\r\n        },\r\n        emit: function (t) {\r\n          kt(new li(u, t, n.output(this.state.selection)), o.apply, o, [t, this.that, this.args])\r\n        }\r\n      }),\r\n      (u.extent = function (t) {\r\n        return arguments.length\r\n          ? ((r = 'function' == typeof t ? t : si([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]])), u)\r\n          : r\r\n      }),\r\n      (u.filter = function (t) {\r\n        return arguments.length ? ((i = 'function' == typeof t ? t : si(!!t)), u) : i\r\n      }),\r\n      (u.handleSize = function (t) {\r\n        return arguments.length ? ((a = +t), u) : a\r\n      }),\r\n      (u.on = function () {\r\n        var t = o.on.apply(o, arguments)\r\n        return t === o ? u : t\r\n      }),\r\n      u\r\n    )\r\n  }\r\n  var zi = Math.cos,\r\n    Ri = Math.sin,\r\n    Di = Math.PI,\r\n    qi = Di / 2,\r\n    Li = 2 * Di,\r\n    Ui = Math.max\r\n  var Oi = Array.prototype.slice\r\n  function Bi (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  var Yi = Math.PI,\r\n    Fi = 2 * Yi,\r\n    Ii = Fi - 1e-6\r\n  function ji () {\r\n    ;(this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = '')\r\n  }\r\n  function Hi () {\r\n    return new ji()\r\n  }\r\n  function Xi (t) {\r\n    return t.source\r\n  }\r\n  function Gi (t) {\r\n    return t.target\r\n  }\r\n  function Vi (t) {\r\n    return t.radius\r\n  }\r\n  function $i (t) {\r\n    return t.startAngle\r\n  }\r\n  function Wi (t) {\r\n    return t.endAngle\r\n  }\r\n  ji.prototype = Hi.prototype = {\r\n    constructor: ji,\r\n    moveTo: function (t, n) {\r\n      this._ += 'M' + (this._x0 = this._x1 = +t) + ',' + (this._y0 = this._y1 = +n)\r\n    },\r\n    closePath: function () {\r\n      null !== this._x1 && ((this._x1 = this._x0), (this._y1 = this._y0), (this._ += 'Z'))\r\n    },\r\n    lineTo: function (t, n) {\r\n      this._ += 'L' + (this._x1 = +t) + ',' + (this._y1 = +n)\r\n    },\r\n    quadraticCurveTo: function (t, n, e, r) {\r\n      this._ += 'Q' + +t + ',' + +n + ',' + (this._x1 = +e) + ',' + (this._y1 = +r)\r\n    },\r\n    bezierCurveTo: function (t, n, e, r, i, o) {\r\n      this._ += 'C' + +t + ',' + +n + ',' + +e + ',' + +r + ',' + (this._x1 = +i) + ',' + (this._y1 = +o)\r\n    },\r\n    arcTo: function (t, n, e, r, i) {\r\n      ;(t = +t), (n = +n), (e = +e), (r = +r), (i = +i)\r\n      var o = this._x1,\r\n        a = this._y1,\r\n        u = e - t,\r\n        c = r - n,\r\n        f = o - t,\r\n        s = a - n,\r\n        l = f * f + s * s\r\n      if (i < 0) throw new Error('negative radius: ' + i)\r\n      if (null === this._x1) this._ += 'M' + (this._x1 = t) + ',' + (this._y1 = n)\r\n      else if (l > 1e-6)\r\n        if (Math.abs(s * u - c * f) > 1e-6 && i) {\r\n          var h = e - o,\r\n            d = r - a,\r\n            p = u * u + c * c,\r\n            v = h * h + d * d,\r\n            g = Math.sqrt(p),\r\n            y = Math.sqrt(l),\r\n            _ = i * Math.tan((Yi - Math.acos((p + l - v) / (2 * g * y))) / 2),\r\n            b = _ / y,\r\n            m = _ / g\r\n          Math.abs(b - 1) > 1e-6 && (this._ += 'L' + (t + b * f) + ',' + (n + b * s)),\r\n            (this._ +=\r\n              'A' +\r\n              i +\r\n              ',' +\r\n              i +\r\n              ',0,0,' +\r\n              +(s * h > f * d) +\r\n              ',' +\r\n              (this._x1 = t + m * u) +\r\n              ',' +\r\n              (this._y1 = n + m * c))\r\n        } else this._ += 'L' + (this._x1 = t) + ',' + (this._y1 = n)\r\n      else;\r\n    },\r\n    arc: function (t, n, e, r, i, o) {\r\n      ;(t = +t), (n = +n)\r\n      var a = (e = +e) * Math.cos(r),\r\n        u = e * Math.sin(r),\r\n        c = t + a,\r\n        f = n + u,\r\n        s = 1 ^ o,\r\n        l = o ? r - i : i - r\r\n      if (e < 0) throw new Error('negative radius: ' + e)\r\n      null === this._x1\r\n        ? (this._ += 'M' + c + ',' + f)\r\n        : (Math.abs(this._x1 - c) > 1e-6 || Math.abs(this._y1 - f) > 1e-6) && (this._ += 'L' + c + ',' + f),\r\n        e &&\r\n          (l < 0 && (l = (l % Fi) + Fi),\r\n          l > Ii\r\n            ? (this._ +=\r\n                'A' +\r\n                e +\r\n                ',' +\r\n                e +\r\n                ',0,1,' +\r\n                s +\r\n                ',' +\r\n                (t - a) +\r\n                ',' +\r\n                (n - u) +\r\n                'A' +\r\n                e +\r\n                ',' +\r\n                e +\r\n                ',0,1,' +\r\n                s +\r\n                ',' +\r\n                (this._x1 = c) +\r\n                ',' +\r\n                (this._y1 = f))\r\n            : l > 1e-6 &&\r\n              (this._ +=\r\n                'A' +\r\n                e +\r\n                ',' +\r\n                e +\r\n                ',0,' +\r\n                +(l >= Yi) +\r\n                ',' +\r\n                s +\r\n                ',' +\r\n                (this._x1 = t + e * Math.cos(i)) +\r\n                ',' +\r\n                (this._y1 = n + e * Math.sin(i))))\r\n    },\r\n    rect: function (t, n, e, r) {\r\n      this._ +=\r\n        'M' + (this._x0 = this._x1 = +t) + ',' + (this._y0 = this._y1 = +n) + 'h' + +e + 'v' + +r + 'h' + -e + 'Z'\r\n    },\r\n    toString: function () {\r\n      return this._\r\n    }\r\n  }\r\n  function Zi () {}\r\n  function Qi (t, n) {\r\n    var e = new Zi()\r\n    if (t instanceof Zi)\r\n      t.each(function (t, n) {\r\n        e.set(n, t)\r\n      })\r\n    else if (Array.isArray(t)) {\r\n      var r,\r\n        i = -1,\r\n        o = t.length\r\n      if (null == n) for (; ++i < o; ) e.set(i, t[i])\r\n      else for (; ++i < o; ) e.set(n((r = t[i]), i, t), r)\r\n    } else if (t) for (var a in t) e.set(a, t[a])\r\n    return e\r\n  }\r\n  function Ji () {\r\n    return {}\r\n  }\r\n  function Ki (t, n, e) {\r\n    t[n] = e\r\n  }\r\n  function to () {\r\n    return Qi()\r\n  }\r\n  function no (t, n, e) {\r\n    t.set(n, e)\r\n  }\r\n  function eo () {}\r\n  Zi.prototype = Qi.prototype = {\r\n    constructor: Zi,\r\n    has: function (t) {\r\n      return '$' + t in this\r\n    },\r\n    get: function (t) {\r\n      return this['$' + t]\r\n    },\r\n    set: function (t, n) {\r\n      return (this['$' + t] = n), this\r\n    },\r\n    remove: function (t) {\r\n      var n = '$' + t\r\n      return n in this && delete this[n]\r\n    },\r\n    clear: function () {\r\n      for (var t in this) '$' === t[0] && delete this[t]\r\n    },\r\n    keys: function () {\r\n      var t = []\r\n      for (var n in this) '$' === n[0] && t.push(n.slice(1))\r\n      return t\r\n    },\r\n    values: function () {\r\n      var t = []\r\n      for (var n in this) '$' === n[0] && t.push(this[n])\r\n      return t\r\n    },\r\n    entries: function () {\r\n      var t = []\r\n      for (var n in this) '$' === n[0] && t.push({ key: n.slice(1), value: this[n] })\r\n      return t\r\n    },\r\n    size: function () {\r\n      var t = 0\r\n      for (var n in this) '$' === n[0] && ++t\r\n      return t\r\n    },\r\n    empty: function () {\r\n      for (var t in this) if ('$' === t[0]) return !1\r\n      return !0\r\n    },\r\n    each: function (t) {\r\n      for (var n in this) '$' === n[0] && t(this[n], n.slice(1), this)\r\n    }\r\n  }\r\n  var ro = Qi.prototype\r\n  function io (t, n) {\r\n    var e = new eo()\r\n    if (t instanceof eo)\r\n      t.each(function (t) {\r\n        e.add(t)\r\n      })\r\n    else if (t) {\r\n      var r = -1,\r\n        i = t.length\r\n      if (null == n) for (; ++r < i; ) e.add(t[r])\r\n      else for (; ++r < i; ) e.add(n(t[r], r, t))\r\n    }\r\n    return e\r\n  }\r\n  eo.prototype = io.prototype = {\r\n    constructor: eo,\r\n    has: ro.has,\r\n    add: function (t) {\r\n      return (this['$' + (t += '')] = t), this\r\n    },\r\n    remove: ro.remove,\r\n    clear: ro.clear,\r\n    values: ro.keys,\r\n    size: ro.size,\r\n    empty: ro.empty,\r\n    each: ro.each\r\n  }\r\n  var oo = Array.prototype.slice\r\n  function ao (t, n) {\r\n    return t - n\r\n  }\r\n  function uo (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function co (t, n) {\r\n    for (var e, r = -1, i = n.length; ++r < i; ) if ((e = fo(t, n[r]))) return e\r\n    return 0\r\n  }\r\n  function fo (t, n) {\r\n    for (var e = n[0], r = n[1], i = -1, o = 0, a = t.length, u = a - 1; o < a; u = o++) {\r\n      var c = t[o],\r\n        f = c[0],\r\n        s = c[1],\r\n        l = t[u],\r\n        h = l[0],\r\n        d = l[1]\r\n      if (so(c, l, n)) return 0\r\n      s > r != d > r && e < ((h - f) * (r - s)) / (d - s) + f && (i = -i)\r\n    }\r\n    return i\r\n  }\r\n  function so (t, n, e) {\r\n    var r, i, o, a\r\n    return (\r\n      (function (t, n, e) {\r\n        return (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1])\r\n      })(t, n, e) && ((i = t[(r = +(t[0] === n[0]))]), (o = e[r]), (a = n[r]), (i <= o && o <= a) || (a <= o && o <= i))\r\n    )\r\n  }\r\n  function lo () {}\r\n  var ho = [\r\n    [],\r\n    [[[1, 1.5], [0.5, 1]]],\r\n    [[[1.5, 1], [1, 1.5]]],\r\n    [[[1.5, 1], [0.5, 1]]],\r\n    [[[1, 0.5], [1.5, 1]]],\r\n    [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],\r\n    [[[1, 0.5], [1, 1.5]]],\r\n    [[[1, 0.5], [0.5, 1]]],\r\n    [[[0.5, 1], [1, 0.5]]],\r\n    [[[1, 1.5], [1, 0.5]]],\r\n    [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],\r\n    [[[1.5, 1], [1, 0.5]]],\r\n    [[[0.5, 1], [1.5, 1]]],\r\n    [[[1, 1.5], [1.5, 1]]],\r\n    [[[0.5, 1], [1, 1.5]]],\r\n    []\r\n  ]\r\n  function po () {\r\n    var t = 1,\r\n      n = 1,\r\n      e = M,\r\n      r = u\r\n    function i (t) {\r\n      var n = e(t)\r\n      if (Array.isArray(n)) n = n.slice().sort(ao)\r\n      else {\r\n        var r = s(t),\r\n          i = r[0],\r\n          a = r[1]\r\n        ;(n = w(i, a, n)), (n = g(Math.floor(i / n) * n, Math.floor(a / n) * n, n))\r\n      }\r\n      return n.map(function (n) {\r\n        return o(t, n)\r\n      })\r\n    }\r\n    function o (e, i) {\r\n      var o = [],\r\n        u = []\r\n      return (\r\n        (function (e, r, i) {\r\n          var o,\r\n            u,\r\n            c,\r\n            f,\r\n            s,\r\n            l,\r\n            h = new Array(),\r\n            d = new Array()\r\n          ;(o = u = -1), (f = e[0] >= r), ho[f << 1].forEach(p)\r\n          for (; ++o < t - 1; ) (c = f), (f = e[o + 1] >= r), ho[c | (f << 1)].forEach(p)\r\n          ho[f << 0].forEach(p)\r\n          for (; ++u < n - 1; ) {\r\n            for (o = -1, f = e[u * t + t] >= r, s = e[u * t] >= r, ho[(f << 1) | (s << 2)].forEach(p); ++o < t - 1; )\r\n              (c = f),\r\n                (f = e[u * t + t + o + 1] >= r),\r\n                (l = s),\r\n                (s = e[u * t + o + 1] >= r),\r\n                ho[c | (f << 1) | (s << 2) | (l << 3)].forEach(p)\r\n            ho[f | (s << 3)].forEach(p)\r\n          }\r\n          ;(o = -1), (s = e[u * t] >= r), ho[s << 2].forEach(p)\r\n          for (; ++o < t - 1; ) (l = s), (s = e[u * t + o + 1] >= r), ho[(s << 2) | (l << 3)].forEach(p)\r\n          function p (t) {\r\n            var n,\r\n              e,\r\n              r = [t[0][0] + o, t[0][1] + u],\r\n              c = [t[1][0] + o, t[1][1] + u],\r\n              f = a(r),\r\n              s = a(c)\r\n            ;(n = d[f])\r\n              ? (e = h[s])\r\n                ? (delete d[n.end],\r\n                  delete h[e.start],\r\n                  n === e\r\n                    ? (n.ring.push(c), i(n.ring))\r\n                    : (h[n.start] = d[e.end] = { start: n.start, end: e.end, ring: n.ring.concat(e.ring) }))\r\n                : (delete d[n.end], n.ring.push(c), (d[(n.end = s)] = n))\r\n              : (n = h[s])\r\n              ? (e = d[f])\r\n                ? (delete h[n.start],\r\n                  delete d[e.end],\r\n                  n === e\r\n                    ? (n.ring.push(c), i(n.ring))\r\n                    : (h[e.start] = d[n.end] = { start: e.start, end: n.end, ring: e.ring.concat(n.ring) }))\r\n                : (delete h[n.start], n.ring.unshift(r), (h[(n.start = f)] = n))\r\n              : (h[f] = d[s] = { start: f, end: s, ring: [r, c] })\r\n          }\r\n          ho[s << 3].forEach(p)\r\n        })(e, i, function (t) {\r\n          r(t, e, i),\r\n            (function (t) {\r\n              for (var n = 0, e = t.length, r = t[e - 1][1] * t[0][0] - t[e - 1][0] * t[0][1]; ++n < e; )\r\n                r += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1]\r\n              return r\r\n            })(t) > 0\r\n              ? o.push([t])\r\n              : u.push(t)\r\n        }),\r\n        u.forEach(function (t) {\r\n          for (var n, e = 0, r = o.length; e < r; ++e) if (-1 !== co((n = o[e])[0], t)) return void n.push(t)\r\n        }),\r\n        { type: 'MultiPolygon', value: i, coordinates: o }\r\n      )\r\n    }\r\n    function a (n) {\r\n      return 2 * n[0] + n[1] * (t + 1) * 4\r\n    }\r\n    function u (e, r, i) {\r\n      e.forEach(function (e) {\r\n        var o,\r\n          a = e[0],\r\n          u = e[1],\r\n          c = 0 | a,\r\n          f = 0 | u,\r\n          s = r[f * t + c]\r\n        a > 0 && a < t && c === a && ((o = r[f * t + c - 1]), (e[0] = a + (i - o) / (s - o) - 0.5)),\r\n          u > 0 && u < n && f === u && ((o = r[(f - 1) * t + c]), (e[1] = u + (i - o) / (s - o) - 0.5))\r\n      })\r\n    }\r\n    return (\r\n      (i.contour = o),\r\n      (i.size = function (e) {\r\n        if (!arguments.length) return [t, n]\r\n        var r = Math.ceil(e[0]),\r\n          o = Math.ceil(e[1])\r\n        if (!(r > 0 && o > 0)) throw new Error('invalid size')\r\n        return (t = r), (n = o), i\r\n      }),\r\n      (i.thresholds = function (t) {\r\n        return arguments.length ? ((e = 'function' == typeof t ? t : Array.isArray(t) ? uo(oo.call(t)) : uo(t)), i) : e\r\n      }),\r\n      (i.smooth = function (t) {\r\n        return arguments.length ? ((r = t ? u : lo), i) : r === u\r\n      }),\r\n      i\r\n    )\r\n  }\r\n  function vo (t, n, e) {\r\n    for (var r = t.width, i = t.height, o = 1 + (e << 1), a = 0; a < i; ++a)\r\n      for (var u = 0, c = 0; u < r + e; ++u)\r\n        u < r && (c += t.data[u + a * r]),\r\n          u >= e &&\r\n            (u >= o && (c -= t.data[u - o + a * r]), (n.data[u - e + a * r] = c / Math.min(u + 1, r - 1 + o - u, o)))\r\n  }\r\n  function go (t, n, e) {\r\n    for (var r = t.width, i = t.height, o = 1 + (e << 1), a = 0; a < r; ++a)\r\n      for (var u = 0, c = 0; u < i + e; ++u)\r\n        u < i && (c += t.data[a + u * r]),\r\n          u >= e &&\r\n            (u >= o && (c -= t.data[a + (u - o) * r]),\r\n            (n.data[a + (u - e) * r] = c / Math.min(u + 1, i - 1 + o - u, o)))\r\n  }\r\n  function yo (t) {\r\n    return t[0]\r\n  }\r\n  function _o (t) {\r\n    return t[1]\r\n  }\r\n  function bo () {\r\n    return 1\r\n  }\r\n  var mo = {},\r\n    xo = {},\r\n    wo = 34,\r\n    Mo = 10,\r\n    No = 13\r\n  function Ao (t) {\r\n    return new Function(\r\n      'd',\r\n      'return {' +\r\n        t\r\n          .map(function (t, n) {\r\n            return JSON.stringify(t) + ': d[' + n + ']'\r\n          })\r\n          .join(',') +\r\n        '}'\r\n    )\r\n  }\r\n  function So (t) {\r\n    var n = Object.create(null),\r\n      e = []\r\n    return (\r\n      t.forEach(function (t) {\r\n        for (var r in t) r in n || e.push((n[r] = r))\r\n      }),\r\n      e\r\n    )\r\n  }\r\n  function ko (t) {\r\n    var n = new RegExp('[\"' + t + '\\n\\r]'),\r\n      e = t.charCodeAt(0)\r\n    function r (t, n) {\r\n      var r,\r\n        i = [],\r\n        o = t.length,\r\n        a = 0,\r\n        u = 0,\r\n        c = o <= 0,\r\n        f = !1\r\n      function s () {\r\n        if (c) return xo\r\n        if (f) return (f = !1), mo\r\n        var n,\r\n          r,\r\n          i = a\r\n        if (t.charCodeAt(i) === wo) {\r\n          for (; (a++ < o && t.charCodeAt(a) !== wo) || t.charCodeAt(++a) === wo; );\r\n          return (\r\n            (n = a) >= o\r\n              ? (c = !0)\r\n              : (r = t.charCodeAt(a++)) === Mo\r\n              ? (f = !0)\r\n              : r === No && ((f = !0), t.charCodeAt(a) === Mo && ++a),\r\n            t.slice(i + 1, n - 1).replace(/\"\"/g, '\"')\r\n          )\r\n        }\r\n        for (; a < o; ) {\r\n          if ((r = t.charCodeAt((n = a++))) === Mo) f = !0\r\n          else if (r === No) (f = !0), t.charCodeAt(a) === Mo && ++a\r\n          else if (r !== e) continue\r\n          return t.slice(i, n)\r\n        }\r\n        return (c = !0), t.slice(i, o)\r\n      }\r\n      for (t.charCodeAt(o - 1) === Mo && --o, t.charCodeAt(o - 1) === No && --o; (r = s()) !== xo; ) {\r\n        for (var l = []; r !== mo && r !== xo; ) l.push(r), (r = s())\r\n        ;(n && null == (l = n(l, u++))) || i.push(l)\r\n      }\r\n      return i\r\n    }\r\n    function i (n, e) {\r\n      return n.map(function (n) {\r\n        return e\r\n          .map(function (t) {\r\n            return a(n[t])\r\n          })\r\n          .join(t)\r\n      })\r\n    }\r\n    function o (n) {\r\n      return n.map(a).join(t)\r\n    }\r\n    function a (t) {\r\n      return null == t\r\n        ? ''\r\n        : t instanceof Date\r\n        ? t.toISOString()\r\n        : n.test((t += ''))\r\n        ? '\"' + t.replace(/\"/g, '\"\"') + '\"'\r\n        : t\r\n    }\r\n    return {\r\n      parse: function (t, n) {\r\n        var e,\r\n          i,\r\n          o = r(t, function (t, r) {\r\n            if (e) return e(t, r - 1)\r\n            ;(i = t),\r\n              (e = n\r\n                ? (function (t, n) {\r\n                    var e = Ao(t)\r\n                    return function (r, i) {\r\n                      return n(e(r), i, t)\r\n                    }\r\n                  })(t, n)\r\n                : Ao(t))\r\n          })\r\n        return (o.columns = i || []), o\r\n      },\r\n      parseRows: r,\r\n      format: function (n, e) {\r\n        return null == e && (e = So(n)), [e.map(a).join(t)].concat(i(n, e)).join('\\n')\r\n      },\r\n      formatBody: function (t, n) {\r\n        return null == n && (n = So(t)), i(t, n).join('\\n')\r\n      },\r\n      formatRows: function (t) {\r\n        return t.map(o).join('\\n')\r\n      }\r\n    }\r\n  }\r\n  var To = ko(','),\r\n    Eo = To.parse,\r\n    Co = To.parseRows,\r\n    Po = To.format,\r\n    zo = To.formatBody,\r\n    Ro = To.formatRows,\r\n    Do = ko('\\t'),\r\n    qo = Do.parse,\r\n    Lo = Do.parseRows,\r\n    Uo = Do.format,\r\n    Oo = Do.formatBody,\r\n    Bo = Do.formatRows\r\n  function Yo (t) {\r\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\r\n    return t.blob()\r\n  }\r\n  function Fo (t) {\r\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\r\n    return t.arrayBuffer()\r\n  }\r\n  function Io (t) {\r\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\r\n    return t.text()\r\n  }\r\n  function jo (t, n) {\r\n    return fetch(t, n).then(Io)\r\n  }\r\n  function Ho (t) {\r\n    return function (n, e, r) {\r\n      return (\r\n        2 === arguments.length && 'function' == typeof e && ((r = e), (e = void 0)),\r\n        jo(n, e).then(function (n) {\r\n          return t(n, r)\r\n        })\r\n      )\r\n    }\r\n  }\r\n  var Xo = Ho(Eo),\r\n    Go = Ho(qo)\r\n  function Vo (t) {\r\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\r\n    return t.json()\r\n  }\r\n  function $o (t) {\r\n    return function (n, e) {\r\n      return jo(n, e).then(function (n) {\r\n        return new DOMParser().parseFromString(n, t)\r\n      })\r\n    }\r\n  }\r\n  var Wo = $o('application/xml'),\r\n    Zo = $o('text/html'),\r\n    Qo = $o('image/svg+xml')\r\n  function Jo (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function Ko () {\r\n    return 1e-6 * (Math.random() - 0.5)\r\n  }\r\n  function ta (t, n, e, r) {\r\n    if (isNaN(n) || isNaN(e)) return t\r\n    var i,\r\n      o,\r\n      a,\r\n      u,\r\n      c,\r\n      f,\r\n      s,\r\n      l,\r\n      h,\r\n      d = t._root,\r\n      p = { data: r },\r\n      v = t._x0,\r\n      g = t._y0,\r\n      y = t._x1,\r\n      _ = t._y1\r\n    if (!d) return (t._root = p), t\r\n    for (; d.length; )\r\n      if (\r\n        ((f = n >= (o = (v + y) / 2)) ? (v = o) : (y = o),\r\n        (s = e >= (a = (g + _) / 2)) ? (g = a) : (_ = a),\r\n        (i = d),\r\n        !(d = d[(l = (s << 1) | f)]))\r\n      )\r\n        return (i[l] = p), t\r\n    if (((u = +t._x.call(null, d.data)), (c = +t._y.call(null, d.data)), n === u && e === c))\r\n      return (p.next = d), i ? (i[l] = p) : (t._root = p), t\r\n    do {\r\n      ;(i = i ? (i[l] = new Array(4)) : (t._root = new Array(4))),\r\n        (f = n >= (o = (v + y) / 2)) ? (v = o) : (y = o),\r\n        (s = e >= (a = (g + _) / 2)) ? (g = a) : (_ = a)\r\n    } while ((l = (s << 1) | f) == (h = ((c >= a) << 1) | (u >= o)))\r\n    return (i[h] = d), (i[l] = p), t\r\n  }\r\n  function na (t, n, e, r, i) {\r\n    ;(this.node = t), (this.x0 = n), (this.y0 = e), (this.x1 = r), (this.y1 = i)\r\n  }\r\n  function ea (t) {\r\n    return t[0]\r\n  }\r\n  function ra (t) {\r\n    return t[1]\r\n  }\r\n  function ia (t, n, e) {\r\n    var r = new oa(null == n ? ea : n, null == e ? ra : e, NaN, NaN, NaN, NaN)\r\n    return null == t ? r : r.addAll(t)\r\n  }\r\n  function oa (t, n, e, r, i, o) {\r\n    ;(this._x = t), (this._y = n), (this._x0 = e), (this._y0 = r), (this._x1 = i), (this._y1 = o), (this._root = void 0)\r\n  }\r\n  function aa (t) {\r\n    for (var n = { data: t.data }, e = n; (t = t.next); ) e = e.next = { data: t.data }\r\n    return n\r\n  }\r\n  var ua = (ia.prototype = oa.prototype)\r\n  function ca (t) {\r\n    return t.x + t.vx\r\n  }\r\n  function fa (t) {\r\n    return t.y + t.vy\r\n  }\r\n  function sa (t) {\r\n    return t.index\r\n  }\r\n  function la (t, n) {\r\n    var e = t.get(n)\r\n    if (!e) throw new Error('missing: ' + n)\r\n    return e\r\n  }\r\n  function ha (t) {\r\n    return t.x\r\n  }\r\n  function da (t) {\r\n    return t.y\r\n  }\r\n  ;(ua.copy = function () {\r\n    var t,\r\n      n,\r\n      e = new oa(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\r\n      r = this._root\r\n    if (!r) return e\r\n    if (!r.length) return (e._root = aa(r)), e\r\n    for (t = [{ source: r, target: (e._root = new Array(4)) }]; (r = t.pop()); )\r\n      for (var i = 0; i < 4; ++i)\r\n        (n = r.source[i]) &&\r\n          (n.length ? t.push({ source: n, target: (r.target[i] = new Array(4)) }) : (r.target[i] = aa(n)))\r\n    return e\r\n  }),\r\n    (ua.add = function (t) {\r\n      var n = +this._x.call(null, t),\r\n        e = +this._y.call(null, t)\r\n      return ta(this.cover(n, e), n, e, t)\r\n    }),\r\n    (ua.addAll = function (t) {\r\n      var n,\r\n        e,\r\n        r,\r\n        i,\r\n        o = t.length,\r\n        a = new Array(o),\r\n        u = new Array(o),\r\n        c = 1 / 0,\r\n        f = 1 / 0,\r\n        s = -1 / 0,\r\n        l = -1 / 0\r\n      for (e = 0; e < o; ++e)\r\n        isNaN((r = +this._x.call(null, (n = t[e])))) ||\r\n          isNaN((i = +this._y.call(null, n))) ||\r\n          ((a[e] = r), (u[e] = i), r < c && (c = r), r > s && (s = r), i < f && (f = i), i > l && (l = i))\r\n      for (\r\n        s < c && ((c = this._x0), (s = this._x1)),\r\n          l < f && ((f = this._y0), (l = this._y1)),\r\n          this.cover(c, f).cover(s, l),\r\n          e = 0;\r\n        e < o;\r\n        ++e\r\n      )\r\n        ta(this, a[e], u[e], t[e])\r\n      return this\r\n    }),\r\n    (ua.cover = function (t, n) {\r\n      if (isNaN((t = +t)) || isNaN((n = +n))) return this\r\n      var e = this._x0,\r\n        r = this._y0,\r\n        i = this._x1,\r\n        o = this._y1\r\n      if (isNaN(e)) (i = (e = Math.floor(t)) + 1), (o = (r = Math.floor(n)) + 1)\r\n      else {\r\n        if (!(e > t || t > i || r > n || n > o)) return this\r\n        var a,\r\n          u,\r\n          c = i - e,\r\n          f = this._root\r\n        switch ((u = ((n < (r + o) / 2) << 1) | (t < (e + i) / 2))) {\r\n          case 0:\r\n            do {\r\n              ;((a = new Array(4))[u] = f), (f = a)\r\n            } while (((o = r + (c *= 2)), t > (i = e + c) || n > o))\r\n            break\r\n          case 1:\r\n            do {\r\n              ;((a = new Array(4))[u] = f), (f = a)\r\n            } while (((o = r + (c *= 2)), (e = i - c) > t || n > o))\r\n            break\r\n          case 2:\r\n            do {\r\n              ;((a = new Array(4))[u] = f), (f = a)\r\n            } while (((r = o - (c *= 2)), t > (i = e + c) || r > n))\r\n            break\r\n          case 3:\r\n            do {\r\n              ;((a = new Array(4))[u] = f), (f = a)\r\n            } while (((r = o - (c *= 2)), (e = i - c) > t || r > n))\r\n        }\r\n        this._root && this._root.length && (this._root = f)\r\n      }\r\n      return (this._x0 = e), (this._y0 = r), (this._x1 = i), (this._y1 = o), this\r\n    }),\r\n    (ua.data = function () {\r\n      var t = []\r\n      return (\r\n        this.visit(function (n) {\r\n          if (!n.length)\r\n            do {\r\n              t.push(n.data)\r\n            } while ((n = n.next))\r\n        }),\r\n        t\r\n      )\r\n    }),\r\n    (ua.extent = function (t) {\r\n      return arguments.length\r\n        ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1])\r\n        : isNaN(this._x0)\r\n        ? void 0\r\n        : [[this._x0, this._y0], [this._x1, this._y1]]\r\n    }),\r\n    (ua.find = function (t, n, e) {\r\n      var r,\r\n        i,\r\n        o,\r\n        a,\r\n        u,\r\n        c,\r\n        f,\r\n        s = this._x0,\r\n        l = this._y0,\r\n        h = this._x1,\r\n        d = this._y1,\r\n        p = [],\r\n        v = this._root\r\n      for (\r\n        v && p.push(new na(v, s, l, h, d)),\r\n          null == e ? (e = 1 / 0) : ((s = t - e), (l = n - e), (h = t + e), (d = n + e), (e *= e));\r\n        (c = p.pop());\r\n\r\n      )\r\n        if (!(!(v = c.node) || (i = c.x0) > h || (o = c.y0) > d || (a = c.x1) < s || (u = c.y1) < l))\r\n          if (v.length) {\r\n            var g = (i + a) / 2,\r\n              y = (o + u) / 2\r\n            p.push(\r\n              new na(v[3], g, y, a, u),\r\n              new na(v[2], i, y, g, u),\r\n              new na(v[1], g, o, a, y),\r\n              new na(v[0], i, o, g, y)\r\n            ),\r\n              (f = ((n >= y) << 1) | (t >= g)) &&\r\n                ((c = p[p.length - 1]), (p[p.length - 1] = p[p.length - 1 - f]), (p[p.length - 1 - f] = c))\r\n          } else {\r\n            var _ = t - +this._x.call(null, v.data),\r\n              b = n - +this._y.call(null, v.data),\r\n              m = _ * _ + b * b\r\n            if (m < e) {\r\n              var x = Math.sqrt((e = m))\r\n              ;(s = t - x), (l = n - x), (h = t + x), (d = n + x), (r = v.data)\r\n            }\r\n          }\r\n      return r\r\n    }),\r\n    (ua.remove = function (t) {\r\n      if (isNaN((o = +this._x.call(null, t))) || isNaN((a = +this._y.call(null, t)))) return this\r\n      var n,\r\n        e,\r\n        r,\r\n        i,\r\n        o,\r\n        a,\r\n        u,\r\n        c,\r\n        f,\r\n        s,\r\n        l,\r\n        h,\r\n        d = this._root,\r\n        p = this._x0,\r\n        v = this._y0,\r\n        g = this._x1,\r\n        y = this._y1\r\n      if (!d) return this\r\n      if (d.length)\r\n        for (;;) {\r\n          if (\r\n            ((f = o >= (u = (p + g) / 2)) ? (p = u) : (g = u),\r\n            (s = a >= (c = (v + y) / 2)) ? (v = c) : (y = c),\r\n            (n = d),\r\n            !(d = d[(l = (s << 1) | f)]))\r\n          )\r\n            return this\r\n          if (!d.length) break\r\n          ;(n[(l + 1) & 3] || n[(l + 2) & 3] || n[(l + 3) & 3]) && ((e = n), (h = l))\r\n        }\r\n      for (; d.data !== t; ) if (((r = d), !(d = d.next))) return this\r\n      return (\r\n        (i = d.next) && delete d.next,\r\n        r\r\n          ? (i ? (r.next = i) : delete r.next, this)\r\n          : n\r\n          ? (i ? (n[l] = i) : delete n[l],\r\n            (d = n[0] || n[1] || n[2] || n[3]) &&\r\n              d === (n[3] || n[2] || n[1] || n[0]) &&\r\n              !d.length &&\r\n              (e ? (e[h] = d) : (this._root = d)),\r\n            this)\r\n          : ((this._root = i), this)\r\n      )\r\n    }),\r\n    (ua.removeAll = function (t) {\r\n      for (var n = 0, e = t.length; n < e; ++n) this.remove(t[n])\r\n      return this\r\n    }),\r\n    (ua.root = function () {\r\n      return this._root\r\n    }),\r\n    (ua.size = function () {\r\n      var t = 0\r\n      return (\r\n        this.visit(function (n) {\r\n          if (!n.length)\r\n            do {\r\n              ++t\r\n            } while ((n = n.next))\r\n        }),\r\n        t\r\n      )\r\n    }),\r\n    (ua.visit = function (t) {\r\n      var n,\r\n        e,\r\n        r,\r\n        i,\r\n        o,\r\n        a,\r\n        u = [],\r\n        c = this._root\r\n      for (c && u.push(new na(c, this._x0, this._y0, this._x1, this._y1)); (n = u.pop()); )\r\n        if (!t((c = n.node), (r = n.x0), (i = n.y0), (o = n.x1), (a = n.y1)) && c.length) {\r\n          var f = (r + o) / 2,\r\n            s = (i + a) / 2\r\n          ;(e = c[3]) && u.push(new na(e, f, s, o, a)),\r\n            (e = c[2]) && u.push(new na(e, r, s, f, a)),\r\n            (e = c[1]) && u.push(new na(e, f, i, o, s)),\r\n            (e = c[0]) && u.push(new na(e, r, i, f, s))\r\n        }\r\n      return this\r\n    }),\r\n    (ua.visitAfter = function (t) {\r\n      var n,\r\n        e = [],\r\n        r = []\r\n      for (this._root && e.push(new na(this._root, this._x0, this._y0, this._x1, this._y1)); (n = e.pop()); ) {\r\n        var i = n.node\r\n        if (i.length) {\r\n          var o,\r\n            a = n.x0,\r\n            u = n.y0,\r\n            c = n.x1,\r\n            f = n.y1,\r\n            s = (a + c) / 2,\r\n            l = (u + f) / 2\r\n          ;(o = i[0]) && e.push(new na(o, a, u, s, l)),\r\n            (o = i[1]) && e.push(new na(o, s, u, c, l)),\r\n            (o = i[2]) && e.push(new na(o, a, l, s, f)),\r\n            (o = i[3]) && e.push(new na(o, s, l, c, f))\r\n        }\r\n        r.push(n)\r\n      }\r\n      for (; (n = r.pop()); ) t(n.node, n.x0, n.y0, n.x1, n.y1)\r\n      return this\r\n    }),\r\n    (ua.x = function (t) {\r\n      return arguments.length ? ((this._x = t), this) : this._x\r\n    }),\r\n    (ua.y = function (t) {\r\n      return arguments.length ? ((this._y = t), this) : this._y\r\n    })\r\n  var pa = 10,\r\n    va = Math.PI * (3 - Math.sqrt(5))\r\n  function ga (t, n) {\r\n    if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf('e')) < 0) return null\r\n    var e,\r\n      r = t.slice(0, e)\r\n    return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)]\r\n  }\r\n  function ya (t) {\r\n    return (t = ga(Math.abs(t))) ? t[1] : NaN\r\n  }\r\n  var _a,\r\n    ba = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i\r\n  function ma (t) {\r\n    return new xa(t)\r\n  }\r\n  function xa (t) {\r\n    if (!(n = ba.exec(t))) throw new Error('invalid format: ' + t)\r\n    var n\r\n    ;(this.fill = n[1] || ' '),\r\n      (this.align = n[2] || '>'),\r\n      (this.sign = n[3] || '-'),\r\n      (this.symbol = n[4] || ''),\r\n      (this.zero = !!n[5]),\r\n      (this.width = n[6] && +n[6]),\r\n      (this.comma = !!n[7]),\r\n      (this.precision = n[8] && +n[8].slice(1)),\r\n      (this.trim = !!n[9]),\r\n      (this.type = n[10] || '')\r\n  }\r\n  function wa (t, n) {\r\n    var e = ga(t, n)\r\n    if (!e) return t + ''\r\n    var r = e[0],\r\n      i = e[1]\r\n    return i < 0\r\n      ? '0.' + new Array(-i).join('0') + r\r\n      : r.length > i + 1\r\n      ? r.slice(0, i + 1) + '.' + r.slice(i + 1)\r\n      : r + new Array(i - r.length + 2).join('0')\r\n  }\r\n  ;(ma.prototype = xa.prototype),\r\n    (xa.prototype.toString = function () {\r\n      return (\r\n        this.fill +\r\n        this.align +\r\n        this.sign +\r\n        this.symbol +\r\n        (this.zero ? '0' : '') +\r\n        (null == this.width ? '' : Math.max(1, 0 | this.width)) +\r\n        (this.comma ? ',' : '') +\r\n        (null == this.precision ? '' : '.' + Math.max(0, 0 | this.precision)) +\r\n        (this.trim ? '~' : '') +\r\n        this.type\r\n      )\r\n    })\r\n  var Ma = {\r\n    '%': function (t, n) {\r\n      return (100 * t).toFixed(n)\r\n    },\r\n    b: function (t) {\r\n      return Math.round(t).toString(2)\r\n    },\r\n    c: function (t) {\r\n      return t + ''\r\n    },\r\n    d: function (t) {\r\n      return Math.round(t).toString(10)\r\n    },\r\n    e: function (t, n) {\r\n      return t.toExponential(n)\r\n    },\r\n    f: function (t, n) {\r\n      return t.toFixed(n)\r\n    },\r\n    g: function (t, n) {\r\n      return t.toPrecision(n)\r\n    },\r\n    o: function (t) {\r\n      return Math.round(t).toString(8)\r\n    },\r\n    p: function (t, n) {\r\n      return wa(100 * t, n)\r\n    },\r\n    r: wa,\r\n    s: function (t, n) {\r\n      var e = ga(t, n)\r\n      if (!e) return t + ''\r\n      var r = e[0],\r\n        i = e[1],\r\n        o = i - (_a = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1,\r\n        a = r.length\r\n      return o === a\r\n        ? r\r\n        : o > a\r\n        ? r + new Array(o - a + 1).join('0')\r\n        : o > 0\r\n        ? r.slice(0, o) + '.' + r.slice(o)\r\n        : '0.' + new Array(1 - o).join('0') + ga(t, Math.max(0, n + o - 1))[0]\r\n    },\r\n    X: function (t) {\r\n      return Math.round(t)\r\n        .toString(16)\r\n        .toUpperCase()\r\n    },\r\n    x: function (t) {\r\n      return Math.round(t).toString(16)\r\n    }\r\n  }\r\n  function Na (t) {\r\n    return t\r\n  }\r\n  var Aa,\r\n    Sa = ['y', 'z', 'a', 'f', 'p', 'n', '', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']\r\n  function ka (t) {\r\n    var n,\r\n      e,\r\n      r =\r\n        t.grouping && t.thousands\r\n          ? ((n = t.grouping),\r\n            (e = t.thousands),\r\n            function (t, r) {\r\n              for (\r\n                var i = t.length, o = [], a = 0, u = n[0], c = 0;\r\n                i > 0 &&\r\n                u > 0 &&\r\n                (c + u + 1 > r && (u = Math.max(1, r - c)), o.push(t.substring((i -= u), i + u)), !((c += u + 1) > r));\r\n\r\n              )\r\n                u = n[(a = (a + 1) % n.length)]\r\n              return o.reverse().join(e)\r\n            })\r\n          : Na,\r\n      i = t.currency,\r\n      o = t.decimal,\r\n      a = t.numerals\r\n        ? (function (t) {\r\n            return function (n) {\r\n              return n.replace(/[0-9]/g, function (n) {\r\n                return t[+n]\r\n              })\r\n            }\r\n          })(t.numerals)\r\n        : Na,\r\n      u = t.percent || '%'\r\n    function c (t) {\r\n      var n = (t = ma(t)).fill,\r\n        e = t.align,\r\n        c = t.sign,\r\n        f = t.symbol,\r\n        s = t.zero,\r\n        l = t.width,\r\n        h = t.comma,\r\n        d = t.precision,\r\n        p = t.trim,\r\n        v = t.type\r\n      'n' === v ? ((h = !0), (v = 'g')) : Ma[v] || (null == d && (d = 12), (p = !0), (v = 'g')),\r\n        (s || ('0' === n && '=' === e)) && ((s = !0), (n = '0'), (e = '='))\r\n      var g = '$' === f ? i[0] : '#' === f && /[boxX]/.test(v) ? '0' + v.toLowerCase() : '',\r\n        y = '$' === f ? i[1] : /[%p]/.test(v) ? u : '',\r\n        _ = Ma[v],\r\n        b = /[defgprs%]/.test(v)\r\n      function m (t) {\r\n        var i,\r\n          u,\r\n          f,\r\n          m = g,\r\n          x = y\r\n        if ('c' === v) (x = _(t) + x), (t = '')\r\n        else {\r\n          var w = (t = +t) < 0\r\n          if (\r\n            ((t = _(Math.abs(t), d)),\r\n            p &&\r\n              (t = (function (t) {\r\n                t: for (var n, e = t.length, r = 1, i = -1; r < e; ++r)\r\n                  switch (t[r]) {\r\n                    case '.':\r\n                      i = n = r\r\n                      break\r\n                    case '0':\r\n                      0 === i && (i = r), (n = r)\r\n                      break\r\n                    default:\r\n                      if (i > 0) {\r\n                        if (!+t[r]) break t\r\n                        i = 0\r\n                      }\r\n                  }\r\n                return i > 0 ? t.slice(0, i) + t.slice(n + 1) : t\r\n              })(t)),\r\n            w && 0 == +t && (w = !1),\r\n            (m = (w ? ('(' === c ? c : '-') : '-' === c || '(' === c ? '' : c) + m),\r\n            (x = ('s' === v ? Sa[8 + _a / 3] : '') + x + (w && '(' === c ? ')' : '')),\r\n            b)\r\n          )\r\n            for (i = -1, u = t.length; ++i < u; )\r\n              if (48 > (f = t.charCodeAt(i)) || f > 57) {\r\n                ;(x = (46 === f ? o + t.slice(i + 1) : t.slice(i)) + x), (t = t.slice(0, i))\r\n                break\r\n              }\r\n        }\r\n        h && !s && (t = r(t, 1 / 0))\r\n        var M = m.length + t.length + x.length,\r\n          N = M < l ? new Array(l - M + 1).join(n) : ''\r\n        switch ((h && s && ((t = r(N + t, N.length ? l - x.length : 1 / 0)), (N = '')), e)) {\r\n          case '<':\r\n            t = m + t + x + N\r\n            break\r\n          case '=':\r\n            t = m + N + t + x\r\n            break\r\n          case '^':\r\n            t = N.slice(0, (M = N.length >> 1)) + m + t + x + N.slice(M)\r\n            break\r\n          default:\r\n            t = N + m + t + x\r\n        }\r\n        return a(t)\r\n      }\r\n      return (\r\n        (d = null == d ? 6 : /[gprs]/.test(v) ? Math.max(1, Math.min(21, d)) : Math.max(0, Math.min(20, d))),\r\n        (m.toString = function () {\r\n          return t + ''\r\n        }),\r\n        m\r\n      )\r\n    }\r\n    return {\r\n      format: c,\r\n      formatPrefix: function (t, n) {\r\n        var e = c((((t = ma(t)).type = 'f'), t)),\r\n          r = 3 * Math.max(-8, Math.min(8, Math.floor(ya(n) / 3))),\r\n          i = Math.pow(10, -r),\r\n          o = Sa[8 + r / 3]\r\n        return function (t) {\r\n          return e(i * t) + o\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function Ta (n) {\r\n    return (Aa = ka(n)), (t.format = Aa.format), (t.formatPrefix = Aa.formatPrefix), Aa\r\n  }\r\n  function Ea (t) {\r\n    return Math.max(0, -ya(Math.abs(t)))\r\n  }\r\n  function Ca (t, n) {\r\n    return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(ya(n) / 3))) - ya(Math.abs(t)))\r\n  }\r\n  function Pa (t, n) {\r\n    return (t = Math.abs(t)), (n = Math.abs(n) - t), Math.max(0, ya(n) - ya(t)) + 1\r\n  }\r\n  function za () {\r\n    return new Ra()\r\n  }\r\n  function Ra () {\r\n    this.reset()\r\n  }\r\n  Ta({ decimal: '.', thousands: ',', grouping: [3], currency: ['$', ''] }),\r\n    (Ra.prototype = {\r\n      constructor: Ra,\r\n      reset: function () {\r\n        this.s = this.t = 0\r\n      },\r\n      add: function (t) {\r\n        qa(Da, t, this.t), qa(this, Da.s, this.s), this.s ? (this.t += Da.t) : (this.s = Da.t)\r\n      },\r\n      valueOf: function () {\r\n        return this.s\r\n      }\r\n    })\r\n  var Da = new Ra()\r\n  function qa (t, n, e) {\r\n    var r = (t.s = n + e),\r\n      i = r - n,\r\n      o = r - i\r\n    t.t = n - o + (e - i)\r\n  }\r\n  var La = 1e-6,\r\n    Ua = 1e-12,\r\n    Oa = Math.PI,\r\n    Ba = Oa / 2,\r\n    Ya = Oa / 4,\r\n    Fa = 2 * Oa,\r\n    Ia = 180 / Oa,\r\n    ja = Oa / 180,\r\n    Ha = Math.abs,\r\n    Xa = Math.atan,\r\n    Ga = Math.atan2,\r\n    Va = Math.cos,\r\n    $a = Math.ceil,\r\n    Wa = Math.exp,\r\n    Za = Math.log,\r\n    Qa = Math.pow,\r\n    Ja = Math.sin,\r\n    Ka =\r\n      Math.sign ||\r\n      function (t) {\r\n        return t > 0 ? 1 : t < 0 ? -1 : 0\r\n      },\r\n    tu = Math.sqrt,\r\n    nu = Math.tan\r\n  function eu (t) {\r\n    return t > 1 ? 0 : t < -1 ? Oa : Math.acos(t)\r\n  }\r\n  function ru (t) {\r\n    return t > 1 ? Ba : t < -1 ? -Ba : Math.asin(t)\r\n  }\r\n  function iu (t) {\r\n    return (t = Ja(t / 2)) * t\r\n  }\r\n  function ou () {}\r\n  function au (t, n) {\r\n    t && cu.hasOwnProperty(t.type) && cu[t.type](t, n)\r\n  }\r\n  var uu = {\r\n      Feature: function (t, n) {\r\n        au(t.geometry, n)\r\n      },\r\n      FeatureCollection: function (t, n) {\r\n        for (var e = t.features, r = -1, i = e.length; ++r < i; ) au(e[r].geometry, n)\r\n      }\r\n    },\r\n    cu = {\r\n      Sphere: function (t, n) {\r\n        n.sphere()\r\n      },\r\n      Point: function (t, n) {\r\n        ;(t = t.coordinates), n.point(t[0], t[1], t[2])\r\n      },\r\n      MultiPoint: function (t, n) {\r\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) (t = e[r]), n.point(t[0], t[1], t[2])\r\n      },\r\n      LineString: function (t, n) {\r\n        fu(t.coordinates, n, 0)\r\n      },\r\n      MultiLineString: function (t, n) {\r\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) fu(e[r], n, 0)\r\n      },\r\n      Polygon: function (t, n) {\r\n        su(t.coordinates, n)\r\n      },\r\n      MultiPolygon: function (t, n) {\r\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) su(e[r], n)\r\n      },\r\n      GeometryCollection: function (t, n) {\r\n        for (var e = t.geometries, r = -1, i = e.length; ++r < i; ) au(e[r], n)\r\n      }\r\n    }\r\n  function fu (t, n, e) {\r\n    var r,\r\n      i = -1,\r\n      o = t.length - e\r\n    for (n.lineStart(); ++i < o; ) (r = t[i]), n.point(r[0], r[1], r[2])\r\n    n.lineEnd()\r\n  }\r\n  function su (t, n) {\r\n    var e = -1,\r\n      r = t.length\r\n    for (n.polygonStart(); ++e < r; ) fu(t[e], n, 1)\r\n    n.polygonEnd()\r\n  }\r\n  function lu (t, n) {\r\n    t && uu.hasOwnProperty(t.type) ? uu[t.type](t, n) : au(t, n)\r\n  }\r\n  var hu,\r\n    du,\r\n    pu,\r\n    vu,\r\n    gu,\r\n    yu = za(),\r\n    _u = za(),\r\n    bu = {\r\n      point: ou,\r\n      lineStart: ou,\r\n      lineEnd: ou,\r\n      polygonStart: function () {\r\n        yu.reset(), (bu.lineStart = mu), (bu.lineEnd = xu)\r\n      },\r\n      polygonEnd: function () {\r\n        var t = +yu\r\n        _u.add(t < 0 ? Fa + t : t), (this.lineStart = this.lineEnd = this.point = ou)\r\n      },\r\n      sphere: function () {\r\n        _u.add(Fa)\r\n      }\r\n    }\r\n  function mu () {\r\n    bu.point = wu\r\n  }\r\n  function xu () {\r\n    Mu(hu, du)\r\n  }\r\n  function wu (t, n) {\r\n    ;(bu.point = Mu), (hu = t), (du = n), (pu = t *= ja), (vu = Va((n = (n *= ja) / 2 + Ya))), (gu = Ja(n))\r\n  }\r\n  function Mu (t, n) {\r\n    var e = (t *= ja) - pu,\r\n      r = e >= 0 ? 1 : -1,\r\n      i = r * e,\r\n      o = Va((n = (n *= ja) / 2 + Ya)),\r\n      a = Ja(n),\r\n      u = gu * a,\r\n      c = vu * o + u * Va(i),\r\n      f = u * r * Ja(i)\r\n    yu.add(Ga(f, c)), (pu = t), (vu = o), (gu = a)\r\n  }\r\n  function Nu (t) {\r\n    return [Ga(t[1], t[0]), ru(t[2])]\r\n  }\r\n  function Au (t) {\r\n    var n = t[0],\r\n      e = t[1],\r\n      r = Va(e)\r\n    return [r * Va(n), r * Ja(n), Ja(e)]\r\n  }\r\n  function Su (t, n) {\r\n    return t[0] * n[0] + t[1] * n[1] + t[2] * n[2]\r\n  }\r\n  function ku (t, n) {\r\n    return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]]\r\n  }\r\n  function Tu (t, n) {\r\n    ;(t[0] += n[0]), (t[1] += n[1]), (t[2] += n[2])\r\n  }\r\n  function Eu (t, n) {\r\n    return [t[0] * n, t[1] * n, t[2] * n]\r\n  }\r\n  function Cu (t) {\r\n    var n = tu(t[0] * t[0] + t[1] * t[1] + t[2] * t[2])\r\n    ;(t[0] /= n), (t[1] /= n), (t[2] /= n)\r\n  }\r\n  var Pu,\r\n    zu,\r\n    Ru,\r\n    Du,\r\n    qu,\r\n    Lu,\r\n    Uu,\r\n    Ou,\r\n    Bu,\r\n    Yu,\r\n    Fu,\r\n    Iu,\r\n    ju,\r\n    Hu,\r\n    Xu,\r\n    Gu,\r\n    Vu,\r\n    $u,\r\n    Wu,\r\n    Zu,\r\n    Qu,\r\n    Ju,\r\n    Ku,\r\n    tc,\r\n    nc,\r\n    ec,\r\n    rc = za(),\r\n    ic = {\r\n      point: oc,\r\n      lineStart: uc,\r\n      lineEnd: cc,\r\n      polygonStart: function () {\r\n        ;(ic.point = fc), (ic.lineStart = sc), (ic.lineEnd = lc), rc.reset(), bu.polygonStart()\r\n      },\r\n      polygonEnd: function () {\r\n        bu.polygonEnd(),\r\n          (ic.point = oc),\r\n          (ic.lineStart = uc),\r\n          (ic.lineEnd = cc),\r\n          yu < 0 ? ((Pu = -(Ru = 180)), (zu = -(Du = 90))) : rc > La ? (Du = 90) : rc < -La && (zu = -90),\r\n          (Yu[0] = Pu),\r\n          (Yu[1] = Ru)\r\n      }\r\n    }\r\n  function oc (t, n) {\r\n    Bu.push((Yu = [(Pu = t), (Ru = t)])), n < zu && (zu = n), n > Du && (Du = n)\r\n  }\r\n  function ac (t, n) {\r\n    var e = Au([t * ja, n * ja])\r\n    if (Ou) {\r\n      var r = ku(Ou, e),\r\n        i = ku([r[1], -r[0], 0], r)\r\n      Cu(i), (i = Nu(i))\r\n      var o,\r\n        a = t - qu,\r\n        u = a > 0 ? 1 : -1,\r\n        c = i[0] * Ia * u,\r\n        f = Ha(a) > 180\r\n      f ^ (u * qu < c && c < u * t)\r\n        ? (o = i[1] * Ia) > Du && (Du = o)\r\n        : f ^ (u * qu < (c = ((c + 360) % 360) - 180) && c < u * t)\r\n        ? (o = -i[1] * Ia) < zu && (zu = o)\r\n        : (n < zu && (zu = n), n > Du && (Du = n)),\r\n        f\r\n          ? t < qu\r\n            ? hc(Pu, t) > hc(Pu, Ru) && (Ru = t)\r\n            : hc(t, Ru) > hc(Pu, Ru) && (Pu = t)\r\n          : Ru >= Pu\r\n          ? (t < Pu && (Pu = t), t > Ru && (Ru = t))\r\n          : t > qu\r\n          ? hc(Pu, t) > hc(Pu, Ru) && (Ru = t)\r\n          : hc(t, Ru) > hc(Pu, Ru) && (Pu = t)\r\n    } else Bu.push((Yu = [(Pu = t), (Ru = t)]))\r\n    n < zu && (zu = n), n > Du && (Du = n), (Ou = e), (qu = t)\r\n  }\r\n  function uc () {\r\n    ic.point = ac\r\n  }\r\n  function cc () {\r\n    ;(Yu[0] = Pu), (Yu[1] = Ru), (ic.point = oc), (Ou = null)\r\n  }\r\n  function fc (t, n) {\r\n    if (Ou) {\r\n      var e = t - qu\r\n      rc.add(Ha(e) > 180 ? e + (e > 0 ? 360 : -360) : e)\r\n    } else (Lu = t), (Uu = n)\r\n    bu.point(t, n), ac(t, n)\r\n  }\r\n  function sc () {\r\n    bu.lineStart()\r\n  }\r\n  function lc () {\r\n    fc(Lu, Uu), bu.lineEnd(), Ha(rc) > La && (Pu = -(Ru = 180)), (Yu[0] = Pu), (Yu[1] = Ru), (Ou = null)\r\n  }\r\n  function hc (t, n) {\r\n    return (n -= t) < 0 ? n + 360 : n\r\n  }\r\n  function dc (t, n) {\r\n    return t[0] - n[0]\r\n  }\r\n  function pc (t, n) {\r\n    return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n\r\n  }\r\n  var vc = {\r\n    sphere: ou,\r\n    point: gc,\r\n    lineStart: _c,\r\n    lineEnd: xc,\r\n    polygonStart: function () {\r\n      ;(vc.lineStart = wc), (vc.lineEnd = Mc)\r\n    },\r\n    polygonEnd: function () {\r\n      ;(vc.lineStart = _c), (vc.lineEnd = xc)\r\n    }\r\n  }\r\n  function gc (t, n) {\r\n    t *= ja\r\n    var e = Va((n *= ja))\r\n    yc(e * Va(t), e * Ja(t), Ja(n))\r\n  }\r\n  function yc (t, n, e) {\r\n    ;(ju += (t - ju) / ++Fu), (Hu += (n - Hu) / Fu), (Xu += (e - Xu) / Fu)\r\n  }\r\n  function _c () {\r\n    vc.point = bc\r\n  }\r\n  function bc (t, n) {\r\n    t *= ja\r\n    var e = Va((n *= ja))\r\n    ;(tc = e * Va(t)), (nc = e * Ja(t)), (ec = Ja(n)), (vc.point = mc), yc(tc, nc, ec)\r\n  }\r\n  function mc (t, n) {\r\n    t *= ja\r\n    var e = Va((n *= ja)),\r\n      r = e * Va(t),\r\n      i = e * Ja(t),\r\n      o = Ja(n),\r\n      a = Ga(\r\n        tu((a = nc * o - ec * i) * a + (a = ec * r - tc * o) * a + (a = tc * i - nc * r) * a),\r\n        tc * r + nc * i + ec * o\r\n      )\r\n    ;(Iu += a), (Gu += a * (tc + (tc = r))), (Vu += a * (nc + (nc = i))), ($u += a * (ec + (ec = o))), yc(tc, nc, ec)\r\n  }\r\n  function xc () {\r\n    vc.point = gc\r\n  }\r\n  function wc () {\r\n    vc.point = Nc\r\n  }\r\n  function Mc () {\r\n    Ac(Ju, Ku), (vc.point = gc)\r\n  }\r\n  function Nc (t, n) {\r\n    ;(Ju = t), (Ku = n), (t *= ja), (n *= ja), (vc.point = Ac)\r\n    var e = Va(n)\r\n    ;(tc = e * Va(t)), (nc = e * Ja(t)), (ec = Ja(n)), yc(tc, nc, ec)\r\n  }\r\n  function Ac (t, n) {\r\n    t *= ja\r\n    var e = Va((n *= ja)),\r\n      r = e * Va(t),\r\n      i = e * Ja(t),\r\n      o = Ja(n),\r\n      a = nc * o - ec * i,\r\n      u = ec * r - tc * o,\r\n      c = tc * i - nc * r,\r\n      f = tu(a * a + u * u + c * c),\r\n      s = ru(f),\r\n      l = f && -s / f\r\n    ;(Wu += l * a),\r\n      (Zu += l * u),\r\n      (Qu += l * c),\r\n      (Iu += s),\r\n      (Gu += s * (tc + (tc = r))),\r\n      (Vu += s * (nc + (nc = i))),\r\n      ($u += s * (ec + (ec = o))),\r\n      yc(tc, nc, ec)\r\n  }\r\n  function Sc (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function kc (t, n) {\r\n    function e (e, r) {\r\n      return (e = t(e, r)), n(e[0], e[1])\r\n    }\r\n    return (\r\n      t.invert &&\r\n        n.invert &&\r\n        (e.invert = function (e, r) {\r\n          return (e = n.invert(e, r)) && t.invert(e[0], e[1])\r\n        }),\r\n      e\r\n    )\r\n  }\r\n  function Tc (t, n) {\r\n    return [Ha(t) > Oa ? t + Math.round(-t / Fa) * Fa : t, n]\r\n  }\r\n  function Ec (t, n, e) {\r\n    return (t %= Fa) ? (n || e ? kc(Pc(t), zc(n, e)) : Pc(t)) : n || e ? zc(n, e) : Tc\r\n  }\r\n  function Cc (t) {\r\n    return function (n, e) {\r\n      return [(n += t) > Oa ? n - Fa : n < -Oa ? n + Fa : n, e]\r\n    }\r\n  }\r\n  function Pc (t) {\r\n    var n = Cc(t)\r\n    return (n.invert = Cc(-t)), n\r\n  }\r\n  function zc (t, n) {\r\n    var e = Va(t),\r\n      r = Ja(t),\r\n      i = Va(n),\r\n      o = Ja(n)\r\n    function a (t, n) {\r\n      var a = Va(n),\r\n        u = Va(t) * a,\r\n        c = Ja(t) * a,\r\n        f = Ja(n),\r\n        s = f * e + u * r\r\n      return [Ga(c * i - s * o, u * e - f * r), ru(s * i + c * o)]\r\n    }\r\n    return (\r\n      (a.invert = function (t, n) {\r\n        var a = Va(n),\r\n          u = Va(t) * a,\r\n          c = Ja(t) * a,\r\n          f = Ja(n),\r\n          s = f * i - c * o\r\n        return [Ga(c * i + f * o, u * e + s * r), ru(s * e - u * r)]\r\n      }),\r\n      a\r\n    )\r\n  }\r\n  function Rc (t) {\r\n    function n (n) {\r\n      return ((n = t(n[0] * ja, n[1] * ja))[0] *= Ia), (n[1] *= Ia), n\r\n    }\r\n    return (\r\n      (t = Ec(t[0] * ja, t[1] * ja, t.length > 2 ? t[2] * ja : 0)),\r\n      (n.invert = function (n) {\r\n        return ((n = t.invert(n[0] * ja, n[1] * ja))[0] *= Ia), (n[1] *= Ia), n\r\n      }),\r\n      n\r\n    )\r\n  }\r\n  function Dc (t, n, e, r, i, o) {\r\n    if (e) {\r\n      var a = Va(n),\r\n        u = Ja(n),\r\n        c = r * e\r\n      null == i\r\n        ? ((i = n + r * Fa), (o = n - c / 2))\r\n        : ((i = qc(a, i)), (o = qc(a, o)), (r > 0 ? i < o : i > o) && (i += r * Fa))\r\n      for (var f, s = i; r > 0 ? s > o : s < o; s -= c) (f = Nu([a, -u * Va(s), -u * Ja(s)])), t.point(f[0], f[1])\r\n    }\r\n  }\r\n  function qc (t, n) {\r\n    ;((n = Au(n))[0] -= t), Cu(n)\r\n    var e = eu(-n[1])\r\n    return ((-n[2] < 0 ? -e : e) + Fa - La) % Fa\r\n  }\r\n  function Lc () {\r\n    var t,\r\n      n = []\r\n    return {\r\n      point: function (n, e) {\r\n        t.push([n, e])\r\n      },\r\n      lineStart: function () {\r\n        n.push((t = []))\r\n      },\r\n      lineEnd: ou,\r\n      rejoin: function () {\r\n        n.length > 1 && n.push(n.pop().concat(n.shift()))\r\n      },\r\n      result: function () {\r\n        var e = n\r\n        return (n = []), (t = null), e\r\n      }\r\n    }\r\n  }\r\n  function Uc (t, n) {\r\n    return Ha(t[0] - n[0]) < La && Ha(t[1] - n[1]) < La\r\n  }\r\n  function Oc (t, n, e, r) {\r\n    ;(this.x = t), (this.z = n), (this.o = e), (this.e = r), (this.v = !1), (this.n = this.p = null)\r\n  }\r\n  function Bc (t, n, e, r, i) {\r\n    var o,\r\n      a,\r\n      u = [],\r\n      c = []\r\n    if (\r\n      (t.forEach(function (t) {\r\n        if (!((n = t.length - 1) <= 0)) {\r\n          var n,\r\n            e,\r\n            r = t[0],\r\n            a = t[n]\r\n          if (Uc(r, a)) {\r\n            for (i.lineStart(), o = 0; o < n; ++o) i.point((r = t[o])[0], r[1])\r\n            i.lineEnd()\r\n          } else\r\n            u.push((e = new Oc(r, t, null, !0))),\r\n              c.push((e.o = new Oc(r, null, e, !1))),\r\n              u.push((e = new Oc(a, t, null, !1))),\r\n              c.push((e.o = new Oc(a, null, e, !0)))\r\n        }\r\n      }),\r\n      u.length)\r\n    ) {\r\n      for (c.sort(n), Yc(u), Yc(c), o = 0, a = c.length; o < a; ++o) c[o].e = e = !e\r\n      for (var f, s, l = u[0]; ; ) {\r\n        for (var h = l, d = !0; h.v; ) if ((h = h.n) === l) return\r\n        ;(f = h.z), i.lineStart()\r\n        do {\r\n          if (((h.v = h.o.v = !0), h.e)) {\r\n            if (d) for (o = 0, a = f.length; o < a; ++o) i.point((s = f[o])[0], s[1])\r\n            else r(h.x, h.n.x, 1, i)\r\n            h = h.n\r\n          } else {\r\n            if (d) for (f = h.p.z, o = f.length - 1; o >= 0; --o) i.point((s = f[o])[0], s[1])\r\n            else r(h.x, h.p.x, -1, i)\r\n            h = h.p\r\n          }\r\n          ;(f = (h = h.o).z), (d = !d)\r\n        } while (!h.v)\r\n        i.lineEnd()\r\n      }\r\n    }\r\n  }\r\n  function Yc (t) {\r\n    if ((n = t.length)) {\r\n      for (var n, e, r = 0, i = t[0]; ++r < n; ) (i.n = e = t[r]), (e.p = i), (i = e)\r\n      ;(i.n = e = t[0]), (e.p = i)\r\n    }\r\n  }\r\n  Tc.invert = Tc\r\n  var Fc = za()\r\n  function Ic (t, n) {\r\n    var e = n[0],\r\n      r = n[1],\r\n      i = Ja(r),\r\n      o = [Ja(e), -Va(e), 0],\r\n      a = 0,\r\n      u = 0\r\n    Fc.reset(), 1 === i ? (r = Ba + La) : -1 === i && (r = -Ba - La)\r\n    for (var c = 0, f = t.length; c < f; ++c)\r\n      if ((l = (s = t[c]).length))\r\n        for (\r\n          var s, l, h = s[l - 1], d = h[0], p = h[1] / 2 + Ya, v = Ja(p), g = Va(p), y = 0;\r\n          y < l;\r\n          ++y, d = b, v = x, g = w, h = _\r\n        ) {\r\n          var _ = s[y],\r\n            b = _[0],\r\n            m = _[1] / 2 + Ya,\r\n            x = Ja(m),\r\n            w = Va(m),\r\n            M = b - d,\r\n            N = M >= 0 ? 1 : -1,\r\n            A = N * M,\r\n            S = A > Oa,\r\n            k = v * x\r\n          if ((Fc.add(Ga(k * N * Ja(A), g * w + k * Va(A))), (a += S ? M + N * Fa : M), S ^ (d >= e) ^ (b >= e))) {\r\n            var T = ku(Au(h), Au(_))\r\n            Cu(T)\r\n            var E = ku(o, T)\r\n            Cu(E)\r\n            var C = (S ^ (M >= 0) ? -1 : 1) * ru(E[2])\r\n            ;(r > C || (r === C && (T[0] || T[1]))) && (u += S ^ (M >= 0) ? 1 : -1)\r\n          }\r\n        }\r\n    return (a < -La || (a < La && Fc < -La)) ^ (1 & u)\r\n  }\r\n  function jc (t, n, e, r) {\r\n    return function (i) {\r\n      var o,\r\n        a,\r\n        u,\r\n        c = n(i),\r\n        f = Lc(),\r\n        s = n(f),\r\n        l = !1,\r\n        h = {\r\n          point: d,\r\n          lineStart: v,\r\n          lineEnd: g,\r\n          polygonStart: function () {\r\n            ;(h.point = y), (h.lineStart = _), (h.lineEnd = b), (a = []), (o = [])\r\n          },\r\n          polygonEnd: function () {\r\n            ;(h.point = d), (h.lineStart = v), (h.lineEnd = g), (a = S(a))\r\n            var t = Ic(o, r)\r\n            a.length\r\n              ? (l || (i.polygonStart(), (l = !0)), Bc(a, Xc, t, e, i))\r\n              : t && (l || (i.polygonStart(), (l = !0)), i.lineStart(), e(null, null, 1, i), i.lineEnd()),\r\n              l && (i.polygonEnd(), (l = !1)),\r\n              (a = o = null)\r\n          },\r\n          sphere: function () {\r\n            i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd()\r\n          }\r\n        }\r\n      function d (n, e) {\r\n        t(n, e) && i.point(n, e)\r\n      }\r\n      function p (t, n) {\r\n        c.point(t, n)\r\n      }\r\n      function v () {\r\n        ;(h.point = p), c.lineStart()\r\n      }\r\n      function g () {\r\n        ;(h.point = d), c.lineEnd()\r\n      }\r\n      function y (t, n) {\r\n        u.push([t, n]), s.point(t, n)\r\n      }\r\n      function _ () {\r\n        s.lineStart(), (u = [])\r\n      }\r\n      function b () {\r\n        y(u[0][0], u[0][1]), s.lineEnd()\r\n        var t,\r\n          n,\r\n          e,\r\n          r,\r\n          c = s.clean(),\r\n          h = f.result(),\r\n          d = h.length\r\n        if ((u.pop(), o.push(u), (u = null), d))\r\n          if (1 & c) {\r\n            if ((n = (e = h[0]).length - 1) > 0) {\r\n              for (l || (i.polygonStart(), (l = !0)), i.lineStart(), t = 0; t < n; ++t) i.point((r = e[t])[0], r[1])\r\n              i.lineEnd()\r\n            }\r\n          } else d > 1 && 2 & c && h.push(h.pop().concat(h.shift())), a.push(h.filter(Hc))\r\n      }\r\n      return h\r\n    }\r\n  }\r\n  function Hc (t) {\r\n    return t.length > 1\r\n  }\r\n  function Xc (t, n) {\r\n    return ((t = t.x)[0] < 0 ? t[1] - Ba - La : Ba - t[1]) - ((n = n.x)[0] < 0 ? n[1] - Ba - La : Ba - n[1])\r\n  }\r\n  var Gc = jc(\r\n    function () {\r\n      return !0\r\n    },\r\n    function (t) {\r\n      var n,\r\n        e = NaN,\r\n        r = NaN,\r\n        i = NaN\r\n      return {\r\n        lineStart: function () {\r\n          t.lineStart(), (n = 1)\r\n        },\r\n        point: function (o, a) {\r\n          var u = o > 0 ? Oa : -Oa,\r\n            c = Ha(o - e)\r\n          Ha(c - Oa) < La\r\n            ? (t.point(e, (r = (r + a) / 2 > 0 ? Ba : -Ba)),\r\n              t.point(i, r),\r\n              t.lineEnd(),\r\n              t.lineStart(),\r\n              t.point(u, r),\r\n              t.point(o, r),\r\n              (n = 0))\r\n            : i !== u &&\r\n              c >= Oa &&\r\n              (Ha(e - i) < La && (e -= i * La),\r\n              Ha(o - u) < La && (o -= u * La),\r\n              (r = (function (t, n, e, r) {\r\n                var i,\r\n                  o,\r\n                  a = Ja(t - e)\r\n                return Ha(a) > La\r\n                  ? Xa((Ja(n) * (o = Va(r)) * Ja(e) - Ja(r) * (i = Va(n)) * Ja(t)) / (i * o * a))\r\n                  : (n + r) / 2\r\n              })(e, r, o, a)),\r\n              t.point(i, r),\r\n              t.lineEnd(),\r\n              t.lineStart(),\r\n              t.point(u, r),\r\n              (n = 0)),\r\n            t.point((e = o), (r = a)),\r\n            (i = u)\r\n        },\r\n        lineEnd: function () {\r\n          t.lineEnd(), (e = r = NaN)\r\n        },\r\n        clean: function () {\r\n          return 2 - n\r\n        }\r\n      }\r\n    },\r\n    function (t, n, e, r) {\r\n      var i\r\n      if (null == t)\r\n        (i = e * Ba),\r\n          r.point(-Oa, i),\r\n          r.point(0, i),\r\n          r.point(Oa, i),\r\n          r.point(Oa, 0),\r\n          r.point(Oa, -i),\r\n          r.point(0, -i),\r\n          r.point(-Oa, -i),\r\n          r.point(-Oa, 0),\r\n          r.point(-Oa, i)\r\n      else if (Ha(t[0] - n[0]) > La) {\r\n        var o = t[0] < n[0] ? Oa : -Oa\r\n        ;(i = (e * o) / 2), r.point(-o, i), r.point(0, i), r.point(o, i)\r\n      } else r.point(n[0], n[1])\r\n    },\r\n    [-Oa, -Ba]\r\n  )\r\n  function Vc (t) {\r\n    var n = Va(t),\r\n      e = 6 * ja,\r\n      r = n > 0,\r\n      i = Ha(n) > La\r\n    function o (t, e) {\r\n      return Va(t) * Va(e) > n\r\n    }\r\n    function a (t, e, r) {\r\n      var i = [1, 0, 0],\r\n        o = ku(Au(t), Au(e)),\r\n        a = Su(o, o),\r\n        u = o[0],\r\n        c = a - u * u\r\n      if (!c) return !r && t\r\n      var f = (n * a) / c,\r\n        s = (-n * u) / c,\r\n        l = ku(i, o),\r\n        h = Eu(i, f)\r\n      Tu(h, Eu(o, s))\r\n      var d = l,\r\n        p = Su(h, d),\r\n        v = Su(d, d),\r\n        g = p * p - v * (Su(h, h) - 1)\r\n      if (!(g < 0)) {\r\n        var y = tu(g),\r\n          _ = Eu(d, (-p - y) / v)\r\n        if ((Tu(_, h), (_ = Nu(_)), !r)) return _\r\n        var b,\r\n          m = t[0],\r\n          x = e[0],\r\n          w = t[1],\r\n          M = e[1]\r\n        x < m && ((b = m), (m = x), (x = b))\r\n        var N = x - m,\r\n          A = Ha(N - Oa) < La\r\n        if (\r\n          (!A && M < w && ((b = w), (w = M), (M = b)),\r\n          A || N < La\r\n            ? A\r\n              ? (w + M > 0) ^ (_[1] < (Ha(_[0] - m) < La ? w : M))\r\n              : w <= _[1] && _[1] <= M\r\n            : (N > Oa) ^ (m <= _[0] && _[0] <= x))\r\n        ) {\r\n          var S = Eu(d, (-p + y) / v)\r\n          return Tu(S, h), [_, Nu(S)]\r\n        }\r\n      }\r\n    }\r\n    function u (n, e) {\r\n      var i = r ? t : Oa - t,\r\n        o = 0\r\n      return n < -i ? (o |= 1) : n > i && (o |= 2), e < -i ? (o |= 4) : e > i && (o |= 8), o\r\n    }\r\n    return jc(\r\n      o,\r\n      function (t) {\r\n        var n, e, c, f, s\r\n        return {\r\n          lineStart: function () {\r\n            ;(f = c = !1), (s = 1)\r\n          },\r\n          point: function (l, h) {\r\n            var d,\r\n              p = [l, h],\r\n              v = o(l, h),\r\n              g = r ? (v ? 0 : u(l, h)) : v ? u(l + (l < 0 ? Oa : -Oa), h) : 0\r\n            if (\r\n              (!n && (f = c = v) && t.lineStart(),\r\n              v !== c && (!(d = a(n, p)) || Uc(n, d) || Uc(p, d)) && ((p[0] += La), (p[1] += La), (v = o(p[0], p[1]))),\r\n              v !== c)\r\n            )\r\n              (s = 0),\r\n                v\r\n                  ? (t.lineStart(), (d = a(p, n)), t.point(d[0], d[1]))\r\n                  : ((d = a(n, p)), t.point(d[0], d[1]), t.lineEnd()),\r\n                (n = d)\r\n            else if (i && n && r ^ v) {\r\n              var y\r\n              g & e ||\r\n                !(y = a(p, n, !0)) ||\r\n                ((s = 0),\r\n                r\r\n                  ? (t.lineStart(), t.point(y[0][0], y[0][1]), t.point(y[1][0], y[1][1]), t.lineEnd())\r\n                  : (t.point(y[1][0], y[1][1]), t.lineEnd(), t.lineStart(), t.point(y[0][0], y[0][1])))\r\n            }\r\n            !v || (n && Uc(n, p)) || t.point(p[0], p[1]), (n = p), (c = v), (e = g)\r\n          },\r\n          lineEnd: function () {\r\n            c && t.lineEnd(), (n = null)\r\n          },\r\n          clean: function () {\r\n            return s | ((f && c) << 1)\r\n          }\r\n        }\r\n      },\r\n      function (n, r, i, o) {\r\n        Dc(o, t, e, i, n, r)\r\n      },\r\n      r ? [0, -t] : [-Oa, t - Oa]\r\n    )\r\n  }\r\n  var $c = 1e9,\r\n    Wc = -$c\r\n  function Zc (t, n, e, r) {\r\n    function i (i, o) {\r\n      return t <= i && i <= e && n <= o && o <= r\r\n    }\r\n    function o (i, o, u, f) {\r\n      var s = 0,\r\n        l = 0\r\n      if (null == i || (s = a(i, u)) !== (l = a(o, u)) || (c(i, o) < 0) ^ (u > 0))\r\n        do {\r\n          f.point(0 === s || 3 === s ? t : e, s > 1 ? r : n)\r\n        } while ((s = (s + u + 4) % 4) !== l)\r\n      else f.point(o[0], o[1])\r\n    }\r\n    function a (r, i) {\r\n      return Ha(r[0] - t) < La\r\n        ? i > 0\r\n          ? 0\r\n          : 3\r\n        : Ha(r[0] - e) < La\r\n        ? i > 0\r\n          ? 2\r\n          : 1\r\n        : Ha(r[1] - n) < La\r\n        ? i > 0\r\n          ? 1\r\n          : 0\r\n        : i > 0\r\n        ? 3\r\n        : 2\r\n    }\r\n    function u (t, n) {\r\n      return c(t.x, n.x)\r\n    }\r\n    function c (t, n) {\r\n      var e = a(t, 1),\r\n        r = a(n, 1)\r\n      return e !== r ? e - r : 0 === e ? n[1] - t[1] : 1 === e ? t[0] - n[0] : 2 === e ? t[1] - n[1] : n[0] - t[0]\r\n    }\r\n    return function (a) {\r\n      var c,\r\n        f,\r\n        s,\r\n        l,\r\n        h,\r\n        d,\r\n        p,\r\n        v,\r\n        g,\r\n        y,\r\n        _,\r\n        b = a,\r\n        m = Lc(),\r\n        x = {\r\n          point: w,\r\n          lineStart: function () {\r\n            ;(x.point = M), f && f.push((s = []))\r\n            ;(y = !0), (g = !1), (p = v = NaN)\r\n          },\r\n          lineEnd: function () {\r\n            c && (M(l, h), d && g && m.rejoin(), c.push(m.result()))\r\n            ;(x.point = w), g && b.lineEnd()\r\n          },\r\n          polygonStart: function () {\r\n            ;(b = m), (c = []), (f = []), (_ = !0)\r\n          },\r\n          polygonEnd: function () {\r\n            var n = (function () {\r\n                for (var n = 0, e = 0, i = f.length; e < i; ++e)\r\n                  for (var o, a, u = f[e], c = 1, s = u.length, l = u[0], h = l[0], d = l[1]; c < s; ++c)\r\n                    (o = h),\r\n                      (a = d),\r\n                      (l = u[c]),\r\n                      (h = l[0]),\r\n                      (d = l[1]),\r\n                      a <= r\r\n                        ? d > r && (h - o) * (r - a) > (d - a) * (t - o) && ++n\r\n                        : d <= r && (h - o) * (r - a) < (d - a) * (t - o) && --n\r\n                return n\r\n              })(),\r\n              e = _ && n,\r\n              i = (c = S(c)).length\r\n            ;(e || i) &&\r\n              (a.polygonStart(),\r\n              e && (a.lineStart(), o(null, null, 1, a), a.lineEnd()),\r\n              i && Bc(c, u, n, o, a),\r\n              a.polygonEnd())\r\n            ;(b = a), (c = f = s = null)\r\n          }\r\n        }\r\n      function w (t, n) {\r\n        i(t, n) && b.point(t, n)\r\n      }\r\n      function M (o, a) {\r\n        var u = i(o, a)\r\n        if ((f && s.push([o, a]), y)) (l = o), (h = a), (d = u), (y = !1), u && (b.lineStart(), b.point(o, a))\r\n        else if (u && g) b.point(o, a)\r\n        else {\r\n          var c = [(p = Math.max(Wc, Math.min($c, p))), (v = Math.max(Wc, Math.min($c, v)))],\r\n            m = [(o = Math.max(Wc, Math.min($c, o))), (a = Math.max(Wc, Math.min($c, a)))]\r\n          !(function (t, n, e, r, i, o) {\r\n            var a,\r\n              u = t[0],\r\n              c = t[1],\r\n              f = 0,\r\n              s = 1,\r\n              l = n[0] - u,\r\n              h = n[1] - c\r\n            if (((a = e - u), l || !(a > 0))) {\r\n              if (((a /= l), l < 0)) {\r\n                if (a < f) return\r\n                a < s && (s = a)\r\n              } else if (l > 0) {\r\n                if (a > s) return\r\n                a > f && (f = a)\r\n              }\r\n              if (((a = i - u), l || !(a < 0))) {\r\n                if (((a /= l), l < 0)) {\r\n                  if (a > s) return\r\n                  a > f && (f = a)\r\n                } else if (l > 0) {\r\n                  if (a < f) return\r\n                  a < s && (s = a)\r\n                }\r\n                if (((a = r - c), h || !(a > 0))) {\r\n                  if (((a /= h), h < 0)) {\r\n                    if (a < f) return\r\n                    a < s && (s = a)\r\n                  } else if (h > 0) {\r\n                    if (a > s) return\r\n                    a > f && (f = a)\r\n                  }\r\n                  if (((a = o - c), h || !(a < 0))) {\r\n                    if (((a /= h), h < 0)) {\r\n                      if (a > s) return\r\n                      a > f && (f = a)\r\n                    } else if (h > 0) {\r\n                      if (a < f) return\r\n                      a < s && (s = a)\r\n                    }\r\n                    return (\r\n                      f > 0 && ((t[0] = u + f * l), (t[1] = c + f * h)),\r\n                      s < 1 && ((n[0] = u + s * l), (n[1] = c + s * h)),\r\n                      !0\r\n                    )\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          })(c, m, t, n, e, r)\r\n            ? u && (b.lineStart(), b.point(o, a), (_ = !1))\r\n            : (g || (b.lineStart(), b.point(c[0], c[1])), b.point(m[0], m[1]), u || b.lineEnd(), (_ = !1))\r\n        }\r\n        ;(p = o), (v = a), (g = u)\r\n      }\r\n      return x\r\n    }\r\n  }\r\n  var Qc,\r\n    Jc,\r\n    Kc,\r\n    tf = za(),\r\n    nf = {\r\n      sphere: ou,\r\n      point: ou,\r\n      lineStart: function () {\r\n        ;(nf.point = rf), (nf.lineEnd = ef)\r\n      },\r\n      lineEnd: ou,\r\n      polygonStart: ou,\r\n      polygonEnd: ou\r\n    }\r\n  function ef () {\r\n    nf.point = nf.lineEnd = ou\r\n  }\r\n  function rf (t, n) {\r\n    ;(Qc = t *= ja), (Jc = Ja((n *= ja))), (Kc = Va(n)), (nf.point = of)\r\n  }\r\n  function of (t, n) {\r\n    t *= ja\r\n    var e = Ja((n *= ja)),\r\n      r = Va(n),\r\n      i = Ha(t - Qc),\r\n      o = Va(i),\r\n      a = r * Ja(i),\r\n      u = Kc * e - Jc * r * o,\r\n      c = Jc * e + Kc * r * o\r\n    tf.add(Ga(tu(a * a + u * u), c)), (Qc = t), (Jc = e), (Kc = r)\r\n  }\r\n  function af (t) {\r\n    return tf.reset(), lu(t, nf), +tf\r\n  }\r\n  var uf = [null, null],\r\n    cf = { type: 'LineString', coordinates: uf }\r\n  function ff (t, n) {\r\n    return (uf[0] = t), (uf[1] = n), af(cf)\r\n  }\r\n  var sf = {\r\n      Feature: function (t, n) {\r\n        return hf(t.geometry, n)\r\n      },\r\n      FeatureCollection: function (t, n) {\r\n        for (var e = t.features, r = -1, i = e.length; ++r < i; ) if (hf(e[r].geometry, n)) return !0\r\n        return !1\r\n      }\r\n    },\r\n    lf = {\r\n      Sphere: function () {\r\n        return !0\r\n      },\r\n      Point: function (t, n) {\r\n        return df(t.coordinates, n)\r\n      },\r\n      MultiPoint: function (t, n) {\r\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) if (df(e[r], n)) return !0\r\n        return !1\r\n      },\r\n      LineString: function (t, n) {\r\n        return pf(t.coordinates, n)\r\n      },\r\n      MultiLineString: function (t, n) {\r\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) if (pf(e[r], n)) return !0\r\n        return !1\r\n      },\r\n      Polygon: function (t, n) {\r\n        return vf(t.coordinates, n)\r\n      },\r\n      MultiPolygon: function (t, n) {\r\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) if (vf(e[r], n)) return !0\r\n        return !1\r\n      },\r\n      GeometryCollection: function (t, n) {\r\n        for (var e = t.geometries, r = -1, i = e.length; ++r < i; ) if (hf(e[r], n)) return !0\r\n        return !1\r\n      }\r\n    }\r\n  function hf (t, n) {\r\n    return !(!t || !lf.hasOwnProperty(t.type)) && lf[t.type](t, n)\r\n  }\r\n  function df (t, n) {\r\n    return 0 === ff(t, n)\r\n  }\r\n  function pf (t, n) {\r\n    var e = ff(t[0], t[1])\r\n    return ff(t[0], n) + ff(n, t[1]) <= e + La\r\n  }\r\n  function vf (t, n) {\r\n    return !!Ic(t.map(gf), yf(n))\r\n  }\r\n  function gf (t) {\r\n    return (t = t.map(yf)).pop(), t\r\n  }\r\n  function yf (t) {\r\n    return [t[0] * ja, t[1] * ja]\r\n  }\r\n  function _f (t, n, e) {\r\n    var r = g(t, n - La, e).concat(n)\r\n    return function (t) {\r\n      return r.map(function (n) {\r\n        return [t, n]\r\n      })\r\n    }\r\n  }\r\n  function bf (t, n, e) {\r\n    var r = g(t, n - La, e).concat(n)\r\n    return function (t) {\r\n      return r.map(function (n) {\r\n        return [n, t]\r\n      })\r\n    }\r\n  }\r\n  function mf () {\r\n    var t,\r\n      n,\r\n      e,\r\n      r,\r\n      i,\r\n      o,\r\n      a,\r\n      u,\r\n      c,\r\n      f,\r\n      s,\r\n      l,\r\n      h = 10,\r\n      d = h,\r\n      p = 90,\r\n      v = 360,\r\n      y = 2.5\r\n    function _ () {\r\n      return { type: 'MultiLineString', coordinates: b() }\r\n    }\r\n    function b () {\r\n      return g($a(r / p) * p, e, p)\r\n        .map(s)\r\n        .concat(g($a(u / v) * v, a, v).map(l))\r\n        .concat(\r\n          g($a(n / h) * h, t, h)\r\n            .filter(function (t) {\r\n              return Ha(t % p) > La\r\n            })\r\n            .map(c)\r\n        )\r\n        .concat(\r\n          g($a(o / d) * d, i, d)\r\n            .filter(function (t) {\r\n              return Ha(t % v) > La\r\n            })\r\n            .map(f)\r\n        )\r\n    }\r\n    return (\r\n      (_.lines = function () {\r\n        return b().map(function (t) {\r\n          return { type: 'LineString', coordinates: t }\r\n        })\r\n      }),\r\n      (_.outline = function () {\r\n        return {\r\n          type: 'Polygon',\r\n          coordinates: [\r\n            s(r).concat(\r\n              l(a).slice(1),\r\n              s(e)\r\n                .reverse()\r\n                .slice(1),\r\n              l(u)\r\n                .reverse()\r\n                .slice(1)\r\n            )\r\n          ]\r\n        }\r\n      }),\r\n      (_.extent = function (t) {\r\n        return arguments.length ? _.extentMajor(t).extentMinor(t) : _.extentMinor()\r\n      }),\r\n      (_.extentMajor = function (t) {\r\n        return arguments.length\r\n          ? ((r = +t[0][0]),\r\n            (e = +t[1][0]),\r\n            (u = +t[0][1]),\r\n            (a = +t[1][1]),\r\n            r > e && ((t = r), (r = e), (e = t)),\r\n            u > a && ((t = u), (u = a), (a = t)),\r\n            _.precision(y))\r\n          : [[r, u], [e, a]]\r\n      }),\r\n      (_.extentMinor = function (e) {\r\n        return arguments.length\r\n          ? ((n = +e[0][0]),\r\n            (t = +e[1][0]),\r\n            (o = +e[0][1]),\r\n            (i = +e[1][1]),\r\n            n > t && ((e = n), (n = t), (t = e)),\r\n            o > i && ((e = o), (o = i), (i = e)),\r\n            _.precision(y))\r\n          : [[n, o], [t, i]]\r\n      }),\r\n      (_.step = function (t) {\r\n        return arguments.length ? _.stepMajor(t).stepMinor(t) : _.stepMinor()\r\n      }),\r\n      (_.stepMajor = function (t) {\r\n        return arguments.length ? ((p = +t[0]), (v = +t[1]), _) : [p, v]\r\n      }),\r\n      (_.stepMinor = function (t) {\r\n        return arguments.length ? ((h = +t[0]), (d = +t[1]), _) : [h, d]\r\n      }),\r\n      (_.precision = function (h) {\r\n        return arguments.length\r\n          ? ((y = +h), (c = _f(o, i, 90)), (f = bf(n, t, y)), (s = _f(u, a, 90)), (l = bf(r, e, y)), _)\r\n          : y\r\n      }),\r\n      _.extentMajor([[-180, -90 + La], [180, 90 - La]]).extentMinor([[-180, -80 - La], [180, 80 + La]])\r\n    )\r\n  }\r\n  function xf (t) {\r\n    return t\r\n  }\r\n  var wf,\r\n    Mf,\r\n    Nf,\r\n    Af,\r\n    Sf = za(),\r\n    kf = za(),\r\n    Tf = {\r\n      point: ou,\r\n      lineStart: ou,\r\n      lineEnd: ou,\r\n      polygonStart: function () {\r\n        ;(Tf.lineStart = Ef), (Tf.lineEnd = zf)\r\n      },\r\n      polygonEnd: function () {\r\n        ;(Tf.lineStart = Tf.lineEnd = Tf.point = ou), Sf.add(Ha(kf)), kf.reset()\r\n      },\r\n      result: function () {\r\n        var t = Sf / 2\r\n        return Sf.reset(), t\r\n      }\r\n    }\r\n  function Ef () {\r\n    Tf.point = Cf\r\n  }\r\n  function Cf (t, n) {\r\n    ;(Tf.point = Pf), (wf = Nf = t), (Mf = Af = n)\r\n  }\r\n  function Pf (t, n) {\r\n    kf.add(Af * t - Nf * n), (Nf = t), (Af = n)\r\n  }\r\n  function zf () {\r\n    Pf(wf, Mf)\r\n  }\r\n  var Rf = 1 / 0,\r\n    Df = Rf,\r\n    qf = -Rf,\r\n    Lf = qf,\r\n    Uf = {\r\n      point: function (t, n) {\r\n        t < Rf && (Rf = t)\r\n        t > qf && (qf = t)\r\n        n < Df && (Df = n)\r\n        n > Lf && (Lf = n)\r\n      },\r\n      lineStart: ou,\r\n      lineEnd: ou,\r\n      polygonStart: ou,\r\n      polygonEnd: ou,\r\n      result: function () {\r\n        var t = [[Rf, Df], [qf, Lf]]\r\n        return (qf = Lf = -(Df = Rf = 1 / 0)), t\r\n      }\r\n    }\r\n  var Of,\r\n    Bf,\r\n    Yf,\r\n    Ff,\r\n    If = 0,\r\n    jf = 0,\r\n    Hf = 0,\r\n    Xf = 0,\r\n    Gf = 0,\r\n    Vf = 0,\r\n    $f = 0,\r\n    Wf = 0,\r\n    Zf = 0,\r\n    Qf = {\r\n      point: Jf,\r\n      lineStart: Kf,\r\n      lineEnd: es,\r\n      polygonStart: function () {\r\n        ;(Qf.lineStart = rs), (Qf.lineEnd = is)\r\n      },\r\n      polygonEnd: function () {\r\n        ;(Qf.point = Jf), (Qf.lineStart = Kf), (Qf.lineEnd = es)\r\n      },\r\n      result: function () {\r\n        var t = Zf ? [$f / Zf, Wf / Zf] : Vf ? [Xf / Vf, Gf / Vf] : Hf ? [If / Hf, jf / Hf] : [NaN, NaN]\r\n        return (If = jf = Hf = Xf = Gf = Vf = $f = Wf = Zf = 0), t\r\n      }\r\n    }\r\n  function Jf (t, n) {\r\n    ;(If += t), (jf += n), ++Hf\r\n  }\r\n  function Kf () {\r\n    Qf.point = ts\r\n  }\r\n  function ts (t, n) {\r\n    ;(Qf.point = ns), Jf((Yf = t), (Ff = n))\r\n  }\r\n  function ns (t, n) {\r\n    var e = t - Yf,\r\n      r = n - Ff,\r\n      i = tu(e * e + r * r)\r\n    ;(Xf += (i * (Yf + t)) / 2), (Gf += (i * (Ff + n)) / 2), (Vf += i), Jf((Yf = t), (Ff = n))\r\n  }\r\n  function es () {\r\n    Qf.point = Jf\r\n  }\r\n  function rs () {\r\n    Qf.point = os\r\n  }\r\n  function is () {\r\n    as(Of, Bf)\r\n  }\r\n  function os (t, n) {\r\n    ;(Qf.point = as), Jf((Of = Yf = t), (Bf = Ff = n))\r\n  }\r\n  function as (t, n) {\r\n    var e = t - Yf,\r\n      r = n - Ff,\r\n      i = tu(e * e + r * r)\r\n    ;(Xf += (i * (Yf + t)) / 2),\r\n      (Gf += (i * (Ff + n)) / 2),\r\n      (Vf += i),\r\n      ($f += (i = Ff * t - Yf * n) * (Yf + t)),\r\n      (Wf += i * (Ff + n)),\r\n      (Zf += 3 * i),\r\n      Jf((Yf = t), (Ff = n))\r\n  }\r\n  function us (t) {\r\n    this._context = t\r\n  }\r\n  us.prototype = {\r\n    _radius: 4.5,\r\n    pointRadius: function (t) {\r\n      return (this._radius = t), this\r\n    },\r\n    polygonStart: function () {\r\n      this._line = 0\r\n    },\r\n    polygonEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      this._point = 0\r\n    },\r\n    lineEnd: function () {\r\n      0 === this._line && this._context.closePath(), (this._point = NaN)\r\n    },\r\n    point: function (t, n) {\r\n      switch (this._point) {\r\n        case 0:\r\n          this._context.moveTo(t, n), (this._point = 1)\r\n          break\r\n        case 1:\r\n          this._context.lineTo(t, n)\r\n          break\r\n        default:\r\n          this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, Fa)\r\n      }\r\n    },\r\n    result: ou\r\n  }\r\n  var cs,\r\n    fs,\r\n    ss,\r\n    ls,\r\n    hs,\r\n    ds = za(),\r\n    ps = {\r\n      point: ou,\r\n      lineStart: function () {\r\n        ps.point = vs\r\n      },\r\n      lineEnd: function () {\r\n        cs && gs(fs, ss), (ps.point = ou)\r\n      },\r\n      polygonStart: function () {\r\n        cs = !0\r\n      },\r\n      polygonEnd: function () {\r\n        cs = null\r\n      },\r\n      result: function () {\r\n        var t = +ds\r\n        return ds.reset(), t\r\n      }\r\n    }\r\n  function vs (t, n) {\r\n    ;(ps.point = gs), (fs = ls = t), (ss = hs = n)\r\n  }\r\n  function gs (t, n) {\r\n    ;(ls -= t), (hs -= n), ds.add(tu(ls * ls + hs * hs)), (ls = t), (hs = n)\r\n  }\r\n  function ys () {\r\n    this._string = []\r\n  }\r\n  function _s (t) {\r\n    return 'm0,' + t + 'a' + t + ',' + t + ' 0 1,1 0,' + -2 * t + 'a' + t + ',' + t + ' 0 1,1 0,' + 2 * t + 'z'\r\n  }\r\n  function bs (t) {\r\n    return function (n) {\r\n      var e = new ms()\r\n      for (var r in t) e[r] = t[r]\r\n      return (e.stream = n), e\r\n    }\r\n  }\r\n  function ms () {}\r\n  function xs (t, n, e) {\r\n    var r = t.clipExtent && t.clipExtent()\r\n    return (\r\n      t.scale(150).translate([0, 0]),\r\n      null != r && t.clipExtent(null),\r\n      lu(e, t.stream(Uf)),\r\n      n(Uf.result()),\r\n      null != r && t.clipExtent(r),\r\n      t\r\n    )\r\n  }\r\n  function ws (t, n, e) {\r\n    return xs(\r\n      t,\r\n      function (e) {\r\n        var r = n[1][0] - n[0][0],\r\n          i = n[1][1] - n[0][1],\r\n          o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])),\r\n          a = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2,\r\n          u = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2\r\n        t.scale(150 * o).translate([a, u])\r\n      },\r\n      e\r\n    )\r\n  }\r\n  function Ms (t, n, e) {\r\n    return ws(t, [[0, 0], n], e)\r\n  }\r\n  function Ns (t, n, e) {\r\n    return xs(\r\n      t,\r\n      function (e) {\r\n        var r = +n,\r\n          i = r / (e[1][0] - e[0][0]),\r\n          o = (r - i * (e[1][0] + e[0][0])) / 2,\r\n          a = -i * e[0][1]\r\n        t.scale(150 * i).translate([o, a])\r\n      },\r\n      e\r\n    )\r\n  }\r\n  function As (t, n, e) {\r\n    return xs(\r\n      t,\r\n      function (e) {\r\n        var r = +n,\r\n          i = r / (e[1][1] - e[0][1]),\r\n          o = -i * e[0][0],\r\n          a = (r - i * (e[1][1] + e[0][1])) / 2\r\n        t.scale(150 * i).translate([o, a])\r\n      },\r\n      e\r\n    )\r\n  }\r\n  ;(ys.prototype = {\r\n    _radius: 4.5,\r\n    _circle: _s(4.5),\r\n    pointRadius: function (t) {\r\n      return (t = +t) !== this._radius && ((this._radius = t), (this._circle = null)), this\r\n    },\r\n    polygonStart: function () {\r\n      this._line = 0\r\n    },\r\n    polygonEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      this._point = 0\r\n    },\r\n    lineEnd: function () {\r\n      0 === this._line && this._string.push('Z'), (this._point = NaN)\r\n    },\r\n    point: function (t, n) {\r\n      switch (this._point) {\r\n        case 0:\r\n          this._string.push('M', t, ',', n), (this._point = 1)\r\n          break\r\n        case 1:\r\n          this._string.push('L', t, ',', n)\r\n          break\r\n        default:\r\n          null == this._circle && (this._circle = _s(this._radius)), this._string.push('M', t, ',', n, this._circle)\r\n      }\r\n    },\r\n    result: function () {\r\n      if (this._string.length) {\r\n        var t = this._string.join('')\r\n        return (this._string = []), t\r\n      }\r\n      return null\r\n    }\r\n  }),\r\n    (ms.prototype = {\r\n      constructor: ms,\r\n      point: function (t, n) {\r\n        this.stream.point(t, n)\r\n      },\r\n      sphere: function () {\r\n        this.stream.sphere()\r\n      },\r\n      lineStart: function () {\r\n        this.stream.lineStart()\r\n      },\r\n      lineEnd: function () {\r\n        this.stream.lineEnd()\r\n      },\r\n      polygonStart: function () {\r\n        this.stream.polygonStart()\r\n      },\r\n      polygonEnd: function () {\r\n        this.stream.polygonEnd()\r\n      }\r\n    })\r\n  var Ss = 16,\r\n    ks = Va(30 * ja)\r\n  function Ts (t, n) {\r\n    return +n\r\n      ? (function (t, n) {\r\n          function e (r, i, o, a, u, c, f, s, l, h, d, p, v, g) {\r\n            var y = f - r,\r\n              _ = s - i,\r\n              b = y * y + _ * _\r\n            if (b > 4 * n && v--) {\r\n              var m = a + h,\r\n                x = u + d,\r\n                w = c + p,\r\n                M = tu(m * m + x * x + w * w),\r\n                N = ru((w /= M)),\r\n                A = Ha(Ha(w) - 1) < La || Ha(o - l) < La ? (o + l) / 2 : Ga(x, m),\r\n                S = t(A, N),\r\n                k = S[0],\r\n                T = S[1],\r\n                E = k - r,\r\n                C = T - i,\r\n                P = _ * E - y * C\r\n              ;((P * P) / b > n || Ha((y * E + _ * C) / b - 0.5) > 0.3 || a * h + u * d + c * p < ks) &&\r\n                (e(r, i, o, a, u, c, k, T, A, (m /= M), (x /= M), w, v, g),\r\n                g.point(k, T),\r\n                e(k, T, A, m, x, w, f, s, l, h, d, p, v, g))\r\n            }\r\n          }\r\n          return function (n) {\r\n            var r,\r\n              i,\r\n              o,\r\n              a,\r\n              u,\r\n              c,\r\n              f,\r\n              s,\r\n              l,\r\n              h,\r\n              d,\r\n              p,\r\n              v = {\r\n                point: g,\r\n                lineStart: y,\r\n                lineEnd: b,\r\n                polygonStart: function () {\r\n                  n.polygonStart(), (v.lineStart = m)\r\n                },\r\n                polygonEnd: function () {\r\n                  n.polygonEnd(), (v.lineStart = y)\r\n                }\r\n              }\r\n            function g (e, r) {\r\n              ;(e = t(e, r)), n.point(e[0], e[1])\r\n            }\r\n            function y () {\r\n              ;(s = NaN), (v.point = _), n.lineStart()\r\n            }\r\n            function _ (r, i) {\r\n              var o = Au([r, i]),\r\n                a = t(r, i)\r\n              e(s, l, f, h, d, p, (s = a[0]), (l = a[1]), (f = r), (h = o[0]), (d = o[1]), (p = o[2]), Ss, n),\r\n                n.point(s, l)\r\n            }\r\n            function b () {\r\n              ;(v.point = g), n.lineEnd()\r\n            }\r\n            function m () {\r\n              y(), (v.point = x), (v.lineEnd = w)\r\n            }\r\n            function x (t, n) {\r\n              _((r = t), n), (i = s), (o = l), (a = h), (u = d), (c = p), (v.point = _)\r\n            }\r\n            function w () {\r\n              e(s, l, f, h, d, p, i, o, r, a, u, c, Ss, n), (v.lineEnd = b), b()\r\n            }\r\n            return v\r\n          }\r\n        })(t, n)\r\n      : (function (t) {\r\n          return bs({\r\n            point: function (n, e) {\r\n              ;(n = t(n, e)), this.stream.point(n[0], n[1])\r\n            }\r\n          })\r\n        })(t)\r\n  }\r\n  var Es = bs({\r\n    point: function (t, n) {\r\n      this.stream.point(t * ja, n * ja)\r\n    }\r\n  })\r\n  function Cs (t, n, e, r) {\r\n    var i = Va(r),\r\n      o = Ja(r),\r\n      a = i * t,\r\n      u = o * t,\r\n      c = i / t,\r\n      f = o / t,\r\n      s = (o * e - i * n) / t,\r\n      l = (o * n + i * e) / t\r\n    function h (t, r) {\r\n      return [a * t - u * r + n, e - u * t - a * r]\r\n    }\r\n    return (\r\n      (h.invert = function (t, n) {\r\n        return [c * t - f * n + s, l - f * t - c * n]\r\n      }),\r\n      h\r\n    )\r\n  }\r\n  function Ps (t) {\r\n    return zs(function () {\r\n      return t\r\n    })()\r\n  }\r\n  function zs (t) {\r\n    var n,\r\n      e,\r\n      r,\r\n      i,\r\n      o,\r\n      a,\r\n      u,\r\n      c,\r\n      f,\r\n      s,\r\n      l = 150,\r\n      h = 480,\r\n      d = 250,\r\n      p = 0,\r\n      v = 0,\r\n      g = 0,\r\n      y = 0,\r\n      _ = 0,\r\n      b = 0,\r\n      m = null,\r\n      x = Gc,\r\n      w = null,\r\n      M = xf,\r\n      N = 0.5\r\n    function A (t) {\r\n      return c(t[0] * ja, t[1] * ja)\r\n    }\r\n    function S (t) {\r\n      return (t = c.invert(t[0], t[1])) && [t[0] * Ia, t[1] * Ia]\r\n    }\r\n    function k () {\r\n      var t = Cs(l, 0, 0, b).apply(null, n(p, v)),\r\n        r = (b\r\n          ? Cs\r\n          : function (t, n, e) {\r\n              function r (r, i) {\r\n                return [n + t * r, e - t * i]\r\n              }\r\n              return (\r\n                (r.invert = function (r, i) {\r\n                  return [(r - n) / t, (e - i) / t]\r\n                }),\r\n                r\r\n              )\r\n            })(l, h - t[0], d - t[1], b)\r\n      return (e = Ec(g, y, _)), (u = kc(n, r)), (c = kc(e, u)), (a = Ts(u, N)), T()\r\n    }\r\n    function T () {\r\n      return (f = s = null), A\r\n    }\r\n    return (\r\n      (A.stream = function (t) {\r\n        return f && s === t\r\n          ? f\r\n          : (f = Es(\r\n              (function (t) {\r\n                return bs({\r\n                  point: function (n, e) {\r\n                    var r = t(n, e)\r\n                    return this.stream.point(r[0], r[1])\r\n                  }\r\n                })\r\n              })(e)(x(a(M((s = t)))))\r\n            ))\r\n      }),\r\n      (A.preclip = function (t) {\r\n        return arguments.length ? ((x = t), (m = void 0), T()) : x\r\n      }),\r\n      (A.postclip = function (t) {\r\n        return arguments.length ? ((M = t), (w = r = i = o = null), T()) : M\r\n      }),\r\n      (A.clipAngle = function (t) {\r\n        return arguments.length ? ((x = +t ? Vc((m = t * ja)) : ((m = null), Gc)), T()) : m * Ia\r\n      }),\r\n      (A.clipExtent = function (t) {\r\n        return arguments.length\r\n          ? ((M =\r\n              null == t\r\n                ? ((w = r = i = o = null), xf)\r\n                : Zc((w = +t[0][0]), (r = +t[0][1]), (i = +t[1][0]), (o = +t[1][1]))),\r\n            T())\r\n          : null == w\r\n          ? null\r\n          : [[w, r], [i, o]]\r\n      }),\r\n      (A.scale = function (t) {\r\n        return arguments.length ? ((l = +t), k()) : l\r\n      }),\r\n      (A.translate = function (t) {\r\n        return arguments.length ? ((h = +t[0]), (d = +t[1]), k()) : [h, d]\r\n      }),\r\n      (A.center = function (t) {\r\n        return arguments.length ? ((p = (t[0] % 360) * ja), (v = (t[1] % 360) * ja), k()) : [p * Ia, v * Ia]\r\n      }),\r\n      (A.rotate = function (t) {\r\n        return arguments.length\r\n          ? ((g = (t[0] % 360) * ja), (y = (t[1] % 360) * ja), (_ = t.length > 2 ? (t[2] % 360) * ja : 0), k())\r\n          : [g * Ia, y * Ia, _ * Ia]\r\n      }),\r\n      (A.angle = function (t) {\r\n        return arguments.length ? ((b = (t % 360) * ja), k()) : b * Ia\r\n      }),\r\n      (A.precision = function (t) {\r\n        return arguments.length ? ((a = Ts(u, (N = t * t))), T()) : tu(N)\r\n      }),\r\n      (A.fitExtent = function (t, n) {\r\n        return ws(A, t, n)\r\n      }),\r\n      (A.fitSize = function (t, n) {\r\n        return Ms(A, t, n)\r\n      }),\r\n      (A.fitWidth = function (t, n) {\r\n        return Ns(A, t, n)\r\n      }),\r\n      (A.fitHeight = function (t, n) {\r\n        return As(A, t, n)\r\n      }),\r\n      function () {\r\n        return (n = t.apply(this, arguments)), (A.invert = n.invert && S), k()\r\n      }\r\n    )\r\n  }\r\n  function Rs (t) {\r\n    var n = 0,\r\n      e = Oa / 3,\r\n      r = zs(t),\r\n      i = r(n, e)\r\n    return (\r\n      (i.parallels = function (t) {\r\n        return arguments.length ? r((n = t[0] * ja), (e = t[1] * ja)) : [n * Ia, e * Ia]\r\n      }),\r\n      i\r\n    )\r\n  }\r\n  function Ds (t, n) {\r\n    var e = Ja(t),\r\n      r = (e + Ja(n)) / 2\r\n    if (Ha(r) < La)\r\n      return (function (t) {\r\n        var n = Va(t)\r\n        function e (t, e) {\r\n          return [t * n, Ja(e) / n]\r\n        }\r\n        return (\r\n          (e.invert = function (t, e) {\r\n            return [t / n, ru(e * n)]\r\n          }),\r\n          e\r\n        )\r\n      })(t)\r\n    var i = 1 + e * (2 * r - e),\r\n      o = tu(i) / r\r\n    function a (t, n) {\r\n      var e = tu(i - 2 * r * Ja(n)) / r\r\n      return [e * Ja((t *= r)), o - e * Va(t)]\r\n    }\r\n    return (\r\n      (a.invert = function (t, n) {\r\n        var e = o - n\r\n        return [(Ga(t, Ha(e)) / r) * Ka(e), ru((i - (t * t + e * e) * r * r) / (2 * r))]\r\n      }),\r\n      a\r\n    )\r\n  }\r\n  function qs () {\r\n    return Rs(Ds)\r\n      .scale(155.424)\r\n      .center([0, 33.6442])\r\n  }\r\n  function Ls () {\r\n    return qs()\r\n      .parallels([29.5, 45.5])\r\n      .scale(1070)\r\n      .translate([480, 250])\r\n      .rotate([96, 0])\r\n      .center([-0.6, 38.7])\r\n  }\r\n  function Us (t) {\r\n    return function (n, e) {\r\n      var r = Va(n),\r\n        i = Va(e),\r\n        o = t(r * i)\r\n      return [o * i * Ja(n), o * Ja(e)]\r\n    }\r\n  }\r\n  function Os (t) {\r\n    return function (n, e) {\r\n      var r = tu(n * n + e * e),\r\n        i = t(r),\r\n        o = Ja(i),\r\n        a = Va(i)\r\n      return [Ga(n * o, r * a), ru(r && (e * o) / r)]\r\n    }\r\n  }\r\n  var Bs = Us(function (t) {\r\n    return tu(2 / (1 + t))\r\n  })\r\n  Bs.invert = Os(function (t) {\r\n    return 2 * ru(t / 2)\r\n  })\r\n  var Ys = Us(function (t) {\r\n    return (t = eu(t)) && t / Ja(t)\r\n  })\r\n  function Fs (t, n) {\r\n    return [t, Za(nu((Ba + n) / 2))]\r\n  }\r\n  function Is (t) {\r\n    var n,\r\n      e,\r\n      r,\r\n      i = Ps(t),\r\n      o = i.center,\r\n      a = i.scale,\r\n      u = i.translate,\r\n      c = i.clipExtent,\r\n      f = null\r\n    function s () {\r\n      var o = Oa * a(),\r\n        u = i(Rc(i.rotate()).invert([0, 0]))\r\n      return c(\r\n        null == f\r\n          ? [[u[0] - o, u[1] - o], [u[0] + o, u[1] + o]]\r\n          : t === Fs\r\n          ? [[Math.max(u[0] - o, f), n], [Math.min(u[0] + o, e), r]]\r\n          : [[f, Math.max(u[1] - o, n)], [e, Math.min(u[1] + o, r)]]\r\n      )\r\n    }\r\n    return (\r\n      (i.scale = function (t) {\r\n        return arguments.length ? (a(t), s()) : a()\r\n      }),\r\n      (i.translate = function (t) {\r\n        return arguments.length ? (u(t), s()) : u()\r\n      }),\r\n      (i.center = function (t) {\r\n        return arguments.length ? (o(t), s()) : o()\r\n      }),\r\n      (i.clipExtent = function (t) {\r\n        return arguments.length\r\n          ? (null == t ? (f = n = e = r = null) : ((f = +t[0][0]), (n = +t[0][1]), (e = +t[1][0]), (r = +t[1][1])), s())\r\n          : null == f\r\n          ? null\r\n          : [[f, n], [e, r]]\r\n      }),\r\n      s()\r\n    )\r\n  }\r\n  function js (t) {\r\n    return nu((Ba + t) / 2)\r\n  }\r\n  function Hs (t, n) {\r\n    var e = Va(t),\r\n      r = t === n ? Ja(t) : Za(e / Va(n)) / Za(js(n) / js(t)),\r\n      i = (e * Qa(js(t), r)) / r\r\n    if (!r) return Fs\r\n    function o (t, n) {\r\n      i > 0 ? n < -Ba + La && (n = -Ba + La) : n > Ba - La && (n = Ba - La)\r\n      var e = i / Qa(js(n), r)\r\n      return [e * Ja(r * t), i - e * Va(r * t)]\r\n    }\r\n    return (\r\n      (o.invert = function (t, n) {\r\n        var e = i - n,\r\n          o = Ka(r) * tu(t * t + e * e)\r\n        return [(Ga(t, Ha(e)) / r) * Ka(e), 2 * Xa(Qa(i / o, 1 / r)) - Ba]\r\n      }),\r\n      o\r\n    )\r\n  }\r\n  function Xs (t, n) {\r\n    return [t, n]\r\n  }\r\n  function Gs (t, n) {\r\n    var e = Va(t),\r\n      r = t === n ? Ja(t) : (e - Va(n)) / (n - t),\r\n      i = e / r + t\r\n    if (Ha(r) < La) return Xs\r\n    function o (t, n) {\r\n      var e = i - n,\r\n        o = r * t\r\n      return [e * Ja(o), i - e * Va(o)]\r\n    }\r\n    return (\r\n      (o.invert = function (t, n) {\r\n        var e = i - n\r\n        return [(Ga(t, Ha(e)) / r) * Ka(e), i - Ka(r) * tu(t * t + e * e)]\r\n      }),\r\n      o\r\n    )\r\n  }\r\n  ;(Ys.invert = Os(function (t) {\r\n    return t\r\n  })),\r\n    (Fs.invert = function (t, n) {\r\n      return [t, 2 * Xa(Wa(n)) - Ba]\r\n    }),\r\n    (Xs.invert = Xs)\r\n  var Vs = 1.340264,\r\n    $s = -0.081106,\r\n    Ws = 893e-6,\r\n    Zs = 0.003796,\r\n    Qs = tu(3) / 2\r\n  function Js (t, n) {\r\n    var e = ru(Qs * Ja(n)),\r\n      r = e * e,\r\n      i = r * r * r\r\n    return [(t * Va(e)) / (Qs * (Vs + 3 * $s * r + i * (7 * Ws + 9 * Zs * r))), e * (Vs + $s * r + i * (Ws + Zs * r))]\r\n  }\r\n  function Ks (t, n) {\r\n    var e = Va(n),\r\n      r = Va(t) * e\r\n    return [(e * Ja(t)) / r, Ja(n) / r]\r\n  }\r\n  function tl (t, n, e, r) {\r\n    return 1 === t && 1 === n && 0 === e && 0 === r\r\n      ? xf\r\n      : bs({\r\n          point: function (i, o) {\r\n            this.stream.point(i * t + e, o * n + r)\r\n          }\r\n        })\r\n  }\r\n  function nl (t, n) {\r\n    var e = n * n,\r\n      r = e * e\r\n    return [\r\n      t * (0.8707 - 0.131979 * e + r * (r * (0.003971 * e - 0.001529 * r) - 0.013791)),\r\n      n * (1.007226 + e * (0.015085 + r * (0.028874 * e - 0.044475 - 0.005916 * r)))\r\n    ]\r\n  }\r\n  function el (t, n) {\r\n    return [Va(n) * Ja(t), Ja(n)]\r\n  }\r\n  function rl (t, n) {\r\n    var e = Va(n),\r\n      r = 1 + Va(t) * e\r\n    return [(e * Ja(t)) / r, Ja(n) / r]\r\n  }\r\n  function il (t, n) {\r\n    return [Za(nu((Ba + n) / 2)), -t]\r\n  }\r\n  function ol (t, n) {\r\n    return t.parent === n.parent ? 1 : 2\r\n  }\r\n  function al (t, n) {\r\n    return t + n.x\r\n  }\r\n  function ul (t, n) {\r\n    return Math.max(t, n.y)\r\n  }\r\n  function cl (t) {\r\n    var n = 0,\r\n      e = t.children,\r\n      r = e && e.length\r\n    if (r) for (; --r >= 0; ) n += e[r].value\r\n    else n = 1\r\n    t.value = n\r\n  }\r\n  function fl (t, n) {\r\n    var e,\r\n      r,\r\n      i,\r\n      o,\r\n      a,\r\n      u = new dl(t),\r\n      c = +t.value && (u.value = t.value),\r\n      f = [u]\r\n    for (null == n && (n = sl); (e = f.pop()); )\r\n      if ((c && (e.value = +e.data.value), (i = n(e.data)) && (a = i.length)))\r\n        for (e.children = new Array(a), o = a - 1; o >= 0; --o)\r\n          f.push((r = e.children[o] = new dl(i[o]))), (r.parent = e), (r.depth = e.depth + 1)\r\n    return u.eachBefore(hl)\r\n  }\r\n  function sl (t) {\r\n    return t.children\r\n  }\r\n  function ll (t) {\r\n    t.data = t.data.data\r\n  }\r\n  function hl (t) {\r\n    var n = 0\r\n    do {\r\n      t.height = n\r\n    } while ((t = t.parent) && t.height < ++n)\r\n  }\r\n  function dl (t) {\r\n    ;(this.data = t), (this.depth = this.height = 0), (this.parent = null)\r\n  }\r\n  ;(Js.invert = function (t, n) {\r\n    for (\r\n      var e, r = n, i = r * r, o = i * i * i, a = 0;\r\n      a < 12 &&\r\n      ((o =\r\n        (i =\r\n          (r -= e = (r * (Vs + $s * i + o * (Ws + Zs * i)) - n) / (Vs + 3 * $s * i + o * (7 * Ws + 9 * Zs * i))) * r) *\r\n        i *\r\n        i),\r\n      !(Ha(e) < Ua));\r\n      ++a\r\n    );\r\n    return [(Qs * t * (Vs + 3 * $s * i + o * (7 * Ws + 9 * Zs * i))) / Va(r), ru(Ja(r) / Qs)]\r\n  }),\r\n    (Ks.invert = Os(Xa)),\r\n    (nl.invert = function (t, n) {\r\n      var e,\r\n        r = n,\r\n        i = 25\r\n      do {\r\n        var o = r * r,\r\n          a = o * o\r\n        r -= e =\r\n          (r * (1.007226 + o * (0.015085 + a * (0.028874 * o - 0.044475 - 0.005916 * a))) - n) /\r\n          (1.007226 + o * (0.045255 + a * (0.259866 * o - 0.311325 - 0.005916 * 11 * a)))\r\n      } while (Ha(e) > La && --i > 0)\r\n      return [t / (0.8707 + (o = r * r) * (o * (o * o * o * (0.003971 - 0.001529 * o) - 0.013791) - 0.131979)), r]\r\n    }),\r\n    (el.invert = Os(ru)),\r\n    (rl.invert = Os(function (t) {\r\n      return 2 * Xa(t)\r\n    })),\r\n    (il.invert = function (t, n) {\r\n      return [-n, 2 * Xa(Wa(t)) - Ba]\r\n    }),\r\n    (dl.prototype = fl.prototype = {\r\n      constructor: dl,\r\n      count: function () {\r\n        return this.eachAfter(cl)\r\n      },\r\n      each: function (t) {\r\n        var n,\r\n          e,\r\n          r,\r\n          i,\r\n          o = this,\r\n          a = [o]\r\n        do {\r\n          for (n = a.reverse(), a = []; (o = n.pop()); )\r\n            if ((t(o), (e = o.children))) for (r = 0, i = e.length; r < i; ++r) a.push(e[r])\r\n        } while (a.length)\r\n        return this\r\n      },\r\n      eachAfter: function (t) {\r\n        for (var n, e, r, i = this, o = [i], a = []; (i = o.pop()); )\r\n          if ((a.push(i), (n = i.children))) for (e = 0, r = n.length; e < r; ++e) o.push(n[e])\r\n        for (; (i = a.pop()); ) t(i)\r\n        return this\r\n      },\r\n      eachBefore: function (t) {\r\n        for (var n, e, r = this, i = [r]; (r = i.pop()); )\r\n          if ((t(r), (n = r.children))) for (e = n.length - 1; e >= 0; --e) i.push(n[e])\r\n        return this\r\n      },\r\n      sum: function (t) {\r\n        return this.eachAfter(function (n) {\r\n          for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0; ) e += r[i].value\r\n          n.value = e\r\n        })\r\n      },\r\n      sort: function (t) {\r\n        return this.eachBefore(function (n) {\r\n          n.children && n.children.sort(t)\r\n        })\r\n      },\r\n      path: function (t) {\r\n        for (\r\n          var n = this,\r\n            e = (function (t, n) {\r\n              if (t === n) return t\r\n              var e = t.ancestors(),\r\n                r = n.ancestors(),\r\n                i = null\r\n              for (t = e.pop(), n = r.pop(); t === n; ) (i = t), (t = e.pop()), (n = r.pop())\r\n              return i\r\n            })(n, t),\r\n            r = [n];\r\n          n !== e;\r\n\r\n        )\r\n          (n = n.parent), r.push(n)\r\n        for (var i = r.length; t !== e; ) r.splice(i, 0, t), (t = t.parent)\r\n        return r\r\n      },\r\n      ancestors: function () {\r\n        for (var t = this, n = [t]; (t = t.parent); ) n.push(t)\r\n        return n\r\n      },\r\n      descendants: function () {\r\n        var t = []\r\n        return (\r\n          this.each(function (n) {\r\n            t.push(n)\r\n          }),\r\n          t\r\n        )\r\n      },\r\n      leaves: function () {\r\n        var t = []\r\n        return (\r\n          this.eachBefore(function (n) {\r\n            n.children || t.push(n)\r\n          }),\r\n          t\r\n        )\r\n      },\r\n      links: function () {\r\n        var t = this,\r\n          n = []\r\n        return (\r\n          t.each(function (e) {\r\n            e !== t && n.push({ source: e.parent, target: e })\r\n          }),\r\n          n\r\n        )\r\n      },\r\n      copy: function () {\r\n        return fl(this).eachBefore(ll)\r\n      }\r\n    })\r\n  var pl = Array.prototype.slice\r\n  function vl (t) {\r\n    for (\r\n      var n,\r\n        e,\r\n        r = 0,\r\n        i = (t = (function (t) {\r\n          for (var n, e, r = t.length; r; ) (e = (Math.random() * r--) | 0), (n = t[r]), (t[r] = t[e]), (t[e] = n)\r\n          return t\r\n        })(pl.call(t))).length,\r\n        o = [];\r\n      r < i;\r\n\r\n    )\r\n      (n = t[r]), e && _l(e, n) ? ++r : ((e = ml((o = gl(o, n)))), (r = 0))\r\n    return e\r\n  }\r\n  function gl (t, n) {\r\n    var e, r\r\n    if (bl(n, t)) return [n]\r\n    for (e = 0; e < t.length; ++e) if (yl(n, t[e]) && bl(xl(t[e], n), t)) return [t[e], n]\r\n    for (e = 0; e < t.length - 1; ++e)\r\n      for (r = e + 1; r < t.length; ++r)\r\n        if (yl(xl(t[e], t[r]), n) && yl(xl(t[e], n), t[r]) && yl(xl(t[r], n), t[e]) && bl(wl(t[e], t[r], n), t))\r\n          return [t[e], t[r], n]\r\n    throw new Error()\r\n  }\r\n  function yl (t, n) {\r\n    var e = t.r - n.r,\r\n      r = n.x - t.x,\r\n      i = n.y - t.y\r\n    return e < 0 || e * e < r * r + i * i\r\n  }\r\n  function _l (t, n) {\r\n    var e = t.r - n.r + 1e-6,\r\n      r = n.x - t.x,\r\n      i = n.y - t.y\r\n    return e > 0 && e * e > r * r + i * i\r\n  }\r\n  function bl (t, n) {\r\n    for (var e = 0; e < n.length; ++e) if (!_l(t, n[e])) return !1\r\n    return !0\r\n  }\r\n  function ml (t) {\r\n    switch (t.length) {\r\n      case 1:\r\n        return { x: (n = t[0]).x, y: n.y, r: n.r }\r\n      case 2:\r\n        return xl(t[0], t[1])\r\n      case 3:\r\n        return wl(t[0], t[1], t[2])\r\n    }\r\n    var n\r\n  }\r\n  function xl (t, n) {\r\n    var e = t.x,\r\n      r = t.y,\r\n      i = t.r,\r\n      o = n.x,\r\n      a = n.y,\r\n      u = n.r,\r\n      c = o - e,\r\n      f = a - r,\r\n      s = u - i,\r\n      l = Math.sqrt(c * c + f * f)\r\n    return { x: (e + o + (c / l) * s) / 2, y: (r + a + (f / l) * s) / 2, r: (l + i + u) / 2 }\r\n  }\r\n  function wl (t, n, e) {\r\n    var r = t.x,\r\n      i = t.y,\r\n      o = t.r,\r\n      a = n.x,\r\n      u = n.y,\r\n      c = n.r,\r\n      f = e.x,\r\n      s = e.y,\r\n      l = e.r,\r\n      h = r - a,\r\n      d = r - f,\r\n      p = i - u,\r\n      v = i - s,\r\n      g = c - o,\r\n      y = l - o,\r\n      _ = r * r + i * i - o * o,\r\n      b = _ - a * a - u * u + c * c,\r\n      m = _ - f * f - s * s + l * l,\r\n      x = d * p - h * v,\r\n      w = (p * m - v * b) / (2 * x) - r,\r\n      M = (v * g - p * y) / x,\r\n      N = (d * b - h * m) / (2 * x) - i,\r\n      A = (h * y - d * g) / x,\r\n      S = M * M + A * A - 1,\r\n      k = 2 * (o + w * M + N * A),\r\n      T = w * w + N * N - o * o,\r\n      E = -(S ? (k + Math.sqrt(k * k - 4 * S * T)) / (2 * S) : T / k)\r\n    return { x: r + w + M * E, y: i + N + A * E, r: E }\r\n  }\r\n  function Ml (t, n, e) {\r\n    var r,\r\n      i,\r\n      o,\r\n      a,\r\n      u = t.x - n.x,\r\n      c = t.y - n.y,\r\n      f = u * u + c * c\r\n    f\r\n      ? ((i = n.r + e.r),\r\n        (i *= i),\r\n        (a = t.r + e.r),\r\n        i > (a *= a)\r\n          ? ((r = (f + a - i) / (2 * f)),\r\n            (o = Math.sqrt(Math.max(0, a / f - r * r))),\r\n            (e.x = t.x - r * u - o * c),\r\n            (e.y = t.y - r * c + o * u))\r\n          : ((r = (f + i - a) / (2 * f)),\r\n            (o = Math.sqrt(Math.max(0, i / f - r * r))),\r\n            (e.x = n.x + r * u - o * c),\r\n            (e.y = n.y + r * c + o * u)))\r\n      : ((e.x = n.x + e.r), (e.y = n.y))\r\n  }\r\n  function Nl (t, n) {\r\n    var e = t.r + n.r - 1e-6,\r\n      r = n.x - t.x,\r\n      i = n.y - t.y\r\n    return e > 0 && e * e > r * r + i * i\r\n  }\r\n  function Al (t) {\r\n    var n = t._,\r\n      e = t.next._,\r\n      r = n.r + e.r,\r\n      i = (n.x * e.r + e.x * n.r) / r,\r\n      o = (n.y * e.r + e.y * n.r) / r\r\n    return i * i + o * o\r\n  }\r\n  function Sl (t) {\r\n    ;(this._ = t), (this.next = null), (this.previous = null)\r\n  }\r\n  function kl (t) {\r\n    if (!(i = t.length)) return 0\r\n    var n, e, r, i, o, a, u, c, f, s, l\r\n    if ((((n = t[0]).x = 0), (n.y = 0), !(i > 1))) return n.r\r\n    if (((e = t[1]), (n.x = -e.r), (e.x = n.r), (e.y = 0), !(i > 2))) return n.r + e.r\r\n    Ml(e, n, (r = t[2])),\r\n      (n = new Sl(n)),\r\n      (e = new Sl(e)),\r\n      (r = new Sl(r)),\r\n      (n.next = r.previous = e),\r\n      (e.next = n.previous = r),\r\n      (r.next = e.previous = n)\r\n    t: for (u = 3; u < i; ++u) {\r\n      Ml(n._, e._, (r = t[u])), (r = new Sl(r)), (c = e.next), (f = n.previous), (s = e._.r), (l = n._.r)\r\n      do {\r\n        if (s <= l) {\r\n          if (Nl(c._, r._)) {\r\n            ;(e = c), (n.next = e), (e.previous = n), --u\r\n            continue t\r\n          }\r\n          ;(s += c._.r), (c = c.next)\r\n        } else {\r\n          if (Nl(f._, r._)) {\r\n            ;((n = f).next = e), (e.previous = n), --u\r\n            continue t\r\n          }\r\n          ;(l += f._.r), (f = f.previous)\r\n        }\r\n      } while (c !== f.next)\r\n      for (r.previous = n, r.next = e, n.next = e.previous = e = r, o = Al(n); (r = r.next) !== e; )\r\n        (a = Al(r)) < o && ((n = r), (o = a))\r\n      e = n.next\r\n    }\r\n    for (n = [e._], r = e; (r = r.next) !== e; ) n.push(r._)\r\n    for (r = vl(n), u = 0; u < i; ++u) ((n = t[u]).x -= r.x), (n.y -= r.y)\r\n    return r.r\r\n  }\r\n  function Tl (t) {\r\n    if ('function' != typeof t) throw new Error()\r\n    return t\r\n  }\r\n  function El () {\r\n    return 0\r\n  }\r\n  function Cl (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function Pl (t) {\r\n    return Math.sqrt(t.value)\r\n  }\r\n  function zl (t) {\r\n    return function (n) {\r\n      n.children || (n.r = Math.max(0, +t(n) || 0))\r\n    }\r\n  }\r\n  function Rl (t, n) {\r\n    return function (e) {\r\n      if ((r = e.children)) {\r\n        var r,\r\n          i,\r\n          o,\r\n          a = r.length,\r\n          u = t(e) * n || 0\r\n        if (u) for (i = 0; i < a; ++i) r[i].r += u\r\n        if (((o = kl(r)), u)) for (i = 0; i < a; ++i) r[i].r -= u\r\n        e.r = o + u\r\n      }\r\n    }\r\n  }\r\n  function Dl (t) {\r\n    return function (n) {\r\n      var e = n.parent\r\n      ;(n.r *= t), e && ((n.x = e.x + t * n.x), (n.y = e.y + t * n.y))\r\n    }\r\n  }\r\n  function ql (t) {\r\n    ;(t.x0 = Math.round(t.x0)), (t.y0 = Math.round(t.y0)), (t.x1 = Math.round(t.x1)), (t.y1 = Math.round(t.y1))\r\n  }\r\n  function Ll (t, n, e, r, i) {\r\n    for (var o, a = t.children, u = -1, c = a.length, f = t.value && (r - n) / t.value; ++u < c; )\r\n      ((o = a[u]).y0 = e), (o.y1 = i), (o.x0 = n), (o.x1 = n += o.value * f)\r\n  }\r\n  var Ul = '$',\r\n    Ol = { depth: -1 },\r\n    Bl = {}\r\n  function Yl (t) {\r\n    return t.id\r\n  }\r\n  function Fl (t) {\r\n    return t.parentId\r\n  }\r\n  function Il (t, n) {\r\n    return t.parent === n.parent ? 1 : 2\r\n  }\r\n  function jl (t) {\r\n    var n = t.children\r\n    return n ? n[0] : t.t\r\n  }\r\n  function Hl (t) {\r\n    var n = t.children\r\n    return n ? n[n.length - 1] : t.t\r\n  }\r\n  function Xl (t, n, e) {\r\n    var r = e / (n.i - t.i)\r\n    ;(n.c -= r), (n.s += e), (t.c += r), (n.z += e), (n.m += e)\r\n  }\r\n  function Gl (t, n, e) {\r\n    return t.a.parent === n.parent ? t.a : e\r\n  }\r\n  function Vl (t, n) {\r\n    ;(this._ = t),\r\n      (this.parent = null),\r\n      (this.children = null),\r\n      (this.A = null),\r\n      (this.a = this),\r\n      (this.z = 0),\r\n      (this.m = 0),\r\n      (this.c = 0),\r\n      (this.s = 0),\r\n      (this.t = null),\r\n      (this.i = n)\r\n  }\r\n  function $l (t, n, e, r, i) {\r\n    for (var o, a = t.children, u = -1, c = a.length, f = t.value && (i - e) / t.value; ++u < c; )\r\n      ((o = a[u]).x0 = n), (o.x1 = r), (o.y0 = e), (o.y1 = e += o.value * f)\r\n  }\r\n  Vl.prototype = Object.create(dl.prototype)\r\n  var Wl = (1 + Math.sqrt(5)) / 2\r\n  function Zl (t, n, e, r, i, o) {\r\n    for (\r\n      var a, u, c, f, s, l, h, d, p, v, g, y = [], _ = n.children, b = 0, m = 0, x = _.length, w = n.value;\r\n      b < x;\r\n\r\n    ) {\r\n      ;(c = i - e), (f = o - r)\r\n      do {\r\n        s = _[m++].value\r\n      } while (!s && m < x)\r\n      for (l = h = s, g = s * s * (v = Math.max(f / c, c / f) / (w * t)), p = Math.max(h / g, g / l); m < x; ++m) {\r\n        if (\r\n          ((s += u = _[m].value), u < l && (l = u), u > h && (h = u), (g = s * s * v), (d = Math.max(h / g, g / l)) > p)\r\n        ) {\r\n          s -= u\r\n          break\r\n        }\r\n        p = d\r\n      }\r\n      y.push((a = { value: s, dice: c < f, children: _.slice(b, m) })),\r\n        a.dice ? Ll(a, e, r, i, w ? (r += (f * s) / w) : o) : $l(a, e, r, w ? (e += (c * s) / w) : i, o),\r\n        (w -= s),\r\n        (b = m)\r\n    }\r\n    return y\r\n  }\r\n  var Ql = (function t (n) {\r\n    function e (t, e, r, i, o) {\r\n      Zl(n, t, e, r, i, o)\r\n    }\r\n    return (\r\n      (e.ratio = function (n) {\r\n        return t((n = +n) > 1 ? n : 1)\r\n      }),\r\n      e\r\n    )\r\n  })(Wl)\r\n  var Jl = (function t (n) {\r\n    function e (t, e, r, i, o) {\r\n      if ((a = t._squarify) && a.ratio === n)\r\n        for (var a, u, c, f, s, l = -1, h = a.length, d = t.value; ++l < h; ) {\r\n          for (c = (u = a[l]).children, f = u.value = 0, s = c.length; f < s; ++f) u.value += c[f].value\r\n          u.dice ? Ll(u, e, r, i, (r += ((o - r) * u.value) / d)) : $l(u, e, r, (e += ((i - e) * u.value) / d), o),\r\n            (d -= u.value)\r\n        }\r\n      else (t._squarify = a = Zl(n, t, e, r, i, o)), (a.ratio = n)\r\n    }\r\n    return (\r\n      (e.ratio = function (n) {\r\n        return t((n = +n) > 1 ? n : 1)\r\n      }),\r\n      e\r\n    )\r\n  })(Wl)\r\n  function Kl (t, n) {\r\n    return t[0] - n[0] || t[1] - n[1]\r\n  }\r\n  function th (t) {\r\n    for (var n, e, r, i = t.length, o = [0, 1], a = 2, u = 2; u < i; ++u) {\r\n      for (\r\n        ;\r\n        a > 1 &&\r\n        ((n = t[o[a - 2]]),\r\n        (e = t[o[a - 1]]),\r\n        (r = t[u]),\r\n        (e[0] - n[0]) * (r[1] - n[1]) - (e[1] - n[1]) * (r[0] - n[0]) <= 0);\r\n\r\n      )\r\n        --a\r\n      o[a++] = u\r\n    }\r\n    return o.slice(0, a)\r\n  }\r\n  function nh () {\r\n    return Math.random()\r\n  }\r\n  var eh = (function t (n) {\r\n      function e (t, e) {\r\n        return (\r\n          (t = null == t ? 0 : +t),\r\n          (e = null == e ? 1 : +e),\r\n          1 === arguments.length ? ((e = t), (t = 0)) : (e -= t),\r\n          function () {\r\n            return n() * e + t\r\n          }\r\n        )\r\n      }\r\n      return (e.source = t), e\r\n    })(nh),\r\n    rh = (function t (n) {\r\n      function e (t, e) {\r\n        var r, i\r\n        return (\r\n          (t = null == t ? 0 : +t),\r\n          (e = null == e ? 1 : +e),\r\n          function () {\r\n            var o\r\n            if (null != r) (o = r), (r = null)\r\n            else\r\n              do {\r\n                ;(r = 2 * n() - 1), (o = 2 * n() - 1), (i = r * r + o * o)\r\n              } while (!i || i > 1)\r\n            return t + e * o * Math.sqrt((-2 * Math.log(i)) / i)\r\n          }\r\n        )\r\n      }\r\n      return (e.source = t), e\r\n    })(nh),\r\n    ih = (function t (n) {\r\n      function e () {\r\n        var t = rh.source(n).apply(this, arguments)\r\n        return function () {\r\n          return Math.exp(t())\r\n        }\r\n      }\r\n      return (e.source = t), e\r\n    })(nh),\r\n    oh = (function t (n) {\r\n      function e (t) {\r\n        return function () {\r\n          for (var e = 0, r = 0; r < t; ++r) e += n()\r\n          return e\r\n        }\r\n      }\r\n      return (e.source = t), e\r\n    })(nh),\r\n    ah = (function t (n) {\r\n      function e (t) {\r\n        var e = oh.source(n)(t)\r\n        return function () {\r\n          return e() / t\r\n        }\r\n      }\r\n      return (e.source = t), e\r\n    })(nh),\r\n    uh = (function t (n) {\r\n      function e (t) {\r\n        return function () {\r\n          return -Math.log(1 - n()) / t\r\n        }\r\n      }\r\n      return (e.source = t), e\r\n    })(nh)\r\n  function ch (t, n) {\r\n    switch (arguments.length) {\r\n      case 0:\r\n        break\r\n      case 1:\r\n        this.range(t)\r\n        break\r\n      default:\r\n        this.range(n).domain(t)\r\n    }\r\n    return this\r\n  }\r\n  function fh (t, n) {\r\n    switch (arguments.length) {\r\n      case 0:\r\n        break\r\n      case 1:\r\n        this.interpolator(t)\r\n        break\r\n      default:\r\n        this.interpolator(n).domain(t)\r\n    }\r\n    return this\r\n  }\r\n  var sh = Array.prototype,\r\n    lh = sh.map,\r\n    hh = sh.slice,\r\n    dh = { name: 'implicit' }\r\n  function ph () {\r\n    var t = Qi(),\r\n      n = [],\r\n      e = [],\r\n      r = dh\r\n    function i (i) {\r\n      var o = i + '',\r\n        a = t.get(o)\r\n      if (!a) {\r\n        if (r !== dh) return r\r\n        t.set(o, (a = n.push(i)))\r\n      }\r\n      return e[(a - 1) % e.length]\r\n    }\r\n    return (\r\n      (i.domain = function (e) {\r\n        if (!arguments.length) return n.slice()\r\n        ;(n = []), (t = Qi())\r\n        for (var r, o, a = -1, u = e.length; ++a < u; ) t.has((o = (r = e[a]) + '')) || t.set(o, n.push(r))\r\n        return i\r\n      }),\r\n      (i.range = function (t) {\r\n        return arguments.length ? ((e = hh.call(t)), i) : e.slice()\r\n      }),\r\n      (i.unknown = function (t) {\r\n        return arguments.length ? ((r = t), i) : r\r\n      }),\r\n      (i.copy = function () {\r\n        return ph(n, e).unknown(r)\r\n      }),\r\n      ch.apply(i, arguments),\r\n      i\r\n    )\r\n  }\r\n  function vh () {\r\n    var t,\r\n      n,\r\n      e = ph().unknown(void 0),\r\n      r = e.domain,\r\n      i = e.range,\r\n      o = [0, 1],\r\n      a = !1,\r\n      u = 0,\r\n      c = 0,\r\n      f = 0.5\r\n    function s () {\r\n      var e = r().length,\r\n        s = o[1] < o[0],\r\n        l = o[s - 0],\r\n        h = o[1 - s]\r\n      ;(t = (h - l) / Math.max(1, e - u + 2 * c)),\r\n        a && (t = Math.floor(t)),\r\n        (l += (h - l - t * (e - u)) * f),\r\n        (n = t * (1 - u)),\r\n        a && ((l = Math.round(l)), (n = Math.round(n)))\r\n      var d = g(e).map(function (n) {\r\n        return l + t * n\r\n      })\r\n      return i(s ? d.reverse() : d)\r\n    }\r\n    return (\r\n      delete e.unknown,\r\n      (e.domain = function (t) {\r\n        return arguments.length ? (r(t), s()) : r()\r\n      }),\r\n      (e.range = function (t) {\r\n        return arguments.length ? ((o = [+t[0], +t[1]]), s()) : o.slice()\r\n      }),\r\n      (e.rangeRound = function (t) {\r\n        return (o = [+t[0], +t[1]]), (a = !0), s()\r\n      }),\r\n      (e.bandwidth = function () {\r\n        return n\r\n      }),\r\n      (e.step = function () {\r\n        return t\r\n      }),\r\n      (e.round = function (t) {\r\n        return arguments.length ? ((a = !!t), s()) : a\r\n      }),\r\n      (e.padding = function (t) {\r\n        return arguments.length ? ((u = Math.min(1, (c = +t))), s()) : u\r\n      }),\r\n      (e.paddingInner = function (t) {\r\n        return arguments.length ? ((u = Math.min(1, t)), s()) : u\r\n      }),\r\n      (e.paddingOuter = function (t) {\r\n        return arguments.length ? ((c = +t), s()) : c\r\n      }),\r\n      (e.align = function (t) {\r\n        return arguments.length ? ((f = Math.max(0, Math.min(1, t))), s()) : f\r\n      }),\r\n      (e.copy = function () {\r\n        return vh(r(), o)\r\n          .round(a)\r\n          .paddingInner(u)\r\n          .paddingOuter(c)\r\n          .align(f)\r\n      }),\r\n      ch.apply(s(), arguments)\r\n    )\r\n  }\r\n  function gh (t) {\r\n    return +t\r\n  }\r\n  var yh = [0, 1]\r\n  function _h (t) {\r\n    return t\r\n  }\r\n  function bh (t, n) {\r\n    return (n -= t = +t)\r\n      ? function (e) {\r\n          return (e - t) / n\r\n        }\r\n      : ((e = isNaN(n) ? NaN : 0.5),\r\n        function () {\r\n          return e\r\n        })\r\n    var e\r\n  }\r\n  function mh (t) {\r\n    var n,\r\n      e = t[0],\r\n      r = t[t.length - 1]\r\n    return (\r\n      e > r && ((n = e), (e = r), (r = n)),\r\n      function (t) {\r\n        return Math.max(e, Math.min(r, t))\r\n      }\r\n    )\r\n  }\r\n  function xh (t, n, e) {\r\n    var r = t[0],\r\n      i = t[1],\r\n      o = n[0],\r\n      a = n[1]\r\n    return (\r\n      i < r ? ((r = bh(i, r)), (o = e(a, o))) : ((r = bh(r, i)), (o = e(o, a))),\r\n      function (t) {\r\n        return o(r(t))\r\n      }\r\n    )\r\n  }\r\n  function wh (t, n, e) {\r\n    var r = Math.min(t.length, n.length) - 1,\r\n      o = new Array(r),\r\n      a = new Array(r),\r\n      u = -1\r\n    for (t[r] < t[0] && ((t = t.slice().reverse()), (n = n.slice().reverse())); ++u < r; )\r\n      (o[u] = bh(t[u], t[u + 1])), (a[u] = e(n[u], n[u + 1]))\r\n    return function (n) {\r\n      var e = i(t, n, 1, r) - 1\r\n      return a[e](o[e](n))\r\n    }\r\n  }\r\n  function Mh (t, n) {\r\n    return n\r\n      .domain(t.domain())\r\n      .range(t.range())\r\n      .interpolate(t.interpolate())\r\n      .clamp(t.clamp())\r\n      .unknown(t.unknown())\r\n  }\r\n  function Nh () {\r\n    var t,\r\n      n,\r\n      e,\r\n      r,\r\n      i,\r\n      o,\r\n      a = yh,\r\n      u = yh,\r\n      c = ye,\r\n      f = _h\r\n    function s () {\r\n      return (r = Math.min(a.length, u.length) > 2 ? wh : xh), (i = o = null), l\r\n    }\r\n    function l (n) {\r\n      return isNaN((n = +n)) ? e : (i || (i = r(a.map(t), u, c)))(t(f(n)))\r\n    }\r\n    return (\r\n      (l.invert = function (e) {\r\n        return f(n((o || (o = r(u, a.map(t), he)))(e)))\r\n      }),\r\n      (l.domain = function (t) {\r\n        return arguments.length ? ((a = lh.call(t, gh)), f === _h || (f = mh(a)), s()) : a.slice()\r\n      }),\r\n      (l.range = function (t) {\r\n        return arguments.length ? ((u = hh.call(t)), s()) : u.slice()\r\n      }),\r\n      (l.rangeRound = function (t) {\r\n        return (u = hh.call(t)), (c = _e), s()\r\n      }),\r\n      (l.clamp = function (t) {\r\n        return arguments.length ? ((f = t ? mh(a) : _h), l) : f !== _h\r\n      }),\r\n      (l.interpolate = function (t) {\r\n        return arguments.length ? ((c = t), s()) : c\r\n      }),\r\n      (l.unknown = function (t) {\r\n        return arguments.length ? ((e = t), l) : e\r\n      }),\r\n      function (e, r) {\r\n        return (t = e), (n = r), s()\r\n      }\r\n    )\r\n  }\r\n  function Ah (t, n) {\r\n    return Nh()(t, n)\r\n  }\r\n  function Sh (n, e, r, i) {\r\n    var o,\r\n      a = w(n, e, r)\r\n    switch ((i = ma(null == i ? ',f' : i)).type) {\r\n      case 's':\r\n        var u = Math.max(Math.abs(n), Math.abs(e))\r\n        return null != i.precision || isNaN((o = Ca(a, u))) || (i.precision = o), t.formatPrefix(i, u)\r\n      case '':\r\n      case 'e':\r\n      case 'g':\r\n      case 'p':\r\n      case 'r':\r\n        null != i.precision ||\r\n          isNaN((o = Pa(a, Math.max(Math.abs(n), Math.abs(e))))) ||\r\n          (i.precision = o - ('e' === i.type))\r\n        break\r\n      case 'f':\r\n      case '%':\r\n        null != i.precision || isNaN((o = Ea(a))) || (i.precision = o - 2 * ('%' === i.type))\r\n    }\r\n    return t.format(i)\r\n  }\r\n  function kh (t) {\r\n    var n = t.domain\r\n    return (\r\n      (t.ticks = function (t) {\r\n        var e = n()\r\n        return m(e[0], e[e.length - 1], null == t ? 10 : t)\r\n      }),\r\n      (t.tickFormat = function (t, e) {\r\n        var r = n()\r\n        return Sh(r[0], r[r.length - 1], null == t ? 10 : t, e)\r\n      }),\r\n      (t.nice = function (e) {\r\n        null == e && (e = 10)\r\n        var r,\r\n          i = n(),\r\n          o = 0,\r\n          a = i.length - 1,\r\n          u = i[o],\r\n          c = i[a]\r\n        return (\r\n          c < u && ((r = u), (u = c), (c = r), (r = o), (o = a), (a = r)),\r\n          (r = x(u, c, e)) > 0\r\n            ? (r = x((u = Math.floor(u / r) * r), (c = Math.ceil(c / r) * r), e))\r\n            : r < 0 && (r = x((u = Math.ceil(u * r) / r), (c = Math.floor(c * r) / r), e)),\r\n          r > 0\r\n            ? ((i[o] = Math.floor(u / r) * r), (i[a] = Math.ceil(c / r) * r), n(i))\r\n            : r < 0 && ((i[o] = Math.ceil(u * r) / r), (i[a] = Math.floor(c * r) / r), n(i)),\r\n          t\r\n        )\r\n      }),\r\n      t\r\n    )\r\n  }\r\n  function Th (t, n) {\r\n    var e,\r\n      r = 0,\r\n      i = (t = t.slice()).length - 1,\r\n      o = t[r],\r\n      a = t[i]\r\n    return a < o && ((e = r), (r = i), (i = e), (e = o), (o = a), (a = e)), (t[r] = n.floor(o)), (t[i] = n.ceil(a)), t\r\n  }\r\n  function Eh (t) {\r\n    return Math.log(t)\r\n  }\r\n  function Ch (t) {\r\n    return Math.exp(t)\r\n  }\r\n  function Ph (t) {\r\n    return -Math.log(-t)\r\n  }\r\n  function zh (t) {\r\n    return -Math.exp(-t)\r\n  }\r\n  function Rh (t) {\r\n    return isFinite(t) ? +('1e' + t) : t < 0 ? 0 : t\r\n  }\r\n  function Dh (t) {\r\n    return function (n) {\r\n      return -t(-n)\r\n    }\r\n  }\r\n  function qh (n) {\r\n    var e,\r\n      r,\r\n      i = n(Eh, Ch),\r\n      o = i.domain,\r\n      a = 10\r\n    function u () {\r\n      return (\r\n        (e = (function (t) {\r\n          return t === Math.E\r\n            ? Math.log\r\n            : (10 === t && Math.log10) ||\r\n                (2 === t && Math.log2) ||\r\n                ((t = Math.log(t)),\r\n                function (n) {\r\n                  return Math.log(n) / t\r\n                })\r\n        })(a)),\r\n        (r = (function (t) {\r\n          return 10 === t\r\n            ? Rh\r\n            : t === Math.E\r\n            ? Math.exp\r\n            : function (n) {\r\n                return Math.pow(t, n)\r\n              }\r\n        })(a)),\r\n        o()[0] < 0 ? ((e = Dh(e)), (r = Dh(r)), n(Ph, zh)) : n(Eh, Ch),\r\n        i\r\n      )\r\n    }\r\n    return (\r\n      (i.base = function (t) {\r\n        return arguments.length ? ((a = +t), u()) : a\r\n      }),\r\n      (i.domain = function (t) {\r\n        return arguments.length ? (o(t), u()) : o()\r\n      }),\r\n      (i.ticks = function (t) {\r\n        var n,\r\n          i = o(),\r\n          u = i[0],\r\n          c = i[i.length - 1]\r\n        ;(n = c < u) && ((h = u), (u = c), (c = h))\r\n        var f,\r\n          s,\r\n          l,\r\n          h = e(u),\r\n          d = e(c),\r\n          p = null == t ? 10 : +t,\r\n          v = []\r\n        if (!(a % 1) && d - h < p) {\r\n          if (((h = Math.round(h) - 1), (d = Math.round(d) + 1), u > 0)) {\r\n            for (; h < d; ++h)\r\n              for (s = 1, f = r(h); s < a; ++s)\r\n                if (!((l = f * s) < u)) {\r\n                  if (l > c) break\r\n                  v.push(l)\r\n                }\r\n          } else\r\n            for (; h < d; ++h)\r\n              for (s = a - 1, f = r(h); s >= 1; --s)\r\n                if (!((l = f * s) < u)) {\r\n                  if (l > c) break\r\n                  v.push(l)\r\n                }\r\n        } else v = m(h, d, Math.min(d - h, p)).map(r)\r\n        return n ? v.reverse() : v\r\n      }),\r\n      (i.tickFormat = function (n, o) {\r\n        if ((null == o && (o = 10 === a ? '.0e' : ','), 'function' != typeof o && (o = t.format(o)), n === 1 / 0))\r\n          return o\r\n        null == n && (n = 10)\r\n        var u = Math.max(1, (a * n) / i.ticks().length)\r\n        return function (t) {\r\n          var n = t / r(Math.round(e(t)))\r\n          return n * a < a - 0.5 && (n *= a), n <= u ? o(t) : ''\r\n        }\r\n      }),\r\n      (i.nice = function () {\r\n        return o(\r\n          Th(o(), {\r\n            floor: function (t) {\r\n              return r(Math.floor(e(t)))\r\n            },\r\n            ceil: function (t) {\r\n              return r(Math.ceil(e(t)))\r\n            }\r\n          })\r\n        )\r\n      }),\r\n      i\r\n    )\r\n  }\r\n  function Lh (t) {\r\n    return function (n) {\r\n      return Math.sign(n) * Math.log1p(Math.abs(n / t))\r\n    }\r\n  }\r\n  function Uh (t) {\r\n    return function (n) {\r\n      return Math.sign(n) * Math.expm1(Math.abs(n)) * t\r\n    }\r\n  }\r\n  function Oh (t) {\r\n    var n = 1,\r\n      e = t(Lh(n), Uh(n))\r\n    return (\r\n      (e.constant = function (e) {\r\n        return arguments.length ? t(Lh((n = +e)), Uh(n)) : n\r\n      }),\r\n      kh(e)\r\n    )\r\n  }\r\n  function Bh (t) {\r\n    return function (n) {\r\n      return n < 0 ? -Math.pow(-n, t) : Math.pow(n, t)\r\n    }\r\n  }\r\n  function Yh (t) {\r\n    return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t)\r\n  }\r\n  function Fh (t) {\r\n    return t < 0 ? -t * t : t * t\r\n  }\r\n  function Ih (t) {\r\n    var n = t(_h, _h),\r\n      e = 1\r\n    return (\r\n      (n.exponent = function (n) {\r\n        return arguments.length ? (1 === (e = +n) ? t(_h, _h) : 0.5 === e ? t(Yh, Fh) : t(Bh(e), Bh(1 / e))) : e\r\n      }),\r\n      kh(n)\r\n    )\r\n  }\r\n  function jh () {\r\n    var t = Ih(Nh())\r\n    return (\r\n      (t.copy = function () {\r\n        return Mh(t, jh()).exponent(t.exponent())\r\n      }),\r\n      ch.apply(t, arguments),\r\n      t\r\n    )\r\n  }\r\n  var Hh = new Date(),\r\n    Xh = new Date()\r\n  function Gh (t, n, e, r) {\r\n    function i (n) {\r\n      return t((n = new Date(+n))), n\r\n    }\r\n    return (\r\n      (i.floor = i),\r\n      (i.ceil = function (e) {\r\n        return t((e = new Date(e - 1))), n(e, 1), t(e), e\r\n      }),\r\n      (i.round = function (t) {\r\n        var n = i(t),\r\n          e = i.ceil(t)\r\n        return t - n < e - t ? n : e\r\n      }),\r\n      (i.offset = function (t, e) {\r\n        return n((t = new Date(+t)), null == e ? 1 : Math.floor(e)), t\r\n      }),\r\n      (i.range = function (e, r, o) {\r\n        var a,\r\n          u = []\r\n        if (((e = i.ceil(e)), (o = null == o ? 1 : Math.floor(o)), !(e < r && o > 0))) return u\r\n        do {\r\n          u.push((a = new Date(+e))), n(e, o), t(e)\r\n        } while (a < e && e < r)\r\n        return u\r\n      }),\r\n      (i.filter = function (e) {\r\n        return Gh(\r\n          function (n) {\r\n            if (n >= n) for (; t(n), !e(n); ) n.setTime(n - 1)\r\n          },\r\n          function (t, r) {\r\n            if (t >= t)\r\n              if (r < 0) for (; ++r <= 0; ) for (; n(t, -1), !e(t); );\r\n              else for (; --r >= 0; ) for (; n(t, 1), !e(t); );\r\n          }\r\n        )\r\n      }),\r\n      e &&\r\n        ((i.count = function (n, r) {\r\n          return Hh.setTime(+n), Xh.setTime(+r), t(Hh), t(Xh), Math.floor(e(Hh, Xh))\r\n        }),\r\n        (i.every = function (t) {\r\n          return (\r\n            (t = Math.floor(t)),\r\n            isFinite(t) && t > 0\r\n              ? t > 1\r\n                ? i.filter(\r\n                    r\r\n                      ? function (n) {\r\n                          return r(n) % t == 0\r\n                        }\r\n                      : function (n) {\r\n                          return i.count(0, n) % t == 0\r\n                        }\r\n                  )\r\n                : i\r\n              : null\r\n          )\r\n        })),\r\n      i\r\n    )\r\n  }\r\n  var Vh = Gh(\r\n    function () {},\r\n    function (t, n) {\r\n      t.setTime(+t + n)\r\n    },\r\n    function (t, n) {\r\n      return n - t\r\n    }\r\n  )\r\n  Vh.every = function (t) {\r\n    return (\r\n      (t = Math.floor(t)),\r\n      isFinite(t) && t > 0\r\n        ? t > 1\r\n          ? Gh(\r\n              function (n) {\r\n                n.setTime(Math.floor(n / t) * t)\r\n              },\r\n              function (n, e) {\r\n                n.setTime(+n + e * t)\r\n              },\r\n              function (n, e) {\r\n                return (e - n) / t\r\n              }\r\n            )\r\n          : Vh\r\n        : null\r\n    )\r\n  }\r\n  var $h = Vh.range,\r\n    Wh = 6e4,\r\n    Zh = 6048e5,\r\n    Qh = Gh(\r\n      function (t) {\r\n        t.setTime(t - t.getMilliseconds())\r\n      },\r\n      function (t, n) {\r\n        t.setTime(+t + 1e3 * n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / 1e3\r\n      },\r\n      function (t) {\r\n        return t.getUTCSeconds()\r\n      }\r\n    ),\r\n    Jh = Qh.range,\r\n    Kh = Gh(\r\n      function (t) {\r\n        t.setTime(t - t.getMilliseconds() - 1e3 * t.getSeconds())\r\n      },\r\n      function (t, n) {\r\n        t.setTime(+t + n * Wh)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / Wh\r\n      },\r\n      function (t) {\r\n        return t.getMinutes()\r\n      }\r\n    ),\r\n    td = Kh.range,\r\n    nd = Gh(\r\n      function (t) {\r\n        t.setTime(t - t.getMilliseconds() - 1e3 * t.getSeconds() - t.getMinutes() * Wh)\r\n      },\r\n      function (t, n) {\r\n        t.setTime(+t + 36e5 * n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / 36e5\r\n      },\r\n      function (t) {\r\n        return t.getHours()\r\n      }\r\n    ),\r\n    ed = nd.range,\r\n    rd = Gh(\r\n      function (t) {\r\n        t.setHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setDate(t.getDate() + n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Wh) / 864e5\r\n      },\r\n      function (t) {\r\n        return t.getDate() - 1\r\n      }\r\n    ),\r\n    id = rd.range\r\n  function od (t) {\r\n    return Gh(\r\n      function (n) {\r\n        n.setDate(n.getDate() - ((n.getDay() + 7 - t) % 7)), n.setHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setDate(t.getDate() + 7 * n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Wh) / Zh\r\n      }\r\n    )\r\n  }\r\n  var ad = od(0),\r\n    ud = od(1),\r\n    cd = od(2),\r\n    fd = od(3),\r\n    sd = od(4),\r\n    ld = od(5),\r\n    hd = od(6),\r\n    dd = ad.range,\r\n    pd = ud.range,\r\n    vd = cd.range,\r\n    gd = fd.range,\r\n    yd = sd.range,\r\n    _d = ld.range,\r\n    bd = hd.range,\r\n    md = Gh(\r\n      function (t) {\r\n        t.setDate(1), t.setHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setMonth(t.getMonth() + n)\r\n      },\r\n      function (t, n) {\r\n        return n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear())\r\n      },\r\n      function (t) {\r\n        return t.getMonth()\r\n      }\r\n    ),\r\n    xd = md.range,\r\n    wd = Gh(\r\n      function (t) {\r\n        t.setMonth(0, 1), t.setHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setFullYear(t.getFullYear() + n)\r\n      },\r\n      function (t, n) {\r\n        return n.getFullYear() - t.getFullYear()\r\n      },\r\n      function (t) {\r\n        return t.getFullYear()\r\n      }\r\n    )\r\n  wd.every = function (t) {\r\n    return isFinite((t = Math.floor(t))) && t > 0\r\n      ? Gh(\r\n          function (n) {\r\n            n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0)\r\n          },\r\n          function (n, e) {\r\n            n.setFullYear(n.getFullYear() + e * t)\r\n          }\r\n        )\r\n      : null\r\n  }\r\n  var Md = wd.range,\r\n    Nd = Gh(\r\n      function (t) {\r\n        t.setUTCSeconds(0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setTime(+t + n * Wh)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / Wh\r\n      },\r\n      function (t) {\r\n        return t.getUTCMinutes()\r\n      }\r\n    ),\r\n    Ad = Nd.range,\r\n    Sd = Gh(\r\n      function (t) {\r\n        t.setUTCMinutes(0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setTime(+t + 36e5 * n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / 36e5\r\n      },\r\n      function (t) {\r\n        return t.getUTCHours()\r\n      }\r\n    ),\r\n    kd = Sd.range,\r\n    Td = Gh(\r\n      function (t) {\r\n        t.setUTCHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setUTCDate(t.getUTCDate() + n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / 864e5\r\n      },\r\n      function (t) {\r\n        return t.getUTCDate() - 1\r\n      }\r\n    ),\r\n    Ed = Td.range\r\n  function Cd (t) {\r\n    return Gh(\r\n      function (n) {\r\n        n.setUTCDate(n.getUTCDate() - ((n.getUTCDay() + 7 - t) % 7)), n.setUTCHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setUTCDate(t.getUTCDate() + 7 * n)\r\n      },\r\n      function (t, n) {\r\n        return (n - t) / Zh\r\n      }\r\n    )\r\n  }\r\n  var Pd = Cd(0),\r\n    zd = Cd(1),\r\n    Rd = Cd(2),\r\n    Dd = Cd(3),\r\n    qd = Cd(4),\r\n    Ld = Cd(5),\r\n    Ud = Cd(6),\r\n    Od = Pd.range,\r\n    Bd = zd.range,\r\n    Yd = Rd.range,\r\n    Fd = Dd.range,\r\n    Id = qd.range,\r\n    jd = Ld.range,\r\n    Hd = Ud.range,\r\n    Xd = Gh(\r\n      function (t) {\r\n        t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setUTCMonth(t.getUTCMonth() + n)\r\n      },\r\n      function (t, n) {\r\n        return n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear())\r\n      },\r\n      function (t) {\r\n        return t.getUTCMonth()\r\n      }\r\n    ),\r\n    Gd = Xd.range,\r\n    Vd = Gh(\r\n      function (t) {\r\n        t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)\r\n      },\r\n      function (t, n) {\r\n        t.setUTCFullYear(t.getUTCFullYear() + n)\r\n      },\r\n      function (t, n) {\r\n        return n.getUTCFullYear() - t.getUTCFullYear()\r\n      },\r\n      function (t) {\r\n        return t.getUTCFullYear()\r\n      }\r\n    )\r\n  Vd.every = function (t) {\r\n    return isFinite((t = Math.floor(t))) && t > 0\r\n      ? Gh(\r\n          function (n) {\r\n            n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0)\r\n          },\r\n          function (n, e) {\r\n            n.setUTCFullYear(n.getUTCFullYear() + e * t)\r\n          }\r\n        )\r\n      : null\r\n  }\r\n  var $d = Vd.range\r\n  function Wd (t) {\r\n    if (0 <= t.y && t.y < 100) {\r\n      var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L)\r\n      return n.setFullYear(t.y), n\r\n    }\r\n    return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L)\r\n  }\r\n  function Zd (t) {\r\n    if (0 <= t.y && t.y < 100) {\r\n      var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L))\r\n      return n.setUTCFullYear(t.y), n\r\n    }\r\n    return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L))\r\n  }\r\n  function Qd (t) {\r\n    return { y: t, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 }\r\n  }\r\n  function Jd (t) {\r\n    var n = t.dateTime,\r\n      e = t.date,\r\n      r = t.time,\r\n      i = t.periods,\r\n      o = t.days,\r\n      a = t.shortDays,\r\n      u = t.months,\r\n      c = t.shortMonths,\r\n      f = ap(i),\r\n      s = up(i),\r\n      l = ap(o),\r\n      h = up(o),\r\n      d = ap(a),\r\n      p = up(a),\r\n      v = ap(u),\r\n      g = up(u),\r\n      y = ap(c),\r\n      _ = up(c),\r\n      b = {\r\n        a: function (t) {\r\n          return a[t.getDay()]\r\n        },\r\n        A: function (t) {\r\n          return o[t.getDay()]\r\n        },\r\n        b: function (t) {\r\n          return c[t.getMonth()]\r\n        },\r\n        B: function (t) {\r\n          return u[t.getMonth()]\r\n        },\r\n        c: null,\r\n        d: kp,\r\n        e: kp,\r\n        f: zp,\r\n        H: Tp,\r\n        I: Ep,\r\n        j: Cp,\r\n        L: Pp,\r\n        m: Rp,\r\n        M: Dp,\r\n        p: function (t) {\r\n          return i[+(t.getHours() >= 12)]\r\n        },\r\n        Q: cv,\r\n        s: fv,\r\n        S: qp,\r\n        u: Lp,\r\n        U: Up,\r\n        V: Op,\r\n        w: Bp,\r\n        W: Yp,\r\n        x: null,\r\n        X: null,\r\n        y: Fp,\r\n        Y: Ip,\r\n        Z: jp,\r\n        '%': uv\r\n      },\r\n      m = {\r\n        a: function (t) {\r\n          return a[t.getUTCDay()]\r\n        },\r\n        A: function (t) {\r\n          return o[t.getUTCDay()]\r\n        },\r\n        b: function (t) {\r\n          return c[t.getUTCMonth()]\r\n        },\r\n        B: function (t) {\r\n          return u[t.getUTCMonth()]\r\n        },\r\n        c: null,\r\n        d: Hp,\r\n        e: Hp,\r\n        f: Wp,\r\n        H: Xp,\r\n        I: Gp,\r\n        j: Vp,\r\n        L: $p,\r\n        m: Zp,\r\n        M: Qp,\r\n        p: function (t) {\r\n          return i[+(t.getUTCHours() >= 12)]\r\n        },\r\n        Q: cv,\r\n        s: fv,\r\n        S: Jp,\r\n        u: Kp,\r\n        U: tv,\r\n        V: nv,\r\n        w: ev,\r\n        W: rv,\r\n        x: null,\r\n        X: null,\r\n        y: iv,\r\n        Y: ov,\r\n        Z: av,\r\n        '%': uv\r\n      },\r\n      x = {\r\n        a: function (t, n, e) {\r\n          var r = d.exec(n.slice(e))\r\n          return r ? ((t.w = p[r[0].toLowerCase()]), e + r[0].length) : -1\r\n        },\r\n        A: function (t, n, e) {\r\n          var r = l.exec(n.slice(e))\r\n          return r ? ((t.w = h[r[0].toLowerCase()]), e + r[0].length) : -1\r\n        },\r\n        b: function (t, n, e) {\r\n          var r = y.exec(n.slice(e))\r\n          return r ? ((t.m = _[r[0].toLowerCase()]), e + r[0].length) : -1\r\n        },\r\n        B: function (t, n, e) {\r\n          var r = v.exec(n.slice(e))\r\n          return r ? ((t.m = g[r[0].toLowerCase()]), e + r[0].length) : -1\r\n        },\r\n        c: function (t, e, r) {\r\n          return N(t, n, e, r)\r\n        },\r\n        d: yp,\r\n        e: yp,\r\n        f: Mp,\r\n        H: bp,\r\n        I: bp,\r\n        j: _p,\r\n        L: wp,\r\n        m: gp,\r\n        M: mp,\r\n        p: function (t, n, e) {\r\n          var r = f.exec(n.slice(e))\r\n          return r ? ((t.p = s[r[0].toLowerCase()]), e + r[0].length) : -1\r\n        },\r\n        Q: Ap,\r\n        s: Sp,\r\n        S: xp,\r\n        u: fp,\r\n        U: sp,\r\n        V: lp,\r\n        w: cp,\r\n        W: hp,\r\n        x: function (t, n, r) {\r\n          return N(t, e, n, r)\r\n        },\r\n        X: function (t, n, e) {\r\n          return N(t, r, n, e)\r\n        },\r\n        y: pp,\r\n        Y: dp,\r\n        Z: vp,\r\n        '%': Np\r\n      }\r\n    function w (t, n) {\r\n      return function (e) {\r\n        var r,\r\n          i,\r\n          o,\r\n          a = [],\r\n          u = -1,\r\n          c = 0,\r\n          f = t.length\r\n        for (e instanceof Date || (e = new Date(+e)); ++u < f; )\r\n          37 === t.charCodeAt(u) &&\r\n            (a.push(t.slice(c, u)),\r\n            null != (i = tp[(r = t.charAt(++u))]) ? (r = t.charAt(++u)) : (i = 'e' === r ? ' ' : '0'),\r\n            (o = n[r]) && (r = o(e, i)),\r\n            a.push(r),\r\n            (c = u + 1))\r\n        return a.push(t.slice(c, u)), a.join('')\r\n      }\r\n    }\r\n    function M (t, n) {\r\n      return function (e) {\r\n        var r,\r\n          i,\r\n          o = Qd(1900)\r\n        if (N(o, t, (e += ''), 0) != e.length) return null\r\n        if ('Q' in o) return new Date(o.Q)\r\n        if (('p' in o && (o.H = (o.H % 12) + 12 * o.p), 'V' in o)) {\r\n          if (o.V < 1 || o.V > 53) return null\r\n          'w' in o || (o.w = 1),\r\n            'Z' in o\r\n              ? ((i = (r = Zd(Qd(o.y))).getUTCDay()),\r\n                (r = i > 4 || 0 === i ? zd.ceil(r) : zd(r)),\r\n                (r = Td.offset(r, 7 * (o.V - 1))),\r\n                (o.y = r.getUTCFullYear()),\r\n                (o.m = r.getUTCMonth()),\r\n                (o.d = r.getUTCDate() + ((o.w + 6) % 7)))\r\n              : ((i = (r = n(Qd(o.y))).getDay()),\r\n                (r = i > 4 || 0 === i ? ud.ceil(r) : ud(r)),\r\n                (r = rd.offset(r, 7 * (o.V - 1))),\r\n                (o.y = r.getFullYear()),\r\n                (o.m = r.getMonth()),\r\n                (o.d = r.getDate() + ((o.w + 6) % 7)))\r\n        } else ('W' in o || 'U' in o) && ('w' in o || (o.w = 'u' in o ? o.u % 7 : 'W' in o ? 1 : 0), (i = 'Z' in o ? Zd(Qd(o.y)).getUTCDay() : n(Qd(o.y)).getDay()), (o.m = 0), (o.d = 'W' in o ? ((o.w + 6) % 7) + 7 * o.W - ((i + 5) % 7) : o.w + 7 * o.U - ((i + 6) % 7)))\r\n        return 'Z' in o ? ((o.H += (o.Z / 100) | 0), (o.M += o.Z % 100), Zd(o)) : n(o)\r\n      }\r\n    }\r\n    function N (t, n, e, r) {\r\n      for (var i, o, a = 0, u = n.length, c = e.length; a < u; ) {\r\n        if (r >= c) return -1\r\n        if (37 === (i = n.charCodeAt(a++))) {\r\n          if (((i = n.charAt(a++)), !(o = x[i in tp ? n.charAt(a++) : i]) || (r = o(t, e, r)) < 0)) return -1\r\n        } else if (i != e.charCodeAt(r++)) return -1\r\n      }\r\n      return r\r\n    }\r\n    return (\r\n      (b.x = w(e, b)),\r\n      (b.X = w(r, b)),\r\n      (b.c = w(n, b)),\r\n      (m.x = w(e, m)),\r\n      (m.X = w(r, m)),\r\n      (m.c = w(n, m)),\r\n      {\r\n        format: function (t) {\r\n          var n = w((t += ''), b)\r\n          return (\r\n            (n.toString = function () {\r\n              return t\r\n            }),\r\n            n\r\n          )\r\n        },\r\n        parse: function (t) {\r\n          var n = M((t += ''), Wd)\r\n          return (\r\n            (n.toString = function () {\r\n              return t\r\n            }),\r\n            n\r\n          )\r\n        },\r\n        utcFormat: function (t) {\r\n          var n = w((t += ''), m)\r\n          return (\r\n            (n.toString = function () {\r\n              return t\r\n            }),\r\n            n\r\n          )\r\n        },\r\n        utcParse: function (t) {\r\n          var n = M(t, Zd)\r\n          return (\r\n            (n.toString = function () {\r\n              return t\r\n            }),\r\n            n\r\n          )\r\n        }\r\n      }\r\n    )\r\n  }\r\n  var Kd,\r\n    tp = { '-': '', _: ' ', 0: '0' },\r\n    np = /^\\s*\\d+/,\r\n    ep = /^%/,\r\n    rp = /[\\\\^$*+?|[\\]().{}]/g\r\n  function ip (t, n, e) {\r\n    var r = t < 0 ? '-' : '',\r\n      i = (r ? -t : t) + '',\r\n      o = i.length\r\n    return r + (o < e ? new Array(e - o + 1).join(n) + i : i)\r\n  }\r\n  function op (t) {\r\n    return t.replace(rp, '\\\\$&')\r\n  }\r\n  function ap (t) {\r\n    return new RegExp('^(?:' + t.map(op).join('|') + ')', 'i')\r\n  }\r\n  function up (t) {\r\n    for (var n = {}, e = -1, r = t.length; ++e < r; ) n[t[e].toLowerCase()] = e\r\n    return n\r\n  }\r\n  function cp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 1))\r\n    return r ? ((t.w = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function fp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 1))\r\n    return r ? ((t.u = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function sp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.U = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function lp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.V = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function hp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.W = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function dp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 4))\r\n    return r ? ((t.y = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function pp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3)), e + r[0].length) : -1\r\n  }\r\n  function vp (t, n, e) {\r\n    var r = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(n.slice(e, e + 6))\r\n    return r ? ((t.Z = r[1] ? 0 : -(r[2] + (r[3] || '00'))), e + r[0].length) : -1\r\n  }\r\n  function gp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.m = r[0] - 1), e + r[0].length) : -1\r\n  }\r\n  function yp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.d = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function _p (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 3))\r\n    return r ? ((t.m = 0), (t.d = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function bp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.H = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function mp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.M = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function xp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 2))\r\n    return r ? ((t.S = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function wp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 3))\r\n    return r ? ((t.L = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function Mp (t, n, e) {\r\n    var r = np.exec(n.slice(e, e + 6))\r\n    return r ? ((t.L = Math.floor(r[0] / 1e3)), e + r[0].length) : -1\r\n  }\r\n  function Np (t, n, e) {\r\n    var r = ep.exec(n.slice(e, e + 1))\r\n    return r ? e + r[0].length : -1\r\n  }\r\n  function Ap (t, n, e) {\r\n    var r = np.exec(n.slice(e))\r\n    return r ? ((t.Q = +r[0]), e + r[0].length) : -1\r\n  }\r\n  function Sp (t, n, e) {\r\n    var r = np.exec(n.slice(e))\r\n    return r ? ((t.Q = 1e3 * +r[0]), e + r[0].length) : -1\r\n  }\r\n  function kp (t, n) {\r\n    return ip(t.getDate(), n, 2)\r\n  }\r\n  function Tp (t, n) {\r\n    return ip(t.getHours(), n, 2)\r\n  }\r\n  function Ep (t, n) {\r\n    return ip(t.getHours() % 12 || 12, n, 2)\r\n  }\r\n  function Cp (t, n) {\r\n    return ip(1 + rd.count(wd(t), t), n, 3)\r\n  }\r\n  function Pp (t, n) {\r\n    return ip(t.getMilliseconds(), n, 3)\r\n  }\r\n  function zp (t, n) {\r\n    return Pp(t, n) + '000'\r\n  }\r\n  function Rp (t, n) {\r\n    return ip(t.getMonth() + 1, n, 2)\r\n  }\r\n  function Dp (t, n) {\r\n    return ip(t.getMinutes(), n, 2)\r\n  }\r\n  function qp (t, n) {\r\n    return ip(t.getSeconds(), n, 2)\r\n  }\r\n  function Lp (t) {\r\n    var n = t.getDay()\r\n    return 0 === n ? 7 : n\r\n  }\r\n  function Up (t, n) {\r\n    return ip(ad.count(wd(t), t), n, 2)\r\n  }\r\n  function Op (t, n) {\r\n    var e = t.getDay()\r\n    return (t = e >= 4 || 0 === e ? sd(t) : sd.ceil(t)), ip(sd.count(wd(t), t) + (4 === wd(t).getDay()), n, 2)\r\n  }\r\n  function Bp (t) {\r\n    return t.getDay()\r\n  }\r\n  function Yp (t, n) {\r\n    return ip(ud.count(wd(t), t), n, 2)\r\n  }\r\n  function Fp (t, n) {\r\n    return ip(t.getFullYear() % 100, n, 2)\r\n  }\r\n  function Ip (t, n) {\r\n    return ip(t.getFullYear() % 1e4, n, 4)\r\n  }\r\n  function jp (t) {\r\n    var n = t.getTimezoneOffset()\r\n    return (n > 0 ? '-' : ((n *= -1), '+')) + ip((n / 60) | 0, '0', 2) + ip(n % 60, '0', 2)\r\n  }\r\n  function Hp (t, n) {\r\n    return ip(t.getUTCDate(), n, 2)\r\n  }\r\n  function Xp (t, n) {\r\n    return ip(t.getUTCHours(), n, 2)\r\n  }\r\n  function Gp (t, n) {\r\n    return ip(t.getUTCHours() % 12 || 12, n, 2)\r\n  }\r\n  function Vp (t, n) {\r\n    return ip(1 + Td.count(Vd(t), t), n, 3)\r\n  }\r\n  function $p (t, n) {\r\n    return ip(t.getUTCMilliseconds(), n, 3)\r\n  }\r\n  function Wp (t, n) {\r\n    return $p(t, n) + '000'\r\n  }\r\n  function Zp (t, n) {\r\n    return ip(t.getUTCMonth() + 1, n, 2)\r\n  }\r\n  function Qp (t, n) {\r\n    return ip(t.getUTCMinutes(), n, 2)\r\n  }\r\n  function Jp (t, n) {\r\n    return ip(t.getUTCSeconds(), n, 2)\r\n  }\r\n  function Kp (t) {\r\n    var n = t.getUTCDay()\r\n    return 0 === n ? 7 : n\r\n  }\r\n  function tv (t, n) {\r\n    return ip(Pd.count(Vd(t), t), n, 2)\r\n  }\r\n  function nv (t, n) {\r\n    var e = t.getUTCDay()\r\n    return (t = e >= 4 || 0 === e ? qd(t) : qd.ceil(t)), ip(qd.count(Vd(t), t) + (4 === Vd(t).getUTCDay()), n, 2)\r\n  }\r\n  function ev (t) {\r\n    return t.getUTCDay()\r\n  }\r\n  function rv (t, n) {\r\n    return ip(zd.count(Vd(t), t), n, 2)\r\n  }\r\n  function iv (t, n) {\r\n    return ip(t.getUTCFullYear() % 100, n, 2)\r\n  }\r\n  function ov (t, n) {\r\n    return ip(t.getUTCFullYear() % 1e4, n, 4)\r\n  }\r\n  function av () {\r\n    return '+0000'\r\n  }\r\n  function uv () {\r\n    return '%'\r\n  }\r\n  function cv (t) {\r\n    return +t\r\n  }\r\n  function fv (t) {\r\n    return Math.floor(+t / 1e3)\r\n  }\r\n  function sv (n) {\r\n    return (\r\n      (Kd = Jd(n)),\r\n      (t.timeFormat = Kd.format),\r\n      (t.timeParse = Kd.parse),\r\n      (t.utcFormat = Kd.utcFormat),\r\n      (t.utcParse = Kd.utcParse),\r\n      Kd\r\n    )\r\n  }\r\n  sv({\r\n    dateTime: '%x, %X',\r\n    date: '%-m/%-d/%Y',\r\n    time: '%-I:%M:%S %p',\r\n    periods: ['AM', 'PM'],\r\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\r\n    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\r\n    months: [\r\n      'January',\r\n      'February',\r\n      'March',\r\n      'April',\r\n      'May',\r\n      'June',\r\n      'July',\r\n      'August',\r\n      'September',\r\n      'October',\r\n      'November',\r\n      'December'\r\n    ],\r\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\r\n  })\r\n  var lv = Date.prototype.toISOString\r\n    ? function (t) {\r\n        return t.toISOString()\r\n      }\r\n    : t.utcFormat('%Y-%m-%dT%H:%M:%S.%LZ')\r\n  var hv = +new Date('2000-01-01T00:00:00.000Z')\r\n      ? function (t) {\r\n          var n = new Date(t)\r\n          return isNaN(n) ? null : n\r\n        }\r\n      : t.utcParse('%Y-%m-%dT%H:%M:%S.%LZ'),\r\n    dv = 1e3,\r\n    pv = 60 * dv,\r\n    vv = 60 * pv,\r\n    gv = 24 * vv,\r\n    yv = 7 * gv,\r\n    _v = 30 * gv,\r\n    bv = 365 * gv\r\n  function mv (t) {\r\n    return new Date(t)\r\n  }\r\n  function xv (t) {\r\n    return t instanceof Date ? +t : +new Date(+t)\r\n  }\r\n  function wv (t, n, r, i, o, a, u, c, f) {\r\n    var s = Ah(_h, _h),\r\n      l = s.invert,\r\n      h = s.domain,\r\n      d = f('.%L'),\r\n      p = f(':%S'),\r\n      v = f('%I:%M'),\r\n      g = f('%I %p'),\r\n      y = f('%a %d'),\r\n      _ = f('%b %d'),\r\n      b = f('%B'),\r\n      m = f('%Y'),\r\n      x = [\r\n        [u, 1, dv],\r\n        [u, 5, 5 * dv],\r\n        [u, 15, 15 * dv],\r\n        [u, 30, 30 * dv],\r\n        [a, 1, pv],\r\n        [a, 5, 5 * pv],\r\n        [a, 15, 15 * pv],\r\n        [a, 30, 30 * pv],\r\n        [o, 1, vv],\r\n        [o, 3, 3 * vv],\r\n        [o, 6, 6 * vv],\r\n        [o, 12, 12 * vv],\r\n        [i, 1, gv],\r\n        [i, 2, 2 * gv],\r\n        [r, 1, yv],\r\n        [n, 1, _v],\r\n        [n, 3, 3 * _v],\r\n        [t, 1, bv]\r\n      ]\r\n    function M (e) {\r\n      return (u(e) < e\r\n        ? d\r\n        : a(e) < e\r\n        ? p\r\n        : o(e) < e\r\n        ? v\r\n        : i(e) < e\r\n        ? g\r\n        : n(e) < e\r\n        ? r(e) < e\r\n          ? y\r\n          : _\r\n        : t(e) < e\r\n        ? b\r\n        : m)(e)\r\n    }\r\n    function N (n, r, i, o) {\r\n      if ((null == n && (n = 10), 'number' == typeof n)) {\r\n        var a = Math.abs(i - r) / n,\r\n          u = e(function (t) {\r\n            return t[2]\r\n          }).right(x, a)\r\n        u === x.length\r\n          ? ((o = w(r / bv, i / bv, n)), (n = t))\r\n          : u\r\n          ? ((o = (u = x[a / x[u - 1][2] < x[u][2] / a ? u - 1 : u])[1]), (n = u[0]))\r\n          : ((o = Math.max(w(r, i, n), 1)), (n = c))\r\n      }\r\n      return null == o ? n : n.every(o)\r\n    }\r\n    return (\r\n      (s.invert = function (t) {\r\n        return new Date(l(t))\r\n      }),\r\n      (s.domain = function (t) {\r\n        return arguments.length ? h(lh.call(t, xv)) : h().map(mv)\r\n      }),\r\n      (s.ticks = function (t, n) {\r\n        var e,\r\n          r = h(),\r\n          i = r[0],\r\n          o = r[r.length - 1],\r\n          a = o < i\r\n        return a && ((e = i), (i = o), (o = e)), (e = (e = N(t, i, o, n)) ? e.range(i, o + 1) : []), a ? e.reverse() : e\r\n      }),\r\n      (s.tickFormat = function (t, n) {\r\n        return null == n ? M : f(n)\r\n      }),\r\n      (s.nice = function (t, n) {\r\n        var e = h()\r\n        return (t = N(t, e[0], e[e.length - 1], n)) ? h(Th(e, t)) : s\r\n      }),\r\n      (s.copy = function () {\r\n        return Mh(s, wv(t, n, r, i, o, a, u, c, f))\r\n      }),\r\n      s\r\n    )\r\n  }\r\n  function Mv () {\r\n    var t,\r\n      n,\r\n      e,\r\n      r,\r\n      i,\r\n      o = 0,\r\n      a = 1,\r\n      u = _h,\r\n      c = !1\r\n    function f (n) {\r\n      return isNaN((n = +n)) ? i : u(0 === e ? 0.5 : ((n = (r(n) - t) * e), c ? Math.max(0, Math.min(1, n)) : n))\r\n    }\r\n    return (\r\n      (f.domain = function (i) {\r\n        return arguments.length\r\n          ? ((t = r((o = +i[0]))), (n = r((a = +i[1]))), (e = t === n ? 0 : 1 / (n - t)), f)\r\n          : [o, a]\r\n      }),\r\n      (f.clamp = function (t) {\r\n        return arguments.length ? ((c = !!t), f) : c\r\n      }),\r\n      (f.interpolator = function (t) {\r\n        return arguments.length ? ((u = t), f) : u\r\n      }),\r\n      (f.unknown = function (t) {\r\n        return arguments.length ? ((i = t), f) : i\r\n      }),\r\n      function (i) {\r\n        return (r = i), (t = i(o)), (n = i(a)), (e = t === n ? 0 : 1 / (n - t)), f\r\n      }\r\n    )\r\n  }\r\n  function Nv (t, n) {\r\n    return n\r\n      .domain(t.domain())\r\n      .interpolator(t.interpolator())\r\n      .clamp(t.clamp())\r\n      .unknown(t.unknown())\r\n  }\r\n  function Av () {\r\n    var t = Ih(Mv())\r\n    return (\r\n      (t.copy = function () {\r\n        return Nv(t, Av()).exponent(t.exponent())\r\n      }),\r\n      fh.apply(t, arguments)\r\n    )\r\n  }\r\n  function Sv () {\r\n    var t,\r\n      n,\r\n      e,\r\n      r,\r\n      i,\r\n      o,\r\n      a,\r\n      u = 0,\r\n      c = 0.5,\r\n      f = 1,\r\n      s = _h,\r\n      l = !1\r\n    function h (t) {\r\n      return isNaN((t = +t))\r\n        ? a\r\n        : ((t = 0.5 + ((t = +o(t)) - n) * (t < n ? r : i)), s(l ? Math.max(0, Math.min(1, t)) : t))\r\n    }\r\n    return (\r\n      (h.domain = function (a) {\r\n        return arguments.length\r\n          ? ((t = o((u = +a[0]))),\r\n            (n = o((c = +a[1]))),\r\n            (e = o((f = +a[2]))),\r\n            (r = t === n ? 0 : 0.5 / (n - t)),\r\n            (i = n === e ? 0 : 0.5 / (e - n)),\r\n            h)\r\n          : [u, c, f]\r\n      }),\r\n      (h.clamp = function (t) {\r\n        return arguments.length ? ((l = !!t), h) : l\r\n      }),\r\n      (h.interpolator = function (t) {\r\n        return arguments.length ? ((s = t), h) : s\r\n      }),\r\n      (h.unknown = function (t) {\r\n        return arguments.length ? ((a = t), h) : a\r\n      }),\r\n      function (a) {\r\n        return (\r\n          (o = a),\r\n          (t = a(u)),\r\n          (n = a(c)),\r\n          (e = a(f)),\r\n          (r = t === n ? 0 : 0.5 / (n - t)),\r\n          (i = n === e ? 0 : 0.5 / (e - n)),\r\n          h\r\n        )\r\n      }\r\n    )\r\n  }\r\n  function kv () {\r\n    var t = Ih(Sv())\r\n    return (\r\n      (t.copy = function () {\r\n        return Nv(t, kv()).exponent(t.exponent())\r\n      }),\r\n      fh.apply(t, arguments)\r\n    )\r\n  }\r\n  function Tv (t) {\r\n    for (var n = (t.length / 6) | 0, e = new Array(n), r = 0; r < n; ) e[r] = '#' + t.slice(6 * r, 6 * ++r)\r\n    return e\r\n  }\r\n  var Ev = Tv('1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf'),\r\n    Cv = Tv('7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666'),\r\n    Pv = Tv('1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666'),\r\n    zv = Tv('a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928'),\r\n    Rv = Tv('fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2'),\r\n    Dv = Tv('b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc'),\r\n    qv = Tv('e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999'),\r\n    Lv = Tv('66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3'),\r\n    Uv = Tv('8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f')\r\n  function Ov (t) {\r\n    return ce(t[t.length - 1])\r\n  }\r\n  var Bv = new Array(3)\r\n      .concat(\r\n        'd8b365f5f5f55ab4ac',\r\n        'a6611adfc27d80cdc1018571',\r\n        'a6611adfc27df5f5f580cdc1018571',\r\n        '8c510ad8b365f6e8c3c7eae55ab4ac01665e',\r\n        '8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e',\r\n        '8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e',\r\n        '8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e',\r\n        '5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30',\r\n        '5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30'\r\n      )\r\n      .map(Tv),\r\n    Yv = Ov(Bv),\r\n    Fv = new Array(3)\r\n      .concat(\r\n        'af8dc3f7f7f77fbf7b',\r\n        '7b3294c2a5cfa6dba0008837',\r\n        '7b3294c2a5cff7f7f7a6dba0008837',\r\n        '762a83af8dc3e7d4e8d9f0d37fbf7b1b7837',\r\n        '762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837',\r\n        '762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837',\r\n        '762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837',\r\n        '40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b',\r\n        '40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b'\r\n      )\r\n      .map(Tv),\r\n    Iv = Ov(Fv),\r\n    jv = new Array(3)\r\n      .concat(\r\n        'e9a3c9f7f7f7a1d76a',\r\n        'd01c8bf1b6dab8e1864dac26',\r\n        'd01c8bf1b6daf7f7f7b8e1864dac26',\r\n        'c51b7de9a3c9fde0efe6f5d0a1d76a4d9221',\r\n        'c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221',\r\n        'c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221',\r\n        'c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221',\r\n        '8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419',\r\n        '8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419'\r\n      )\r\n      .map(Tv),\r\n    Hv = Ov(jv),\r\n    Xv = new Array(3)\r\n      .concat(\r\n        '998ec3f7f7f7f1a340',\r\n        '5e3c99b2abd2fdb863e66101',\r\n        '5e3c99b2abd2f7f7f7fdb863e66101',\r\n        '542788998ec3d8daebfee0b6f1a340b35806',\r\n        '542788998ec3d8daebf7f7f7fee0b6f1a340b35806',\r\n        '5427888073acb2abd2d8daebfee0b6fdb863e08214b35806',\r\n        '5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806',\r\n        '2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08',\r\n        '2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08'\r\n      )\r\n      .map(Tv),\r\n    Gv = Ov(Xv),\r\n    Vv = new Array(3)\r\n      .concat(\r\n        'ef8a62f7f7f767a9cf',\r\n        'ca0020f4a58292c5de0571b0',\r\n        'ca0020f4a582f7f7f792c5de0571b0',\r\n        'b2182bef8a62fddbc7d1e5f067a9cf2166ac',\r\n        'b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac',\r\n        'b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac',\r\n        'b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac',\r\n        '67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061',\r\n        '67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061'\r\n      )\r\n      .map(Tv),\r\n    $v = Ov(Vv),\r\n    Wv = new Array(3)\r\n      .concat(\r\n        'ef8a62ffffff999999',\r\n        'ca0020f4a582bababa404040',\r\n        'ca0020f4a582ffffffbababa404040',\r\n        'b2182bef8a62fddbc7e0e0e09999994d4d4d',\r\n        'b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d',\r\n        'b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d',\r\n        'b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d',\r\n        '67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a',\r\n        '67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a'\r\n      )\r\n      .map(Tv),\r\n    Zv = Ov(Wv),\r\n    Qv = new Array(3)\r\n      .concat(\r\n        'fc8d59ffffbf91bfdb',\r\n        'd7191cfdae61abd9e92c7bb6',\r\n        'd7191cfdae61ffffbfabd9e92c7bb6',\r\n        'd73027fc8d59fee090e0f3f891bfdb4575b4',\r\n        'd73027fc8d59fee090ffffbfe0f3f891bfdb4575b4',\r\n        'd73027f46d43fdae61fee090e0f3f8abd9e974add14575b4',\r\n        'd73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4',\r\n        'a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695',\r\n        'a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695'\r\n      )\r\n      .map(Tv),\r\n    Jv = Ov(Qv),\r\n    Kv = new Array(3)\r\n      .concat(\r\n        'fc8d59ffffbf91cf60',\r\n        'd7191cfdae61a6d96a1a9641',\r\n        'd7191cfdae61ffffbfa6d96a1a9641',\r\n        'd73027fc8d59fee08bd9ef8b91cf601a9850',\r\n        'd73027fc8d59fee08bffffbfd9ef8b91cf601a9850',\r\n        'd73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850',\r\n        'd73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850',\r\n        'a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837',\r\n        'a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837'\r\n      )\r\n      .map(Tv),\r\n    tg = Ov(Kv),\r\n    ng = new Array(3)\r\n      .concat(\r\n        'fc8d59ffffbf99d594',\r\n        'd7191cfdae61abdda42b83ba',\r\n        'd7191cfdae61ffffbfabdda42b83ba',\r\n        'd53e4ffc8d59fee08be6f59899d5943288bd',\r\n        'd53e4ffc8d59fee08bffffbfe6f59899d5943288bd',\r\n        'd53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd',\r\n        'd53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd',\r\n        '9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2',\r\n        '9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2'\r\n      )\r\n      .map(Tv),\r\n    eg = Ov(ng),\r\n    rg = new Array(3)\r\n      .concat(\r\n        'e5f5f999d8c92ca25f',\r\n        'edf8fbb2e2e266c2a4238b45',\r\n        'edf8fbb2e2e266c2a42ca25f006d2c',\r\n        'edf8fbccece699d8c966c2a42ca25f006d2c',\r\n        'edf8fbccece699d8c966c2a441ae76238b45005824',\r\n        'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824',\r\n        'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b'\r\n      )\r\n      .map(Tv),\r\n    ig = Ov(rg),\r\n    og = new Array(3)\r\n      .concat(\r\n        'e0ecf49ebcda8856a7',\r\n        'edf8fbb3cde38c96c688419d',\r\n        'edf8fbb3cde38c96c68856a7810f7c',\r\n        'edf8fbbfd3e69ebcda8c96c68856a7810f7c',\r\n        'edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b',\r\n        'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b',\r\n        'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b'\r\n      )\r\n      .map(Tv),\r\n    ag = Ov(og),\r\n    ug = new Array(3)\r\n      .concat(\r\n        'e0f3dba8ddb543a2ca',\r\n        'f0f9e8bae4bc7bccc42b8cbe',\r\n        'f0f9e8bae4bc7bccc443a2ca0868ac',\r\n        'f0f9e8ccebc5a8ddb57bccc443a2ca0868ac',\r\n        'f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e',\r\n        'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e',\r\n        'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081'\r\n      )\r\n      .map(Tv),\r\n    cg = Ov(ug),\r\n    fg = new Array(3)\r\n      .concat(\r\n        'fee8c8fdbb84e34a33',\r\n        'fef0d9fdcc8afc8d59d7301f',\r\n        'fef0d9fdcc8afc8d59e34a33b30000',\r\n        'fef0d9fdd49efdbb84fc8d59e34a33b30000',\r\n        'fef0d9fdd49efdbb84fc8d59ef6548d7301f990000',\r\n        'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000',\r\n        'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000'\r\n      )\r\n      .map(Tv),\r\n    sg = Ov(fg),\r\n    lg = new Array(3)\r\n      .concat(\r\n        'ece2f0a6bddb1c9099',\r\n        'f6eff7bdc9e167a9cf02818a',\r\n        'f6eff7bdc9e167a9cf1c9099016c59',\r\n        'f6eff7d0d1e6a6bddb67a9cf1c9099016c59',\r\n        'f6eff7d0d1e6a6bddb67a9cf3690c002818a016450',\r\n        'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450',\r\n        'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636'\r\n      )\r\n      .map(Tv),\r\n    hg = Ov(lg),\r\n    dg = new Array(3)\r\n      .concat(\r\n        'ece7f2a6bddb2b8cbe',\r\n        'f1eef6bdc9e174a9cf0570b0',\r\n        'f1eef6bdc9e174a9cf2b8cbe045a8d',\r\n        'f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d',\r\n        'f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b',\r\n        'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b',\r\n        'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858'\r\n      )\r\n      .map(Tv),\r\n    pg = Ov(dg),\r\n    vg = new Array(3)\r\n      .concat(\r\n        'e7e1efc994c7dd1c77',\r\n        'f1eef6d7b5d8df65b0ce1256',\r\n        'f1eef6d7b5d8df65b0dd1c77980043',\r\n        'f1eef6d4b9dac994c7df65b0dd1c77980043',\r\n        'f1eef6d4b9dac994c7df65b0e7298ace125691003f',\r\n        'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f',\r\n        'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f'\r\n      )\r\n      .map(Tv),\r\n    gg = Ov(vg),\r\n    yg = new Array(3)\r\n      .concat(\r\n        'fde0ddfa9fb5c51b8a',\r\n        'feebe2fbb4b9f768a1ae017e',\r\n        'feebe2fbb4b9f768a1c51b8a7a0177',\r\n        'feebe2fcc5c0fa9fb5f768a1c51b8a7a0177',\r\n        'feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177',\r\n        'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177',\r\n        'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a'\r\n      )\r\n      .map(Tv),\r\n    _g = Ov(yg),\r\n    bg = new Array(3)\r\n      .concat(\r\n        'edf8b17fcdbb2c7fb8',\r\n        'ffffcca1dab441b6c4225ea8',\r\n        'ffffcca1dab441b6c42c7fb8253494',\r\n        'ffffccc7e9b47fcdbb41b6c42c7fb8253494',\r\n        'ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84',\r\n        'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84',\r\n        'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58'\r\n      )\r\n      .map(Tv),\r\n    mg = Ov(bg),\r\n    xg = new Array(3)\r\n      .concat(\r\n        'f7fcb9addd8e31a354',\r\n        'ffffccc2e69978c679238443',\r\n        'ffffccc2e69978c67931a354006837',\r\n        'ffffccd9f0a3addd8e78c67931a354006837',\r\n        'ffffccd9f0a3addd8e78c67941ab5d238443005a32',\r\n        'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32',\r\n        'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529'\r\n      )\r\n      .map(Tv),\r\n    wg = Ov(xg),\r\n    Mg = new Array(3)\r\n      .concat(\r\n        'fff7bcfec44fd95f0e',\r\n        'ffffd4fed98efe9929cc4c02',\r\n        'ffffd4fed98efe9929d95f0e993404',\r\n        'ffffd4fee391fec44ffe9929d95f0e993404',\r\n        'ffffd4fee391fec44ffe9929ec7014cc4c028c2d04',\r\n        'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04',\r\n        'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506'\r\n      )\r\n      .map(Tv),\r\n    Ng = Ov(Mg),\r\n    Ag = new Array(3)\r\n      .concat(\r\n        'ffeda0feb24cf03b20',\r\n        'ffffb2fecc5cfd8d3ce31a1c',\r\n        'ffffb2fecc5cfd8d3cf03b20bd0026',\r\n        'ffffb2fed976feb24cfd8d3cf03b20bd0026',\r\n        'ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026',\r\n        'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026',\r\n        'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026'\r\n      )\r\n      .map(Tv),\r\n    Sg = Ov(Ag),\r\n    kg = new Array(3)\r\n      .concat(\r\n        'deebf79ecae13182bd',\r\n        'eff3ffbdd7e76baed62171b5',\r\n        'eff3ffbdd7e76baed63182bd08519c',\r\n        'eff3ffc6dbef9ecae16baed63182bd08519c',\r\n        'eff3ffc6dbef9ecae16baed64292c62171b5084594',\r\n        'f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594',\r\n        'f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b'\r\n      )\r\n      .map(Tv),\r\n    Tg = Ov(kg),\r\n    Eg = new Array(3)\r\n      .concat(\r\n        'e5f5e0a1d99b31a354',\r\n        'edf8e9bae4b374c476238b45',\r\n        'edf8e9bae4b374c47631a354006d2c',\r\n        'edf8e9c7e9c0a1d99b74c47631a354006d2c',\r\n        'edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32',\r\n        'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32',\r\n        'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b'\r\n      )\r\n      .map(Tv),\r\n    Cg = Ov(Eg),\r\n    Pg = new Array(3)\r\n      .concat(\r\n        'f0f0f0bdbdbd636363',\r\n        'f7f7f7cccccc969696525252',\r\n        'f7f7f7cccccc969696636363252525',\r\n        'f7f7f7d9d9d9bdbdbd969696636363252525',\r\n        'f7f7f7d9d9d9bdbdbd969696737373525252252525',\r\n        'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525',\r\n        'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000'\r\n      )\r\n      .map(Tv),\r\n    zg = Ov(Pg),\r\n    Rg = new Array(3)\r\n      .concat(\r\n        'efedf5bcbddc756bb1',\r\n        'f2f0f7cbc9e29e9ac86a51a3',\r\n        'f2f0f7cbc9e29e9ac8756bb154278f',\r\n        'f2f0f7dadaebbcbddc9e9ac8756bb154278f',\r\n        'f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486',\r\n        'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486',\r\n        'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d'\r\n      )\r\n      .map(Tv),\r\n    Dg = Ov(Rg),\r\n    qg = new Array(3)\r\n      .concat(\r\n        'fee0d2fc9272de2d26',\r\n        'fee5d9fcae91fb6a4acb181d',\r\n        'fee5d9fcae91fb6a4ade2d26a50f15',\r\n        'fee5d9fcbba1fc9272fb6a4ade2d26a50f15',\r\n        'fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d',\r\n        'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d',\r\n        'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d'\r\n      )\r\n      .map(Tv),\r\n    Lg = Ov(qg),\r\n    Ug = new Array(3)\r\n      .concat(\r\n        'fee6cefdae6be6550d',\r\n        'feeddefdbe85fd8d3cd94701',\r\n        'feeddefdbe85fd8d3ce6550da63603',\r\n        'feeddefdd0a2fdae6bfd8d3ce6550da63603',\r\n        'feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04',\r\n        'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04',\r\n        'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704'\r\n      )\r\n      .map(Tv),\r\n    Og = Ov(Ug),\r\n    Bg = je(Zn(300, 0.5, 0), Zn(-240, 0.5, 1)),\r\n    Yg = je(Zn(-100, 0.75, 0.35), Zn(80, 1.5, 0.8)),\r\n    Fg = je(Zn(260, 0.75, 0.35), Zn(80, 1.5, 0.8)),\r\n    Ig = Zn()\r\n  var jg = gn(),\r\n    Hg = Math.PI / 3,\r\n    Xg = (2 * Math.PI) / 3\r\n  function Gg (t) {\r\n    var n = t.length\r\n    return function (e) {\r\n      return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))]\r\n    }\r\n  }\r\n  var Vg = Gg(\r\n      Tv(\r\n        '44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725'\r\n      )\r\n    ),\r\n    $g = Gg(\r\n      Tv(\r\n        '00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf'\r\n      )\r\n    ),\r\n    Wg = Gg(\r\n      Tv(\r\n        '00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4'\r\n      )\r\n    ),\r\n    Zg = Gg(\r\n      Tv(\r\n        '0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921'\r\n      )\r\n    )\r\n  function Qg (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  var Jg = Math.abs,\r\n    Kg = Math.atan2,\r\n    ty = Math.cos,\r\n    ny = Math.max,\r\n    ey = Math.min,\r\n    ry = Math.sin,\r\n    iy = Math.sqrt,\r\n    oy = 1e-12,\r\n    ay = Math.PI,\r\n    uy = ay / 2,\r\n    cy = 2 * ay\r\n  function fy (t) {\r\n    return t >= 1 ? uy : t <= -1 ? -uy : Math.asin(t)\r\n  }\r\n  function sy (t) {\r\n    return t.innerRadius\r\n  }\r\n  function ly (t) {\r\n    return t.outerRadius\r\n  }\r\n  function hy (t) {\r\n    return t.startAngle\r\n  }\r\n  function dy (t) {\r\n    return t.endAngle\r\n  }\r\n  function py (t) {\r\n    return t && t.padAngle\r\n  }\r\n  function vy (t, n, e, r, i, o, a) {\r\n    var u = t - e,\r\n      c = n - r,\r\n      f = (a ? o : -o) / iy(u * u + c * c),\r\n      s = f * c,\r\n      l = -f * u,\r\n      h = t + s,\r\n      d = n + l,\r\n      p = e + s,\r\n      v = r + l,\r\n      g = (h + p) / 2,\r\n      y = (d + v) / 2,\r\n      _ = p - h,\r\n      b = v - d,\r\n      m = _ * _ + b * b,\r\n      x = i - o,\r\n      w = h * v - p * d,\r\n      M = (b < 0 ? -1 : 1) * iy(ny(0, x * x * m - w * w)),\r\n      N = (w * b - _ * M) / m,\r\n      A = (-w * _ - b * M) / m,\r\n      S = (w * b + _ * M) / m,\r\n      k = (-w * _ + b * M) / m,\r\n      T = N - g,\r\n      E = A - y,\r\n      C = S - g,\r\n      P = k - y\r\n    return (\r\n      T * T + E * E > C * C + P * P && ((N = S), (A = k)),\r\n      { cx: N, cy: A, x01: -s, y01: -l, x11: N * (i / x - 1), y11: A * (i / x - 1) }\r\n    )\r\n  }\r\n  function gy (t) {\r\n    this._context = t\r\n  }\r\n  function yy (t) {\r\n    return new gy(t)\r\n  }\r\n  function _y (t) {\r\n    return t[0]\r\n  }\r\n  function by (t) {\r\n    return t[1]\r\n  }\r\n  function my () {\r\n    var t = _y,\r\n      n = by,\r\n      e = Qg(!0),\r\n      r = null,\r\n      i = yy,\r\n      o = null\r\n    function a (a) {\r\n      var u,\r\n        c,\r\n        f,\r\n        s = a.length,\r\n        l = !1\r\n      for (null == r && (o = i((f = Hi()))), u = 0; u <= s; ++u)\r\n        !(u < s && e((c = a[u]), u, a)) === l && ((l = !l) ? o.lineStart() : o.lineEnd()),\r\n          l && o.point(+t(c, u, a), +n(c, u, a))\r\n      if (f) return (o = null), f + '' || null\r\n    }\r\n    return (\r\n      (a.x = function (n) {\r\n        return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), a) : t\r\n      }),\r\n      (a.y = function (t) {\r\n        return arguments.length ? ((n = 'function' == typeof t ? t : Qg(+t)), a) : n\r\n      }),\r\n      (a.defined = function (t) {\r\n        return arguments.length ? ((e = 'function' == typeof t ? t : Qg(!!t)), a) : e\r\n      }),\r\n      (a.curve = function (t) {\r\n        return arguments.length ? ((i = t), null != r && (o = i(r)), a) : i\r\n      }),\r\n      (a.context = function (t) {\r\n        return arguments.length ? (null == t ? (r = o = null) : (o = i((r = t))), a) : r\r\n      }),\r\n      a\r\n    )\r\n  }\r\n  function xy () {\r\n    var t = _y,\r\n      n = null,\r\n      e = Qg(0),\r\n      r = by,\r\n      i = Qg(!0),\r\n      o = null,\r\n      a = yy,\r\n      u = null\r\n    function c (c) {\r\n      var f,\r\n        s,\r\n        l,\r\n        h,\r\n        d,\r\n        p = c.length,\r\n        v = !1,\r\n        g = new Array(p),\r\n        y = new Array(p)\r\n      for (null == o && (u = a((d = Hi()))), f = 0; f <= p; ++f) {\r\n        if (!(f < p && i((h = c[f]), f, c)) === v)\r\n          if ((v = !v)) (s = f), u.areaStart(), u.lineStart()\r\n          else {\r\n            for (u.lineEnd(), u.lineStart(), l = f - 1; l >= s; --l) u.point(g[l], y[l])\r\n            u.lineEnd(), u.areaEnd()\r\n          }\r\n        v && ((g[f] = +t(h, f, c)), (y[f] = +e(h, f, c)), u.point(n ? +n(h, f, c) : g[f], r ? +r(h, f, c) : y[f]))\r\n      }\r\n      if (d) return (u = null), d + '' || null\r\n    }\r\n    function f () {\r\n      return my()\r\n        .defined(i)\r\n        .curve(a)\r\n        .context(o)\r\n    }\r\n    return (\r\n      (c.x = function (e) {\r\n        return arguments.length ? ((t = 'function' == typeof e ? e : Qg(+e)), (n = null), c) : t\r\n      }),\r\n      (c.x0 = function (n) {\r\n        return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), c) : t\r\n      }),\r\n      (c.x1 = function (t) {\r\n        return arguments.length ? ((n = null == t ? null : 'function' == typeof t ? t : Qg(+t)), c) : n\r\n      }),\r\n      (c.y = function (t) {\r\n        return arguments.length ? ((e = 'function' == typeof t ? t : Qg(+t)), (r = null), c) : e\r\n      }),\r\n      (c.y0 = function (t) {\r\n        return arguments.length ? ((e = 'function' == typeof t ? t : Qg(+t)), c) : e\r\n      }),\r\n      (c.y1 = function (t) {\r\n        return arguments.length ? ((r = null == t ? null : 'function' == typeof t ? t : Qg(+t)), c) : r\r\n      }),\r\n      (c.lineX0 = c.lineY0 = function () {\r\n        return f()\r\n          .x(t)\r\n          .y(e)\r\n      }),\r\n      (c.lineY1 = function () {\r\n        return f()\r\n          .x(t)\r\n          .y(r)\r\n      }),\r\n      (c.lineX1 = function () {\r\n        return f()\r\n          .x(n)\r\n          .y(e)\r\n      }),\r\n      (c.defined = function (t) {\r\n        return arguments.length ? ((i = 'function' == typeof t ? t : Qg(!!t)), c) : i\r\n      }),\r\n      (c.curve = function (t) {\r\n        return arguments.length ? ((a = t), null != o && (u = a(o)), c) : a\r\n      }),\r\n      (c.context = function (t) {\r\n        return arguments.length ? (null == t ? (o = u = null) : (u = a((o = t))), c) : o\r\n      }),\r\n      c\r\n    )\r\n  }\r\n  function wy (t, n) {\r\n    return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN\r\n  }\r\n  function My (t) {\r\n    return t\r\n  }\r\n  gy.prototype = {\r\n    areaStart: function () {\r\n      this._line = 0\r\n    },\r\n    areaEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      this._point = 0\r\n    },\r\n    lineEnd: function () {\r\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\r\n        (this._line = 1 - this._line)\r\n    },\r\n    point: function (t, n) {\r\n      switch (((t = +t), (n = +n), this._point)) {\r\n        case 0:\r\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\r\n          break\r\n        case 1:\r\n          this._point = 2\r\n        default:\r\n          this._context.lineTo(t, n)\r\n      }\r\n    }\r\n  }\r\n  var Ny = Sy(yy)\r\n  function Ay (t) {\r\n    this._curve = t\r\n  }\r\n  function Sy (t) {\r\n    function n (n) {\r\n      return new Ay(t(n))\r\n    }\r\n    return (n._curve = t), n\r\n  }\r\n  function ky (t) {\r\n    var n = t.curve\r\n    return (\r\n      (t.angle = t.x),\r\n      delete t.x,\r\n      (t.radius = t.y),\r\n      delete t.y,\r\n      (t.curve = function (t) {\r\n        return arguments.length ? n(Sy(t)) : n()._curve\r\n      }),\r\n      t\r\n    )\r\n  }\r\n  function Ty () {\r\n    return ky(my().curve(Ny))\r\n  }\r\n  function Ey () {\r\n    var t = xy().curve(Ny),\r\n      n = t.curve,\r\n      e = t.lineX0,\r\n      r = t.lineX1,\r\n      i = t.lineY0,\r\n      o = t.lineY1\r\n    return (\r\n      (t.angle = t.x),\r\n      delete t.x,\r\n      (t.startAngle = t.x0),\r\n      delete t.x0,\r\n      (t.endAngle = t.x1),\r\n      delete t.x1,\r\n      (t.radius = t.y),\r\n      delete t.y,\r\n      (t.innerRadius = t.y0),\r\n      delete t.y0,\r\n      (t.outerRadius = t.y1),\r\n      delete t.y1,\r\n      (t.lineStartAngle = function () {\r\n        return ky(e())\r\n      }),\r\n      delete t.lineX0,\r\n      (t.lineEndAngle = function () {\r\n        return ky(r())\r\n      }),\r\n      delete t.lineX1,\r\n      (t.lineInnerRadius = function () {\r\n        return ky(i())\r\n      }),\r\n      delete t.lineY0,\r\n      (t.lineOuterRadius = function () {\r\n        return ky(o())\r\n      }),\r\n      delete t.lineY1,\r\n      (t.curve = function (t) {\r\n        return arguments.length ? n(Sy(t)) : n()._curve\r\n      }),\r\n      t\r\n    )\r\n  }\r\n  function Cy (t, n) {\r\n    return [(n = +n) * Math.cos((t -= Math.PI / 2)), n * Math.sin(t)]\r\n  }\r\n  Ay.prototype = {\r\n    areaStart: function () {\r\n      this._curve.areaStart()\r\n    },\r\n    areaEnd: function () {\r\n      this._curve.areaEnd()\r\n    },\r\n    lineStart: function () {\r\n      this._curve.lineStart()\r\n    },\r\n    lineEnd: function () {\r\n      this._curve.lineEnd()\r\n    },\r\n    point: function (t, n) {\r\n      this._curve.point(n * Math.sin(t), n * -Math.cos(t))\r\n    }\r\n  }\r\n  var Py = Array.prototype.slice\r\n  function zy (t) {\r\n    return t.source\r\n  }\r\n  function Ry (t) {\r\n    return t.target\r\n  }\r\n  function Dy (t) {\r\n    var n = zy,\r\n      e = Ry,\r\n      r = _y,\r\n      i = by,\r\n      o = null\r\n    function a () {\r\n      var a,\r\n        u = Py.call(arguments),\r\n        c = n.apply(this, u),\r\n        f = e.apply(this, u)\r\n      if (\r\n        (o || (o = a = Hi()),\r\n        t(o, +r.apply(this, ((u[0] = c), u)), +i.apply(this, u), +r.apply(this, ((u[0] = f), u)), +i.apply(this, u)),\r\n        a)\r\n      )\r\n        return (o = null), a + '' || null\r\n    }\r\n    return (\r\n      (a.source = function (t) {\r\n        return arguments.length ? ((n = t), a) : n\r\n      }),\r\n      (a.target = function (t) {\r\n        return arguments.length ? ((e = t), a) : e\r\n      }),\r\n      (a.x = function (t) {\r\n        return arguments.length ? ((r = 'function' == typeof t ? t : Qg(+t)), a) : r\r\n      }),\r\n      (a.y = function (t) {\r\n        return arguments.length ? ((i = 'function' == typeof t ? t : Qg(+t)), a) : i\r\n      }),\r\n      (a.context = function (t) {\r\n        return arguments.length ? ((o = null == t ? null : t), a) : o\r\n      }),\r\n      a\r\n    )\r\n  }\r\n  function qy (t, n, e, r, i) {\r\n    t.moveTo(n, e), t.bezierCurveTo((n = (n + r) / 2), e, n, i, r, i)\r\n  }\r\n  function Ly (t, n, e, r, i) {\r\n    t.moveTo(n, e), t.bezierCurveTo(n, (e = (e + i) / 2), r, e, r, i)\r\n  }\r\n  function Uy (t, n, e, r, i) {\r\n    var o = Cy(n, e),\r\n      a = Cy(n, (e = (e + i) / 2)),\r\n      u = Cy(r, e),\r\n      c = Cy(r, i)\r\n    t.moveTo(o[0], o[1]), t.bezierCurveTo(a[0], a[1], u[0], u[1], c[0], c[1])\r\n  }\r\n  var Oy = {\r\n      draw: function (t, n) {\r\n        var e = Math.sqrt(n / ay)\r\n        t.moveTo(e, 0), t.arc(0, 0, e, 0, cy)\r\n      }\r\n    },\r\n    By = {\r\n      draw: function (t, n) {\r\n        var e = Math.sqrt(n / 5) / 2\r\n        t.moveTo(-3 * e, -e),\r\n          t.lineTo(-e, -e),\r\n          t.lineTo(-e, -3 * e),\r\n          t.lineTo(e, -3 * e),\r\n          t.lineTo(e, -e),\r\n          t.lineTo(3 * e, -e),\r\n          t.lineTo(3 * e, e),\r\n          t.lineTo(e, e),\r\n          t.lineTo(e, 3 * e),\r\n          t.lineTo(-e, 3 * e),\r\n          t.lineTo(-e, e),\r\n          t.lineTo(-3 * e, e),\r\n          t.closePath()\r\n      }\r\n    },\r\n    Yy = Math.sqrt(1 / 3),\r\n    Fy = 2 * Yy,\r\n    Iy = {\r\n      draw: function (t, n) {\r\n        var e = Math.sqrt(n / Fy),\r\n          r = e * Yy\r\n        t.moveTo(0, -e), t.lineTo(r, 0), t.lineTo(0, e), t.lineTo(-r, 0), t.closePath()\r\n      }\r\n    },\r\n    jy = Math.sin(ay / 10) / Math.sin((7 * ay) / 10),\r\n    Hy = Math.sin(cy / 10) * jy,\r\n    Xy = -Math.cos(cy / 10) * jy,\r\n    Gy = {\r\n      draw: function (t, n) {\r\n        var e = Math.sqrt(0.8908130915292852 * n),\r\n          r = Hy * e,\r\n          i = Xy * e\r\n        t.moveTo(0, -e), t.lineTo(r, i)\r\n        for (var o = 1; o < 5; ++o) {\r\n          var a = (cy * o) / 5,\r\n            u = Math.cos(a),\r\n            c = Math.sin(a)\r\n          t.lineTo(c * e, -u * e), t.lineTo(u * r - c * i, c * r + u * i)\r\n        }\r\n        t.closePath()\r\n      }\r\n    },\r\n    Vy = {\r\n      draw: function (t, n) {\r\n        var e = Math.sqrt(n),\r\n          r = -e / 2\r\n        t.rect(r, r, e, e)\r\n      }\r\n    },\r\n    $y = Math.sqrt(3),\r\n    Wy = {\r\n      draw: function (t, n) {\r\n        var e = -Math.sqrt(n / (3 * $y))\r\n        t.moveTo(0, 2 * e), t.lineTo(-$y * e, -e), t.lineTo($y * e, -e), t.closePath()\r\n      }\r\n    },\r\n    Zy = Math.sqrt(3) / 2,\r\n    Qy = 1 / Math.sqrt(12),\r\n    Jy = 3 * (Qy / 2 + 1),\r\n    Ky = {\r\n      draw: function (t, n) {\r\n        var e = Math.sqrt(n / Jy),\r\n          r = e / 2,\r\n          i = e * Qy,\r\n          o = r,\r\n          a = e * Qy + e,\r\n          u = -o,\r\n          c = a\r\n        t.moveTo(r, i),\r\n          t.lineTo(o, a),\r\n          t.lineTo(u, c),\r\n          t.lineTo(-0.5 * r - Zy * i, Zy * r + -0.5 * i),\r\n          t.lineTo(-0.5 * o - Zy * a, Zy * o + -0.5 * a),\r\n          t.lineTo(-0.5 * u - Zy * c, Zy * u + -0.5 * c),\r\n          t.lineTo(-0.5 * r + Zy * i, -0.5 * i - Zy * r),\r\n          t.lineTo(-0.5 * o + Zy * a, -0.5 * a - Zy * o),\r\n          t.lineTo(-0.5 * u + Zy * c, -0.5 * c - Zy * u),\r\n          t.closePath()\r\n      }\r\n    },\r\n    t_ = [Oy, By, Iy, Vy, Gy, Wy, Ky]\r\n  function n_ () {}\r\n  function e_ (t, n, e) {\r\n    t._context.bezierCurveTo(\r\n      (2 * t._x0 + t._x1) / 3,\r\n      (2 * t._y0 + t._y1) / 3,\r\n      (t._x0 + 2 * t._x1) / 3,\r\n      (t._y0 + 2 * t._y1) / 3,\r\n      (t._x0 + 4 * t._x1 + n) / 6,\r\n      (t._y0 + 4 * t._y1 + e) / 6\r\n    )\r\n  }\r\n  function r_ (t) {\r\n    this._context = t\r\n  }\r\n  function i_ (t) {\r\n    this._context = t\r\n  }\r\n  function o_ (t) {\r\n    this._context = t\r\n  }\r\n  function a_ (t, n) {\r\n    ;(this._basis = new r_(t)), (this._beta = n)\r\n  }\r\n  ;(r_.prototype = {\r\n    areaStart: function () {\r\n      this._line = 0\r\n    },\r\n    areaEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      switch (this._point) {\r\n        case 3:\r\n          e_(this, this._x1, this._y1)\r\n        case 2:\r\n          this._context.lineTo(this._x1, this._y1)\r\n      }\r\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\r\n        (this._line = 1 - this._line)\r\n    },\r\n    point: function (t, n) {\r\n      switch (((t = +t), (n = +n), this._point)) {\r\n        case 0:\r\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\r\n          break\r\n        case 1:\r\n          this._point = 2\r\n          break\r\n        case 2:\r\n          ;(this._point = 3), this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6)\r\n        default:\r\n          e_(this, t, n)\r\n      }\r\n      ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n)\r\n    }\r\n  }),\r\n    (i_.prototype = {\r\n      areaStart: n_,\r\n      areaEnd: n_,\r\n      lineStart: function () {\r\n        ;(this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN),\r\n          (this._point = 0)\r\n      },\r\n      lineEnd: function () {\r\n        switch (this._point) {\r\n          case 1:\r\n            this._context.moveTo(this._x2, this._y2), this._context.closePath()\r\n            break\r\n          case 2:\r\n            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),\r\n              this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),\r\n              this._context.closePath()\r\n            break\r\n          case 3:\r\n            this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4)\r\n        }\r\n      },\r\n      point: function (t, n) {\r\n        switch (((t = +t), (n = +n), this._point)) {\r\n          case 0:\r\n            ;(this._point = 1), (this._x2 = t), (this._y2 = n)\r\n            break\r\n          case 1:\r\n            ;(this._point = 2), (this._x3 = t), (this._y3 = n)\r\n            break\r\n          case 2:\r\n            ;(this._point = 3),\r\n              (this._x4 = t),\r\n              (this._y4 = n),\r\n              this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6)\r\n            break\r\n          default:\r\n            e_(this, t, n)\r\n        }\r\n        ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n)\r\n      }\r\n    }),\r\n    (o_.prototype = {\r\n      areaStart: function () {\r\n        this._line = 0\r\n      },\r\n      areaEnd: function () {\r\n        this._line = NaN\r\n      },\r\n      lineStart: function () {\r\n        ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)\r\n      },\r\n      lineEnd: function () {\r\n        ;(this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),\r\n          (this._line = 1 - this._line)\r\n      },\r\n      point: function (t, n) {\r\n        switch (((t = +t), (n = +n), this._point)) {\r\n          case 0:\r\n            this._point = 1\r\n            break\r\n          case 1:\r\n            this._point = 2\r\n            break\r\n          case 2:\r\n            this._point = 3\r\n            var e = (this._x0 + 4 * this._x1 + t) / 6,\r\n              r = (this._y0 + 4 * this._y1 + n) / 6\r\n            this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r)\r\n            break\r\n          case 3:\r\n            this._point = 4\r\n          default:\r\n            e_(this, t, n)\r\n        }\r\n        ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n)\r\n      }\r\n    }),\r\n    (a_.prototype = {\r\n      lineStart: function () {\r\n        ;(this._x = []), (this._y = []), this._basis.lineStart()\r\n      },\r\n      lineEnd: function () {\r\n        var t = this._x,\r\n          n = this._y,\r\n          e = t.length - 1\r\n        if (e > 0)\r\n          for (var r, i = t[0], o = n[0], a = t[e] - i, u = n[e] - o, c = -1; ++c <= e; )\r\n            (r = c / e),\r\n              this._basis.point(\r\n                this._beta * t[c] + (1 - this._beta) * (i + r * a),\r\n                this._beta * n[c] + (1 - this._beta) * (o + r * u)\r\n              )\r\n        ;(this._x = this._y = null), this._basis.lineEnd()\r\n      },\r\n      point: function (t, n) {\r\n        this._x.push(+t), this._y.push(+n)\r\n      }\r\n    })\r\n  var u_ = (function t (n) {\r\n    function e (t) {\r\n      return 1 === n ? new r_(t) : new a_(t, n)\r\n    }\r\n    return (\r\n      (e.beta = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0.85)\r\n  function c_ (t, n, e) {\r\n    t._context.bezierCurveTo(\r\n      t._x1 + t._k * (t._x2 - t._x0),\r\n      t._y1 + t._k * (t._y2 - t._y0),\r\n      t._x2 + t._k * (t._x1 - n),\r\n      t._y2 + t._k * (t._y1 - e),\r\n      t._x2,\r\n      t._y2\r\n    )\r\n  }\r\n  function f_ (t, n) {\r\n    ;(this._context = t), (this._k = (1 - n) / 6)\r\n  }\r\n  f_.prototype = {\r\n    areaStart: function () {\r\n      this._line = 0\r\n    },\r\n    areaEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      switch (this._point) {\r\n        case 2:\r\n          this._context.lineTo(this._x2, this._y2)\r\n          break\r\n        case 3:\r\n          c_(this, this._x1, this._y1)\r\n      }\r\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\r\n        (this._line = 1 - this._line)\r\n    },\r\n    point: function (t, n) {\r\n      switch (((t = +t), (n = +n), this._point)) {\r\n        case 0:\r\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\r\n          break\r\n        case 1:\r\n          ;(this._point = 2), (this._x1 = t), (this._y1 = n)\r\n          break\r\n        case 2:\r\n          this._point = 3\r\n        default:\r\n          c_(this, t, n)\r\n      }\r\n      ;(this._x0 = this._x1),\r\n        (this._x1 = this._x2),\r\n        (this._x2 = t),\r\n        (this._y0 = this._y1),\r\n        (this._y1 = this._y2),\r\n        (this._y2 = n)\r\n    }\r\n  }\r\n  var s_ = (function t (n) {\r\n    function e (t) {\r\n      return new f_(t, n)\r\n    }\r\n    return (\r\n      (e.tension = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0)\r\n  function l_ (t, n) {\r\n    ;(this._context = t), (this._k = (1 - n) / 6)\r\n  }\r\n  l_.prototype = {\r\n    areaStart: n_,\r\n    areaEnd: n_,\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN),\r\n        (this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      switch (this._point) {\r\n        case 1:\r\n          this._context.moveTo(this._x3, this._y3), this._context.closePath()\r\n          break\r\n        case 2:\r\n          this._context.lineTo(this._x3, this._y3), this._context.closePath()\r\n          break\r\n        case 3:\r\n          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5)\r\n      }\r\n    },\r\n    point: function (t, n) {\r\n      switch (((t = +t), (n = +n), this._point)) {\r\n        case 0:\r\n          ;(this._point = 1), (this._x3 = t), (this._y3 = n)\r\n          break\r\n        case 1:\r\n          ;(this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = n))\r\n          break\r\n        case 2:\r\n          ;(this._point = 3), (this._x5 = t), (this._y5 = n)\r\n          break\r\n        default:\r\n          c_(this, t, n)\r\n      }\r\n      ;(this._x0 = this._x1),\r\n        (this._x1 = this._x2),\r\n        (this._x2 = t),\r\n        (this._y0 = this._y1),\r\n        (this._y1 = this._y2),\r\n        (this._y2 = n)\r\n    }\r\n  }\r\n  var h_ = (function t (n) {\r\n    function e (t) {\r\n      return new l_(t, n)\r\n    }\r\n    return (\r\n      (e.tension = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0)\r\n  function d_ (t, n) {\r\n    ;(this._context = t), (this._k = (1 - n) / 6)\r\n  }\r\n  d_.prototype = {\r\n    areaStart: function () {\r\n      this._line = 0\r\n    },\r\n    areaEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      ;(this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),\r\n        (this._line = 1 - this._line)\r\n    },\r\n    point: function (t, n) {\r\n      switch (((t = +t), (n = +n), this._point)) {\r\n        case 0:\r\n          this._point = 1\r\n          break\r\n        case 1:\r\n          this._point = 2\r\n          break\r\n        case 2:\r\n          ;(this._point = 3),\r\n            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2)\r\n          break\r\n        case 3:\r\n          this._point = 4\r\n        default:\r\n          c_(this, t, n)\r\n      }\r\n      ;(this._x0 = this._x1),\r\n        (this._x1 = this._x2),\r\n        (this._x2 = t),\r\n        (this._y0 = this._y1),\r\n        (this._y1 = this._y2),\r\n        (this._y2 = n)\r\n    }\r\n  }\r\n  var p_ = (function t (n) {\r\n    function e (t) {\r\n      return new d_(t, n)\r\n    }\r\n    return (\r\n      (e.tension = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0)\r\n  function v_ (t, n, e) {\r\n    var r = t._x1,\r\n      i = t._y1,\r\n      o = t._x2,\r\n      a = t._y2\r\n    if (t._l01_a > oy) {\r\n      var u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,\r\n        c = 3 * t._l01_a * (t._l01_a + t._l12_a)\r\n      ;(r = (r * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c),\r\n        (i = (i * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c)\r\n    }\r\n    if (t._l23_a > oy) {\r\n      var f = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,\r\n        s = 3 * t._l23_a * (t._l23_a + t._l12_a)\r\n      ;(o = (o * f + t._x1 * t._l23_2a - n * t._l12_2a) / s), (a = (a * f + t._y1 * t._l23_2a - e * t._l12_2a) / s)\r\n    }\r\n    t._context.bezierCurveTo(r, i, o, a, t._x2, t._y2)\r\n  }\r\n  function g_ (t, n) {\r\n    ;(this._context = t), (this._alpha = n)\r\n  }\r\n  g_.prototype = {\r\n    areaStart: function () {\r\n      this._line = 0\r\n    },\r\n    areaEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),\r\n        (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      switch (this._point) {\r\n        case 2:\r\n          this._context.lineTo(this._x2, this._y2)\r\n          break\r\n        case 3:\r\n          this.point(this._x2, this._y2)\r\n      }\r\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\r\n        (this._line = 1 - this._line)\r\n    },\r\n    point: function (t, n) {\r\n      if (((t = +t), (n = +n), this._point)) {\r\n        var e = this._x2 - t,\r\n          r = this._y2 - n\r\n        this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)))\r\n      }\r\n      switch (this._point) {\r\n        case 0:\r\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\r\n          break\r\n        case 1:\r\n          this._point = 2\r\n          break\r\n        case 2:\r\n          this._point = 3\r\n        default:\r\n          v_(this, t, n)\r\n      }\r\n      ;(this._l01_a = this._l12_a),\r\n        (this._l12_a = this._l23_a),\r\n        (this._l01_2a = this._l12_2a),\r\n        (this._l12_2a = this._l23_2a),\r\n        (this._x0 = this._x1),\r\n        (this._x1 = this._x2),\r\n        (this._x2 = t),\r\n        (this._y0 = this._y1),\r\n        (this._y1 = this._y2),\r\n        (this._y2 = n)\r\n    }\r\n  }\r\n  var y_ = (function t (n) {\r\n    function e (t) {\r\n      return n ? new g_(t, n) : new f_(t, 0)\r\n    }\r\n    return (\r\n      (e.alpha = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0.5)\r\n  function __ (t, n) {\r\n    ;(this._context = t), (this._alpha = n)\r\n  }\r\n  __.prototype = {\r\n    areaStart: n_,\r\n    areaEnd: n_,\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN),\r\n        (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      switch (this._point) {\r\n        case 1:\r\n          this._context.moveTo(this._x3, this._y3), this._context.closePath()\r\n          break\r\n        case 2:\r\n          this._context.lineTo(this._x3, this._y3), this._context.closePath()\r\n          break\r\n        case 3:\r\n          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5)\r\n      }\r\n    },\r\n    point: function (t, n) {\r\n      if (((t = +t), (n = +n), this._point)) {\r\n        var e = this._x2 - t,\r\n          r = this._y2 - n\r\n        this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)))\r\n      }\r\n      switch (this._point) {\r\n        case 0:\r\n          ;(this._point = 1), (this._x3 = t), (this._y3 = n)\r\n          break\r\n        case 1:\r\n          ;(this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = n))\r\n          break\r\n        case 2:\r\n          ;(this._point = 3), (this._x5 = t), (this._y5 = n)\r\n          break\r\n        default:\r\n          v_(this, t, n)\r\n      }\r\n      ;(this._l01_a = this._l12_a),\r\n        (this._l12_a = this._l23_a),\r\n        (this._l01_2a = this._l12_2a),\r\n        (this._l12_2a = this._l23_2a),\r\n        (this._x0 = this._x1),\r\n        (this._x1 = this._x2),\r\n        (this._x2 = t),\r\n        (this._y0 = this._y1),\r\n        (this._y1 = this._y2),\r\n        (this._y2 = n)\r\n    }\r\n  }\r\n  var b_ = (function t (n) {\r\n    function e (t) {\r\n      return n ? new __(t, n) : new l_(t, 0)\r\n    }\r\n    return (\r\n      (e.alpha = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0.5)\r\n  function m_ (t, n) {\r\n    ;(this._context = t), (this._alpha = n)\r\n  }\r\n  m_.prototype = {\r\n    areaStart: function () {\r\n      this._line = 0\r\n    },\r\n    areaEnd: function () {\r\n      this._line = NaN\r\n    },\r\n    lineStart: function () {\r\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),\r\n        (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)\r\n    },\r\n    lineEnd: function () {\r\n      ;(this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),\r\n        (this._line = 1 - this._line)\r\n    },\r\n    point: function (t, n) {\r\n      if (((t = +t), (n = +n), this._point)) {\r\n        var e = this._x2 - t,\r\n          r = this._y2 - n\r\n        this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)))\r\n      }\r\n      switch (this._point) {\r\n        case 0:\r\n          this._point = 1\r\n          break\r\n        case 1:\r\n          this._point = 2\r\n          break\r\n        case 2:\r\n          ;(this._point = 3),\r\n            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2)\r\n          break\r\n        case 3:\r\n          this._point = 4\r\n        default:\r\n          v_(this, t, n)\r\n      }\r\n      ;(this._l01_a = this._l12_a),\r\n        (this._l12_a = this._l23_a),\r\n        (this._l01_2a = this._l12_2a),\r\n        (this._l12_2a = this._l23_2a),\r\n        (this._x0 = this._x1),\r\n        (this._x1 = this._x2),\r\n        (this._x2 = t),\r\n        (this._y0 = this._y1),\r\n        (this._y1 = this._y2),\r\n        (this._y2 = n)\r\n    }\r\n  }\r\n  var x_ = (function t (n) {\r\n    function e (t) {\r\n      return n ? new m_(t, n) : new d_(t, 0)\r\n    }\r\n    return (\r\n      (e.alpha = function (n) {\r\n        return t(+n)\r\n      }),\r\n      e\r\n    )\r\n  })(0.5)\r\n  function w_ (t) {\r\n    this._context = t\r\n  }\r\n  function M_ (t) {\r\n    return t < 0 ? -1 : 1\r\n  }\r\n  function N_ (t, n, e) {\r\n    var r = t._x1 - t._x0,\r\n      i = n - t._x1,\r\n      o = (t._y1 - t._y0) / (r || (i < 0 && -0)),\r\n      a = (e - t._y1) / (i || (r < 0 && -0)),\r\n      u = (o * i + a * r) / (r + i)\r\n    return (M_(o) + M_(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(u)) || 0\r\n  }\r\n  function A_ (t, n) {\r\n    var e = t._x1 - t._x0\r\n    return e ? ((3 * (t._y1 - t._y0)) / e - n) / 2 : n\r\n  }\r\n  function S_ (t, n, e) {\r\n    var r = t._x0,\r\n      i = t._y0,\r\n      o = t._x1,\r\n      a = t._y1,\r\n      u = (o - r) / 3\r\n    t._context.bezierCurveTo(r + u, i + u * n, o - u, a - u * e, o, a)\r\n  }\r\n  function k_ (t) {\r\n    this._context = t\r\n  }\r\n  function T_ (t) {\r\n    this._context = new E_(t)\r\n  }\r\n  function E_ (t) {\r\n    this._context = t\r\n  }\r\n  function C_ (t) {\r\n    this._context = t\r\n  }\r\n  function P_ (t) {\r\n    var n,\r\n      e,\r\n      r = t.length - 1,\r\n      i = new Array(r),\r\n      o = new Array(r),\r\n      a = new Array(r)\r\n    for (i[0] = 0, o[0] = 2, a[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n)\r\n      (i[n] = 1), (o[n] = 4), (a[n] = 4 * t[n] + 2 * t[n + 1])\r\n    for (i[r - 1] = 2, o[r - 1] = 7, a[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n)\r\n      (e = i[n] / o[n - 1]), (o[n] -= e), (a[n] -= e * a[n - 1])\r\n    for (i[r - 1] = a[r - 1] / o[r - 1], n = r - 2; n >= 0; --n) i[n] = (a[n] - i[n + 1]) / o[n]\r\n    for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n) o[n] = 2 * t[n + 1] - i[n + 1]\r\n    return [i, o]\r\n  }\r\n  function z_ (t, n) {\r\n    ;(this._context = t), (this._t = n)\r\n  }\r\n  function R_ (t, n) {\r\n    if ((i = t.length) > 1)\r\n      for (var e, r, i, o = 1, a = t[n[0]], u = a.length; o < i; ++o)\r\n        for (r = a, a = t[n[o]], e = 0; e < u; ++e) a[e][1] += a[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1]\r\n  }\r\n  function D_ (t) {\r\n    for (var n = t.length, e = new Array(n); --n >= 0; ) e[n] = n\r\n    return e\r\n  }\r\n  function q_ (t, n) {\r\n    return t[n]\r\n  }\r\n  function L_ (t) {\r\n    var n = t.map(U_)\r\n    return D_(t).sort(function (t, e) {\r\n      return n[t] - n[e]\r\n    })\r\n  }\r\n  function U_ (t) {\r\n    for (var n, e = -1, r = 0, i = t.length, o = -1 / 0; ++e < i; ) (n = +t[e][1]) > o && ((o = n), (r = e))\r\n    return r\r\n  }\r\n  function O_ (t) {\r\n    var n = t.map(B_)\r\n    return D_(t).sort(function (t, e) {\r\n      return n[t] - n[e]\r\n    })\r\n  }\r\n  function B_ (t) {\r\n    for (var n, e = 0, r = -1, i = t.length; ++r < i; ) (n = +t[r][1]) && (e += n)\r\n    return e\r\n  }\r\n  function Y_ (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function F_ (t) {\r\n    return t[0]\r\n  }\r\n  function I_ (t) {\r\n    return t[1]\r\n  }\r\n  function j_ () {\r\n    this._ = null\r\n  }\r\n  function H_ (t) {\r\n    t.U = t.C = t.L = t.R = t.P = t.N = null\r\n  }\r\n  function X_ (t, n) {\r\n    var e = n,\r\n      r = n.R,\r\n      i = e.U\r\n    i ? (i.L === e ? (i.L = r) : (i.R = r)) : (t._ = r),\r\n      (r.U = i),\r\n      (e.U = r),\r\n      (e.R = r.L),\r\n      e.R && (e.R.U = e),\r\n      (r.L = e)\r\n  }\r\n  function G_ (t, n) {\r\n    var e = n,\r\n      r = n.L,\r\n      i = e.U\r\n    i ? (i.L === e ? (i.L = r) : (i.R = r)) : (t._ = r),\r\n      (r.U = i),\r\n      (e.U = r),\r\n      (e.L = r.R),\r\n      e.L && (e.L.U = e),\r\n      (r.R = e)\r\n  }\r\n  function V_ (t) {\r\n    for (; t.L; ) t = t.L\r\n    return t\r\n  }\r\n  function $_ (t, n, e, r) {\r\n    var i = [null, null],\r\n      o = _b.push(i) - 1\r\n    return (\r\n      (i.left = t),\r\n      (i.right = n),\r\n      e && Z_(i, t, n, e),\r\n      r && Z_(i, n, t, r),\r\n      gb[t.index].halfedges.push(o),\r\n      gb[n.index].halfedges.push(o),\r\n      i\r\n    )\r\n  }\r\n  function W_ (t, n, e) {\r\n    var r = [n, e]\r\n    return (r.left = t), r\r\n  }\r\n  function Z_ (t, n, e, r) {\r\n    t[0] || t[1] ? (t.left === e ? (t[1] = r) : (t[0] = r)) : ((t[0] = r), (t.left = n), (t.right = e))\r\n  }\r\n  function Q_ (t, n, e, r, i) {\r\n    var o,\r\n      a = t[0],\r\n      u = t[1],\r\n      c = a[0],\r\n      f = a[1],\r\n      s = 0,\r\n      l = 1,\r\n      h = u[0] - c,\r\n      d = u[1] - f\r\n    if (((o = n - c), h || !(o > 0))) {\r\n      if (((o /= h), h < 0)) {\r\n        if (o < s) return\r\n        o < l && (l = o)\r\n      } else if (h > 0) {\r\n        if (o > l) return\r\n        o > s && (s = o)\r\n      }\r\n      if (((o = r - c), h || !(o < 0))) {\r\n        if (((o /= h), h < 0)) {\r\n          if (o > l) return\r\n          o > s && (s = o)\r\n        } else if (h > 0) {\r\n          if (o < s) return\r\n          o < l && (l = o)\r\n        }\r\n        if (((o = e - f), d || !(o > 0))) {\r\n          if (((o /= d), d < 0)) {\r\n            if (o < s) return\r\n            o < l && (l = o)\r\n          } else if (d > 0) {\r\n            if (o > l) return\r\n            o > s && (s = o)\r\n          }\r\n          if (((o = i - f), d || !(o < 0))) {\r\n            if (((o /= d), d < 0)) {\r\n              if (o > l) return\r\n              o > s && (s = o)\r\n            } else if (d > 0) {\r\n              if (o < s) return\r\n              o < l && (l = o)\r\n            }\r\n            return (\r\n              !(s > 0 || l < 1) ||\r\n              (s > 0 && (t[0] = [c + s * h, f + s * d]), l < 1 && (t[1] = [c + l * h, f + l * d]), !0)\r\n            )\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function J_ (t, n, e, r, i) {\r\n    var o = t[1]\r\n    if (o) return !0\r\n    var a,\r\n      u,\r\n      c = t[0],\r\n      f = t.left,\r\n      s = t.right,\r\n      l = f[0],\r\n      h = f[1],\r\n      d = s[0],\r\n      p = s[1],\r\n      v = (l + d) / 2,\r\n      g = (h + p) / 2\r\n    if (p === h) {\r\n      if (v < n || v >= r) return\r\n      if (l > d) {\r\n        if (c) {\r\n          if (c[1] >= i) return\r\n        } else c = [v, e]\r\n        o = [v, i]\r\n      } else {\r\n        if (c) {\r\n          if (c[1] < e) return\r\n        } else c = [v, i]\r\n        o = [v, e]\r\n      }\r\n    } else if (((u = g - (a = (l - d) / (p - h)) * v), a < -1 || a > 1))\r\n      if (l > d) {\r\n        if (c) {\r\n          if (c[1] >= i) return\r\n        } else c = [(e - u) / a, e]\r\n        o = [(i - u) / a, i]\r\n      } else {\r\n        if (c) {\r\n          if (c[1] < e) return\r\n        } else c = [(i - u) / a, i]\r\n        o = [(e - u) / a, e]\r\n      }\r\n    else if (h < p) {\r\n      if (c) {\r\n        if (c[0] >= r) return\r\n      } else c = [n, a * n + u]\r\n      o = [r, a * r + u]\r\n    } else {\r\n      if (c) {\r\n        if (c[0] < n) return\r\n      } else c = [r, a * r + u]\r\n      o = [n, a * n + u]\r\n    }\r\n    return (t[0] = c), (t[1] = o), !0\r\n  }\r\n  function K_ (t, n) {\r\n    var e = t.site,\r\n      r = n.left,\r\n      i = n.right\r\n    return (\r\n      e === i && ((i = r), (r = e)),\r\n      i\r\n        ? Math.atan2(i[1] - r[1], i[0] - r[0])\r\n        : (e === r ? ((r = n[1]), (i = n[0])) : ((r = n[0]), (i = n[1])), Math.atan2(r[0] - i[0], i[1] - r[1]))\r\n    )\r\n  }\r\n  function tb (t, n) {\r\n    return n[+(n.left !== t.site)]\r\n  }\r\n  function nb (t, n) {\r\n    return n[+(n.left === t.site)]\r\n  }\r\n  ;(w_.prototype = {\r\n    areaStart: n_,\r\n    areaEnd: n_,\r\n    lineStart: function () {\r\n      this._point = 0\r\n    },\r\n    lineEnd: function () {\r\n      this._point && this._context.closePath()\r\n    },\r\n    point: function (t, n) {\r\n      ;(t = +t), (n = +n), this._point ? this._context.lineTo(t, n) : ((this._point = 1), this._context.moveTo(t, n))\r\n    }\r\n  }),\r\n    (k_.prototype = {\r\n      areaStart: function () {\r\n        this._line = 0\r\n      },\r\n      areaEnd: function () {\r\n        this._line = NaN\r\n      },\r\n      lineStart: function () {\r\n        ;(this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN), (this._point = 0)\r\n      },\r\n      lineEnd: function () {\r\n        switch (this._point) {\r\n          case 2:\r\n            this._context.lineTo(this._x1, this._y1)\r\n            break\r\n          case 3:\r\n            S_(this, this._t0, A_(this, this._t0))\r\n        }\r\n        ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\r\n          (this._line = 1 - this._line)\r\n      },\r\n      point: function (t, n) {\r\n        var e = NaN\r\n        if (((n = +n), (t = +t) !== this._x1 || n !== this._y1)) {\r\n          switch (this._point) {\r\n            case 0:\r\n              ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\r\n              break\r\n            case 1:\r\n              this._point = 2\r\n              break\r\n            case 2:\r\n              ;(this._point = 3), S_(this, A_(this, (e = N_(this, t, n))), e)\r\n              break\r\n            default:\r\n              S_(this, this._t0, (e = N_(this, t, n)))\r\n          }\r\n          ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n), (this._t0 = e)\r\n        }\r\n      }\r\n    }),\r\n    ((T_.prototype = Object.create(k_.prototype)).point = function (t, n) {\r\n      k_.prototype.point.call(this, n, t)\r\n    }),\r\n    (E_.prototype = {\r\n      moveTo: function (t, n) {\r\n        this._context.moveTo(n, t)\r\n      },\r\n      closePath: function () {\r\n        this._context.closePath()\r\n      },\r\n      lineTo: function (t, n) {\r\n        this._context.lineTo(n, t)\r\n      },\r\n      bezierCurveTo: function (t, n, e, r, i, o) {\r\n        this._context.bezierCurveTo(n, t, r, e, o, i)\r\n      }\r\n    }),\r\n    (C_.prototype = {\r\n      areaStart: function () {\r\n        this._line = 0\r\n      },\r\n      areaEnd: function () {\r\n        this._line = NaN\r\n      },\r\n      lineStart: function () {\r\n        ;(this._x = []), (this._y = [])\r\n      },\r\n      lineEnd: function () {\r\n        var t = this._x,\r\n          n = this._y,\r\n          e = t.length\r\n        if (e)\r\n          if ((this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e))\r\n            this._context.lineTo(t[1], n[1])\r\n          else\r\n            for (var r = P_(t), i = P_(n), o = 0, a = 1; a < e; ++o, ++a)\r\n              this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[a], n[a])\r\n        ;(this._line || (0 !== this._line && 1 === e)) && this._context.closePath(),\r\n          (this._line = 1 - this._line),\r\n          (this._x = this._y = null)\r\n      },\r\n      point: function (t, n) {\r\n        this._x.push(+t), this._y.push(+n)\r\n      }\r\n    }),\r\n    (z_.prototype = {\r\n      areaStart: function () {\r\n        this._line = 0\r\n      },\r\n      areaEnd: function () {\r\n        this._line = NaN\r\n      },\r\n      lineStart: function () {\r\n        ;(this._x = this._y = NaN), (this._point = 0)\r\n      },\r\n      lineEnd: function () {\r\n        0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y),\r\n          (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\r\n          this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line))\r\n      },\r\n      point: function (t, n) {\r\n        switch (((t = +t), (n = +n), this._point)) {\r\n          case 0:\r\n            ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\r\n            break\r\n          case 1:\r\n            this._point = 2\r\n          default:\r\n            if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n)\r\n            else {\r\n              var e = this._x * (1 - this._t) + t * this._t\r\n              this._context.lineTo(e, this._y), this._context.lineTo(e, n)\r\n            }\r\n        }\r\n        ;(this._x = t), (this._y = n)\r\n      }\r\n    }),\r\n    (j_.prototype = {\r\n      constructor: j_,\r\n      insert: function (t, n) {\r\n        var e, r, i\r\n        if (t) {\r\n          if (((n.P = t), (n.N = t.N), t.N && (t.N.P = n), (t.N = n), t.R)) {\r\n            for (t = t.R; t.L; ) t = t.L\r\n            t.L = n\r\n          } else t.R = n\r\n          e = t\r\n        } else\r\n          this._\r\n            ? ((t = V_(this._)), (n.P = null), (n.N = t), (t.P = t.L = n), (e = t))\r\n            : ((n.P = n.N = null), (this._ = n), (e = null))\r\n        for (n.L = n.R = null, n.U = e, n.C = !0, t = n; e && e.C; )\r\n          e === (r = e.U).L\r\n            ? (i = r.R) && i.C\r\n              ? ((e.C = i.C = !1), (r.C = !0), (t = r))\r\n              : (t === e.R && (X_(this, e), (e = (t = e).U)), (e.C = !1), (r.C = !0), G_(this, r))\r\n            : (i = r.L) && i.C\r\n            ? ((e.C = i.C = !1), (r.C = !0), (t = r))\r\n            : (t === e.L && (G_(this, e), (e = (t = e).U)), (e.C = !1), (r.C = !0), X_(this, r)),\r\n            (e = t.U)\r\n        this._.C = !1\r\n      },\r\n      remove: function (t) {\r\n        t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), (t.N = t.P = null)\r\n        var n,\r\n          e,\r\n          r,\r\n          i = t.U,\r\n          o = t.L,\r\n          a = t.R\r\n        if (\r\n          ((e = o ? (a ? V_(a) : o) : a),\r\n          i ? (i.L === t ? (i.L = e) : (i.R = e)) : (this._ = e),\r\n          o && a\r\n            ? ((r = e.C),\r\n              (e.C = t.C),\r\n              (e.L = o),\r\n              (o.U = e),\r\n              e !== a\r\n                ? ((i = e.U), (e.U = t.U), (t = e.R), (i.L = t), (e.R = a), (a.U = e))\r\n                : ((e.U = i), (i = e), (t = e.R)))\r\n            : ((r = t.C), (t = e)),\r\n          t && (t.U = i),\r\n          !r)\r\n        )\r\n          if (t && t.C) t.C = !1\r\n          else {\r\n            do {\r\n              if (t === this._) break\r\n              if (t === i.L) {\r\n                if (\r\n                  ((n = i.R).C && ((n.C = !1), (i.C = !0), X_(this, i), (n = i.R)), (n.L && n.L.C) || (n.R && n.R.C))\r\n                ) {\r\n                  ;(n.R && n.R.C) || ((n.L.C = !1), (n.C = !0), G_(this, n), (n = i.R)),\r\n                    (n.C = i.C),\r\n                    (i.C = n.R.C = !1),\r\n                    X_(this, i),\r\n                    (t = this._)\r\n                  break\r\n                }\r\n              } else if (\r\n                ((n = i.L).C && ((n.C = !1), (i.C = !0), G_(this, i), (n = i.L)), (n.L && n.L.C) || (n.R && n.R.C))\r\n              ) {\r\n                ;(n.L && n.L.C) || ((n.R.C = !1), (n.C = !0), X_(this, n), (n = i.L)),\r\n                  (n.C = i.C),\r\n                  (i.C = n.L.C = !1),\r\n                  G_(this, i),\r\n                  (t = this._)\r\n                break\r\n              }\r\n              ;(n.C = !0), (t = i), (i = i.U)\r\n            } while (!t.C)\r\n            t && (t.C = !1)\r\n          }\r\n      }\r\n    })\r\n  var eb,\r\n    rb = []\r\n  function ib () {\r\n    H_(this), (this.x = this.y = this.arc = this.site = this.cy = null)\r\n  }\r\n  function ob (t) {\r\n    var n = t.P,\r\n      e = t.N\r\n    if (n && e) {\r\n      var r = n.site,\r\n        i = t.site,\r\n        o = e.site\r\n      if (r !== o) {\r\n        var a = i[0],\r\n          u = i[1],\r\n          c = r[0] - a,\r\n          f = r[1] - u,\r\n          s = o[0] - a,\r\n          l = o[1] - u,\r\n          h = 2 * (c * l - f * s)\r\n        if (!(h >= -mb)) {\r\n          var d = c * c + f * f,\r\n            p = s * s + l * l,\r\n            v = (l * d - f * p) / h,\r\n            g = (c * p - s * d) / h,\r\n            y = rb.pop() || new ib()\r\n          ;(y.arc = t), (y.site = i), (y.x = v + a), (y.y = (y.cy = g + u) + Math.sqrt(v * v + g * g)), (t.circle = y)\r\n          for (var _ = null, b = yb._; b; )\r\n            if (y.y < b.y || (y.y === b.y && y.x <= b.x)) {\r\n              if (!b.L) {\r\n                _ = b.P\r\n                break\r\n              }\r\n              b = b.L\r\n            } else {\r\n              if (!b.R) {\r\n                _ = b\r\n                break\r\n              }\r\n              b = b.R\r\n            }\r\n          yb.insert(_, y), _ || (eb = y)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  function ab (t) {\r\n    var n = t.circle\r\n    n && (n.P || (eb = n.N), yb.remove(n), rb.push(n), H_(n), (t.circle = null))\r\n  }\r\n  var ub = []\r\n  function cb () {\r\n    H_(this), (this.edge = this.site = this.circle = null)\r\n  }\r\n  function fb (t) {\r\n    var n = ub.pop() || new cb()\r\n    return (n.site = t), n\r\n  }\r\n  function sb (t) {\r\n    ab(t), vb.remove(t), ub.push(t), H_(t)\r\n  }\r\n  function lb (t) {\r\n    var n = t.circle,\r\n      e = n.x,\r\n      r = n.cy,\r\n      i = [e, r],\r\n      o = t.P,\r\n      a = t.N,\r\n      u = [t]\r\n    sb(t)\r\n    for (var c = o; c.circle && Math.abs(e - c.circle.x) < bb && Math.abs(r - c.circle.cy) < bb; )\r\n      (o = c.P), u.unshift(c), sb(c), (c = o)\r\n    u.unshift(c), ab(c)\r\n    for (var f = a; f.circle && Math.abs(e - f.circle.x) < bb && Math.abs(r - f.circle.cy) < bb; )\r\n      (a = f.N), u.push(f), sb(f), (f = a)\r\n    u.push(f), ab(f)\r\n    var s,\r\n      l = u.length\r\n    for (s = 1; s < l; ++s) (f = u[s]), (c = u[s - 1]), Z_(f.edge, c.site, f.site, i)\r\n    ;(c = u[0]), ((f = u[l - 1]).edge = $_(c.site, f.site, null, i)), ob(c), ob(f)\r\n  }\r\n  function hb (t) {\r\n    for (var n, e, r, i, o = t[0], a = t[1], u = vb._; u; )\r\n      if ((r = db(u, a) - o) > bb) u = u.L\r\n      else {\r\n        if (!((i = o - pb(u, a)) > bb)) {\r\n          r > -bb ? ((n = u.P), (e = u)) : i > -bb ? ((n = u), (e = u.N)) : (n = e = u)\r\n          break\r\n        }\r\n        if (!u.R) {\r\n          n = u\r\n          break\r\n        }\r\n        u = u.R\r\n      }\r\n    !(function (t) {\r\n      gb[t.index] = { site: t, halfedges: [] }\r\n    })(t)\r\n    var c = fb(t)\r\n    if ((vb.insert(n, c), n || e)) {\r\n      if (n === e)\r\n        return ab(n), (e = fb(n.site)), vb.insert(c, e), (c.edge = e.edge = $_(n.site, c.site)), ob(n), void ob(e)\r\n      if (e) {\r\n        ab(n), ab(e)\r\n        var f = n.site,\r\n          s = f[0],\r\n          l = f[1],\r\n          h = t[0] - s,\r\n          d = t[1] - l,\r\n          p = e.site,\r\n          v = p[0] - s,\r\n          g = p[1] - l,\r\n          y = 2 * (h * g - d * v),\r\n          _ = h * h + d * d,\r\n          b = v * v + g * g,\r\n          m = [(g * _ - d * b) / y + s, (h * b - v * _) / y + l]\r\n        Z_(e.edge, f, p, m), (c.edge = $_(f, t, null, m)), (e.edge = $_(t, p, null, m)), ob(n), ob(e)\r\n      } else c.edge = $_(n.site, c.site)\r\n    }\r\n  }\r\n  function db (t, n) {\r\n    var e = t.site,\r\n      r = e[0],\r\n      i = e[1],\r\n      o = i - n\r\n    if (!o) return r\r\n    var a = t.P\r\n    if (!a) return -1 / 0\r\n    var u = (e = a.site)[0],\r\n      c = e[1],\r\n      f = c - n\r\n    if (!f) return u\r\n    var s = u - r,\r\n      l = 1 / o - 1 / f,\r\n      h = s / f\r\n    return l ? (-h + Math.sqrt(h * h - 2 * l * ((s * s) / (-2 * f) - c + f / 2 + i - o / 2))) / l + r : (r + u) / 2\r\n  }\r\n  function pb (t, n) {\r\n    var e = t.N\r\n    if (e) return db(e, n)\r\n    var r = t.site\r\n    return r[1] === n ? r[0] : 1 / 0\r\n  }\r\n  var vb,\r\n    gb,\r\n    yb,\r\n    _b,\r\n    bb = 1e-6,\r\n    mb = 1e-12\r\n  function xb (t, n) {\r\n    return n[1] - t[1] || n[0] - t[0]\r\n  }\r\n  function wb (t, n) {\r\n    var e,\r\n      r,\r\n      i,\r\n      o = t.sort(xb).pop()\r\n    for (_b = [], gb = new Array(t.length), vb = new j_(), yb = new j_(); ; )\r\n      if (((i = eb), o && (!i || o[1] < i.y || (o[1] === i.y && o[0] < i.x))))\r\n        (o[0] === e && o[1] === r) || (hb(o), (e = o[0]), (r = o[1])), (o = t.pop())\r\n      else {\r\n        if (!i) break\r\n        lb(i.arc)\r\n      }\r\n    if (\r\n      ((function () {\r\n        for (var t, n, e, r, i = 0, o = gb.length; i < o; ++i)\r\n          if ((t = gb[i]) && (r = (n = t.halfedges).length)) {\r\n            var a = new Array(r),\r\n              u = new Array(r)\r\n            for (e = 0; e < r; ++e) (a[e] = e), (u[e] = K_(t, _b[n[e]]))\r\n            for (\r\n              a.sort(function (t, n) {\r\n                return u[n] - u[t]\r\n              }),\r\n                e = 0;\r\n              e < r;\r\n              ++e\r\n            )\r\n              u[e] = n[a[e]]\r\n            for (e = 0; e < r; ++e) n[e] = u[e]\r\n          }\r\n      })(),\r\n      n)\r\n    ) {\r\n      var a = +n[0][0],\r\n        u = +n[0][1],\r\n        c = +n[1][0],\r\n        f = +n[1][1]\r\n      !(function (t, n, e, r) {\r\n        for (var i, o = _b.length; o--; )\r\n          (J_((i = _b[o]), t, n, e, r) &&\r\n            Q_(i, t, n, e, r) &&\r\n            (Math.abs(i[0][0] - i[1][0]) > bb || Math.abs(i[0][1] - i[1][1]) > bb)) ||\r\n            delete _b[o]\r\n      })(a, u, c, f),\r\n        (function (t, n, e, r) {\r\n          var i,\r\n            o,\r\n            a,\r\n            u,\r\n            c,\r\n            f,\r\n            s,\r\n            l,\r\n            h,\r\n            d,\r\n            p,\r\n            v,\r\n            g = gb.length,\r\n            y = !0\r\n          for (i = 0; i < g; ++i)\r\n            if ((o = gb[i])) {\r\n              for (a = o.site, u = (c = o.halfedges).length; u--; ) _b[c[u]] || c.splice(u, 1)\r\n              for (u = 0, f = c.length; u < f; )\r\n                (p = (d = nb(o, _b[c[u]]))[0]),\r\n                  (v = d[1]),\r\n                  (l = (s = tb(o, _b[c[++u % f]]))[0]),\r\n                  (h = s[1]),\r\n                  (Math.abs(p - l) > bb || Math.abs(v - h) > bb) &&\r\n                    (c.splice(\r\n                      u,\r\n                      0,\r\n                      _b.push(\r\n                        W_(\r\n                          a,\r\n                          d,\r\n                          Math.abs(p - t) < bb && r - v > bb\r\n                            ? [t, Math.abs(l - t) < bb ? h : r]\r\n                            : Math.abs(v - r) < bb && e - p > bb\r\n                            ? [Math.abs(h - r) < bb ? l : e, r]\r\n                            : Math.abs(p - e) < bb && v - n > bb\r\n                            ? [e, Math.abs(l - e) < bb ? h : n]\r\n                            : Math.abs(v - n) < bb && p - t > bb\r\n                            ? [Math.abs(h - n) < bb ? l : t, n]\r\n                            : null\r\n                        )\r\n                      ) - 1\r\n                    ),\r\n                    ++f)\r\n              f && (y = !1)\r\n            }\r\n          if (y) {\r\n            var _,\r\n              b,\r\n              m,\r\n              x = 1 / 0\r\n            for (i = 0, y = null; i < g; ++i)\r\n              (o = gb[i]) && (m = (_ = (a = o.site)[0] - t) * _ + (b = a[1] - n) * b) < x && ((x = m), (y = o))\r\n            if (y) {\r\n              var w = [t, n],\r\n                M = [t, r],\r\n                N = [e, r],\r\n                A = [e, n]\r\n              y.halfedges.push(\r\n                _b.push(W_((a = y.site), w, M)) - 1,\r\n                _b.push(W_(a, M, N)) - 1,\r\n                _b.push(W_(a, N, A)) - 1,\r\n                _b.push(W_(a, A, w)) - 1\r\n              )\r\n            }\r\n          }\r\n          for (i = 0; i < g; ++i) (o = gb[i]) && (o.halfedges.length || delete gb[i])\r\n        })(a, u, c, f)\r\n    }\r\n    ;(this.edges = _b), (this.cells = gb), (vb = yb = _b = gb = null)\r\n  }\r\n  function Mb (t) {\r\n    return function () {\r\n      return t\r\n    }\r\n  }\r\n  function Nb (t, n, e) {\r\n    ;(this.target = t), (this.type = n), (this.transform = e)\r\n  }\r\n  function Ab (t, n, e) {\r\n    ;(this.k = t), (this.x = n), (this.y = e)\r\n  }\r\n  ;(wb.prototype = {\r\n    constructor: wb,\r\n    polygons: function () {\r\n      var t = this.edges\r\n      return this.cells.map(function (n) {\r\n        var e = n.halfedges.map(function (e) {\r\n          return tb(n, t[e])\r\n        })\r\n        return (e.data = n.site.data), e\r\n      })\r\n    },\r\n    triangles: function () {\r\n      var t = [],\r\n        n = this.edges\r\n      return (\r\n        this.cells.forEach(function (e, r) {\r\n          if ((o = (i = e.halfedges).length))\r\n            for (\r\n              var i, o, a, u, c, f, s = e.site, l = -1, h = n[i[o - 1]], d = h.left === s ? h.right : h.left;\r\n              ++l < o;\r\n\r\n            )\r\n              (a = d),\r\n                (d = (h = n[i[l]]).left === s ? h.right : h.left),\r\n                a &&\r\n                  d &&\r\n                  r < a.index &&\r\n                  r < d.index &&\r\n                  ((c = a), (f = d), ((u = s)[0] - f[0]) * (c[1] - u[1]) - (u[0] - c[0]) * (f[1] - u[1]) < 0) &&\r\n                  t.push([s.data, a.data, d.data])\r\n        }),\r\n        t\r\n      )\r\n    },\r\n    links: function () {\r\n      return this.edges\r\n        .filter(function (t) {\r\n          return t.right\r\n        })\r\n        .map(function (t) {\r\n          return { source: t.left.data, target: t.right.data }\r\n        })\r\n    },\r\n    find: function (t, n, e) {\r\n      for (var r, i, o = this, a = o._found || 0, u = o.cells.length; !(i = o.cells[a]); ) if (++a >= u) return null\r\n      var c = t - i.site[0],\r\n        f = n - i.site[1],\r\n        s = c * c + f * f\r\n      do {\r\n        ;(i = o.cells[(r = a)]),\r\n          (a = null),\r\n          i.halfedges.forEach(function (e) {\r\n            var r = o.edges[e],\r\n              u = r.left\r\n            if ((u !== i.site && u) || (u = r.right)) {\r\n              var c = t - u[0],\r\n                f = n - u[1],\r\n                l = c * c + f * f\r\n              l < s && ((s = l), (a = u.index))\r\n            }\r\n          })\r\n      } while (null !== a)\r\n      return (o._found = r), null == e || s <= e * e ? i.site : null\r\n    }\r\n  }),\r\n    (Ab.prototype = {\r\n      constructor: Ab,\r\n      scale: function (t) {\r\n        return 1 === t ? this : new Ab(this.k * t, this.x, this.y)\r\n      },\r\n      translate: function (t, n) {\r\n        return (0 === t) & (0 === n) ? this : new Ab(this.k, this.x + this.k * t, this.y + this.k * n)\r\n      },\r\n      apply: function (t) {\r\n        return [t[0] * this.k + this.x, t[1] * this.k + this.y]\r\n      },\r\n      applyX: function (t) {\r\n        return t * this.k + this.x\r\n      },\r\n      applyY: function (t) {\r\n        return t * this.k + this.y\r\n      },\r\n      invert: function (t) {\r\n        return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k]\r\n      },\r\n      invertX: function (t) {\r\n        return (t - this.x) / this.k\r\n      },\r\n      invertY: function (t) {\r\n        return (t - this.y) / this.k\r\n      },\r\n      rescaleX: function (t) {\r\n        return t.copy().domain(\r\n          t\r\n            .range()\r\n            .map(this.invertX, this)\r\n            .map(t.invert, t)\r\n        )\r\n      },\r\n      rescaleY: function (t) {\r\n        return t.copy().domain(\r\n          t\r\n            .range()\r\n            .map(this.invertY, this)\r\n            .map(t.invert, t)\r\n        )\r\n      },\r\n      toString: function () {\r\n        return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'\r\n      }\r\n    })\r\n  var Sb = new Ab(1, 0, 0)\r\n  function kb (t) {\r\n    return t.__zoom || Sb\r\n  }\r\n  function Tb () {\r\n    t.event.stopImmediatePropagation()\r\n  }\r\n  function Eb () {\r\n    t.event.preventDefault(), t.event.stopImmediatePropagation()\r\n  }\r\n  function Cb () {\r\n    return !t.event.button\r\n  }\r\n  function Pb () {\r\n    var t,\r\n      n,\r\n      e = this\r\n    return (\r\n      e instanceof SVGElement\r\n        ? ((t = (e = e.ownerSVGElement || e).width.baseVal.value), (n = e.height.baseVal.value))\r\n        : ((t = e.clientWidth), (n = e.clientHeight)),\r\n      [[0, 0], [t, n]]\r\n    )\r\n  }\r\n  function zb () {\r\n    return this.__zoom || Sb\r\n  }\r\n  function Rb () {\r\n    return (-t.event.deltaY * (t.event.deltaMode ? 120 : 1)) / 500\r\n  }\r\n  function Db () {\r\n    return 'ontouchstart' in this\r\n  }\r\n  function qb (t, n, e) {\r\n    var r = t.invertX(n[0][0]) - e[0][0],\r\n      i = t.invertX(n[1][0]) - e[1][0],\r\n      o = t.invertY(n[0][1]) - e[0][1],\r\n      a = t.invertY(n[1][1]) - e[1][1]\r\n    return t.translate(\r\n      i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),\r\n      a > o ? (o + a) / 2 : Math.min(0, o) || Math.max(0, a)\r\n    )\r\n  }\r\n  ;(kb.prototype = Ab.prototype),\r\n    (t.version = '5.9.0'),\r\n    (t.bisect = i),\r\n    (t.bisectRight = i),\r\n    (t.bisectLeft = o),\r\n    (t.ascending = n),\r\n    (t.bisector = e),\r\n    (t.cross = function (t, n, e) {\r\n      var r,\r\n        i,\r\n        o,\r\n        u,\r\n        c = t.length,\r\n        f = n.length,\r\n        s = new Array(c * f)\r\n      for (null == e && (e = a), r = o = 0; r < c; ++r) for (u = t[r], i = 0; i < f; ++i, ++o) s[o] = e(u, n[i])\r\n      return s\r\n    }),\r\n    (t.descending = function (t, n) {\r\n      return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN\r\n    }),\r\n    (t.deviation = f),\r\n    (t.extent = s),\r\n    (t.histogram = function () {\r\n      var t = v,\r\n        n = s,\r\n        e = M\r\n      function r (r) {\r\n        var o,\r\n          a,\r\n          u = r.length,\r\n          c = new Array(u)\r\n        for (o = 0; o < u; ++o) c[o] = t(r[o], o, r)\r\n        var f = n(c),\r\n          s = f[0],\r\n          l = f[1],\r\n          h = e(c, s, l)\r\n        Array.isArray(h) || ((h = w(s, l, h)), (h = g(Math.ceil(s / h) * h, l, h)))\r\n        for (var d = h.length; h[0] <= s; ) h.shift(), --d\r\n        for (; h[d - 1] > l; ) h.pop(), --d\r\n        var p,\r\n          v = new Array(d + 1)\r\n        for (o = 0; o <= d; ++o) ((p = v[o] = []).x0 = o > 0 ? h[o - 1] : s), (p.x1 = o < d ? h[o] : l)\r\n        for (o = 0; o < u; ++o) s <= (a = c[o]) && a <= l && v[i(h, a, 0, d)].push(r[o])\r\n        return v\r\n      }\r\n      return (\r\n        (r.value = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : p(n)), r) : t\r\n        }),\r\n        (r.domain = function (t) {\r\n          return arguments.length ? ((n = 'function' == typeof t ? t : p([t[0], t[1]])), r) : n\r\n        }),\r\n        (r.thresholds = function (t) {\r\n          return arguments.length ? ((e = 'function' == typeof t ? t : Array.isArray(t) ? p(h.call(t)) : p(t)), r) : e\r\n        }),\r\n        r\r\n      )\r\n    }),\r\n    (t.thresholdFreedmanDiaconis = function (t, e, r) {\r\n      return (\r\n        (t = d.call(t, u).sort(n)), Math.ceil((r - e) / (2 * (N(t, 0.75) - N(t, 0.25)) * Math.pow(t.length, -1 / 3)))\r\n      )\r\n    }),\r\n    (t.thresholdScott = function (t, n, e) {\r\n      return Math.ceil((e - n) / (3.5 * f(t) * Math.pow(t.length, -1 / 3)))\r\n    }),\r\n    (t.thresholdSturges = M),\r\n    (t.max = A),\r\n    (t.mean = function (t, n) {\r\n      var e,\r\n        r = t.length,\r\n        i = r,\r\n        o = -1,\r\n        a = 0\r\n      if (null == n) for (; ++o < r; ) isNaN((e = u(t[o]))) ? --i : (a += e)\r\n      else for (; ++o < r; ) isNaN((e = u(n(t[o], o, t)))) ? --i : (a += e)\r\n      if (i) return a / i\r\n    }),\r\n    (t.median = function (t, e) {\r\n      var r,\r\n        i = t.length,\r\n        o = -1,\r\n        a = []\r\n      if (null == e) for (; ++o < i; ) isNaN((r = u(t[o]))) || a.push(r)\r\n      else for (; ++o < i; ) isNaN((r = u(e(t[o], o, t)))) || a.push(r)\r\n      return N(a.sort(n), 0.5)\r\n    }),\r\n    (t.merge = S),\r\n    (t.min = k),\r\n    (t.pairs = function (t, n) {\r\n      null == n && (n = a)\r\n      for (var e = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); e < r; ) o[e] = n(i, (i = t[++e]))\r\n      return o\r\n    }),\r\n    (t.permute = function (t, n) {\r\n      for (var e = n.length, r = new Array(e); e--; ) r[e] = t[n[e]]\r\n      return r\r\n    }),\r\n    (t.quantile = N),\r\n    (t.range = g),\r\n    (t.scan = function (t, e) {\r\n      if ((r = t.length)) {\r\n        var r,\r\n          i,\r\n          o = 0,\r\n          a = 0,\r\n          u = t[a]\r\n        for (null == e && (e = n); ++o < r; ) (e((i = t[o]), u) < 0 || 0 !== e(u, u)) && ((u = i), (a = o))\r\n        return 0 === e(u, u) ? a : void 0\r\n      }\r\n    }),\r\n    (t.shuffle = function (t, n, e) {\r\n      for (var r, i, o = (null == e ? t.length : e) - (n = null == n ? 0 : +n); o; )\r\n        (i = (Math.random() * o--) | 0), (r = t[o + n]), (t[o + n] = t[i + n]), (t[i + n] = r)\r\n      return t\r\n    }),\r\n    (t.sum = function (t, n) {\r\n      var e,\r\n        r = t.length,\r\n        i = -1,\r\n        o = 0\r\n      if (null == n) for (; ++i < r; ) (e = +t[i]) && (o += e)\r\n      else for (; ++i < r; ) (e = +n(t[i], i, t)) && (o += e)\r\n      return o\r\n    }),\r\n    (t.ticks = m),\r\n    (t.tickIncrement = x),\r\n    (t.tickStep = w),\r\n    (t.transpose = T),\r\n    (t.variance = c),\r\n    (t.zip = function () {\r\n      return T(arguments)\r\n    }),\r\n    (t.axisTop = function (t) {\r\n      return Y(z, t)\r\n    }),\r\n    (t.axisRight = function (t) {\r\n      return Y(R, t)\r\n    }),\r\n    (t.axisBottom = function (t) {\r\n      return Y(D, t)\r\n    }),\r\n    (t.axisLeft = function (t) {\r\n      return Y(q, t)\r\n    }),\r\n    (t.brush = function () {\r\n      return Pi(mi)\r\n    }),\r\n    (t.brushX = function () {\r\n      return Pi(_i)\r\n    }),\r\n    (t.brushY = function () {\r\n      return Pi(bi)\r\n    }),\r\n    (t.brushSelection = function (t) {\r\n      var n = t.__brush\r\n      return n ? n.dim.output(n.selection) : null\r\n    }),\r\n    (t.chord = function () {\r\n      var t = 0,\r\n        n = null,\r\n        e = null,\r\n        r = null\r\n      function i (i) {\r\n        var o,\r\n          a,\r\n          u,\r\n          c,\r\n          f,\r\n          s,\r\n          l = i.length,\r\n          h = [],\r\n          d = g(l),\r\n          p = [],\r\n          v = [],\r\n          y = (v.groups = new Array(l)),\r\n          _ = new Array(l * l)\r\n        for (o = 0, f = -1; ++f < l; ) {\r\n          for (a = 0, s = -1; ++s < l; ) a += i[f][s]\r\n          h.push(a), p.push(g(l)), (o += a)\r\n        }\r\n        for (\r\n          n &&\r\n            d.sort(function (t, e) {\r\n              return n(h[t], h[e])\r\n            }),\r\n            e &&\r\n              p.forEach(function (t, n) {\r\n                t.sort(function (t, r) {\r\n                  return e(i[n][t], i[n][r])\r\n                })\r\n              }),\r\n            c = (o = Ui(0, Li - t * l) / o) ? t : Li / l,\r\n            a = 0,\r\n            f = -1;\r\n          ++f < l;\r\n\r\n        ) {\r\n          for (u = a, s = -1; ++s < l; ) {\r\n            var b = d[f],\r\n              m = p[b][s],\r\n              x = i[b][m],\r\n              w = a,\r\n              M = (a += x * o)\r\n            _[m * l + b] = { index: b, subindex: m, startAngle: w, endAngle: M, value: x }\r\n          }\r\n          ;(y[b] = { index: b, startAngle: u, endAngle: a, value: h[b] }), (a += c)\r\n        }\r\n        for (f = -1; ++f < l; )\r\n          for (s = f - 1; ++s < l; ) {\r\n            var N = _[s * l + f],\r\n              A = _[f * l + s]\r\n            ;(N.value || A.value) && v.push(N.value < A.value ? { source: A, target: N } : { source: N, target: A })\r\n          }\r\n        return r ? v.sort(r) : v\r\n      }\r\n      return (\r\n        (i.padAngle = function (n) {\r\n          return arguments.length ? ((t = Ui(0, n)), i) : t\r\n        }),\r\n        (i.sortGroups = function (t) {\r\n          return arguments.length ? ((n = t), i) : n\r\n        }),\r\n        (i.sortSubgroups = function (t) {\r\n          return arguments.length ? ((e = t), i) : e\r\n        }),\r\n        (i.sortChords = function (t) {\r\n          return arguments.length\r\n            ? (null == t\r\n                ? (r = null)\r\n                : (((n = t),\r\n                  (r = function (t, e) {\r\n                    return n(t.source.value + t.target.value, e.source.value + e.target.value)\r\n                  }))._ = t),\r\n              i)\r\n            : r && r._\r\n          var n\r\n        }),\r\n        i\r\n      )\r\n    }),\r\n    (t.ribbon = function () {\r\n      var t = Xi,\r\n        n = Gi,\r\n        e = Vi,\r\n        r = $i,\r\n        i = Wi,\r\n        o = null\r\n      function a () {\r\n        var a,\r\n          u = Oi.call(arguments),\r\n          c = t.apply(this, u),\r\n          f = n.apply(this, u),\r\n          s = +e.apply(this, ((u[0] = c), u)),\r\n          l = r.apply(this, u) - qi,\r\n          h = i.apply(this, u) - qi,\r\n          d = s * zi(l),\r\n          p = s * Ri(l),\r\n          v = +e.apply(this, ((u[0] = f), u)),\r\n          g = r.apply(this, u) - qi,\r\n          y = i.apply(this, u) - qi\r\n        if (\r\n          (o || (o = a = Hi()),\r\n          o.moveTo(d, p),\r\n          o.arc(0, 0, s, l, h),\r\n          (l === g && h === y) || (o.quadraticCurveTo(0, 0, v * zi(g), v * Ri(g)), o.arc(0, 0, v, g, y)),\r\n          o.quadraticCurveTo(0, 0, d, p),\r\n          o.closePath(),\r\n          a)\r\n        )\r\n          return (o = null), a + '' || null\r\n      }\r\n      return (\r\n        (a.radius = function (t) {\r\n          return arguments.length ? ((e = 'function' == typeof t ? t : Bi(+t)), a) : e\r\n        }),\r\n        (a.startAngle = function (t) {\r\n          return arguments.length ? ((r = 'function' == typeof t ? t : Bi(+t)), a) : r\r\n        }),\r\n        (a.endAngle = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Bi(+t)), a) : i\r\n        }),\r\n        (a.source = function (n) {\r\n          return arguments.length ? ((t = n), a) : t\r\n        }),\r\n        (a.target = function (t) {\r\n          return arguments.length ? ((n = t), a) : n\r\n        }),\r\n        (a.context = function (t) {\r\n          return arguments.length ? ((o = null == t ? null : t), a) : o\r\n        }),\r\n        a\r\n      )\r\n    }),\r\n    (t.nest = function () {\r\n      var t,\r\n        n,\r\n        e,\r\n        r = [],\r\n        i = []\r\n      function o (e, i, a, u) {\r\n        if (i >= r.length) return null != t && e.sort(t), null != n ? n(e) : e\r\n        for (var c, f, s, l = -1, h = e.length, d = r[i++], p = Qi(), v = a(); ++l < h; )\r\n          (s = p.get((c = d((f = e[l])) + ''))) ? s.push(f) : p.set(c, [f])\r\n        return (\r\n          p.each(function (t, n) {\r\n            u(v, n, o(t, i, a, u))\r\n          }),\r\n          v\r\n        )\r\n      }\r\n      return (e = {\r\n        object: function (t) {\r\n          return o(t, 0, Ji, Ki)\r\n        },\r\n        map: function (t) {\r\n          return o(t, 0, to, no)\r\n        },\r\n        entries: function (t) {\r\n          return (function t (e, o) {\r\n            if (++o > r.length) return e\r\n            var a,\r\n              u = i[o - 1]\r\n            return (\r\n              null != n && o >= r.length\r\n                ? (a = e.entries())\r\n                : ((a = []),\r\n                  e.each(function (n, e) {\r\n                    a.push({ key: e, values: t(n, o) })\r\n                  })),\r\n              null != u\r\n                ? a.sort(function (t, n) {\r\n                    return u(t.key, n.key)\r\n                  })\r\n                : a\r\n            )\r\n          })(o(t, 0, to, no), 0)\r\n        },\r\n        key: function (t) {\r\n          return r.push(t), e\r\n        },\r\n        sortKeys: function (t) {\r\n          return (i[r.length - 1] = t), e\r\n        },\r\n        sortValues: function (n) {\r\n          return (t = n), e\r\n        },\r\n        rollup: function (t) {\r\n          return (n = t), e\r\n        }\r\n      })\r\n    }),\r\n    (t.set = io),\r\n    (t.map = Qi),\r\n    (t.keys = function (t) {\r\n      var n = []\r\n      for (var e in t) n.push(e)\r\n      return n\r\n    }),\r\n    (t.values = function (t) {\r\n      var n = []\r\n      for (var e in t) n.push(t[e])\r\n      return n\r\n    }),\r\n    (t.entries = function (t) {\r\n      var n = []\r\n      for (var e in t) n.push({ key: e, value: t[e] })\r\n      return n\r\n    }),\r\n    (t.color = hn),\r\n    (t.rgb = gn),\r\n    (t.hsl = mn),\r\n    (t.lab = Rn),\r\n    (t.hcl = Yn),\r\n    (t.lch = function (t, n, e, r) {\r\n      return 1 === arguments.length ? Bn(t) : new Fn(e, n, t, null == r ? 1 : r)\r\n    }),\r\n    (t.gray = function (t, n) {\r\n      return new Dn(t, 0, 0, null == n ? 1 : n)\r\n    }),\r\n    (t.cubehelix = Zn),\r\n    (t.contours = po),\r\n    (t.contourDensity = function () {\r\n      var t = yo,\r\n        n = _o,\r\n        e = bo,\r\n        r = 960,\r\n        i = 500,\r\n        o = 20,\r\n        a = 2,\r\n        u = 3 * o,\r\n        c = (r + 2 * u) >> a,\r\n        f = (i + 2 * u) >> a,\r\n        s = uo(20)\r\n      function l (r) {\r\n        var i = new Float32Array(c * f),\r\n          l = new Float32Array(c * f)\r\n        r.forEach(function (r, o, s) {\r\n          var l = (+t(r, o, s) + u) >> a,\r\n            h = (+n(r, o, s) + u) >> a,\r\n            d = +e(r, o, s)\r\n          l >= 0 && l < c && h >= 0 && h < f && (i[l + h * c] += d)\r\n        }),\r\n          vo({ width: c, height: f, data: i }, { width: c, height: f, data: l }, o >> a),\r\n          go({ width: c, height: f, data: l }, { width: c, height: f, data: i }, o >> a),\r\n          vo({ width: c, height: f, data: i }, { width: c, height: f, data: l }, o >> a),\r\n          go({ width: c, height: f, data: l }, { width: c, height: f, data: i }, o >> a),\r\n          vo({ width: c, height: f, data: i }, { width: c, height: f, data: l }, o >> a),\r\n          go({ width: c, height: f, data: l }, { width: c, height: f, data: i }, o >> a)\r\n        var d = s(i)\r\n        if (!Array.isArray(d)) {\r\n          var p = A(i)\r\n          ;(d = w(0, p, d)), (d = g(0, Math.floor(p / d) * d, d)).shift()\r\n        }\r\n        return po()\r\n          .thresholds(d)\r\n          .size([c, f])(i)\r\n          .map(h)\r\n      }\r\n      function h (t) {\r\n        return (t.value *= Math.pow(2, -2 * a)), t.coordinates.forEach(d), t\r\n      }\r\n      function d (t) {\r\n        t.forEach(p)\r\n      }\r\n      function p (t) {\r\n        t.forEach(v)\r\n      }\r\n      function v (t) {\r\n        ;(t[0] = t[0] * Math.pow(2, a) - u), (t[1] = t[1] * Math.pow(2, a) - u)\r\n      }\r\n      function y () {\r\n        return (c = (r + 2 * (u = 3 * o)) >> a), (f = (i + 2 * u) >> a), l\r\n      }\r\n      return (\r\n        (l.x = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : uo(+n)), l) : t\r\n        }),\r\n        (l.y = function (t) {\r\n          return arguments.length ? ((n = 'function' == typeof t ? t : uo(+t)), l) : n\r\n        }),\r\n        (l.weight = function (t) {\r\n          return arguments.length ? ((e = 'function' == typeof t ? t : uo(+t)), l) : e\r\n        }),\r\n        (l.size = function (t) {\r\n          if (!arguments.length) return [r, i]\r\n          var n = Math.ceil(t[0]),\r\n            e = Math.ceil(t[1])\r\n          if (!(n >= 0 || n >= 0)) throw new Error('invalid size')\r\n          return (r = n), (i = e), y()\r\n        }),\r\n        (l.cellSize = function (t) {\r\n          if (!arguments.length) return 1 << a\r\n          if (!((t = +t) >= 1)) throw new Error('invalid cell size')\r\n          return (a = Math.floor(Math.log(t) / Math.LN2)), y()\r\n        }),\r\n        (l.thresholds = function (t) {\r\n          return arguments.length\r\n            ? ((s = 'function' == typeof t ? t : Array.isArray(t) ? uo(oo.call(t)) : uo(t)), l)\r\n            : s\r\n        }),\r\n        (l.bandwidth = function (t) {\r\n          if (!arguments.length) return Math.sqrt(o * (o + 1))\r\n          if (!((t = +t) >= 0)) throw new Error('invalid bandwidth')\r\n          return (o = Math.round((Math.sqrt(4 * t * t + 1) - 1) / 2)), y()\r\n        }),\r\n        l\r\n      )\r\n    }),\r\n    (t.dispatch = I),\r\n    (t.drag = function () {\r\n      var n,\r\n        e,\r\n        r,\r\n        i,\r\n        o = Gt,\r\n        a = Vt,\r\n        u = $t,\r\n        c = Wt,\r\n        f = {},\r\n        s = I('start', 'drag', 'end'),\r\n        l = 0,\r\n        h = 0\r\n      function d (t) {\r\n        t.on('mousedown.drag', p)\r\n          .filter(c)\r\n          .on('touchstart.drag', y)\r\n          .on('touchmove.drag', _)\r\n          .on('touchend.drag touchcancel.drag', b)\r\n          .style('touch-action', 'none')\r\n          .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')\r\n      }\r\n      function p () {\r\n        if (!i && o.apply(this, arguments)) {\r\n          var u = m('mouse', a.apply(this, arguments), Ot, this, arguments)\r\n          u &&\r\n            (zt(t.event.view)\r\n              .on('mousemove.drag', v, !0)\r\n              .on('mouseup.drag', g, !0),\r\n            It(t.event.view),\r\n            Yt(),\r\n            (r = !1),\r\n            (n = t.event.clientX),\r\n            (e = t.event.clientY),\r\n            u('start'))\r\n        }\r\n      }\r\n      function v () {\r\n        if ((Ft(), !r)) {\r\n          var i = t.event.clientX - n,\r\n            o = t.event.clientY - e\r\n          r = i * i + o * o > h\r\n        }\r\n        f.mouse('drag')\r\n      }\r\n      function g () {\r\n        zt(t.event.view).on('mousemove.drag mouseup.drag', null), jt(t.event.view, r), Ft(), f.mouse('end')\r\n      }\r\n      function y () {\r\n        if (o.apply(this, arguments)) {\r\n          var n,\r\n            e,\r\n            r = t.event.changedTouches,\r\n            i = a.apply(this, arguments),\r\n            u = r.length\r\n          for (n = 0; n < u; ++n) (e = m(r[n].identifier, i, Bt, this, arguments)) && (Yt(), e('start'))\r\n        }\r\n      }\r\n      function _ () {\r\n        var n,\r\n          e,\r\n          r = t.event.changedTouches,\r\n          i = r.length\r\n        for (n = 0; n < i; ++n) (e = f[r[n].identifier]) && (Ft(), e('drag'))\r\n      }\r\n      function b () {\r\n        var n,\r\n          e,\r\n          r = t.event.changedTouches,\r\n          o = r.length\r\n        for (\r\n          i && clearTimeout(i),\r\n            i = setTimeout(function () {\r\n              i = null\r\n            }, 500),\r\n            n = 0;\r\n          n < o;\r\n          ++n\r\n        )\r\n          (e = f[r[n].identifier]) && (Yt(), e('end'))\r\n      }\r\n      function m (n, e, r, i, o) {\r\n        var a,\r\n          c,\r\n          h,\r\n          p = r(e, n),\r\n          v = s.copy()\r\n        if (\r\n          kt(new Xt(d, 'beforestart', a, n, l, p[0], p[1], 0, 0, v), function () {\r\n            return null != (t.event.subject = a = u.apply(i, o)) && ((c = a.x - p[0] || 0), (h = a.y - p[1] || 0), !0)\r\n          })\r\n        )\r\n          return function t (u) {\r\n            var s,\r\n              g = p\r\n            switch (u) {\r\n              case 'start':\r\n                ;(f[n] = t), (s = l++)\r\n                break\r\n              case 'end':\r\n                delete f[n], --l\r\n              case 'drag':\r\n                ;(p = r(e, n)), (s = l)\r\n            }\r\n            kt(new Xt(d, u, a, n, s, p[0] + c, p[1] + h, p[0] - g[0], p[1] - g[1], v), v.apply, v, [u, i, o])\r\n          }\r\n      }\r\n      return (\r\n        (d.filter = function (t) {\r\n          return arguments.length ? ((o = 'function' == typeof t ? t : Ht(!!t)), d) : o\r\n        }),\r\n        (d.container = function (t) {\r\n          return arguments.length ? ((a = 'function' == typeof t ? t : Ht(t)), d) : a\r\n        }),\r\n        (d.subject = function (t) {\r\n          return arguments.length ? ((u = 'function' == typeof t ? t : Ht(t)), d) : u\r\n        }),\r\n        (d.touchable = function (t) {\r\n          return arguments.length ? ((c = 'function' == typeof t ? t : Ht(!!t)), d) : c\r\n        }),\r\n        (d.on = function () {\r\n          var t = s.on.apply(s, arguments)\r\n          return t === s ? d : t\r\n        }),\r\n        (d.clickDistance = function (t) {\r\n          return arguments.length ? ((h = (t = +t) * t), d) : Math.sqrt(h)\r\n        }),\r\n        d\r\n      )\r\n    }),\r\n    (t.dragDisable = It),\r\n    (t.dragEnable = jt),\r\n    (t.dsvFormat = ko),\r\n    (t.csvParse = Eo),\r\n    (t.csvParseRows = Co),\r\n    (t.csvFormat = Po),\r\n    (t.csvFormatBody = zo),\r\n    (t.csvFormatRows = Ro),\r\n    (t.tsvParse = qo),\r\n    (t.tsvParseRows = Lo),\r\n    (t.tsvFormat = Uo),\r\n    (t.tsvFormatBody = Oo),\r\n    (t.tsvFormatRows = Bo),\r\n    (t.autoType = function (t) {\r\n      for (var n in t) {\r\n        var e,\r\n          r = t[n].trim()\r\n        if (r)\r\n          if ('true' === r) r = !0\r\n          else if ('false' === r) r = !1\r\n          else if ('NaN' === r) r = NaN\r\n          else if (isNaN((e = +r))) {\r\n            if (!/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/.test(r))\r\n              continue\r\n            r = new Date(r)\r\n          } else r = e\r\n        else r = null\r\n        t[n] = r\r\n      }\r\n      return t\r\n    }),\r\n    (t.easeLinear = function (t) {\r\n      return +t\r\n    }),\r\n    (t.easeQuad = Rr),\r\n    (t.easeQuadIn = function (t) {\r\n      return t * t\r\n    }),\r\n    (t.easeQuadOut = function (t) {\r\n      return t * (2 - t)\r\n    }),\r\n    (t.easeQuadInOut = Rr),\r\n    (t.easeCubic = Dr),\r\n    (t.easeCubicIn = function (t) {\r\n      return t * t * t\r\n    }),\r\n    (t.easeCubicOut = function (t) {\r\n      return --t * t * t + 1\r\n    }),\r\n    (t.easeCubicInOut = Dr),\r\n    (t.easePoly = Ur),\r\n    (t.easePolyIn = qr),\r\n    (t.easePolyOut = Lr),\r\n    (t.easePolyInOut = Ur),\r\n    (t.easeSin = Yr),\r\n    (t.easeSinIn = function (t) {\r\n      return 1 - Math.cos(t * Br)\r\n    }),\r\n    (t.easeSinOut = function (t) {\r\n      return Math.sin(t * Br)\r\n    }),\r\n    (t.easeSinInOut = Yr),\r\n    (t.easeExp = Fr),\r\n    (t.easeExpIn = function (t) {\r\n      return Math.pow(2, 10 * t - 10)\r\n    }),\r\n    (t.easeExpOut = function (t) {\r\n      return 1 - Math.pow(2, -10 * t)\r\n    }),\r\n    (t.easeExpInOut = Fr),\r\n    (t.easeCircle = Ir),\r\n    (t.easeCircleIn = function (t) {\r\n      return 1 - Math.sqrt(1 - t * t)\r\n    }),\r\n    (t.easeCircleOut = function (t) {\r\n      return Math.sqrt(1 - --t * t)\r\n    }),\r\n    (t.easeCircleInOut = Ir),\r\n    (t.easeBounce = Kr),\r\n    (t.easeBounceIn = function (t) {\r\n      return 1 - Kr(1 - t)\r\n    }),\r\n    (t.easeBounceOut = Kr),\r\n    (t.easeBounceInOut = function (t) {\r\n      return ((t *= 2) <= 1 ? 1 - Kr(1 - t) : Kr(t - 1) + 1) / 2\r\n    }),\r\n    (t.easeBack = ei),\r\n    (t.easeBackIn = ti),\r\n    (t.easeBackOut = ni),\r\n    (t.easeBackInOut = ei),\r\n    (t.easeElastic = oi),\r\n    (t.easeElasticIn = ii),\r\n    (t.easeElasticOut = oi),\r\n    (t.easeElasticInOut = ai),\r\n    (t.blob = function (t, n) {\r\n      return fetch(t, n).then(Yo)\r\n    }),\r\n    (t.buffer = function (t, n) {\r\n      return fetch(t, n).then(Fo)\r\n    }),\r\n    (t.dsv = function (t, n, e, r) {\r\n      3 === arguments.length && 'function' == typeof e && ((r = e), (e = void 0))\r\n      var i = ko(t)\r\n      return jo(n, e).then(function (t) {\r\n        return i.parse(t, r)\r\n      })\r\n    }),\r\n    (t.csv = Xo),\r\n    (t.tsv = Go),\r\n    (t.image = function (t, n) {\r\n      return new Promise(function (e, r) {\r\n        var i = new Image()\r\n        for (var o in n) i[o] = n[o]\r\n        ;(i.onerror = r),\r\n          (i.onload = function () {\r\n            e(i)\r\n          }),\r\n          (i.src = t)\r\n      })\r\n    }),\r\n    (t.json = function (t, n) {\r\n      return fetch(t, n).then(Vo)\r\n    }),\r\n    (t.text = jo),\r\n    (t.xml = Wo),\r\n    (t.html = Zo),\r\n    (t.svg = Qo),\r\n    (t.forceCenter = function (t, n) {\r\n      var e\r\n      function r () {\r\n        var r,\r\n          i,\r\n          o = e.length,\r\n          a = 0,\r\n          u = 0\r\n        for (r = 0; r < o; ++r) (a += (i = e[r]).x), (u += i.y)\r\n        for (a = a / o - t, u = u / o - n, r = 0; r < o; ++r) ((i = e[r]).x -= a), (i.y -= u)\r\n      }\r\n      return (\r\n        null == t && (t = 0),\r\n        null == n && (n = 0),\r\n        (r.initialize = function (t) {\r\n          e = t\r\n        }),\r\n        (r.x = function (n) {\r\n          return arguments.length ? ((t = +n), r) : t\r\n        }),\r\n        (r.y = function (t) {\r\n          return arguments.length ? ((n = +t), r) : n\r\n        }),\r\n        r\r\n      )\r\n    }),\r\n    (t.forceCollide = function (t) {\r\n      var n,\r\n        e,\r\n        r = 1,\r\n        i = 1\r\n      function o () {\r\n        for (var t, o, u, c, f, s, l, h = n.length, d = 0; d < i; ++d)\r\n          for (o = ia(n, ca, fa).visitAfter(a), t = 0; t < h; ++t)\r\n            (u = n[t]), (s = e[u.index]), (l = s * s), (c = u.x + u.vx), (f = u.y + u.vy), o.visit(p)\r\n        function p (t, n, e, i, o) {\r\n          var a = t.data,\r\n            h = t.r,\r\n            d = s + h\r\n          if (!a) return n > c + d || i < c - d || e > f + d || o < f - d\r\n          if (a.index > u.index) {\r\n            var p = c - a.x - a.vx,\r\n              v = f - a.y - a.vy,\r\n              g = p * p + v * v\r\n            g < d * d &&\r\n              (0 === p && (g += (p = Ko()) * p),\r\n              0 === v && (g += (v = Ko()) * v),\r\n              (g = ((d - (g = Math.sqrt(g))) / g) * r),\r\n              (u.vx += (p *= g) * (d = (h *= h) / (l + h))),\r\n              (u.vy += (v *= g) * d),\r\n              (a.vx -= p * (d = 1 - d)),\r\n              (a.vy -= v * d))\r\n          }\r\n        }\r\n      }\r\n      function a (t) {\r\n        if (t.data) return (t.r = e[t.data.index])\r\n        for (var n = (t.r = 0); n < 4; ++n) t[n] && t[n].r > t.r && (t.r = t[n].r)\r\n      }\r\n      function u () {\r\n        if (n) {\r\n          var r,\r\n            i,\r\n            o = n.length\r\n          for (e = new Array(o), r = 0; r < o; ++r) (i = n[r]), (e[i.index] = +t(i, r, n))\r\n        }\r\n      }\r\n      return (\r\n        'function' != typeof t && (t = Jo(null == t ? 1 : +t)),\r\n        (o.initialize = function (t) {\r\n          ;(n = t), u()\r\n        }),\r\n        (o.iterations = function (t) {\r\n          return arguments.length ? ((i = +t), o) : i\r\n        }),\r\n        (o.strength = function (t) {\r\n          return arguments.length ? ((r = +t), o) : r\r\n        }),\r\n        (o.radius = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), u(), o) : t\r\n        }),\r\n        o\r\n      )\r\n    }),\r\n    (t.forceLink = function (t) {\r\n      var n,\r\n        e,\r\n        r,\r\n        i,\r\n        o,\r\n        a = sa,\r\n        u = function (t) {\r\n          return 1 / Math.min(i[t.source.index], i[t.target.index])\r\n        },\r\n        c = Jo(30),\r\n        f = 1\r\n      function s (r) {\r\n        for (var i = 0, a = t.length; i < f; ++i)\r\n          for (var u, c, s, l, h, d, p, v = 0; v < a; ++v)\r\n            (c = (u = t[v]).source),\r\n              (l = (s = u.target).x + s.vx - c.x - c.vx || Ko()),\r\n              (h = s.y + s.vy - c.y - c.vy || Ko()),\r\n              (l *= d = (((d = Math.sqrt(l * l + h * h)) - e[v]) / d) * r * n[v]),\r\n              (h *= d),\r\n              (s.vx -= l * (p = o[v])),\r\n              (s.vy -= h * p),\r\n              (c.vx += l * (p = 1 - p)),\r\n              (c.vy += h * p)\r\n      }\r\n      function l () {\r\n        if (r) {\r\n          var u,\r\n            c,\r\n            f = r.length,\r\n            s = t.length,\r\n            l = Qi(r, a)\r\n          for (u = 0, i = new Array(f); u < s; ++u)\r\n            ((c = t[u]).index = u),\r\n              'object' != typeof c.source && (c.source = la(l, c.source)),\r\n              'object' != typeof c.target && (c.target = la(l, c.target)),\r\n              (i[c.source.index] = (i[c.source.index] || 0) + 1),\r\n              (i[c.target.index] = (i[c.target.index] || 0) + 1)\r\n          for (u = 0, o = new Array(s); u < s; ++u)\r\n            (c = t[u]), (o[u] = i[c.source.index] / (i[c.source.index] + i[c.target.index]))\r\n          ;(n = new Array(s)), h(), (e = new Array(s)), d()\r\n        }\r\n      }\r\n      function h () {\r\n        if (r) for (var e = 0, i = t.length; e < i; ++e) n[e] = +u(t[e], e, t)\r\n      }\r\n      function d () {\r\n        if (r) for (var n = 0, i = t.length; n < i; ++n) e[n] = +c(t[n], n, t)\r\n      }\r\n      return (\r\n        null == t && (t = []),\r\n        (s.initialize = function (t) {\r\n          ;(r = t), l()\r\n        }),\r\n        (s.links = function (n) {\r\n          return arguments.length ? ((t = n), l(), s) : t\r\n        }),\r\n        (s.id = function (t) {\r\n          return arguments.length ? ((a = t), s) : a\r\n        }),\r\n        (s.iterations = function (t) {\r\n          return arguments.length ? ((f = +t), s) : f\r\n        }),\r\n        (s.strength = function (t) {\r\n          return arguments.length ? ((u = 'function' == typeof t ? t : Jo(+t)), h(), s) : u\r\n        }),\r\n        (s.distance = function (t) {\r\n          return arguments.length ? ((c = 'function' == typeof t ? t : Jo(+t)), d(), s) : c\r\n        }),\r\n        s\r\n      )\r\n    }),\r\n    (t.forceManyBody = function () {\r\n      var t,\r\n        n,\r\n        e,\r\n        r,\r\n        i = Jo(-30),\r\n        o = 1,\r\n        a = 1 / 0,\r\n        u = 0.81\r\n      function c (r) {\r\n        var i,\r\n          o = t.length,\r\n          a = ia(t, ha, da).visitAfter(s)\r\n        for (e = r, i = 0; i < o; ++i) (n = t[i]), a.visit(l)\r\n      }\r\n      function f () {\r\n        if (t) {\r\n          var n,\r\n            e,\r\n            o = t.length\r\n          for (r = new Array(o), n = 0; n < o; ++n) (e = t[n]), (r[e.index] = +i(e, n, t))\r\n        }\r\n      }\r\n      function s (t) {\r\n        var n,\r\n          e,\r\n          i,\r\n          o,\r\n          a,\r\n          u = 0,\r\n          c = 0\r\n        if (t.length) {\r\n          for (i = o = a = 0; a < 4; ++a)\r\n            (n = t[a]) && (e = Math.abs(n.value)) && ((u += n.value), (c += e), (i += e * n.x), (o += e * n.y))\r\n          ;(t.x = i / c), (t.y = o / c)\r\n        } else {\r\n          ;((n = t).x = n.data.x), (n.y = n.data.y)\r\n          do {\r\n            u += r[n.data.index]\r\n          } while ((n = n.next))\r\n        }\r\n        t.value = u\r\n      }\r\n      function l (t, i, c, f) {\r\n        if (!t.value) return !0\r\n        var s = t.x - n.x,\r\n          l = t.y - n.y,\r\n          h = f - i,\r\n          d = s * s + l * l\r\n        if ((h * h) / u < d)\r\n          return (\r\n            d < a &&\r\n              (0 === s && (d += (s = Ko()) * s),\r\n              0 === l && (d += (l = Ko()) * l),\r\n              d < o && (d = Math.sqrt(o * d)),\r\n              (n.vx += (s * t.value * e) / d),\r\n              (n.vy += (l * t.value * e) / d)),\r\n            !0\r\n          )\r\n        if (!(t.length || d >= a)) {\r\n          ;(t.data !== n || t.next) &&\r\n            (0 === s && (d += (s = Ko()) * s), 0 === l && (d += (l = Ko()) * l), d < o && (d = Math.sqrt(o * d)))\r\n          do {\r\n            t.data !== n && ((h = (r[t.data.index] * e) / d), (n.vx += s * h), (n.vy += l * h))\r\n          } while ((t = t.next))\r\n        }\r\n      }\r\n      return (\r\n        (c.initialize = function (n) {\r\n          ;(t = n), f()\r\n        }),\r\n        (c.strength = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Jo(+t)), f(), c) : i\r\n        }),\r\n        (c.distanceMin = function (t) {\r\n          return arguments.length ? ((o = t * t), c) : Math.sqrt(o)\r\n        }),\r\n        (c.distanceMax = function (t) {\r\n          return arguments.length ? ((a = t * t), c) : Math.sqrt(a)\r\n        }),\r\n        (c.theta = function (t) {\r\n          return arguments.length ? ((u = t * t), c) : Math.sqrt(u)\r\n        }),\r\n        c\r\n      )\r\n    }),\r\n    (t.forceRadial = function (t, n, e) {\r\n      var r,\r\n        i,\r\n        o,\r\n        a = Jo(0.1)\r\n      function u (t) {\r\n        for (var a = 0, u = r.length; a < u; ++a) {\r\n          var c = r[a],\r\n            f = c.x - n || 1e-6,\r\n            s = c.y - e || 1e-6,\r\n            l = Math.sqrt(f * f + s * s),\r\n            h = ((o[a] - l) * i[a] * t) / l\r\n          ;(c.vx += f * h), (c.vy += s * h)\r\n        }\r\n      }\r\n      function c () {\r\n        if (r) {\r\n          var n,\r\n            e = r.length\r\n          for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n)\r\n            (o[n] = +t(r[n], n, r)), (i[n] = isNaN(o[n]) ? 0 : +a(r[n], n, r))\r\n        }\r\n      }\r\n      return (\r\n        'function' != typeof t && (t = Jo(+t)),\r\n        null == n && (n = 0),\r\n        null == e && (e = 0),\r\n        (u.initialize = function (t) {\r\n          ;(r = t), c()\r\n        }),\r\n        (u.strength = function (t) {\r\n          return arguments.length ? ((a = 'function' == typeof t ? t : Jo(+t)), c(), u) : a\r\n        }),\r\n        (u.radius = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), c(), u) : t\r\n        }),\r\n        (u.x = function (t) {\r\n          return arguments.length ? ((n = +t), u) : n\r\n        }),\r\n        (u.y = function (t) {\r\n          return arguments.length ? ((e = +t), u) : e\r\n        }),\r\n        u\r\n      )\r\n    }),\r\n    (t.forceSimulation = function (t) {\r\n      var n,\r\n        e = 1,\r\n        r = 0.001,\r\n        i = 1 - Math.pow(r, 1 / 300),\r\n        o = 0,\r\n        a = 0.6,\r\n        u = Qi(),\r\n        c = ir(s),\r\n        f = I('tick', 'end')\r\n      function s () {\r\n        l(), f.call('tick', n), e < r && (c.stop(), f.call('end', n))\r\n      }\r\n      function l (r) {\r\n        var c,\r\n          f,\r\n          s = t.length\r\n        void 0 === r && (r = 1)\r\n        for (var l = 0; l < r; ++l)\r\n          for (\r\n            e += (o - e) * i,\r\n              u.each(function (t) {\r\n                t(e)\r\n              }),\r\n              c = 0;\r\n            c < s;\r\n            ++c\r\n          )\r\n            null == (f = t[c]).fx ? (f.x += f.vx *= a) : ((f.x = f.fx), (f.vx = 0)),\r\n              null == f.fy ? (f.y += f.vy *= a) : ((f.y = f.fy), (f.vy = 0))\r\n        return n\r\n      }\r\n      function h () {\r\n        for (var n, e = 0, r = t.length; e < r; ++e) {\r\n          if (\r\n            (((n = t[e]).index = e), isNaN(n.fx) || (n.x = n.fx), isNaN(n.fy) || (n.y = n.fy), isNaN(n.x) || isNaN(n.y))\r\n          ) {\r\n            var i = pa * Math.sqrt(e),\r\n              o = e * va\r\n            ;(n.x = i * Math.cos(o)), (n.y = i * Math.sin(o))\r\n          }\r\n          ;(isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0)\r\n        }\r\n      }\r\n      function d (n) {\r\n        return n.initialize && n.initialize(t), n\r\n      }\r\n      return (\r\n        null == t && (t = []),\r\n        h(),\r\n        (n = {\r\n          tick: l,\r\n          restart: function () {\r\n            return c.restart(s), n\r\n          },\r\n          stop: function () {\r\n            return c.stop(), n\r\n          },\r\n          nodes: function (e) {\r\n            return arguments.length ? ((t = e), h(), u.each(d), n) : t\r\n          },\r\n          alpha: function (t) {\r\n            return arguments.length ? ((e = +t), n) : e\r\n          },\r\n          alphaMin: function (t) {\r\n            return arguments.length ? ((r = +t), n) : r\r\n          },\r\n          alphaDecay: function (t) {\r\n            return arguments.length ? ((i = +t), n) : +i\r\n          },\r\n          alphaTarget: function (t) {\r\n            return arguments.length ? ((o = +t), n) : o\r\n          },\r\n          velocityDecay: function (t) {\r\n            return arguments.length ? ((a = 1 - t), n) : 1 - a\r\n          },\r\n          force: function (t, e) {\r\n            return arguments.length > 1 ? (null == e ? u.remove(t) : u.set(t, d(e)), n) : u.get(t)\r\n          },\r\n          find: function (n, e, r) {\r\n            var i,\r\n              o,\r\n              a,\r\n              u,\r\n              c,\r\n              f = 0,\r\n              s = t.length\r\n            for (null == r ? (r = 1 / 0) : (r *= r), f = 0; f < s; ++f)\r\n              (a = (i = n - (u = t[f]).x) * i + (o = e - u.y) * o) < r && ((c = u), (r = a))\r\n            return c\r\n          },\r\n          on: function (t, e) {\r\n            return arguments.length > 1 ? (f.on(t, e), n) : f.on(t)\r\n          }\r\n        })\r\n      )\r\n    }),\r\n    (t.forceX = function (t) {\r\n      var n,\r\n        e,\r\n        r,\r\n        i = Jo(0.1)\r\n      function o (t) {\r\n        for (var i, o = 0, a = n.length; o < a; ++o) (i = n[o]).vx += (r[o] - i.x) * e[o] * t\r\n      }\r\n      function a () {\r\n        if (n) {\r\n          var o,\r\n            a = n.length\r\n          for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)\r\n            e[o] = isNaN((r[o] = +t(n[o], o, n))) ? 0 : +i(n[o], o, n)\r\n        }\r\n      }\r\n      return (\r\n        'function' != typeof t && (t = Jo(null == t ? 0 : +t)),\r\n        (o.initialize = function (t) {\r\n          ;(n = t), a()\r\n        }),\r\n        (o.strength = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Jo(+t)), a(), o) : i\r\n        }),\r\n        (o.x = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), a(), o) : t\r\n        }),\r\n        o\r\n      )\r\n    }),\r\n    (t.forceY = function (t) {\r\n      var n,\r\n        e,\r\n        r,\r\n        i = Jo(0.1)\r\n      function o (t) {\r\n        for (var i, o = 0, a = n.length; o < a; ++o) (i = n[o]).vy += (r[o] - i.y) * e[o] * t\r\n      }\r\n      function a () {\r\n        if (n) {\r\n          var o,\r\n            a = n.length\r\n          for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)\r\n            e[o] = isNaN((r[o] = +t(n[o], o, n))) ? 0 : +i(n[o], o, n)\r\n        }\r\n      }\r\n      return (\r\n        'function' != typeof t && (t = Jo(null == t ? 0 : +t)),\r\n        (o.initialize = function (t) {\r\n          ;(n = t), a()\r\n        }),\r\n        (o.strength = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Jo(+t)), a(), o) : i\r\n        }),\r\n        (o.y = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), a(), o) : t\r\n        }),\r\n        o\r\n      )\r\n    }),\r\n    (t.formatDefaultLocale = Ta),\r\n    (t.formatLocale = ka),\r\n    (t.formatSpecifier = ma),\r\n    (t.precisionFixed = Ea),\r\n    (t.precisionPrefix = Ca),\r\n    (t.precisionRound = Pa),\r\n    (t.geoArea = function (t) {\r\n      return _u.reset(), lu(t, bu), 2 * _u\r\n    }),\r\n    (t.geoBounds = function (t) {\r\n      var n, e, r, i, o, a, u\r\n      if (((Du = Ru = -(Pu = zu = 1 / 0)), (Bu = []), lu(t, ic), (e = Bu.length))) {\r\n        for (Bu.sort(dc), n = 1, o = [(r = Bu[0])]; n < e; ++n)\r\n          pc(r, (i = Bu[n])[0]) || pc(r, i[1])\r\n            ? (hc(r[0], i[1]) > hc(r[0], r[1]) && (r[1] = i[1]), hc(i[0], r[1]) > hc(r[0], r[1]) && (r[0] = i[0]))\r\n            : o.push((r = i))\r\n        for (a = -1 / 0, n = 0, r = o[(e = o.length - 1)]; n <= e; r = i, ++n)\r\n          (i = o[n]), (u = hc(r[1], i[0])) > a && ((a = u), (Pu = i[0]), (Ru = r[1]))\r\n      }\r\n      return (Bu = Yu = null), Pu === 1 / 0 || zu === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Pu, zu], [Ru, Du]]\r\n    }),\r\n    (t.geoCentroid = function (t) {\r\n      ;(Fu = Iu = ju = Hu = Xu = Gu = Vu = $u = Wu = Zu = Qu = 0), lu(t, vc)\r\n      var n = Wu,\r\n        e = Zu,\r\n        r = Qu,\r\n        i = n * n + e * e + r * r\r\n      return i < Ua &&\r\n        ((n = Gu), (e = Vu), (r = $u), Iu < La && ((n = ju), (e = Hu), (r = Xu)), (i = n * n + e * e + r * r) < Ua)\r\n        ? [NaN, NaN]\r\n        : [Ga(e, n) * Ia, ru(r / tu(i)) * Ia]\r\n    }),\r\n    (t.geoCircle = function () {\r\n      var t,\r\n        n,\r\n        e = Sc([0, 0]),\r\n        r = Sc(90),\r\n        i = Sc(6),\r\n        o = {\r\n          point: function (e, r) {\r\n            t.push((e = n(e, r))), (e[0] *= Ia), (e[1] *= Ia)\r\n          }\r\n        }\r\n      function a () {\r\n        var a = e.apply(this, arguments),\r\n          u = r.apply(this, arguments) * ja,\r\n          c = i.apply(this, arguments) * ja\r\n        return (\r\n          (t = []),\r\n          (n = Ec(-a[0] * ja, -a[1] * ja, 0).invert),\r\n          Dc(o, u, c, 1),\r\n          (a = { type: 'Polygon', coordinates: [t] }),\r\n          (t = n = null),\r\n          a\r\n        )\r\n      }\r\n      return (\r\n        (a.center = function (t) {\r\n          return arguments.length ? ((e = 'function' == typeof t ? t : Sc([+t[0], +t[1]])), a) : e\r\n        }),\r\n        (a.radius = function (t) {\r\n          return arguments.length ? ((r = 'function' == typeof t ? t : Sc(+t)), a) : r\r\n        }),\r\n        (a.precision = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Sc(+t)), a) : i\r\n        }),\r\n        a\r\n      )\r\n    }),\r\n    (t.geoClipAntimeridian = Gc),\r\n    (t.geoClipCircle = Vc),\r\n    (t.geoClipExtent = function () {\r\n      var t,\r\n        n,\r\n        e,\r\n        r = 0,\r\n        i = 0,\r\n        o = 960,\r\n        a = 500\r\n      return (e = {\r\n        stream: function (e) {\r\n          return t && n === e ? t : (t = Zc(r, i, o, a)((n = e)))\r\n        },\r\n        extent: function (u) {\r\n          return arguments.length\r\n            ? ((r = +u[0][0]), (i = +u[0][1]), (o = +u[1][0]), (a = +u[1][1]), (t = n = null), e)\r\n            : [[r, i], [o, a]]\r\n        }\r\n      })\r\n    }),\r\n    (t.geoClipRectangle = Zc),\r\n    (t.geoContains = function (t, n) {\r\n      return (t && sf.hasOwnProperty(t.type) ? sf[t.type] : hf)(t, n)\r\n    }),\r\n    (t.geoDistance = ff),\r\n    (t.geoGraticule = mf),\r\n    (t.geoGraticule10 = function () {\r\n      return mf()()\r\n    }),\r\n    (t.geoInterpolate = function (t, n) {\r\n      var e = t[0] * ja,\r\n        r = t[1] * ja,\r\n        i = n[0] * ja,\r\n        o = n[1] * ja,\r\n        a = Va(r),\r\n        u = Ja(r),\r\n        c = Va(o),\r\n        f = Ja(o),\r\n        s = a * Va(e),\r\n        l = a * Ja(e),\r\n        h = c * Va(i),\r\n        d = c * Ja(i),\r\n        p = 2 * ru(tu(iu(o - r) + a * c * iu(i - e))),\r\n        v = Ja(p),\r\n        g = p\r\n          ? function (t) {\r\n              var n = Ja((t *= p)) / v,\r\n                e = Ja(p - t) / v,\r\n                r = e * s + n * h,\r\n                i = e * l + n * d,\r\n                o = e * u + n * f\r\n              return [Ga(i, r) * Ia, Ga(o, tu(r * r + i * i)) * Ia]\r\n            }\r\n          : function () {\r\n              return [e * Ia, r * Ia]\r\n            }\r\n      return (g.distance = p), g\r\n    }),\r\n    (t.geoLength = af),\r\n    (t.geoPath = function (t, n) {\r\n      var e,\r\n        r,\r\n        i = 4.5\r\n      function o (t) {\r\n        return t && ('function' == typeof i && r.pointRadius(+i.apply(this, arguments)), lu(t, e(r))), r.result()\r\n      }\r\n      return (\r\n        (o.area = function (t) {\r\n          return lu(t, e(Tf)), Tf.result()\r\n        }),\r\n        (o.measure = function (t) {\r\n          return lu(t, e(ps)), ps.result()\r\n        }),\r\n        (o.bounds = function (t) {\r\n          return lu(t, e(Uf)), Uf.result()\r\n        }),\r\n        (o.centroid = function (t) {\r\n          return lu(t, e(Qf)), Qf.result()\r\n        }),\r\n        (o.projection = function (n) {\r\n          return arguments.length ? ((e = null == n ? ((t = null), xf) : (t = n).stream), o) : t\r\n        }),\r\n        (o.context = function (t) {\r\n          return arguments.length\r\n            ? ((r = null == t ? ((n = null), new ys()) : new us((n = t))),\r\n              'function' != typeof i && r.pointRadius(i),\r\n              o)\r\n            : n\r\n        }),\r\n        (o.pointRadius = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : (r.pointRadius(+t), +t)), o) : i\r\n        }),\r\n        o.projection(t).context(n)\r\n      )\r\n    }),\r\n    (t.geoAlbers = Ls),\r\n    (t.geoAlbersUsa = function () {\r\n      var t,\r\n        n,\r\n        e,\r\n        r,\r\n        i,\r\n        o,\r\n        a = Ls(),\r\n        u = qs()\r\n          .rotate([154, 0])\r\n          .center([-2, 58.5])\r\n          .parallels([55, 65]),\r\n        c = qs()\r\n          .rotate([157, 0])\r\n          .center([-3, 19.9])\r\n          .parallels([8, 18]),\r\n        f = {\r\n          point: function (t, n) {\r\n            o = [t, n]\r\n          }\r\n        }\r\n      function s (t) {\r\n        var n = t[0],\r\n          a = t[1]\r\n        return (o = null), e.point(n, a), o || (r.point(n, a), o) || (i.point(n, a), o)\r\n      }\r\n      function l () {\r\n        return (t = n = null), s\r\n      }\r\n      return (\r\n        (s.invert = function (t) {\r\n          var n = a.scale(),\r\n            e = a.translate(),\r\n            r = (t[0] - e[0]) / n,\r\n            i = (t[1] - e[1]) / n\r\n          return (i >= 0.12 && i < 0.234 && r >= -0.425 && r < -0.214\r\n            ? u\r\n            : i >= 0.166 && i < 0.234 && r >= -0.214 && r < -0.115\r\n            ? c\r\n            : a\r\n          ).invert(t)\r\n        }),\r\n        (s.stream = function (e) {\r\n          return t && n === e\r\n            ? t\r\n            : ((r = [a.stream((n = e)), u.stream(e), c.stream(e)]),\r\n              (i = r.length),\r\n              (t = {\r\n                point: function (t, n) {\r\n                  for (var e = -1; ++e < i; ) r[e].point(t, n)\r\n                },\r\n                sphere: function () {\r\n                  for (var t = -1; ++t < i; ) r[t].sphere()\r\n                },\r\n                lineStart: function () {\r\n                  for (var t = -1; ++t < i; ) r[t].lineStart()\r\n                },\r\n                lineEnd: function () {\r\n                  for (var t = -1; ++t < i; ) r[t].lineEnd()\r\n                },\r\n                polygonStart: function () {\r\n                  for (var t = -1; ++t < i; ) r[t].polygonStart()\r\n                },\r\n                polygonEnd: function () {\r\n                  for (var t = -1; ++t < i; ) r[t].polygonEnd()\r\n                }\r\n              }))\r\n          var r, i\r\n        }),\r\n        (s.precision = function (t) {\r\n          return arguments.length ? (a.precision(t), u.precision(t), c.precision(t), l()) : a.precision()\r\n        }),\r\n        (s.scale = function (t) {\r\n          return arguments.length ? (a.scale(t), u.scale(0.35 * t), c.scale(t), s.translate(a.translate())) : a.scale()\r\n        }),\r\n        (s.translate = function (t) {\r\n          if (!arguments.length) return a.translate()\r\n          var n = a.scale(),\r\n            o = +t[0],\r\n            s = +t[1]\r\n          return (\r\n            (e = a\r\n              .translate(t)\r\n              .clipExtent([[o - 0.455 * n, s - 0.238 * n], [o + 0.455 * n, s + 0.238 * n]])\r\n              .stream(f)),\r\n            (r = u\r\n              .translate([o - 0.307 * n, s + 0.201 * n])\r\n              .clipExtent([[o - 0.425 * n + La, s + 0.12 * n + La], [o - 0.214 * n - La, s + 0.234 * n - La]])\r\n              .stream(f)),\r\n            (i = c\r\n              .translate([o - 0.205 * n, s + 0.212 * n])\r\n              .clipExtent([[o - 0.214 * n + La, s + 0.166 * n + La], [o - 0.115 * n - La, s + 0.234 * n - La]])\r\n              .stream(f)),\r\n            l()\r\n          )\r\n        }),\r\n        (s.fitExtent = function (t, n) {\r\n          return ws(s, t, n)\r\n        }),\r\n        (s.fitSize = function (t, n) {\r\n          return Ms(s, t, n)\r\n        }),\r\n        (s.fitWidth = function (t, n) {\r\n          return Ns(s, t, n)\r\n        }),\r\n        (s.fitHeight = function (t, n) {\r\n          return As(s, t, n)\r\n        }),\r\n        s.scale(1070)\r\n      )\r\n    }),\r\n    (t.geoAzimuthalEqualArea = function () {\r\n      return Ps(Bs)\r\n        .scale(124.75)\r\n        .clipAngle(179.999)\r\n    }),\r\n    (t.geoAzimuthalEqualAreaRaw = Bs),\r\n    (t.geoAzimuthalEquidistant = function () {\r\n      return Ps(Ys)\r\n        .scale(79.4188)\r\n        .clipAngle(179.999)\r\n    }),\r\n    (t.geoAzimuthalEquidistantRaw = Ys),\r\n    (t.geoConicConformal = function () {\r\n      return Rs(Hs)\r\n        .scale(109.5)\r\n        .parallels([30, 30])\r\n    }),\r\n    (t.geoConicConformalRaw = Hs),\r\n    (t.geoConicEqualArea = qs),\r\n    (t.geoConicEqualAreaRaw = Ds),\r\n    (t.geoConicEquidistant = function () {\r\n      return Rs(Gs)\r\n        .scale(131.154)\r\n        .center([0, 13.9389])\r\n    }),\r\n    (t.geoConicEquidistantRaw = Gs),\r\n    (t.geoEqualEarth = function () {\r\n      return Ps(Js).scale(177.158)\r\n    }),\r\n    (t.geoEqualEarthRaw = Js),\r\n    (t.geoEquirectangular = function () {\r\n      return Ps(Xs).scale(152.63)\r\n    }),\r\n    (t.geoEquirectangularRaw = Xs),\r\n    (t.geoGnomonic = function () {\r\n      return Ps(Ks)\r\n        .scale(144.049)\r\n        .clipAngle(60)\r\n    }),\r\n    (t.geoGnomonicRaw = Ks),\r\n    (t.geoIdentity = function () {\r\n      var t,\r\n        n,\r\n        e,\r\n        r,\r\n        i,\r\n        o,\r\n        a = 1,\r\n        u = 0,\r\n        c = 0,\r\n        f = 1,\r\n        s = 1,\r\n        l = xf,\r\n        h = null,\r\n        d = xf\r\n      function p () {\r\n        return (r = i = null), o\r\n      }\r\n      return (o = {\r\n        stream: function (t) {\r\n          return r && i === t ? r : (r = l(d((i = t))))\r\n        },\r\n        postclip: function (r) {\r\n          return arguments.length ? ((d = r), (h = t = n = e = null), p()) : d\r\n        },\r\n        clipExtent: function (r) {\r\n          return arguments.length\r\n            ? ((d =\r\n                null == r\r\n                  ? ((h = t = n = e = null), xf)\r\n                  : Zc((h = +r[0][0]), (t = +r[0][1]), (n = +r[1][0]), (e = +r[1][1]))),\r\n              p())\r\n            : null == h\r\n            ? null\r\n            : [[h, t], [n, e]]\r\n        },\r\n        scale: function (t) {\r\n          return arguments.length ? ((l = tl((a = +t) * f, a * s, u, c)), p()) : a\r\n        },\r\n        translate: function (t) {\r\n          return arguments.length ? ((l = tl(a * f, a * s, (u = +t[0]), (c = +t[1]))), p()) : [u, c]\r\n        },\r\n        reflectX: function (t) {\r\n          return arguments.length ? ((l = tl(a * (f = t ? -1 : 1), a * s, u, c)), p()) : f < 0\r\n        },\r\n        reflectY: function (t) {\r\n          return arguments.length ? ((l = tl(a * f, a * (s = t ? -1 : 1), u, c)), p()) : s < 0\r\n        },\r\n        fitExtent: function (t, n) {\r\n          return ws(o, t, n)\r\n        },\r\n        fitSize: function (t, n) {\r\n          return Ms(o, t, n)\r\n        },\r\n        fitWidth: function (t, n) {\r\n          return Ns(o, t, n)\r\n        },\r\n        fitHeight: function (t, n) {\r\n          return As(o, t, n)\r\n        }\r\n      })\r\n    }),\r\n    (t.geoProjection = Ps),\r\n    (t.geoProjectionMutator = zs),\r\n    (t.geoMercator = function () {\r\n      return Is(Fs).scale(961 / Fa)\r\n    }),\r\n    (t.geoMercatorRaw = Fs),\r\n    (t.geoNaturalEarth1 = function () {\r\n      return Ps(nl).scale(175.295)\r\n    }),\r\n    (t.geoNaturalEarth1Raw = nl),\r\n    (t.geoOrthographic = function () {\r\n      return Ps(el)\r\n        .scale(249.5)\r\n        .clipAngle(90 + La)\r\n    }),\r\n    (t.geoOrthographicRaw = el),\r\n    (t.geoStereographic = function () {\r\n      return Ps(rl)\r\n        .scale(250)\r\n        .clipAngle(142)\r\n    }),\r\n    (t.geoStereographicRaw = rl),\r\n    (t.geoTransverseMercator = function () {\r\n      var t = Is(il),\r\n        n = t.center,\r\n        e = t.rotate\r\n      return (\r\n        (t.center = function (t) {\r\n          return arguments.length ? n([-t[1], t[0]]) : [(t = n())[1], -t[0]]\r\n        }),\r\n        (t.rotate = function (t) {\r\n          return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = e())[0], t[1], t[2] - 90]\r\n        }),\r\n        e([0, 0, 90]).scale(159.155)\r\n      )\r\n    }),\r\n    (t.geoTransverseMercatorRaw = il),\r\n    (t.geoRotation = Rc),\r\n    (t.geoStream = lu),\r\n    (t.geoTransform = function (t) {\r\n      return { stream: bs(t) }\r\n    }),\r\n    (t.cluster = function () {\r\n      var t = ol,\r\n        n = 1,\r\n        e = 1,\r\n        r = !1\r\n      function i (i) {\r\n        var o,\r\n          a = 0\r\n        i.eachAfter(function (n) {\r\n          var e = n.children\r\n          e\r\n            ? ((n.x = (function (t) {\r\n                return t.reduce(al, 0) / t.length\r\n              })(e)),\r\n              (n.y = (function (t) {\r\n                return 1 + t.reduce(ul, 0)\r\n              })(e)))\r\n            : ((n.x = o ? (a += t(n, o)) : 0), (n.y = 0), (o = n))\r\n        })\r\n        var u = (function (t) {\r\n            for (var n; (n = t.children); ) t = n[0]\r\n            return t\r\n          })(i),\r\n          c = (function (t) {\r\n            for (var n; (n = t.children); ) t = n[n.length - 1]\r\n            return t\r\n          })(i),\r\n          f = u.x - t(u, c) / 2,\r\n          s = c.x + t(c, u) / 2\r\n        return i.eachAfter(\r\n          r\r\n            ? function (t) {\r\n                ;(t.x = (t.x - i.x) * n), (t.y = (i.y - t.y) * e)\r\n              }\r\n            : function (t) {\r\n                ;(t.x = ((t.x - f) / (s - f)) * n), (t.y = (1 - (i.y ? t.y / i.y : 1)) * e)\r\n              }\r\n        )\r\n      }\r\n      return (\r\n        (i.separation = function (n) {\r\n          return arguments.length ? ((t = n), i) : t\r\n        }),\r\n        (i.size = function (t) {\r\n          return arguments.length ? ((r = !1), (n = +t[0]), (e = +t[1]), i) : r ? null : [n, e]\r\n        }),\r\n        (i.nodeSize = function (t) {\r\n          return arguments.length ? ((r = !0), (n = +t[0]), (e = +t[1]), i) : r ? [n, e] : null\r\n        }),\r\n        i\r\n      )\r\n    }),\r\n    (t.hierarchy = fl),\r\n    (t.pack = function () {\r\n      var t = null,\r\n        n = 1,\r\n        e = 1,\r\n        r = El\r\n      function i (i) {\r\n        return (\r\n          (i.x = n / 2),\r\n          (i.y = e / 2),\r\n          t\r\n            ? i\r\n                .eachBefore(zl(t))\r\n                .eachAfter(Rl(r, 0.5))\r\n                .eachBefore(Dl(1))\r\n            : i\r\n                .eachBefore(zl(Pl))\r\n                .eachAfter(Rl(El, 1))\r\n                .eachAfter(Rl(r, i.r / Math.min(n, e)))\r\n                .eachBefore(Dl(Math.min(n, e) / (2 * i.r))),\r\n          i\r\n        )\r\n      }\r\n      return (\r\n        (i.radius = function (n) {\r\n          return arguments.length ? ((t = null == (e = n) ? null : Tl(e)), i) : t\r\n          var e\r\n        }),\r\n        (i.size = function (t) {\r\n          return arguments.length ? ((n = +t[0]), (e = +t[1]), i) : [n, e]\r\n        }),\r\n        (i.padding = function (t) {\r\n          return arguments.length ? ((r = 'function' == typeof t ? t : Cl(+t)), i) : r\r\n        }),\r\n        i\r\n      )\r\n    }),\r\n    (t.packSiblings = function (t) {\r\n      return kl(t), t\r\n    }),\r\n    (t.packEnclose = vl),\r\n    (t.partition = function () {\r\n      var t = 1,\r\n        n = 1,\r\n        e = 0,\r\n        r = !1\r\n      function i (i) {\r\n        var o = i.height + 1\r\n        return (\r\n          (i.x0 = i.y0 = e),\r\n          (i.x1 = t),\r\n          (i.y1 = n / o),\r\n          i.eachBefore(\r\n            (function (t, n) {\r\n              return function (r) {\r\n                r.children && Ll(r, r.x0, (t * (r.depth + 1)) / n, r.x1, (t * (r.depth + 2)) / n)\r\n                var i = r.x0,\r\n                  o = r.y0,\r\n                  a = r.x1 - e,\r\n                  u = r.y1 - e\r\n                a < i && (i = a = (i + a) / 2),\r\n                  u < o && (o = u = (o + u) / 2),\r\n                  (r.x0 = i),\r\n                  (r.y0 = o),\r\n                  (r.x1 = a),\r\n                  (r.y1 = u)\r\n              }\r\n            })(n, o)\r\n          ),\r\n          r && i.eachBefore(ql),\r\n          i\r\n        )\r\n      }\r\n      return (\r\n        (i.round = function (t) {\r\n          return arguments.length ? ((r = !!t), i) : r\r\n        }),\r\n        (i.size = function (e) {\r\n          return arguments.length ? ((t = +e[0]), (n = +e[1]), i) : [t, n]\r\n        }),\r\n        (i.padding = function (t) {\r\n          return arguments.length ? ((e = +t), i) : e\r\n        }),\r\n        i\r\n      )\r\n    }),\r\n    (t.stratify = function () {\r\n      var t = Yl,\r\n        n = Fl\r\n      function e (e) {\r\n        var r,\r\n          i,\r\n          o,\r\n          a,\r\n          u,\r\n          c,\r\n          f,\r\n          s = e.length,\r\n          l = new Array(s),\r\n          h = {}\r\n        for (i = 0; i < s; ++i)\r\n          (r = e[i]),\r\n            (u = l[i] = new dl(r)),\r\n            null != (c = t(r, i, e)) && (c += '') && (h[(f = Ul + (u.id = c))] = f in h ? Bl : u)\r\n        for (i = 0; i < s; ++i)\r\n          if (((u = l[i]), null != (c = n(e[i], i, e)) && (c += ''))) {\r\n            if (!(a = h[Ul + c])) throw new Error('missing: ' + c)\r\n            if (a === Bl) throw new Error('ambiguous: ' + c)\r\n            a.children ? a.children.push(u) : (a.children = [u]), (u.parent = a)\r\n          } else {\r\n            if (o) throw new Error('multiple roots')\r\n            o = u\r\n          }\r\n        if (!o) throw new Error('no root')\r\n        if (\r\n          ((o.parent = Ol),\r\n          o\r\n            .eachBefore(function (t) {\r\n              ;(t.depth = t.parent.depth + 1), --s\r\n            })\r\n            .eachBefore(hl),\r\n          (o.parent = null),\r\n          s > 0)\r\n        )\r\n          throw new Error('cycle')\r\n        return o\r\n      }\r\n      return (\r\n        (e.id = function (n) {\r\n          return arguments.length ? ((t = Tl(n)), e) : t\r\n        }),\r\n        (e.parentId = function (t) {\r\n          return arguments.length ? ((n = Tl(t)), e) : n\r\n        }),\r\n        e\r\n      )\r\n    }),\r\n    (t.tree = function () {\r\n      var t = Il,\r\n        n = 1,\r\n        e = 1,\r\n        r = null\r\n      function i (i) {\r\n        var c = (function (t) {\r\n          for (var n, e, r, i, o, a = new Vl(t, 0), u = [a]; (n = u.pop()); )\r\n            if ((r = n._.children))\r\n              for (n.children = new Array((o = r.length)), i = o - 1; i >= 0; --i)\r\n                u.push((e = n.children[i] = new Vl(r[i], i))), (e.parent = n)\r\n          return ((a.parent = new Vl(null, 0)).children = [a]), a\r\n        })(i)\r\n        if ((c.eachAfter(o), (c.parent.m = -c.z), c.eachBefore(a), r)) i.eachBefore(u)\r\n        else {\r\n          var f = i,\r\n            s = i,\r\n            l = i\r\n          i.eachBefore(function (t) {\r\n            t.x < f.x && (f = t), t.x > s.x && (s = t), t.depth > l.depth && (l = t)\r\n          })\r\n          var h = f === s ? 1 : t(f, s) / 2,\r\n            d = h - f.x,\r\n            p = n / (s.x + h + d),\r\n            v = e / (l.depth || 1)\r\n          i.eachBefore(function (t) {\r\n            ;(t.x = (t.x + d) * p), (t.y = t.depth * v)\r\n          })\r\n        }\r\n        return i\r\n      }\r\n      function o (n) {\r\n        var e = n.children,\r\n          r = n.parent.children,\r\n          i = n.i ? r[n.i - 1] : null\r\n        if (e) {\r\n          !(function (t) {\r\n            for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0; )\r\n              ((n = i[o]).z += e), (n.m += e), (e += n.s + (r += n.c))\r\n          })(n)\r\n          var o = (e[0].z + e[e.length - 1].z) / 2\r\n          i ? ((n.z = i.z + t(n._, i._)), (n.m = n.z - o)) : (n.z = o)\r\n        } else i && (n.z = i.z + t(n._, i._))\r\n        n.parent.A = (function (n, e, r) {\r\n          if (e) {\r\n            for (\r\n              var i, o = n, a = n, u = e, c = o.parent.children[0], f = o.m, s = a.m, l = u.m, h = c.m;\r\n              (u = Hl(u)), (o = jl(o)), u && o;\r\n\r\n            )\r\n              (c = jl(c)),\r\n                ((a = Hl(a)).a = n),\r\n                (i = u.z + l - o.z - f + t(u._, o._)) > 0 && (Xl(Gl(u, n, r), n, i), (f += i), (s += i)),\r\n                (l += u.m),\r\n                (f += o.m),\r\n                (h += c.m),\r\n                (s += a.m)\r\n            u && !Hl(a) && ((a.t = u), (a.m += l - s)), o && !jl(c) && ((c.t = o), (c.m += f - h), (r = n))\r\n          }\r\n          return r\r\n        })(n, i, n.parent.A || r[0])\r\n      }\r\n      function a (t) {\r\n        ;(t._.x = t.z + t.parent.m), (t.m += t.parent.m)\r\n      }\r\n      function u (t) {\r\n        ;(t.x *= n), (t.y = t.depth * e)\r\n      }\r\n      return (\r\n        (i.separation = function (n) {\r\n          return arguments.length ? ((t = n), i) : t\r\n        }),\r\n        (i.size = function (t) {\r\n          return arguments.length ? ((r = !1), (n = +t[0]), (e = +t[1]), i) : r ? null : [n, e]\r\n        }),\r\n        (i.nodeSize = function (t) {\r\n          return arguments.length ? ((r = !0), (n = +t[0]), (e = +t[1]), i) : r ? [n, e] : null\r\n        }),\r\n        i\r\n      )\r\n    }),\r\n    (t.treemap = function () {\r\n      var t = Ql,\r\n        n = !1,\r\n        e = 1,\r\n        r = 1,\r\n        i = [0],\r\n        o = El,\r\n        a = El,\r\n        u = El,\r\n        c = El,\r\n        f = El\r\n      function s (t) {\r\n        return (t.x0 = t.y0 = 0), (t.x1 = e), (t.y1 = r), t.eachBefore(l), (i = [0]), n && t.eachBefore(ql), t\r\n      }\r\n      function l (n) {\r\n        var e = i[n.depth],\r\n          r = n.x0 + e,\r\n          s = n.y0 + e,\r\n          l = n.x1 - e,\r\n          h = n.y1 - e\r\n        l < r && (r = l = (r + l) / 2),\r\n          h < s && (s = h = (s + h) / 2),\r\n          (n.x0 = r),\r\n          (n.y0 = s),\r\n          (n.x1 = l),\r\n          (n.y1 = h),\r\n          n.children &&\r\n            ((e = i[n.depth + 1] = o(n) / 2),\r\n            (r += f(n) - e),\r\n            (s += a(n) - e),\r\n            (l -= u(n) - e) < r && (r = l = (r + l) / 2),\r\n            (h -= c(n) - e) < s && (s = h = (s + h) / 2),\r\n            t(n, r, s, l, h))\r\n      }\r\n      return (\r\n        (s.round = function (t) {\r\n          return arguments.length ? ((n = !!t), s) : n\r\n        }),\r\n        (s.size = function (t) {\r\n          return arguments.length ? ((e = +t[0]), (r = +t[1]), s) : [e, r]\r\n        }),\r\n        (s.tile = function (n) {\r\n          return arguments.length ? ((t = Tl(n)), s) : t\r\n        }),\r\n        (s.padding = function (t) {\r\n          return arguments.length ? s.paddingInner(t).paddingOuter(t) : s.paddingInner()\r\n        }),\r\n        (s.paddingInner = function (t) {\r\n          return arguments.length ? ((o = 'function' == typeof t ? t : Cl(+t)), s) : o\r\n        }),\r\n        (s.paddingOuter = function (t) {\r\n          return arguments.length\r\n            ? s\r\n                .paddingTop(t)\r\n                .paddingRight(t)\r\n                .paddingBottom(t)\r\n                .paddingLeft(t)\r\n            : s.paddingTop()\r\n        }),\r\n        (s.paddingTop = function (t) {\r\n          return arguments.length ? ((a = 'function' == typeof t ? t : Cl(+t)), s) : a\r\n        }),\r\n        (s.paddingRight = function (t) {\r\n          return arguments.length ? ((u = 'function' == typeof t ? t : Cl(+t)), s) : u\r\n        }),\r\n        (s.paddingBottom = function (t) {\r\n          return arguments.length ? ((c = 'function' == typeof t ? t : Cl(+t)), s) : c\r\n        }),\r\n        (s.paddingLeft = function (t) {\r\n          return arguments.length ? ((f = 'function' == typeof t ? t : Cl(+t)), s) : f\r\n        }),\r\n        s\r\n      )\r\n    }),\r\n    (t.treemapBinary = function (t, n, e, r, i) {\r\n      var o,\r\n        a,\r\n        u = t.children,\r\n        c = u.length,\r\n        f = new Array(c + 1)\r\n      for (f[0] = a = o = 0; o < c; ++o) f[o + 1] = a += u[o].value\r\n      !(function t (n, e, r, i, o, a, c) {\r\n        if (n >= e - 1) {\r\n          var s = u[n]\r\n          return (s.x0 = i), (s.y0 = o), (s.x1 = a), void (s.y1 = c)\r\n        }\r\n        for (var l = f[n], h = r / 2 + l, d = n + 1, p = e - 1; d < p; ) {\r\n          var v = (d + p) >>> 1\r\n          f[v] < h ? (d = v + 1) : (p = v)\r\n        }\r\n        h - f[d - 1] < f[d] - h && n + 1 < d && --d\r\n        var g = f[d] - l,\r\n          y = r - g\r\n        if (a - i > c - o) {\r\n          var _ = (i * y + a * g) / r\r\n          t(n, d, g, i, o, _, c), t(d, e, y, _, o, a, c)\r\n        } else {\r\n          var b = (o * y + c * g) / r\r\n          t(n, d, g, i, o, a, b), t(d, e, y, i, b, a, c)\r\n        }\r\n      })(0, c, t.value, n, e, r, i)\r\n    }),\r\n    (t.treemapDice = Ll),\r\n    (t.treemapSlice = $l),\r\n    (t.treemapSliceDice = function (t, n, e, r, i) {\r\n      ;(1 & t.depth ? $l : Ll)(t, n, e, r, i)\r\n    }),\r\n    (t.treemapSquarify = Ql),\r\n    (t.treemapResquarify = Jl),\r\n    (t.interpolate = ye),\r\n    (t.interpolateArray = se),\r\n    (t.interpolateBasis = Kn),\r\n    (t.interpolateBasisClosed = te),\r\n    (t.interpolateDate = le),\r\n    (t.interpolateDiscrete = function (t) {\r\n      var n = t.length\r\n      return function (e) {\r\n        return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))]\r\n      }\r\n    }),\r\n    (t.interpolateHue = function (t, n) {\r\n      var e = re(+t, +n)\r\n      return function (t) {\r\n        var n = e(t)\r\n        return n - 360 * Math.floor(n / 360)\r\n      }\r\n    }),\r\n    (t.interpolateNumber = he),\r\n    (t.interpolateObject = de),\r\n    (t.interpolateRound = _e),\r\n    (t.interpolateString = ge),\r\n    (t.interpolateTransformCss = ke),\r\n    (t.interpolateTransformSvg = Te),\r\n    (t.interpolateZoom = De),\r\n    (t.interpolateRgb = ae),\r\n    (t.interpolateRgbBasis = ce),\r\n    (t.interpolateRgbBasisClosed = fe),\r\n    (t.interpolateHsl = Le),\r\n    (t.interpolateHslLong = Ue),\r\n    (t.interpolateLab = function (t, n) {\r\n      var e = oe((t = Rn(t)).l, (n = Rn(n)).l),\r\n        r = oe(t.a, n.a),\r\n        i = oe(t.b, n.b),\r\n        o = oe(t.opacity, n.opacity)\r\n      return function (n) {\r\n        return (t.l = e(n)), (t.a = r(n)), (t.b = i(n)), (t.opacity = o(n)), t + ''\r\n      }\r\n    }),\r\n    (t.interpolateHcl = Be),\r\n    (t.interpolateHclLong = Ye),\r\n    (t.interpolateCubehelix = Ie),\r\n    (t.interpolateCubehelixLong = je),\r\n    (t.piecewise = function (t, n) {\r\n      for (var e = 0, r = n.length - 1, i = n[0], o = new Array(r < 0 ? 0 : r); e < r; ) o[e] = t(i, (i = n[++e]))\r\n      return function (t) {\r\n        var n = Math.max(0, Math.min(r - 1, Math.floor((t *= r))))\r\n        return o[n](t - n)\r\n      }\r\n    }),\r\n    (t.quantize = function (t, n) {\r\n      for (var e = new Array(n), r = 0; r < n; ++r) e[r] = t(r / (n - 1))\r\n      return e\r\n    }),\r\n    (t.path = Hi),\r\n    (t.polygonArea = function (t) {\r\n      for (var n, e = -1, r = t.length, i = t[r - 1], o = 0; ++e < r; )\r\n        (n = i), (i = t[e]), (o += n[1] * i[0] - n[0] * i[1])\r\n      return o / 2\r\n    }),\r\n    (t.polygonCentroid = function (t) {\r\n      for (var n, e, r = -1, i = t.length, o = 0, a = 0, u = t[i - 1], c = 0; ++r < i; )\r\n        (n = u), (u = t[r]), (c += e = n[0] * u[1] - u[0] * n[1]), (o += (n[0] + u[0]) * e), (a += (n[1] + u[1]) * e)\r\n      return [o / (c *= 3), a / c]\r\n    }),\r\n    (t.polygonHull = function (t) {\r\n      if ((e = t.length) < 3) return null\r\n      var n,\r\n        e,\r\n        r = new Array(e),\r\n        i = new Array(e)\r\n      for (n = 0; n < e; ++n) r[n] = [+t[n][0], +t[n][1], n]\r\n      for (r.sort(Kl), n = 0; n < e; ++n) i[n] = [r[n][0], -r[n][1]]\r\n      var o = th(r),\r\n        a = th(i),\r\n        u = a[0] === o[0],\r\n        c = a[a.length - 1] === o[o.length - 1],\r\n        f = []\r\n      for (n = o.length - 1; n >= 0; --n) f.push(t[r[o[n]][2]])\r\n      for (n = +u; n < a.length - c; ++n) f.push(t[r[a[n]][2]])\r\n      return f\r\n    }),\r\n    (t.polygonContains = function (t, n) {\r\n      for (var e, r, i = t.length, o = t[i - 1], a = n[0], u = n[1], c = o[0], f = o[1], s = !1, l = 0; l < i; ++l)\r\n        (e = (o = t[l])[0]),\r\n          (r = o[1]) > u != f > u && a < ((c - e) * (u - r)) / (f - r) + e && (s = !s),\r\n          (c = e),\r\n          (f = r)\r\n      return s\r\n    }),\r\n    (t.polygonLength = function (t) {\r\n      for (var n, e, r = -1, i = t.length, o = t[i - 1], a = o[0], u = o[1], c = 0; ++r < i; )\r\n        (n = a), (e = u), (n -= a = (o = t[r])[0]), (e -= u = o[1]), (c += Math.sqrt(n * n + e * e))\r\n      return c\r\n    }),\r\n    (t.quadtree = ia),\r\n    (t.randomUniform = eh),\r\n    (t.randomNormal = rh),\r\n    (t.randomLogNormal = ih),\r\n    (t.randomBates = ah),\r\n    (t.randomIrwinHall = oh),\r\n    (t.randomExponential = uh),\r\n    (t.scaleBand = vh),\r\n    (t.scalePoint = function () {\r\n      return (function t (n) {\r\n        var e = n.copy\r\n        return (\r\n          (n.padding = n.paddingOuter),\r\n          delete n.paddingInner,\r\n          delete n.paddingOuter,\r\n          (n.copy = function () {\r\n            return t(e())\r\n          }),\r\n          n\r\n        )\r\n      })(vh.apply(null, arguments).paddingInner(1))\r\n    }),\r\n    (t.scaleIdentity = function t (n) {\r\n      var e\r\n      function r (t) {\r\n        return isNaN((t = +t)) ? e : t\r\n      }\r\n      return (\r\n        (r.invert = r),\r\n        (r.domain = r.range = function (t) {\r\n          return arguments.length ? ((n = lh.call(t, gh)), r) : n.slice()\r\n        }),\r\n        (r.unknown = function (t) {\r\n          return arguments.length ? ((e = t), r) : e\r\n        }),\r\n        (r.copy = function () {\r\n          return t(n).unknown(e)\r\n        }),\r\n        (n = arguments.length ? lh.call(n, gh) : [0, 1]),\r\n        kh(r)\r\n      )\r\n    }),\r\n    (t.scaleLinear = function t () {\r\n      var n = Ah(_h, _h)\r\n      return (\r\n        (n.copy = function () {\r\n          return Mh(n, t())\r\n        }),\r\n        ch.apply(n, arguments),\r\n        kh(n)\r\n      )\r\n    }),\r\n    (t.scaleLog = function t () {\r\n      var n = qh(Nh()).domain([1, 10])\r\n      return (\r\n        (n.copy = function () {\r\n          return Mh(n, t()).base(n.base())\r\n        }),\r\n        ch.apply(n, arguments),\r\n        n\r\n      )\r\n    }),\r\n    (t.scaleSymlog = function t () {\r\n      var n = Oh(Nh())\r\n      return (\r\n        (n.copy = function () {\r\n          return Mh(n, t()).constant(n.constant())\r\n        }),\r\n        ch.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.scaleOrdinal = ph),\r\n    (t.scaleImplicit = dh),\r\n    (t.scalePow = jh),\r\n    (t.scaleSqrt = function () {\r\n      return jh.apply(null, arguments).exponent(0.5)\r\n    }),\r\n    (t.scaleQuantile = function t () {\r\n      var e,\r\n        r = [],\r\n        o = [],\r\n        a = []\r\n      function u () {\r\n        var t = 0,\r\n          n = Math.max(1, o.length)\r\n        for (a = new Array(n - 1); ++t < n; ) a[t - 1] = N(r, t / n)\r\n        return c\r\n      }\r\n      function c (t) {\r\n        return isNaN((t = +t)) ? e : o[i(a, t)]\r\n      }\r\n      return (\r\n        (c.invertExtent = function (t) {\r\n          var n = o.indexOf(t)\r\n          return n < 0 ? [NaN, NaN] : [n > 0 ? a[n - 1] : r[0], n < a.length ? a[n] : r[r.length - 1]]\r\n        }),\r\n        (c.domain = function (t) {\r\n          if (!arguments.length) return r.slice()\r\n          r = []\r\n          for (var e, i = 0, o = t.length; i < o; ++i) null == (e = t[i]) || isNaN((e = +e)) || r.push(e)\r\n          return r.sort(n), u()\r\n        }),\r\n        (c.range = function (t) {\r\n          return arguments.length ? ((o = hh.call(t)), u()) : o.slice()\r\n        }),\r\n        (c.unknown = function (t) {\r\n          return arguments.length ? ((e = t), c) : e\r\n        }),\r\n        (c.quantiles = function () {\r\n          return a.slice()\r\n        }),\r\n        (c.copy = function () {\r\n          return t()\r\n            .domain(r)\r\n            .range(o)\r\n            .unknown(e)\r\n        }),\r\n        ch.apply(c, arguments)\r\n      )\r\n    }),\r\n    (t.scaleQuantize = function t () {\r\n      var n,\r\n        e = 0,\r\n        r = 1,\r\n        o = 1,\r\n        a = [0.5],\r\n        u = [0, 1]\r\n      function c (t) {\r\n        return t <= t ? u[i(a, t, 0, o)] : n\r\n      }\r\n      function f () {\r\n        var t = -1\r\n        for (a = new Array(o); ++t < o; ) a[t] = ((t + 1) * r - (t - o) * e) / (o + 1)\r\n        return c\r\n      }\r\n      return (\r\n        (c.domain = function (t) {\r\n          return arguments.length ? ((e = +t[0]), (r = +t[1]), f()) : [e, r]\r\n        }),\r\n        (c.range = function (t) {\r\n          return arguments.length ? ((o = (u = hh.call(t)).length - 1), f()) : u.slice()\r\n        }),\r\n        (c.invertExtent = function (t) {\r\n          var n = u.indexOf(t)\r\n          return n < 0 ? [NaN, NaN] : n < 1 ? [e, a[0]] : n >= o ? [a[o - 1], r] : [a[n - 1], a[n]]\r\n        }),\r\n        (c.unknown = function (t) {\r\n          return arguments.length ? ((n = t), c) : c\r\n        }),\r\n        (c.thresholds = function () {\r\n          return a.slice()\r\n        }),\r\n        (c.copy = function () {\r\n          return t()\r\n            .domain([e, r])\r\n            .range(u)\r\n            .unknown(n)\r\n        }),\r\n        ch.apply(kh(c), arguments)\r\n      )\r\n    }),\r\n    (t.scaleThreshold = function t () {\r\n      var n,\r\n        e = [0.5],\r\n        r = [0, 1],\r\n        o = 1\r\n      function a (t) {\r\n        return t <= t ? r[i(e, t, 0, o)] : n\r\n      }\r\n      return (\r\n        (a.domain = function (t) {\r\n          return arguments.length ? ((e = hh.call(t)), (o = Math.min(e.length, r.length - 1)), a) : e.slice()\r\n        }),\r\n        (a.range = function (t) {\r\n          return arguments.length ? ((r = hh.call(t)), (o = Math.min(e.length, r.length - 1)), a) : r.slice()\r\n        }),\r\n        (a.invertExtent = function (t) {\r\n          var n = r.indexOf(t)\r\n          return [e[n - 1], e[n]]\r\n        }),\r\n        (a.unknown = function (t) {\r\n          return arguments.length ? ((n = t), a) : n\r\n        }),\r\n        (a.copy = function () {\r\n          return t()\r\n            .domain(e)\r\n            .range(r)\r\n            .unknown(n)\r\n        }),\r\n        ch.apply(a, arguments)\r\n      )\r\n    }),\r\n    (t.scaleTime = function () {\r\n      return ch.apply(\r\n        wv(wd, md, ad, rd, nd, Kh, Qh, Vh, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]),\r\n        arguments\r\n      )\r\n    }),\r\n    (t.scaleUtc = function () {\r\n      return ch.apply(\r\n        wv(Vd, Xd, Pd, Td, Sd, Nd, Qh, Vh, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]),\r\n        arguments\r\n      )\r\n    }),\r\n    (t.scaleSequential = function t () {\r\n      var n = kh(Mv()(_h))\r\n      return (\r\n        (n.copy = function () {\r\n          return Nv(n, t())\r\n        }),\r\n        fh.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.scaleSequentialLog = function t () {\r\n      var n = qh(Mv()).domain([1, 10])\r\n      return (\r\n        (n.copy = function () {\r\n          return Nv(n, t()).base(n.base())\r\n        }),\r\n        fh.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.scaleSequentialPow = Av),\r\n    (t.scaleSequentialSqrt = function () {\r\n      return Av.apply(null, arguments).exponent(0.5)\r\n    }),\r\n    (t.scaleSequentialSymlog = function t () {\r\n      var n = Oh(Mv())\r\n      return (\r\n        (n.copy = function () {\r\n          return Nv(n, t()).constant(n.constant())\r\n        }),\r\n        fh.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.scaleSequentialQuantile = function t () {\r\n      var e = [],\r\n        r = _h\r\n      function o (t) {\r\n        if (!isNaN((t = +t))) return r((i(e, t) - 1) / (e.length - 1))\r\n      }\r\n      return (\r\n        (o.domain = function (t) {\r\n          if (!arguments.length) return e.slice()\r\n          e = []\r\n          for (var r, i = 0, a = t.length; i < a; ++i) null == (r = t[i]) || isNaN((r = +r)) || e.push(r)\r\n          return e.sort(n), o\r\n        }),\r\n        (o.interpolator = function (t) {\r\n          return arguments.length ? ((r = t), o) : r\r\n        }),\r\n        (o.copy = function () {\r\n          return t(r).domain(e)\r\n        }),\r\n        fh.apply(o, arguments)\r\n      )\r\n    }),\r\n    (t.scaleDiverging = function t () {\r\n      var n = kh(Sv()(_h))\r\n      return (\r\n        (n.copy = function () {\r\n          return Nv(n, t())\r\n        }),\r\n        fh.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.scaleDivergingLog = function t () {\r\n      var n = qh(Sv()).domain([0.1, 1, 10])\r\n      return (\r\n        (n.copy = function () {\r\n          return Nv(n, t()).base(n.base())\r\n        }),\r\n        fh.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.scaleDivergingPow = kv),\r\n    (t.scaleDivergingSqrt = function () {\r\n      return kv.apply(null, arguments).exponent(0.5)\r\n    }),\r\n    (t.scaleDivergingSymlog = function t () {\r\n      var n = Oh(Sv())\r\n      return (\r\n        (n.copy = function () {\r\n          return Nv(n, t()).constant(n.constant())\r\n        }),\r\n        fh.apply(n, arguments)\r\n      )\r\n    }),\r\n    (t.tickFormat = Sh),\r\n    (t.schemeCategory10 = Ev),\r\n    (t.schemeAccent = Cv),\r\n    (t.schemeDark2 = Pv),\r\n    (t.schemePaired = zv),\r\n    (t.schemePastel1 = Rv),\r\n    (t.schemePastel2 = Dv),\r\n    (t.schemeSet1 = qv),\r\n    (t.schemeSet2 = Lv),\r\n    (t.schemeSet3 = Uv),\r\n    (t.interpolateBrBG = Yv),\r\n    (t.schemeBrBG = Bv),\r\n    (t.interpolatePRGn = Iv),\r\n    (t.schemePRGn = Fv),\r\n    (t.interpolatePiYG = Hv),\r\n    (t.schemePiYG = jv),\r\n    (t.interpolatePuOr = Gv),\r\n    (t.schemePuOr = Xv),\r\n    (t.interpolateRdBu = $v),\r\n    (t.schemeRdBu = Vv),\r\n    (t.interpolateRdGy = Zv),\r\n    (t.schemeRdGy = Wv),\r\n    (t.interpolateRdYlBu = Jv),\r\n    (t.schemeRdYlBu = Qv),\r\n    (t.interpolateRdYlGn = tg),\r\n    (t.schemeRdYlGn = Kv),\r\n    (t.interpolateSpectral = eg),\r\n    (t.schemeSpectral = ng),\r\n    (t.interpolateBuGn = ig),\r\n    (t.schemeBuGn = rg),\r\n    (t.interpolateBuPu = ag),\r\n    (t.schemeBuPu = og),\r\n    (t.interpolateGnBu = cg),\r\n    (t.schemeGnBu = ug),\r\n    (t.interpolateOrRd = sg),\r\n    (t.schemeOrRd = fg),\r\n    (t.interpolatePuBuGn = hg),\r\n    (t.schemePuBuGn = lg),\r\n    (t.interpolatePuBu = pg),\r\n    (t.schemePuBu = dg),\r\n    (t.interpolatePuRd = gg),\r\n    (t.schemePuRd = vg),\r\n    (t.interpolateRdPu = _g),\r\n    (t.schemeRdPu = yg),\r\n    (t.interpolateYlGnBu = mg),\r\n    (t.schemeYlGnBu = bg),\r\n    (t.interpolateYlGn = wg),\r\n    (t.schemeYlGn = xg),\r\n    (t.interpolateYlOrBr = Ng),\r\n    (t.schemeYlOrBr = Mg),\r\n    (t.interpolateYlOrRd = Sg),\r\n    (t.schemeYlOrRd = Ag),\r\n    (t.interpolateBlues = Tg),\r\n    (t.schemeBlues = kg),\r\n    (t.interpolateGreens = Cg),\r\n    (t.schemeGreens = Eg),\r\n    (t.interpolateGreys = zg),\r\n    (t.schemeGreys = Pg),\r\n    (t.interpolatePurples = Dg),\r\n    (t.schemePurples = Rg),\r\n    (t.interpolateReds = Lg),\r\n    (t.schemeReds = qg),\r\n    (t.interpolateOranges = Og),\r\n    (t.schemeOranges = Ug),\r\n    (t.interpolateCubehelixDefault = Bg),\r\n    (t.interpolateRainbow = function (t) {\r\n      ;(t < 0 || t > 1) && (t -= Math.floor(t))\r\n      var n = Math.abs(t - 0.5)\r\n      return (Ig.h = 360 * t - 100), (Ig.s = 1.5 - 1.5 * n), (Ig.l = 0.8 - 0.9 * n), Ig + ''\r\n    }),\r\n    (t.interpolateWarm = Yg),\r\n    (t.interpolateCool = Fg),\r\n    (t.interpolateSinebow = function (t) {\r\n      var n\r\n      return (\r\n        (t = (0.5 - t) * Math.PI),\r\n        (jg.r = 255 * (n = Math.sin(t)) * n),\r\n        (jg.g = 255 * (n = Math.sin(t + Hg)) * n),\r\n        (jg.b = 255 * (n = Math.sin(t + Xg)) * n),\r\n        jg + ''\r\n      )\r\n    }),\r\n    (t.interpolateViridis = Vg),\r\n    (t.interpolateMagma = $g),\r\n    (t.interpolateInferno = Wg),\r\n    (t.interpolatePlasma = Zg),\r\n    (t.create = function (t) {\r\n      return zt(W(t).call(document.documentElement))\r\n    }),\r\n    (t.creator = W),\r\n    (t.local = Dt),\r\n    (t.matcher = tt),\r\n    (t.mouse = Ot),\r\n    (t.namespace = $),\r\n    (t.namespaces = V),\r\n    (t.clientPoint = Ut),\r\n    (t.select = zt),\r\n    (t.selectAll = function (t) {\r\n      return 'string' == typeof t\r\n        ? new Ct([document.querySelectorAll(t)], [document.documentElement])\r\n        : new Ct([null == t ? [] : t], Et)\r\n    }),\r\n    (t.selection = Pt),\r\n    (t.selector = Q),\r\n    (t.selectorAll = K),\r\n    (t.style = ct),\r\n    (t.touch = Bt),\r\n    (t.touches = function (t, n) {\r\n      null == n && (n = Lt().touches)\r\n      for (var e = 0, r = n ? n.length : 0, i = new Array(r); e < r; ++e) i[e] = Ut(t, n[e])\r\n      return i\r\n    }),\r\n    (t.window = ut),\r\n    (t.customEvent = kt),\r\n    (t.arc = function () {\r\n      var t = sy,\r\n        n = ly,\r\n        e = Qg(0),\r\n        r = null,\r\n        i = hy,\r\n        o = dy,\r\n        a = py,\r\n        u = null\r\n      function c () {\r\n        var c,\r\n          f,\r\n          s,\r\n          l = +t.apply(this, arguments),\r\n          h = +n.apply(this, arguments),\r\n          d = i.apply(this, arguments) - uy,\r\n          p = o.apply(this, arguments) - uy,\r\n          v = Jg(p - d),\r\n          g = p > d\r\n        if ((u || (u = c = Hi()), h < l && ((f = h), (h = l), (l = f)), h > oy))\r\n          if (v > cy - oy)\r\n            u.moveTo(h * ty(d), h * ry(d)),\r\n              u.arc(0, 0, h, d, p, !g),\r\n              l > oy && (u.moveTo(l * ty(p), l * ry(p)), u.arc(0, 0, l, p, d, g))\r\n          else {\r\n            var y,\r\n              _,\r\n              b = d,\r\n              m = p,\r\n              x = d,\r\n              w = p,\r\n              M = v,\r\n              N = v,\r\n              A = a.apply(this, arguments) / 2,\r\n              S = A > oy && (r ? +r.apply(this, arguments) : iy(l * l + h * h)),\r\n              k = ey(Jg(h - l) / 2, +e.apply(this, arguments)),\r\n              T = k,\r\n              E = k\r\n            if (S > oy) {\r\n              var C = fy((S / l) * ry(A)),\r\n                P = fy((S / h) * ry(A))\r\n              ;(M -= 2 * C) > oy ? ((x += C *= g ? 1 : -1), (w -= C)) : ((M = 0), (x = w = (d + p) / 2)),\r\n                (N -= 2 * P) > oy ? ((b += P *= g ? 1 : -1), (m -= P)) : ((N = 0), (b = m = (d + p) / 2))\r\n            }\r\n            var z = h * ty(b),\r\n              R = h * ry(b),\r\n              D = l * ty(w),\r\n              q = l * ry(w)\r\n            if (k > oy) {\r\n              var L,\r\n                U = h * ty(m),\r\n                O = h * ry(m),\r\n                B = l * ty(x),\r\n                Y = l * ry(x)\r\n              if (\r\n                v < ay &&\r\n                (L = (function (t, n, e, r, i, o, a, u) {\r\n                  var c = e - t,\r\n                    f = r - n,\r\n                    s = a - i,\r\n                    l = u - o,\r\n                    h = l * c - s * f\r\n                  if (!(h * h < oy)) return [t + (h = (s * (n - o) - l * (t - i)) / h) * c, n + h * f]\r\n                })(z, R, B, Y, U, O, D, q))\r\n              ) {\r\n                var F = z - L[0],\r\n                  I = R - L[1],\r\n                  j = U - L[0],\r\n                  H = O - L[1],\r\n                  X =\r\n                    1 /\r\n                    ry(\r\n                      ((s = (F * j + I * H) / (iy(F * F + I * I) * iy(j * j + H * H))) > 1\r\n                        ? 0\r\n                        : s < -1\r\n                        ? ay\r\n                        : Math.acos(s)) / 2\r\n                    ),\r\n                  G = iy(L[0] * L[0] + L[1] * L[1])\r\n                ;(T = ey(k, (l - G) / (X - 1))), (E = ey(k, (h - G) / (X + 1)))\r\n              }\r\n            }\r\n            N > oy\r\n              ? E > oy\r\n                ? ((y = vy(B, Y, z, R, h, E, g)),\r\n                  (_ = vy(U, O, D, q, h, E, g)),\r\n                  u.moveTo(y.cx + y.x01, y.cy + y.y01),\r\n                  E < k\r\n                    ? u.arc(y.cx, y.cy, E, Kg(y.y01, y.x01), Kg(_.y01, _.x01), !g)\r\n                    : (u.arc(y.cx, y.cy, E, Kg(y.y01, y.x01), Kg(y.y11, y.x11), !g),\r\n                      u.arc(0, 0, h, Kg(y.cy + y.y11, y.cx + y.x11), Kg(_.cy + _.y11, _.cx + _.x11), !g),\r\n                      u.arc(_.cx, _.cy, E, Kg(_.y11, _.x11), Kg(_.y01, _.x01), !g)))\r\n                : (u.moveTo(z, R), u.arc(0, 0, h, b, m, !g))\r\n              : u.moveTo(z, R),\r\n              l > oy && M > oy\r\n                ? T > oy\r\n                  ? ((y = vy(D, q, U, O, l, -T, g)),\r\n                    (_ = vy(z, R, B, Y, l, -T, g)),\r\n                    u.lineTo(y.cx + y.x01, y.cy + y.y01),\r\n                    T < k\r\n                      ? u.arc(y.cx, y.cy, T, Kg(y.y01, y.x01), Kg(_.y01, _.x01), !g)\r\n                      : (u.arc(y.cx, y.cy, T, Kg(y.y01, y.x01), Kg(y.y11, y.x11), !g),\r\n                        u.arc(0, 0, l, Kg(y.cy + y.y11, y.cx + y.x11), Kg(_.cy + _.y11, _.cx + _.x11), g),\r\n                        u.arc(_.cx, _.cy, T, Kg(_.y11, _.x11), Kg(_.y01, _.x01), !g)))\r\n                  : u.arc(0, 0, l, w, x, g)\r\n                : u.lineTo(D, q)\r\n          }\r\n        else u.moveTo(0, 0)\r\n        if ((u.closePath(), c)) return (u = null), c + '' || null\r\n      }\r\n      return (\r\n        (c.centroid = function () {\r\n          var e = (+t.apply(this, arguments) + +n.apply(this, arguments)) / 2,\r\n            r = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - ay / 2\r\n          return [ty(r) * e, ry(r) * e]\r\n        }),\r\n        (c.innerRadius = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), c) : t\r\n        }),\r\n        (c.outerRadius = function (t) {\r\n          return arguments.length ? ((n = 'function' == typeof t ? t : Qg(+t)), c) : n\r\n        }),\r\n        (c.cornerRadius = function (t) {\r\n          return arguments.length ? ((e = 'function' == typeof t ? t : Qg(+t)), c) : e\r\n        }),\r\n        (c.padRadius = function (t) {\r\n          return arguments.length ? ((r = null == t ? null : 'function' == typeof t ? t : Qg(+t)), c) : r\r\n        }),\r\n        (c.startAngle = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Qg(+t)), c) : i\r\n        }),\r\n        (c.endAngle = function (t) {\r\n          return arguments.length ? ((o = 'function' == typeof t ? t : Qg(+t)), c) : o\r\n        }),\r\n        (c.padAngle = function (t) {\r\n          return arguments.length ? ((a = 'function' == typeof t ? t : Qg(+t)), c) : a\r\n        }),\r\n        (c.context = function (t) {\r\n          return arguments.length ? ((u = null == t ? null : t), c) : u\r\n        }),\r\n        c\r\n      )\r\n    }),\r\n    (t.area = xy),\r\n    (t.line = my),\r\n    (t.pie = function () {\r\n      var t = My,\r\n        n = wy,\r\n        e = null,\r\n        r = Qg(0),\r\n        i = Qg(cy),\r\n        o = Qg(0)\r\n      function a (a) {\r\n        var u,\r\n          c,\r\n          f,\r\n          s,\r\n          l,\r\n          h = a.length,\r\n          d = 0,\r\n          p = new Array(h),\r\n          v = new Array(h),\r\n          g = +r.apply(this, arguments),\r\n          y = Math.min(cy, Math.max(-cy, i.apply(this, arguments) - g)),\r\n          _ = Math.min(Math.abs(y) / h, o.apply(this, arguments)),\r\n          b = _ * (y < 0 ? -1 : 1)\r\n        for (u = 0; u < h; ++u) (l = v[(p[u] = u)] = +t(a[u], u, a)) > 0 && (d += l)\r\n        for (\r\n          null != n\r\n            ? p.sort(function (t, e) {\r\n                return n(v[t], v[e])\r\n              })\r\n            : null != e &&\r\n              p.sort(function (t, n) {\r\n                return e(a[t], a[n])\r\n              }),\r\n            u = 0,\r\n            f = d ? (y - h * b) / d : 0;\r\n          u < h;\r\n          ++u, g = s\r\n        )\r\n          (c = p[u]),\r\n            (s = g + ((l = v[c]) > 0 ? l * f : 0) + b),\r\n            (v[c] = { data: a[c], index: u, value: l, startAngle: g, endAngle: s, padAngle: _ })\r\n        return v\r\n      }\r\n      return (\r\n        (a.value = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), a) : t\r\n        }),\r\n        (a.sortValues = function (t) {\r\n          return arguments.length ? ((n = t), (e = null), a) : n\r\n        }),\r\n        (a.sort = function (t) {\r\n          return arguments.length ? ((e = t), (n = null), a) : e\r\n        }),\r\n        (a.startAngle = function (t) {\r\n          return arguments.length ? ((r = 'function' == typeof t ? t : Qg(+t)), a) : r\r\n        }),\r\n        (a.endAngle = function (t) {\r\n          return arguments.length ? ((i = 'function' == typeof t ? t : Qg(+t)), a) : i\r\n        }),\r\n        (a.padAngle = function (t) {\r\n          return arguments.length ? ((o = 'function' == typeof t ? t : Qg(+t)), a) : o\r\n        }),\r\n        a\r\n      )\r\n    }),\r\n    (t.areaRadial = Ey),\r\n    (t.radialArea = Ey),\r\n    (t.lineRadial = Ty),\r\n    (t.radialLine = Ty),\r\n    (t.pointRadial = Cy),\r\n    (t.linkHorizontal = function () {\r\n      return Dy(qy)\r\n    }),\r\n    (t.linkVertical = function () {\r\n      return Dy(Ly)\r\n    }),\r\n    (t.linkRadial = function () {\r\n      var t = Dy(Uy)\r\n      return (t.angle = t.x), delete t.x, (t.radius = t.y), delete t.y, t\r\n    }),\r\n    (t.symbol = function () {\r\n      var t = Qg(Oy),\r\n        n = Qg(64),\r\n        e = null\r\n      function r () {\r\n        var r\r\n        if ((e || (e = r = Hi()), t.apply(this, arguments).draw(e, +n.apply(this, arguments)), r))\r\n          return (e = null), r + '' || null\r\n      }\r\n      return (\r\n        (r.type = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(n)), r) : t\r\n        }),\r\n        (r.size = function (t) {\r\n          return arguments.length ? ((n = 'function' == typeof t ? t : Qg(+t)), r) : n\r\n        }),\r\n        (r.context = function (t) {\r\n          return arguments.length ? ((e = null == t ? null : t), r) : e\r\n        }),\r\n        r\r\n      )\r\n    }),\r\n    (t.symbols = t_),\r\n    (t.symbolCircle = Oy),\r\n    (t.symbolCross = By),\r\n    (t.symbolDiamond = Iy),\r\n    (t.symbolSquare = Vy),\r\n    (t.symbolStar = Gy),\r\n    (t.symbolTriangle = Wy),\r\n    (t.symbolWye = Ky),\r\n    (t.curveBasisClosed = function (t) {\r\n      return new i_(t)\r\n    }),\r\n    (t.curveBasisOpen = function (t) {\r\n      return new o_(t)\r\n    }),\r\n    (t.curveBasis = function (t) {\r\n      return new r_(t)\r\n    }),\r\n    (t.curveBundle = u_),\r\n    (t.curveCardinalClosed = h_),\r\n    (t.curveCardinalOpen = p_),\r\n    (t.curveCardinal = s_),\r\n    (t.curveCatmullRomClosed = b_),\r\n    (t.curveCatmullRomOpen = x_),\r\n    (t.curveCatmullRom = y_),\r\n    (t.curveLinearClosed = function (t) {\r\n      return new w_(t)\r\n    }),\r\n    (t.curveLinear = yy),\r\n    (t.curveMonotoneX = function (t) {\r\n      return new k_(t)\r\n    }),\r\n    (t.curveMonotoneY = function (t) {\r\n      return new T_(t)\r\n    }),\r\n    (t.curveNatural = function (t) {\r\n      return new C_(t)\r\n    }),\r\n    (t.curveStep = function (t) {\r\n      return new z_(t, 0.5)\r\n    }),\r\n    (t.curveStepAfter = function (t) {\r\n      return new z_(t, 1)\r\n    }),\r\n    (t.curveStepBefore = function (t) {\r\n      return new z_(t, 0)\r\n    }),\r\n    (t.stack = function () {\r\n      var t = Qg([]),\r\n        n = D_,\r\n        e = R_,\r\n        r = q_\r\n      function i (i) {\r\n        var o,\r\n          a,\r\n          u = t.apply(this, arguments),\r\n          c = i.length,\r\n          f = u.length,\r\n          s = new Array(f)\r\n        for (o = 0; o < f; ++o) {\r\n          for (var l, h = u[o], d = (s[o] = new Array(c)), p = 0; p < c; ++p)\r\n            (d[p] = l = [0, +r(i[p], h, p, i)]), (l.data = i[p])\r\n          d.key = h\r\n        }\r\n        for (o = 0, a = n(s); o < f; ++o) s[a[o]].index = o\r\n        return e(s, a), s\r\n      }\r\n      return (\r\n        (i.keys = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(Py.call(n))), i) : t\r\n        }),\r\n        (i.value = function (t) {\r\n          return arguments.length ? ((r = 'function' == typeof t ? t : Qg(+t)), i) : r\r\n        }),\r\n        (i.order = function (t) {\r\n          return arguments.length ? ((n = null == t ? D_ : 'function' == typeof t ? t : Qg(Py.call(t))), i) : n\r\n        }),\r\n        (i.offset = function (t) {\r\n          return arguments.length ? ((e = null == t ? R_ : t), i) : e\r\n        }),\r\n        i\r\n      )\r\n    }),\r\n    (t.stackOffsetExpand = function (t, n) {\r\n      if ((r = t.length) > 0) {\r\n        for (var e, r, i, o = 0, a = t[0].length; o < a; ++o) {\r\n          for (i = e = 0; e < r; ++e) i += t[e][o][1] || 0\r\n          if (i) for (e = 0; e < r; ++e) t[e][o][1] /= i\r\n        }\r\n        R_(t, n)\r\n      }\r\n    }),\r\n    (t.stackOffsetDiverging = function (t, n) {\r\n      if ((u = t.length) > 1)\r\n        for (var e, r, i, o, a, u, c = 0, f = t[n[0]].length; c < f; ++c)\r\n          for (o = a = 0, e = 0; e < u; ++e)\r\n            (i = (r = t[n[e]][c])[1] - r[0]) >= 0\r\n              ? ((r[0] = o), (r[1] = o += i))\r\n              : i < 0\r\n              ? ((r[1] = a), (r[0] = a += i))\r\n              : (r[0] = o)\r\n    }),\r\n    (t.stackOffsetNone = R_),\r\n    (t.stackOffsetSilhouette = function (t, n) {\r\n      if ((e = t.length) > 0) {\r\n        for (var e, r = 0, i = t[n[0]], o = i.length; r < o; ++r) {\r\n          for (var a = 0, u = 0; a < e; ++a) u += t[a][r][1] || 0\r\n          i[r][1] += i[r][0] = -u / 2\r\n        }\r\n        R_(t, n)\r\n      }\r\n    }),\r\n    (t.stackOffsetWiggle = function (t, n) {\r\n      if ((i = t.length) > 0 && (r = (e = t[n[0]]).length) > 0) {\r\n        for (var e, r, i, o = 0, a = 1; a < r; ++a) {\r\n          for (var u = 0, c = 0, f = 0; u < i; ++u) {\r\n            for (var s = t[n[u]], l = s[a][1] || 0, h = (l - (s[a - 1][1] || 0)) / 2, d = 0; d < u; ++d) {\r\n              var p = t[n[d]]\r\n              h += (p[a][1] || 0) - (p[a - 1][1] || 0)\r\n            }\r\n            ;(c += l), (f += h * l)\r\n          }\r\n          ;(e[a - 1][1] += e[a - 1][0] = o), c && (o -= f / c)\r\n        }\r\n        ;(e[a - 1][1] += e[a - 1][0] = o), R_(t, n)\r\n      }\r\n    }),\r\n    (t.stackOrderAppearance = L_),\r\n    (t.stackOrderAscending = O_),\r\n    (t.stackOrderDescending = function (t) {\r\n      return O_(t).reverse()\r\n    }),\r\n    (t.stackOrderInsideOut = function (t) {\r\n      var n,\r\n        e,\r\n        r = t.length,\r\n        i = t.map(B_),\r\n        o = L_(t),\r\n        a = 0,\r\n        u = 0,\r\n        c = [],\r\n        f = []\r\n      for (n = 0; n < r; ++n) (e = o[n]), a < u ? ((a += i[e]), c.push(e)) : ((u += i[e]), f.push(e))\r\n      return f.reverse().concat(c)\r\n    }),\r\n    (t.stackOrderNone = D_),\r\n    (t.stackOrderReverse = function (t) {\r\n      return D_(t).reverse()\r\n    }),\r\n    (t.timeInterval = Gh),\r\n    (t.timeMillisecond = Vh),\r\n    (t.timeMilliseconds = $h),\r\n    (t.utcMillisecond = Vh),\r\n    (t.utcMilliseconds = $h),\r\n    (t.timeSecond = Qh),\r\n    (t.timeSeconds = Jh),\r\n    (t.utcSecond = Qh),\r\n    (t.utcSeconds = Jh),\r\n    (t.timeMinute = Kh),\r\n    (t.timeMinutes = td),\r\n    (t.timeHour = nd),\r\n    (t.timeHours = ed),\r\n    (t.timeDay = rd),\r\n    (t.timeDays = id),\r\n    (t.timeWeek = ad),\r\n    (t.timeWeeks = dd),\r\n    (t.timeSunday = ad),\r\n    (t.timeSundays = dd),\r\n    (t.timeMonday = ud),\r\n    (t.timeMondays = pd),\r\n    (t.timeTuesday = cd),\r\n    (t.timeTuesdays = vd),\r\n    (t.timeWednesday = fd),\r\n    (t.timeWednesdays = gd),\r\n    (t.timeThursday = sd),\r\n    (t.timeThursdays = yd),\r\n    (t.timeFriday = ld),\r\n    (t.timeFridays = _d),\r\n    (t.timeSaturday = hd),\r\n    (t.timeSaturdays = bd),\r\n    (t.timeMonth = md),\r\n    (t.timeMonths = xd),\r\n    (t.timeYear = wd),\r\n    (t.timeYears = Md),\r\n    (t.utcMinute = Nd),\r\n    (t.utcMinutes = Ad),\r\n    (t.utcHour = Sd),\r\n    (t.utcHours = kd),\r\n    (t.utcDay = Td),\r\n    (t.utcDays = Ed),\r\n    (t.utcWeek = Pd),\r\n    (t.utcWeeks = Od),\r\n    (t.utcSunday = Pd),\r\n    (t.utcSundays = Od),\r\n    (t.utcMonday = zd),\r\n    (t.utcMondays = Bd),\r\n    (t.utcTuesday = Rd),\r\n    (t.utcTuesdays = Yd),\r\n    (t.utcWednesday = Dd),\r\n    (t.utcWednesdays = Fd),\r\n    (t.utcThursday = qd),\r\n    (t.utcThursdays = Id),\r\n    (t.utcFriday = Ld),\r\n    (t.utcFridays = jd),\r\n    (t.utcSaturday = Ud),\r\n    (t.utcSaturdays = Hd),\r\n    (t.utcMonth = Xd),\r\n    (t.utcMonths = Gd),\r\n    (t.utcYear = Vd),\r\n    (t.utcYears = $d),\r\n    (t.timeFormatDefaultLocale = sv),\r\n    (t.timeFormatLocale = Jd),\r\n    (t.isoFormat = lv),\r\n    (t.isoParse = hv),\r\n    (t.now = nr),\r\n    (t.timer = ir),\r\n    (t.timerFlush = or),\r\n    (t.timeout = fr),\r\n    (t.interval = function (t, n, e) {\r\n      var r = new rr(),\r\n        i = n\r\n      return null == n\r\n        ? (r.restart(t, n, e), r)\r\n        : ((n = +n),\r\n          (e = null == e ? nr() : +e),\r\n          r.restart(\r\n            function o (a) {\r\n              ;(a += i), r.restart(o, (i += n), e), t(a)\r\n            },\r\n            n,\r\n            e\r\n          ),\r\n          r)\r\n    }),\r\n    (t.transition = Cr),\r\n    (t.active = function (t, n) {\r\n      var e,\r\n        r,\r\n        i = t.__transition\r\n      if (i)\r\n        for (r in ((n = null == n ? null : n + ''), i))\r\n          if ((e = i[r]).state > dr && e.name === n) return new Er([[t]], fi, n, +r)\r\n      return null\r\n    }),\r\n    (t.interrupt = Mr),\r\n    (t.voronoi = function () {\r\n      var t = F_,\r\n        n = I_,\r\n        e = null\r\n      function r (r) {\r\n        return new wb(\r\n          r.map(function (e, i) {\r\n            var o = [Math.round(t(e, i, r) / bb) * bb, Math.round(n(e, i, r) / bb) * bb]\r\n            return (o.index = i), (o.data = e), o\r\n          }),\r\n          e\r\n        )\r\n      }\r\n      return (\r\n        (r.polygons = function (t) {\r\n          return r(t).polygons()\r\n        }),\r\n        (r.links = function (t) {\r\n          return r(t).links()\r\n        }),\r\n        (r.triangles = function (t) {\r\n          return r(t).triangles()\r\n        }),\r\n        (r.x = function (n) {\r\n          return arguments.length ? ((t = 'function' == typeof n ? n : Y_(+n)), r) : t\r\n        }),\r\n        (r.y = function (t) {\r\n          return arguments.length ? ((n = 'function' == typeof t ? t : Y_(+t)), r) : n\r\n        }),\r\n        (r.extent = function (t) {\r\n          return arguments.length\r\n            ? ((e = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), r)\r\n            : e && [[e[0][0], e[0][1]], [e[1][0], e[1][1]]]\r\n        }),\r\n        (r.size = function (t) {\r\n          return arguments.length\r\n            ? ((e = null == t ? null : [[0, 0], [+t[0], +t[1]]]), r)\r\n            : e && [e[1][0] - e[0][0], e[1][1] - e[0][1]]\r\n        }),\r\n        r\r\n      )\r\n    }),\r\n    (t.zoom = function () {\r\n      var n,\r\n        e,\r\n        r = Cb,\r\n        i = Pb,\r\n        o = qb,\r\n        a = Rb,\r\n        u = Db,\r\n        c = [0, 1 / 0],\r\n        f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]],\r\n        s = 250,\r\n        l = De,\r\n        h = [],\r\n        d = I('start', 'zoom', 'end'),\r\n        p = 500,\r\n        v = 150,\r\n        g = 0\r\n      function y (t) {\r\n        t.property('__zoom', zb)\r\n          .on('wheel.zoom', N)\r\n          .on('mousedown.zoom', A)\r\n          .on('dblclick.zoom', S)\r\n          .filter(u)\r\n          .on('touchstart.zoom', k)\r\n          .on('touchmove.zoom', T)\r\n          .on('touchend.zoom touchcancel.zoom', E)\r\n          .style('touch-action', 'none')\r\n          .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')\r\n      }\r\n      function _ (t, n) {\r\n        return (n = Math.max(c[0], Math.min(c[1], n))) === t.k ? t : new Ab(n, t.x, t.y)\r\n      }\r\n      function b (t, n, e) {\r\n        var r = n[0] - e[0] * t.k,\r\n          i = n[1] - e[1] * t.k\r\n        return r === t.x && i === t.y ? t : new Ab(t.k, r, i)\r\n      }\r\n      function m (t) {\r\n        return [(+t[0][0] + +t[1][0]) / 2, (+t[0][1] + +t[1][1]) / 2]\r\n      }\r\n      function x (t, n, e) {\r\n        t.on('start.zoom', function () {\r\n          w(this, arguments).start()\r\n        })\r\n          .on('interrupt.zoom end.zoom', function () {\r\n            w(this, arguments).end()\r\n          })\r\n          .tween('zoom', function () {\r\n            var t = arguments,\r\n              r = w(this, t),\r\n              o = i.apply(this, t),\r\n              a = e || m(o),\r\n              u = Math.max(o[1][0] - o[0][0], o[1][1] - o[0][1]),\r\n              c = this.__zoom,\r\n              f = 'function' == typeof n ? n.apply(this, t) : n,\r\n              s = l(c.invert(a).concat(u / c.k), f.invert(a).concat(u / f.k))\r\n            return function (t) {\r\n              if (1 === t) t = f\r\n              else {\r\n                var n = s(t),\r\n                  e = u / n[2]\r\n                t = new Ab(e, a[0] - n[0] * e, a[1] - n[1] * e)\r\n              }\r\n              r.zoom(null, t)\r\n            }\r\n          })\r\n      }\r\n      function w (t, n) {\r\n        for (var e, r = 0, i = h.length; r < i; ++r) if ((e = h[r]).that === t) return e\r\n        return new M(t, n)\r\n      }\r\n      function M (t, n) {\r\n        ;(this.that = t), (this.args = n), (this.index = -1), (this.active = 0), (this.extent = i.apply(t, n))\r\n      }\r\n      function N () {\r\n        if (r.apply(this, arguments)) {\r\n          var t = w(this, arguments),\r\n            n = this.__zoom,\r\n            e = Math.max(c[0], Math.min(c[1], n.k * Math.pow(2, a.apply(this, arguments)))),\r\n            i = Ot(this)\r\n          if (t.wheel)\r\n            (t.mouse[0][0] === i[0] && t.mouse[0][1] === i[1]) || (t.mouse[1] = n.invert((t.mouse[0] = i))),\r\n              clearTimeout(t.wheel)\r\n          else {\r\n            if (n.k === e) return\r\n            ;(t.mouse = [i, n.invert(i)]), Mr(this), t.start()\r\n          }\r\n          Eb(),\r\n            (t.wheel = setTimeout(function () {\r\n              ;(t.wheel = null), t.end()\r\n            }, v)),\r\n            t.zoom('mouse', o(b(_(n, e), t.mouse[0], t.mouse[1]), t.extent, f))\r\n        }\r\n      }\r\n      function A () {\r\n        if (!e && r.apply(this, arguments)) {\r\n          var n = w(this, arguments),\r\n            i = zt(t.event.view)\r\n              .on(\r\n                'mousemove.zoom',\r\n                function () {\r\n                  if ((Eb(), !n.moved)) {\r\n                    var e = t.event.clientX - u,\r\n                      r = t.event.clientY - c\r\n                    n.moved = e * e + r * r > g\r\n                  }\r\n                  n.zoom('mouse', o(b(n.that.__zoom, (n.mouse[0] = Ot(n.that)), n.mouse[1]), n.extent, f))\r\n                },\r\n                !0\r\n              )\r\n              .on(\r\n                'mouseup.zoom',\r\n                function () {\r\n                  i.on('mousemove.zoom mouseup.zoom', null), jt(t.event.view, n.moved), Eb(), n.end()\r\n                },\r\n                !0\r\n              ),\r\n            a = Ot(this),\r\n            u = t.event.clientX,\r\n            c = t.event.clientY\r\n          It(t.event.view), Tb(), (n.mouse = [a, this.__zoom.invert(a)]), Mr(this), n.start()\r\n        }\r\n      }\r\n      function S () {\r\n        if (r.apply(this, arguments)) {\r\n          var n = this.__zoom,\r\n            e = Ot(this),\r\n            a = n.invert(e),\r\n            u = n.k * (t.event.shiftKey ? 0.5 : 2),\r\n            c = o(b(_(n, u), e, a), i.apply(this, arguments), f)\r\n          Eb(),\r\n            s > 0\r\n              ? zt(this)\r\n                  .transition()\r\n                  .duration(s)\r\n                  .call(x, c, e)\r\n              : zt(this).call(y.transform, c)\r\n        }\r\n      }\r\n      function k () {\r\n        if (r.apply(this, arguments)) {\r\n          var e,\r\n            i,\r\n            o,\r\n            a,\r\n            u = w(this, arguments),\r\n            c = t.event.changedTouches,\r\n            f = c.length\r\n          for (Tb(), i = 0; i < f; ++i)\r\n            (a = [(a = Bt(this, c, (o = c[i]).identifier)), this.__zoom.invert(a), o.identifier]),\r\n              u.touch0 ? u.touch1 || (u.touch1 = a) : ((u.touch0 = a), (e = !0))\r\n          if (n && ((n = clearTimeout(n)), !u.touch1))\r\n            return u.end(), void ((a = zt(this).on('dblclick.zoom')) && a.apply(this, arguments))\r\n          e &&\r\n            ((n = setTimeout(function () {\r\n              n = null\r\n            }, p)),\r\n            Mr(this),\r\n            u.start())\r\n        }\r\n      }\r\n      function T () {\r\n        var e,\r\n          r,\r\n          i,\r\n          a,\r\n          u = w(this, arguments),\r\n          c = t.event.changedTouches,\r\n          s = c.length\r\n        for (Eb(), n && (n = clearTimeout(n)), e = 0; e < s; ++e)\r\n          (i = Bt(this, c, (r = c[e]).identifier)),\r\n            u.touch0 && u.touch0[2] === r.identifier\r\n              ? (u.touch0[0] = i)\r\n              : u.touch1 && u.touch1[2] === r.identifier && (u.touch1[0] = i)\r\n        if (((r = u.that.__zoom), u.touch1)) {\r\n          var l = u.touch0[0],\r\n            h = u.touch0[1],\r\n            d = u.touch1[0],\r\n            p = u.touch1[1],\r\n            v = (v = d[0] - l[0]) * v + (v = d[1] - l[1]) * v,\r\n            g = (g = p[0] - h[0]) * g + (g = p[1] - h[1]) * g\r\n          ;(r = _(r, Math.sqrt(v / g))),\r\n            (i = [(l[0] + d[0]) / 2, (l[1] + d[1]) / 2]),\r\n            (a = [(h[0] + p[0]) / 2, (h[1] + p[1]) / 2])\r\n        } else {\r\n          if (!u.touch0) return\r\n          ;(i = u.touch0[0]), (a = u.touch0[1])\r\n        }\r\n        u.zoom('touch', o(b(r, i, a), u.extent, f))\r\n      }\r\n      function E () {\r\n        var n,\r\n          r,\r\n          i = w(this, arguments),\r\n          o = t.event.changedTouches,\r\n          a = o.length\r\n        for (\r\n          Tb(),\r\n            e && clearTimeout(e),\r\n            e = setTimeout(function () {\r\n              e = null\r\n            }, p),\r\n            n = 0;\r\n          n < a;\r\n          ++n\r\n        )\r\n          (r = o[n]),\r\n            i.touch0 && i.touch0[2] === r.identifier\r\n              ? delete i.touch0\r\n              : i.touch1 && i.touch1[2] === r.identifier && delete i.touch1\r\n        i.touch1 && !i.touch0 && ((i.touch0 = i.touch1), delete i.touch1),\r\n          i.touch0 ? (i.touch0[1] = this.__zoom.invert(i.touch0[0])) : i.end()\r\n      }\r\n      return (\r\n        (y.transform = function (t, n) {\r\n          var e = t.selection ? t.selection() : t\r\n          e.property('__zoom', zb),\r\n            t !== e\r\n              ? x(t, n)\r\n              : e.interrupt().each(function () {\r\n                  w(this, arguments)\r\n                    .start()\r\n                    .zoom(null, 'function' == typeof n ? n.apply(this, arguments) : n)\r\n                    .end()\r\n                })\r\n        }),\r\n        (y.scaleBy = function (t, n) {\r\n          y.scaleTo(t, function () {\r\n            return this.__zoom.k * ('function' == typeof n ? n.apply(this, arguments) : n)\r\n          })\r\n        }),\r\n        (y.scaleTo = function (t, n) {\r\n          y.transform(t, function () {\r\n            var t = i.apply(this, arguments),\r\n              e = this.__zoom,\r\n              r = m(t),\r\n              a = e.invert(r),\r\n              u = 'function' == typeof n ? n.apply(this, arguments) : n\r\n            return o(b(_(e, u), r, a), t, f)\r\n          })\r\n        }),\r\n        (y.translateBy = function (t, n, e) {\r\n          y.transform(t, function () {\r\n            return o(\r\n              this.__zoom.translate(\r\n                'function' == typeof n ? n.apply(this, arguments) : n,\r\n                'function' == typeof e ? e.apply(this, arguments) : e\r\n              ),\r\n              i.apply(this, arguments),\r\n              f\r\n            )\r\n          })\r\n        }),\r\n        (y.translateTo = function (t, n, e) {\r\n          y.transform(t, function () {\r\n            var t = i.apply(this, arguments),\r\n              r = this.__zoom,\r\n              a = m(t)\r\n            return o(\r\n              Sb.translate(a[0], a[1])\r\n                .scale(r.k)\r\n                .translate(\r\n                  'function' == typeof n ? -n.apply(this, arguments) : -n,\r\n                  'function' == typeof e ? -e.apply(this, arguments) : -e\r\n                ),\r\n              t,\r\n              f\r\n            )\r\n          })\r\n        }),\r\n        (M.prototype = {\r\n          start: function () {\r\n            return 1 == ++this.active && ((this.index = h.push(this) - 1), this.emit('start')), this\r\n          },\r\n          zoom: function (t, n) {\r\n            return (\r\n              this.mouse && 'mouse' !== t && (this.mouse[1] = n.invert(this.mouse[0])),\r\n              this.touch0 && 'touch' !== t && (this.touch0[1] = n.invert(this.touch0[0])),\r\n              this.touch1 && 'touch' !== t && (this.touch1[1] = n.invert(this.touch1[0])),\r\n              (this.that.__zoom = n),\r\n              this.emit('zoom'),\r\n              this\r\n            )\r\n          },\r\n          end: function () {\r\n            return 0 == --this.active && (h.splice(this.index, 1), (this.index = -1), this.emit('end')), this\r\n          },\r\n          emit: function (t) {\r\n            kt(new Nb(y, t, this.that.__zoom), d.apply, d, [t, this.that, this.args])\r\n          }\r\n        }),\r\n        (y.wheelDelta = function (t) {\r\n          return arguments.length ? ((a = 'function' == typeof t ? t : Mb(+t)), y) : a\r\n        }),\r\n        (y.filter = function (t) {\r\n          return arguments.length ? ((r = 'function' == typeof t ? t : Mb(!!t)), y) : r\r\n        }),\r\n        (y.touchable = function (t) {\r\n          return arguments.length ? ((u = 'function' == typeof t ? t : Mb(!!t)), y) : u\r\n        }),\r\n        (y.extent = function (t) {\r\n          return arguments.length\r\n            ? ((i = 'function' == typeof t ? t : Mb([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]])), y)\r\n            : i\r\n        }),\r\n        (y.scaleExtent = function (t) {\r\n          return arguments.length ? ((c[0] = +t[0]), (c[1] = +t[1]), y) : [c[0], c[1]]\r\n        }),\r\n        (y.translateExtent = function (t) {\r\n          return arguments.length\r\n            ? ((f[0][0] = +t[0][0]), (f[1][0] = +t[1][0]), (f[0][1] = +t[0][1]), (f[1][1] = +t[1][1]), y)\r\n            : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]]\r\n        }),\r\n        (y.constrain = function (t) {\r\n          return arguments.length ? ((o = t), y) : o\r\n        }),\r\n        (y.duration = function (t) {\r\n          return arguments.length ? ((s = +t), y) : s\r\n        }),\r\n        (y.interpolate = function (t) {\r\n          return arguments.length ? ((l = t), y) : l\r\n        }),\r\n        (y.on = function () {\r\n          var t = d.on.apply(d, arguments)\r\n          return t === d ? y : t\r\n        }),\r\n        (y.clickDistance = function (t) {\r\n          return arguments.length ? ((g = (t = +t) * t), y) : Math.sqrt(g)\r\n        }),\r\n        y\r\n      )\r\n    }),\r\n    (t.zoomTransform = kb),\r\n    (t.zoomIdentity = Sb),\r\n    Object.defineProperty(t, '__esModule', { value: !0 })\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/d3/d3.min.js?");

/***/ }),

/***/ 231:
/*!*************************************************!*\
  !*** ./src/public/js/vendor/d3pie/d3pie.min.js ***!
  \*************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * d3pie\r\n * @author Ben Keen\r\n * @version 0.1.8\r\n * @date May 1st, 2015\r\n * @repo http://github.com/benkeen/d3pie\r\n */\r\n\r\n// UMD pattern from https://github.com/umdjs/umd/blob/master/returnExports.js\r\n;(function (root, factory) {\r\n  if (true) {\r\n    // AMD. Register as an anonymous module\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else {}\r\n})(this, function () {\r\n  var _scriptName = 'd3pie'\r\n  var _version = '0.1.6'\r\n\r\n  // used to uniquely generate IDs and classes, ensuring no conflict between multiple pies on the same page\r\n  var _uniqueIDCounter = 0\r\n\r\n  // this section includes all helper libs on the d3pie object. They're populated via grunt-template. Note: to keep\r\n  // the syntax highlighting from getting all messed up, I commented out each line. That REQUIRES each of the files\r\n  // to have an empty first line. Crumby, yes, but acceptable.\r\n  //// --------- _default-settings.js -----------/**\r\n  /**\r\n   * Contains the out-the-box settings for the script. Any of these settings that aren't explicitly overridden for the\r\n   * d3pie instance will inherit from these. This is also included on the main website for use in the generation script.\r\n   */\r\n  var defaultSettings = {\r\n    header: {\r\n      title: {\r\n        text: '',\r\n        color: '#333333',\r\n        fontSize: 18,\r\n        font: 'arial'\r\n      },\r\n      subtitle: {\r\n        text: '',\r\n        color: '#666666',\r\n        fontSize: 14,\r\n        font: 'arial'\r\n      },\r\n      location: 'top-center',\r\n      titleSubtitlePadding: 8\r\n    },\r\n    footer: {\r\n      text: '',\r\n      color: '#666666',\r\n      fontSize: 14,\r\n      font: 'arial',\r\n      location: 'left'\r\n    },\r\n    size: {\r\n      canvasHeight: 500,\r\n      canvasWidth: 500,\r\n      pieInnerRadius: '0%',\r\n      pieOuterRadius: null\r\n    },\r\n    data: {\r\n      sortOrder: 'none',\r\n      ignoreSmallSegments: {\r\n        enabled: false,\r\n        valueType: 'percentage',\r\n        value: null\r\n      },\r\n      smallSegmentGrouping: {\r\n        enabled: false,\r\n        value: 1,\r\n        valueType: 'percentage',\r\n        label: 'Other',\r\n        color: '#cccccc'\r\n      },\r\n      content: []\r\n    },\r\n    labels: {\r\n      outer: {\r\n        format: 'label',\r\n        hideWhenLessThanPercentage: null,\r\n        pieDistance: 30\r\n      },\r\n      inner: {\r\n        format: 'percentage',\r\n        hideWhenLessThanPercentage: null\r\n      },\r\n      mainLabel: {\r\n        color: '#333333',\r\n        font: 'arial',\r\n        fontSize: 10\r\n      },\r\n      percentage: {\r\n        color: '#dddddd',\r\n        font: 'arial',\r\n        fontSize: 10,\r\n        decimalPlaces: 0\r\n      },\r\n      value: {\r\n        color: '#cccc44',\r\n        font: 'arial',\r\n        fontSize: 10\r\n      },\r\n      lines: {\r\n        enabled: true,\r\n        style: 'curved',\r\n        color: 'segment'\r\n      },\r\n      truncation: {\r\n        enabled: false,\r\n        truncateLength: 30\r\n      },\r\n      formatter: null\r\n    },\r\n    effects: {\r\n      load: {\r\n        effect: 'default',\r\n        speed: 1000\r\n      },\r\n      pullOutSegmentOnClick: {\r\n        effect: 'bounce',\r\n        speed: 300,\r\n        size: 10\r\n      },\r\n      highlightSegmentOnMouseover: true,\r\n      highlightLuminosity: -0.2\r\n    },\r\n    tooltips: {\r\n      enabled: false,\r\n      type: 'placeholder', // caption|placeholder\r\n      string: '',\r\n      placeholderParser: null,\r\n      styles: {\r\n        fadeInSpeed: 250,\r\n        backgroundColor: '#000000',\r\n        backgroundOpacity: 0.5,\r\n        color: '#efefef',\r\n        borderRadius: 2,\r\n        font: 'arial',\r\n        fontSize: 10,\r\n        padding: 4\r\n      }\r\n    },\r\n    misc: {\r\n      colors: {\r\n        background: null,\r\n        segments: [\r\n          '#2484c1',\r\n          '#65a620',\r\n          '#7b6888',\r\n          '#a05d56',\r\n          '#961a1a',\r\n          '#d8d23a',\r\n          '#e98125',\r\n          '#d0743c',\r\n          '#635222',\r\n          '#6ada6a',\r\n          '#0c6197',\r\n          '#7d9058',\r\n          '#207f33',\r\n          '#44b9b0',\r\n          '#bca44a',\r\n          '#e4a14b',\r\n          '#a3acb2',\r\n          '#8cc3e9',\r\n          '#69a6f9',\r\n          '#5b388f',\r\n          '#546e91',\r\n          '#8bde95',\r\n          '#d2ab58',\r\n          '#273c71',\r\n          '#98bf6e',\r\n          '#4daa4b',\r\n          '#98abc5',\r\n          '#cc1010',\r\n          '#31383b',\r\n          '#006391',\r\n          '#c2643f',\r\n          '#b0a474',\r\n          '#a5a39c',\r\n          '#a9c2bc',\r\n          '#22af8c',\r\n          '#7fcecf',\r\n          '#987ac6',\r\n          '#3d3b87',\r\n          '#b77b1c',\r\n          '#c9c2b6',\r\n          '#807ece',\r\n          '#8db27c',\r\n          '#be66a2',\r\n          '#9ed3c6',\r\n          '#00644b',\r\n          '#005064',\r\n          '#77979f',\r\n          '#77e079',\r\n          '#9c73ab',\r\n          '#1f79a7'\r\n        ],\r\n        segmentStroke: '#ffffff'\r\n      },\r\n      gradient: {\r\n        enabled: false,\r\n        percentage: 95,\r\n        color: '#000000'\r\n      },\r\n      canvasPadding: {\r\n        top: 5,\r\n        right: 5,\r\n        bottom: 5,\r\n        left: 5\r\n      },\r\n      pieCenterOffset: {\r\n        x: 0,\r\n        y: 0\r\n      },\r\n      cssPrefix: null\r\n    },\r\n    callbacks: {\r\n      onload: null,\r\n      onMouseoverSegment: null,\r\n      onMouseoutSegment: null,\r\n      onClickSegment: null\r\n    }\r\n  }\r\n\r\n  //// --------- validate.js -----------\r\n  var validate = {\r\n    // called whenever a new pie chart is created\r\n    initialCheck: function (pie) {\r\n      var cssPrefix = pie.cssPrefix\r\n      var element = pie.element\r\n      var options = pie.options\r\n\r\n      // confirm d3 is available [check minimum version]\r\n      if (!window.d3 || !window.d3.hasOwnProperty('version')) {\r\n        console.error('d3pie error: d3 is not available')\r\n        return false\r\n      }\r\n\r\n      // confirm element is either a DOM element or a valid string for a DOM element\r\n      if (!(element instanceof HTMLElement || element instanceof SVGElement)) {\r\n        console.error('d3pie error: the first d3pie() param must be a valid DOM element (not jQuery) or a ID string.')\r\n        return false\r\n      }\r\n\r\n      // confirm the CSS prefix is valid. It has to start with a-Z and contain nothing but a-Z0-9_-\r\n      if (!/[a-zA-Z][a-zA-Z0-9_-]*$/.test(cssPrefix)) {\r\n        console.error('d3pie error: invalid options.misc.cssPrefix')\r\n        return false\r\n      }\r\n\r\n      // confirm some data has been supplied\r\n      if (!helpers.isArray(options.data.content)) {\r\n        console.error('d3pie error: invalid config structure: missing data.content property.')\r\n        return false\r\n      }\r\n      if (options.data.content.length === 0) {\r\n        console.error('d3pie error: no data supplied.')\r\n        return false\r\n      }\r\n\r\n      // clear out any invalid data. Each data row needs a valid positive number and a label\r\n      var data = []\r\n      for (var i = 0; i < options.data.content.length; i++) {\r\n        if (typeof options.data.content[i].value !== 'number' || isNaN(options.data.content[i].value)) {\r\n          console.log('not valid: ', options.data.content[i])\r\n          continue\r\n        }\r\n        if (options.data.content[i].value <= 0) {\r\n          console.log('not valid - should have positive value: ', options.data.content[i])\r\n          continue\r\n        }\r\n        data.push(options.data.content[i])\r\n      }\r\n      pie.options.data.content = data\r\n\r\n      // labels.outer.hideWhenLessThanPercentage - 1-100\r\n      // labels.inner.hideWhenLessThanPercentage - 1-100\r\n\r\n      return true\r\n    }\r\n  }\r\n\r\n  //// --------- helpers.js -----------\r\n  var helpers = {\r\n    // creates the SVG element\r\n    addSVGSpace: function (pie) {\r\n      var element = pie.element\r\n      var canvasWidth = pie.options.size.canvasWidth\r\n      var canvasHeight = pie.options.size.canvasHeight\r\n      var backgroundColor = pie.options.misc.colors.background\r\n\r\n      var svg = d3\r\n        .select(element)\r\n        .append('svg:svg')\r\n        .attr('width', canvasWidth)\r\n        .attr('height', canvasHeight)\r\n\r\n      if (backgroundColor !== 'transparent') {\r\n        svg.style('background-color', function () {\r\n          return backgroundColor\r\n        })\r\n      }\r\n\r\n      return svg\r\n    },\r\n\r\n    whenIdExists: function (id, callback) {\r\n      var inc = 1\r\n      var giveupIterationCount = 1000\r\n\r\n      var interval = setInterval(function () {\r\n        if (document.getElementById(id)) {\r\n          clearInterval(interval)\r\n          callback()\r\n        }\r\n        if (inc > giveupIterationCount) {\r\n          clearInterval(interval)\r\n        }\r\n        inc++\r\n      }, 1)\r\n    },\r\n\r\n    whenElementsExist: function (els, callback) {\r\n      var inc = 1\r\n      var giveupIterationCount = 1000\r\n\r\n      var interval = setInterval(function () {\r\n        var allExist = true\r\n        for (var i = 0; i < els.length; i++) {\r\n          if (!document.getElementById(els[i])) {\r\n            allExist = false\r\n            break\r\n          }\r\n        }\r\n        if (allExist) {\r\n          clearInterval(interval)\r\n          callback()\r\n        }\r\n        if (inc > giveupIterationCount) {\r\n          clearInterval(interval)\r\n        }\r\n        inc++\r\n      }, 1)\r\n    },\r\n\r\n    shuffleArray: function (array) {\r\n      var currentIndex = array.length,\r\n        tmpVal,\r\n        randomIndex\r\n\r\n      while (0 !== currentIndex) {\r\n        randomIndex = Math.floor(Math.random() * currentIndex)\r\n        currentIndex -= 1\r\n\r\n        // and swap it with the current element\r\n        tmpVal = array[currentIndex]\r\n        array[currentIndex] = array[randomIndex]\r\n        array[randomIndex] = tmpVal\r\n      }\r\n      return array\r\n    },\r\n\r\n    processObj: function (obj, is, value) {\r\n      if (typeof is === 'string') {\r\n        return helpers.processObj(obj, is.split('.'), value)\r\n      } else if (is.length === 1 && value !== undefined) {\r\n        obj[is[0]] = value\r\n        return obj[is[0]]\r\n      } else if (is.length === 0) {\r\n        return obj\r\n      } else {\r\n        return helpers.processObj(obj[is[0]], is.slice(1), value)\r\n      }\r\n    },\r\n\r\n    getDimensions: function (id) {\r\n      var el = document.getElementById(id)\r\n      var w = 0,\r\n        h = 0\r\n      if (el) {\r\n        var dimensions = el.getBBox()\r\n        w = dimensions.width\r\n        h = dimensions.height\r\n      } else {\r\n        console.log('error: getDimensions() ' + id + ' not found.')\r\n      }\r\n      return { w: w, h: h }\r\n    },\r\n\r\n    /**\r\n     * This is based on the SVG coordinate system, where top-left is 0,0 and bottom right is n-n.\r\n     * @param r1\r\n     * @param r2\r\n     * @returns {boolean}\r\n     */\r\n    rectIntersect: function (r1, r2) {\r\n      var returnVal =\r\n        // r2.left > r1.right\r\n        r2.x > r1.x + r1.w ||\r\n        // r2.right < r1.left\r\n        r2.x + r2.w < r1.x ||\r\n        // r2.top < r1.bottom\r\n        r2.y + r2.h < r1.y ||\r\n        // r2.bottom > r1.top\r\n        r2.y > r1.y + r1.h\r\n\r\n      return !returnVal\r\n    },\r\n\r\n    /**\r\n     * Returns a lighter/darker shade of a hex value, based on a luminance value passed.\r\n     * @param hex a hex color value such as #abc or #123456 (the hash is optional)\r\n     * @param lum the luminosity factor: -0.1 is 10% darker, 0.2 is 20% lighter, etc.\r\n     * @returns {string}\r\n     */\r\n    getColorShade: function (hex, lum) {\r\n      // validate hex string\r\n      hex = String(hex).replace(/[^0-9a-f]/gi, '')\r\n      if (hex.length < 6) {\r\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]\r\n      }\r\n      lum = lum || 0\r\n\r\n      // convert to decimal and change luminosity\r\n      var newHex = '#'\r\n      for (var i = 0; i < 3; i++) {\r\n        var c = parseInt(hex.substr(i * 2, 2), 16)\r\n        c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16)\r\n        newHex += ('00' + c).substr(c.length)\r\n      }\r\n\r\n      return newHex\r\n    },\r\n\r\n    /**\r\n     * Users can choose to specify segment colors in three ways (in order of precedence):\r\n     * \t1. include a \"color\" attribute for each row in data.content\r\n     * \t2. include a misc.colors.segments property which contains an array of hex codes\r\n     * \t3. specify nothing at all and rely on this lib provide some reasonable defaults\r\n     *\r\n     * This function sees what's included and populates this.options.colors with whatever's required\r\n     * for this pie chart.\r\n     * @param data\r\n     */\r\n    initSegmentColors: function (pie) {\r\n      var data = pie.options.data.content\r\n      var colors = pie.options.misc.colors.segments\r\n\r\n      // TODO this needs a ton of error handling\r\n\r\n      var finalColors = []\r\n      for (var i = 0; i < data.length; i++) {\r\n        if (data[i].hasOwnProperty('color')) {\r\n          finalColors.push(data[i].color)\r\n        } else {\r\n          finalColors.push(colors[i])\r\n        }\r\n      }\r\n\r\n      return finalColors\r\n    },\r\n\r\n    applySmallSegmentGrouping: function (data, smallSegmentGrouping) {\r\n      var totalSize\r\n      if (smallSegmentGrouping.valueType === 'percentage') {\r\n        totalSize = math.getTotalPieSize(data)\r\n      }\r\n\r\n      // loop through each data item\r\n      var newData = []\r\n      var groupedData = []\r\n      var totalGroupedData = 0\r\n      for (var i = 0; i < data.length; i++) {\r\n        if (smallSegmentGrouping.valueType === 'percentage') {\r\n          var dataPercent = (data[i].value / totalSize) * 100\r\n          if (dataPercent <= smallSegmentGrouping.value) {\r\n            groupedData.push(data[i])\r\n            totalGroupedData += data[i].value\r\n            continue\r\n          }\r\n          data[i].isGrouped = false\r\n          newData.push(data[i])\r\n        } else {\r\n          if (data[i].value <= smallSegmentGrouping.value) {\r\n            groupedData.push(data[i])\r\n            totalGroupedData += data[i].value\r\n            continue\r\n          }\r\n          data[i].isGrouped = false\r\n          newData.push(data[i])\r\n        }\r\n      }\r\n\r\n      // we're done! See if there's any small segment groups to add\r\n      if (groupedData.length) {\r\n        newData.push({\r\n          color: smallSegmentGrouping.color,\r\n          label: smallSegmentGrouping.label,\r\n          value: totalGroupedData,\r\n          isGrouped: true,\r\n          groupedData: groupedData\r\n        })\r\n      }\r\n\r\n      return newData\r\n    },\r\n\r\n    // for debugging\r\n    showPoint: function (svg, x, y) {\r\n      svg\r\n        .append('circle')\r\n        .attr('cx', x)\r\n        .attr('cy', y)\r\n        .attr('r', 2)\r\n        .style('fill', 'black')\r\n    },\r\n\r\n    isFunction: function (functionToCheck) {\r\n      var getType = {}\r\n      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]'\r\n    },\r\n\r\n    isArray: function (o) {\r\n      return Object.prototype.toString.call(o) === '[object Array]'\r\n    }\r\n  }\r\n\r\n  // taken from jQuery\r\n  var extend = function () {\r\n    var options,\r\n      name,\r\n      src,\r\n      copy,\r\n      copyIsArray,\r\n      clone,\r\n      target = arguments[0] || {},\r\n      i = 1,\r\n      length = arguments.length,\r\n      deep = false,\r\n      toString = Object.prototype.toString,\r\n      hasOwn = Object.prototype.hasOwnProperty,\r\n      class2type = {\r\n        '[object Boolean]': 'boolean',\r\n        '[object Number]': 'number',\r\n        '[object String]': 'string',\r\n        '[object Function]': 'function',\r\n        '[object Array]': 'array',\r\n        '[object Date]': 'date',\r\n        '[object RegExp]': 'regexp',\r\n        '[object Object]': 'object'\r\n      },\r\n      jQuery = {\r\n        isFunction: function (obj) {\r\n          return jQuery.type(obj) === 'function'\r\n        },\r\n        isArray:\r\n          Array.isArray ||\r\n          function (obj) {\r\n            return jQuery.type(obj) === 'array'\r\n          },\r\n        isWindow: function (obj) {\r\n          return obj !== null && obj === obj.window\r\n        },\r\n        isNumeric: function (obj) {\r\n          return !isNaN(parseFloat(obj)) && isFinite(obj)\r\n        },\r\n        type: function (obj) {\r\n          return obj === null ? String(obj) : class2type[toString.call(obj)] || 'object'\r\n        },\r\n        isPlainObject: function (obj) {\r\n          if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType) {\r\n            return false\r\n          }\r\n          try {\r\n            if (\r\n              obj.constructor &&\r\n              !hasOwn.call(obj, 'constructor') &&\r\n              !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')\r\n            ) {\r\n              return false\r\n            }\r\n          } catch (e) {\r\n            return false\r\n          }\r\n          var key\r\n          for (key in obj) {\r\n          }\r\n          return key === undefined || hasOwn.call(obj, key)\r\n        }\r\n      }\r\n    if (typeof target === 'boolean') {\r\n      deep = target\r\n      target = arguments[1] || {}\r\n      i = 2\r\n    }\r\n    if (typeof target !== 'object' && !jQuery.isFunction(target)) {\r\n      target = {}\r\n    }\r\n    if (length === i) {\r\n      target = this\r\n      --i\r\n    }\r\n    for (i; i < length; i++) {\r\n      if ((options = arguments[i]) !== null) {\r\n        for (name in options) {\r\n          src = target[name]\r\n          copy = options[name]\r\n          if (target === copy) {\r\n            continue\r\n          }\r\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\r\n            if (copyIsArray) {\r\n              copyIsArray = false\r\n              clone = src && jQuery.isArray(src) ? src : []\r\n            } else {\r\n              clone = src && jQuery.isPlainObject(src) ? src : {}\r\n            }\r\n            // WARNING: RECURSION\r\n            target[name] = extend(deep, clone, copy)\r\n          } else if (copy !== undefined) {\r\n            target[name] = copy\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return target\r\n  }\r\n  //// --------- math.js -----------\r\n  var math = {\r\n    toRadians: function (degrees) {\r\n      return degrees * (Math.PI / 180)\r\n    },\r\n\r\n    toDegrees: function (radians) {\r\n      return radians * (180 / Math.PI)\r\n    },\r\n\r\n    computePieRadius: function (pie) {\r\n      var size = pie.options.size\r\n      var canvasPadding = pie.options.misc.canvasPadding\r\n\r\n      // outer radius is either specified (e.g. through the generator), or omitted altogether\r\n      // and calculated based on the canvas dimensions. Right now the estimated version isn't great - it should\r\n      // be possible to calculate it to precisely generate the maximum sized pie, but it's fussy as heck. Something\r\n      // for the next release.\r\n\r\n      // first, calculate the default _outerRadius\r\n      var w = size.canvasWidth - canvasPadding.left - canvasPadding.right\r\n      var h = size.canvasHeight - canvasPadding.top - canvasPadding.bottom\r\n\r\n      // now factor in the footer, title & subtitle\r\n      if (pie.options.header.location !== 'pie-center') {\r\n        h -= pie.textComponents.headerHeight\r\n      }\r\n\r\n      if (pie.textComponents.footer.exists) {\r\n        h -= pie.textComponents.footer.h\r\n      }\r\n\r\n      // for really teeny pies, h may be < 0. Adjust it back\r\n      h = h < 0 ? 0 : h\r\n\r\n      var outerRadius = (w < h ? w : h) / 3\r\n      var innerRadius, percent\r\n\r\n      // if the user specified something, use that instead\r\n      if (size.pieOuterRadius !== null) {\r\n        if (/%/.test(size.pieOuterRadius)) {\r\n          percent = parseInt(size.pieOuterRadius.replace(/[\\D]/, ''), 10)\r\n          percent = percent > 99 ? 99 : percent\r\n          percent = percent < 0 ? 0 : percent\r\n\r\n          var smallestDimension = w < h ? w : h\r\n\r\n          // now factor in the label line size\r\n          if (pie.options.labels.outer.format !== 'none') {\r\n            var pieDistanceSpace = parseInt(pie.options.labels.outer.pieDistance, 10) * 2\r\n            if (smallestDimension - pieDistanceSpace > 0) {\r\n              smallestDimension -= pieDistanceSpace\r\n            }\r\n          }\r\n\r\n          outerRadius = Math.floor((smallestDimension / 100) * percent) / 2\r\n        } else {\r\n          outerRadius = parseInt(size.pieOuterRadius, 10)\r\n        }\r\n      }\r\n\r\n      // inner radius\r\n      if (/%/.test(size.pieInnerRadius)) {\r\n        percent = parseInt(size.pieInnerRadius.replace(/[\\D]/, ''), 10)\r\n        percent = percent > 99 ? 99 : percent\r\n        percent = percent < 0 ? 0 : percent\r\n        innerRadius = Math.floor((outerRadius / 100) * percent)\r\n      } else {\r\n        innerRadius = parseInt(size.pieInnerRadius, 10)\r\n      }\r\n\r\n      pie.innerRadius = innerRadius\r\n      pie.outerRadius = outerRadius\r\n    },\r\n\r\n    getTotalPieSize: function (data) {\r\n      var totalSize = 0\r\n      for (var i = 0; i < data.length; i++) {\r\n        totalSize += data[i].value\r\n      }\r\n      return totalSize\r\n    },\r\n\r\n    sortPieData: function (pie) {\r\n      var data = pie.options.data.content\r\n      var sortOrder = pie.options.data.sortOrder\r\n\r\n      switch (sortOrder) {\r\n        case 'none':\r\n          // do nothing\r\n          break\r\n        case 'random':\r\n          data = helpers.shuffleArray(data)\r\n          break\r\n        case 'value-asc':\r\n          data.sort(function (a, b) {\r\n            return a.value < b.value ? -1 : 1\r\n          })\r\n          break\r\n        case 'value-desc':\r\n          data.sort(function (a, b) {\r\n            return a.value < b.value ? 1 : -1\r\n          })\r\n          break\r\n        case 'label-asc':\r\n          data.sort(function (a, b) {\r\n            return a.label.toLowerCase() > b.label.toLowerCase() ? 1 : -1\r\n          })\r\n          break\r\n        case 'label-desc':\r\n          data.sort(function (a, b) {\r\n            return a.label.toLowerCase() < b.label.toLowerCase() ? 1 : -1\r\n          })\r\n          break\r\n      }\r\n\r\n      return data\r\n    },\r\n\r\n    // var pieCenter = math.getPieCenter();\r\n    getPieTranslateCenter: function (pieCenter) {\r\n      return 'translate(' + pieCenter.x + ',' + pieCenter.y + ')'\r\n    },\r\n\r\n    /**\r\n     * Used to determine where on the canvas the center of the pie chart should be. It takes into account the\r\n     * height and position of the title, subtitle and footer, and the various paddings.\r\n     * @private\r\n     */\r\n    calculatePieCenter: function (pie) {\r\n      var pieCenterOffset = pie.options.misc.pieCenterOffset\r\n      var hasTopTitle = pie.textComponents.title.exists && pie.options.header.location !== 'pie-center'\r\n      var hasTopSubtitle = pie.textComponents.subtitle.exists && pie.options.header.location !== 'pie-center'\r\n\r\n      var headerOffset = pie.options.misc.canvasPadding.top\r\n      if (hasTopTitle && hasTopSubtitle) {\r\n        headerOffset +=\r\n          pie.textComponents.title.h + pie.options.header.titleSubtitlePadding + pie.textComponents.subtitle.h\r\n      } else if (hasTopTitle) {\r\n        headerOffset += pie.textComponents.title.h\r\n      } else if (hasTopSubtitle) {\r\n        headerOffset += pie.textComponents.subtitle.h\r\n      }\r\n\r\n      var footerOffset = 0\r\n      if (pie.textComponents.footer.exists) {\r\n        footerOffset = pie.textComponents.footer.h + pie.options.misc.canvasPadding.bottom\r\n      }\r\n\r\n      var x =\r\n        (pie.options.size.canvasWidth - pie.options.misc.canvasPadding.left - pie.options.misc.canvasPadding.right) /\r\n          2 +\r\n        pie.options.misc.canvasPadding.left\r\n      var y = (pie.options.size.canvasHeight - footerOffset - headerOffset) / 2 + headerOffset\r\n\r\n      x += pieCenterOffset.x\r\n      y += pieCenterOffset.y\r\n\r\n      pie.pieCenter = { x: x, y: y }\r\n    },\r\n\r\n    /**\r\n     * Rotates a point (x, y) around an axis (xm, ym) by degrees (a).\r\n     * @param x\r\n     * @param y\r\n     * @param xm\r\n     * @param ym\r\n     * @param a angle in degrees\r\n     * @returns {Array}\r\n     */\r\n    rotate: function (x, y, xm, ym, a) {\r\n      a = (a * Math.PI) / 180 // convert to radians\r\n\r\n      var cos = Math.cos,\r\n        sin = Math.sin,\r\n        // subtract midpoints, so that midpoint is translated to origin and add it in the end again\r\n        xr = (x - xm) * cos(a) - (y - ym) * sin(a) + xm,\r\n        yr = (x - xm) * sin(a) + (y - ym) * cos(a) + ym\r\n\r\n      return { x: xr, y: yr }\r\n    },\r\n\r\n    /**\r\n     * Translates a point x, y by distance d, and by angle a.\r\n     * @param x\r\n     * @param y\r\n     * @param dist\r\n     * @param a angle in degrees\r\n     */\r\n    translate: function (x, y, d, a) {\r\n      var rads = math.toRadians(a)\r\n      return {\r\n        x: x + d * Math.sin(rads),\r\n        y: y - d * Math.cos(rads)\r\n      }\r\n    },\r\n\r\n    // from: http://stackoverflow.com/questions/19792552/d3-put-arc-labels-in-a-pie-chart-if-there-is-enough-space\r\n    pointIsInArc: function (pt, ptData, d3Arc) {\r\n      // Center of the arc is assumed to be 0,0\r\n      // (pt.x, pt.y) are assumed to be relative to the center\r\n      var r1 = d3Arc.innerRadius()(ptData), // Note: Using the innerRadius\r\n        r2 = d3Arc.outerRadius()(ptData),\r\n        theta1 = d3Arc.startAngle()(ptData),\r\n        theta2 = d3Arc.endAngle()(ptData)\r\n\r\n      var dist = pt.x * pt.x + pt.y * pt.y,\r\n        angle = Math.atan2(pt.x, -pt.y) // Note: different coordinate system\r\n\r\n      angle = angle < 0 ? angle + Math.PI * 2 : angle\r\n\r\n      return r1 * r1 <= dist && dist <= r2 * r2 && theta1 <= angle && angle <= theta2\r\n    }\r\n  }\r\n\r\n  //// --------- labels.js -----------\r\n  var labels = {\r\n    /**\r\n     * Adds the labels to the pie chart, but doesn't position them. There are two locations for the\r\n     * labels: inside (center) of the segments, or outside the segments on the edge.\r\n     * @param section \"inner\" or \"outer\"\r\n     * @param sectionDisplayType \"percentage\", \"value\", \"label\", \"label-value1\", etc.\r\n     * @param pie\r\n     */\r\n    add: function (pie, section, sectionDisplayType) {\r\n      var include = labels.getIncludes(sectionDisplayType)\r\n      var settings = pie.options.labels\r\n\r\n      // group the label groups (label, percentage, value) into a single element for simpler positioning\r\n      var outerLabel = pie.svg\r\n        .insert('g', '.' + pie.cssPrefix + 'labels-' + section)\r\n        .attr('class', pie.cssPrefix + 'labels-' + section)\r\n\r\n      var labelGroup = outerLabel\r\n        .selectAll('.' + pie.cssPrefix + 'labelGroup-' + section)\r\n        .data(pie.options.data.content)\r\n        .enter()\r\n        .append('g')\r\n        .attr('id', function (d, i) {\r\n          return pie.cssPrefix + 'labelGroup' + i + '-' + section\r\n        })\r\n        .attr('data-index', function (d, i) {\r\n          return i\r\n        })\r\n        .attr('class', pie.cssPrefix + 'labelGroup-' + section)\r\n        .style('opacity', 0)\r\n\r\n      var formatterContext = { section: section, sectionDisplayType: sectionDisplayType }\r\n\r\n      // 1. Add the main label\r\n      if (include.mainLabel) {\r\n        labelGroup\r\n          .append('text')\r\n          .attr('id', function (d, i) {\r\n            return pie.cssPrefix + 'segmentMainLabel' + i + '-' + section\r\n          })\r\n          .attr('class', pie.cssPrefix + 'segmentMainLabel-' + section)\r\n          .text(function (d, i) {\r\n            var str = d.label\r\n\r\n            // if a custom formatter has been defined, pass it the raw label string - it can do whatever it wants with it.\r\n            // we only apply truncation if it's not defined\r\n            if (settings.formatter) {\r\n              formatterContext.index = i\r\n              formatterContext.part = 'mainLabel'\r\n              formatterContext.value = d.value\r\n              formatterContext.label = str\r\n              str = settings.formatter(formatterContext)\r\n            } else if (settings.truncation.enabled && d.label.length > settings.truncation.truncateLength) {\r\n              str = d.label.substring(0, settings.truncation.truncateLength) + '...'\r\n            }\r\n            return str\r\n          })\r\n          .style('font-size', settings.mainLabel.fontSize + 'px')\r\n          .style('font-family', settings.mainLabel.font)\r\n          .style('fill', settings.mainLabel.color)\r\n      }\r\n\r\n      // 2. Add the percentage label\r\n      if (include.percentage) {\r\n        labelGroup\r\n          .append('text')\r\n          .attr('id', function (d, i) {\r\n            return pie.cssPrefix + 'segmentPercentage' + i + '-' + section\r\n          })\r\n          .attr('class', pie.cssPrefix + 'segmentPercentage-' + section)\r\n          .text(function (d, i) {\r\n            var percentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\r\n            if (settings.formatter) {\r\n              formatterContext.index = i\r\n              formatterContext.part = 'percentage'\r\n              formatterContext.value = d.value\r\n              formatterContext.label = percentage\r\n              percentage = settings.formatter(formatterContext)\r\n            } else {\r\n              percentage += '%'\r\n            }\r\n            return percentage\r\n          })\r\n          .style('font-size', settings.percentage.fontSize + 'px')\r\n          .style('font-family', settings.percentage.font)\r\n          .style('fill', settings.percentage.color)\r\n      }\r\n\r\n      // 3. Add the value label\r\n      if (include.value) {\r\n        labelGroup\r\n          .append('text')\r\n          .attr('id', function (d, i) {\r\n            return pie.cssPrefix + 'segmentValue' + i + '-' + section\r\n          })\r\n          .attr('class', pie.cssPrefix + 'segmentValue-' + section)\r\n          .text(function (d, i) {\r\n            formatterContext.index = i\r\n            formatterContext.part = 'value'\r\n            formatterContext.value = d.value\r\n            formatterContext.label = d.value\r\n            return settings.formatter ? settings.formatter(formatterContext, d.value) : d.value\r\n          })\r\n          .style('font-size', settings.value.fontSize + 'px')\r\n          .style('font-family', settings.value.font)\r\n          .style('fill', settings.value.color)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param section \"inner\" / \"outer\"\r\n     */\r\n    positionLabelElements: function (pie, section, sectionDisplayType) {\r\n      labels['dimensions-' + section] = []\r\n\r\n      // get the latest widths, heights\r\n      var labelGroups = d3.selectAll('.' + pie.cssPrefix + 'labelGroup-' + section)\r\n      labelGroups.each(function (d, i) {\r\n        var mainLabel = d3.select(this).selectAll('.' + pie.cssPrefix + 'segmentMainLabel-' + section)\r\n        var percentage = d3.select(this).selectAll('.' + pie.cssPrefix + 'segmentPercentage-' + section)\r\n        var value = d3.select(this).selectAll('.' + pie.cssPrefix + 'segmentValue-' + section)\r\n\r\n        labels['dimensions-' + section].push({\r\n          mainLabel: mainLabel.node() !== null ? mainLabel.node().getBBox() : null,\r\n          percentage: percentage.node() !== null ? percentage.node().getBBox() : null,\r\n          value: value.node() !== null ? value.node().getBBox() : null\r\n        })\r\n      })\r\n\r\n      var singleLinePad = 5\r\n      var dims = labels['dimensions-' + section]\r\n      switch (sectionDisplayType) {\r\n        case 'label-value1':\r\n          d3.selectAll('.' + pie.cssPrefix + 'segmentValue-' + section).attr('dx', function (d, i) {\r\n            return dims[i].mainLabel.width + singleLinePad\r\n          })\r\n          break\r\n        case 'label-value2':\r\n          d3.selectAll('.' + pie.cssPrefix + 'segmentValue-' + section).attr('dy', function (d, i) {\r\n            return dims[i].mainLabel.height\r\n          })\r\n          break\r\n        case 'label-percentage1':\r\n          d3.selectAll('.' + pie.cssPrefix + 'segmentPercentage-' + section).attr('dx', function (d, i) {\r\n            return dims[i].mainLabel.width + singleLinePad\r\n          })\r\n          break\r\n        case 'label-percentage2':\r\n          d3.selectAll('.' + pie.cssPrefix + 'segmentPercentage-' + section)\r\n            .attr('dx', function (d, i) {\r\n              return dims[i].mainLabel.width / 2 - dims[i].percentage.width / 2\r\n            })\r\n            .attr('dy', function (d, i) {\r\n              return dims[i].mainLabel.height\r\n            })\r\n          break\r\n      }\r\n    },\r\n\r\n    computeLabelLinePositions: function (pie) {\r\n      pie.lineCoordGroups = []\r\n      d3.selectAll('.' + pie.cssPrefix + 'labelGroup-outer').each(function (d, i) {\r\n        return labels.computeLinePosition(pie, i)\r\n      })\r\n    },\r\n\r\n    computeLinePosition: function (pie, i) {\r\n      var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true })\r\n      var originCoords = math.rotate(\r\n        pie.pieCenter.x,\r\n        pie.pieCenter.y - pie.outerRadius,\r\n        pie.pieCenter.x,\r\n        pie.pieCenter.y,\r\n        angle\r\n      )\r\n      var heightOffset = pie.outerLabelGroupData[i].h / 5 // TODO check\r\n      var labelXMargin = 6 // the x-distance of the label from the end of the line [TODO configurable]\r\n\r\n      var quarter = Math.floor(angle / 90)\r\n      var midPoint = 4\r\n      var x2, y2, x3, y3\r\n\r\n      // this resolves an issue when the\r\n      if (quarter === 2 && angle === 180) {\r\n        quarter = 1\r\n      }\r\n\r\n      switch (quarter) {\r\n        case 0:\r\n          x2 =\r\n            pie.outerLabelGroupData[i].x -\r\n            labelXMargin -\r\n            (pie.outerLabelGroupData[i].x - labelXMargin - originCoords.x) / 2\r\n          y2 = pie.outerLabelGroupData[i].y + (originCoords.y - pie.outerLabelGroupData[i].y) / midPoint\r\n          x3 = pie.outerLabelGroupData[i].x - labelXMargin\r\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\r\n          break\r\n        case 1:\r\n          x2 = originCoords.x + (pie.outerLabelGroupData[i].x - originCoords.x) / midPoint\r\n          y2 = originCoords.y + (pie.outerLabelGroupData[i].y - originCoords.y) / midPoint\r\n          x3 = pie.outerLabelGroupData[i].x - labelXMargin\r\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\r\n          break\r\n        case 2:\r\n          var startOfLabelX = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\r\n          x2 = originCoords.x - (originCoords.x - startOfLabelX) / midPoint\r\n          y2 = originCoords.y + (pie.outerLabelGroupData[i].y - originCoords.y) / midPoint\r\n          x3 = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\r\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\r\n          break\r\n        case 3:\r\n          var startOfLabel = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\r\n          x2 = startOfLabel + (originCoords.x - startOfLabel) / midPoint\r\n          y2 = pie.outerLabelGroupData[i].y + (originCoords.y - pie.outerLabelGroupData[i].y) / midPoint\r\n          x3 = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\r\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\r\n          break\r\n      }\r\n\r\n      /*\r\n       * x1 / y1: the x/y coords of the start of the line, at the mid point of the segments arc on the pie circumference\r\n       * x2 / y2: if \"curved\" line style is being used, this is the midpoint of the line. Other\r\n       * x3 / y3: the end of the line; closest point to the label\r\n       */\r\n      if (pie.options.labels.lines.style === 'straight') {\r\n        pie.lineCoordGroups[i] = [{ x: originCoords.x, y: originCoords.y }, { x: x3, y: y3 }]\r\n      } else {\r\n        pie.lineCoordGroups[i] = [{ x: originCoords.x, y: originCoords.y }, { x: x2, y: y2 }, { x: x3, y: y3 }]\r\n      }\r\n    },\r\n\r\n    addLabelLines: function (pie) {\r\n      var lineGroups = pie.svg\r\n        .insert('g', '.' + pie.cssPrefix + 'pieChart') // meaning, BEFORE .pieChart\r\n        .attr('class', pie.cssPrefix + 'lineGroups')\r\n        .style('opacity', 0)\r\n\r\n      var lineGroup = lineGroups\r\n        .selectAll('.' + pie.cssPrefix + 'lineGroup')\r\n        .data(pie.lineCoordGroups)\r\n        .enter()\r\n        .append('g')\r\n        .attr('class', pie.cssPrefix + 'lineGroup')\r\n\r\n      var lineFunction = d3.svg\r\n        .line()\r\n        .interpolate('basis')\r\n        .x(function (d) {\r\n          return d.x\r\n        })\r\n        .y(function (d) {\r\n          return d.y\r\n        })\r\n\r\n      lineGroup\r\n        .append('path')\r\n        .attr('d', lineFunction)\r\n        .attr('stroke', function (d, i) {\r\n          return pie.options.labels.lines.color === 'segment' ? pie.options.colors[i] : pie.options.labels.lines.color\r\n        })\r\n        .attr('stroke-width', 1)\r\n        .attr('fill', 'none')\r\n        .style('opacity', function (d, i) {\r\n          var percentage = pie.options.labels.outer.hideWhenLessThanPercentage\r\n          var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\r\n          var isHidden =\r\n            (percentage !== null && segmentPercentage < percentage) || pie.options.data.content[i].label === ''\r\n          return isHidden ? 0 : 1\r\n        })\r\n    },\r\n\r\n    positionLabelGroups: function (pie, section) {\r\n      if (pie.options.labels[section].format === 'none') {\r\n        return\r\n      }\r\n\r\n      d3.selectAll('.' + pie.cssPrefix + 'labelGroup-' + section)\r\n        .style('opacity', 0)\r\n        .attr('transform', function (d, i) {\r\n          var x, y\r\n          if (section === 'outer') {\r\n            x = pie.outerLabelGroupData[i].x\r\n            y = pie.outerLabelGroupData[i].y\r\n          } else {\r\n            var pieCenterCopy = extend(true, {}, pie.pieCenter)\r\n\r\n            // now recompute the \"center\" based on the current _innerRadius\r\n            if (pie.innerRadius > 0) {\r\n              var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true })\r\n              var newCoords = math.translate(pie.pieCenter.x, pie.pieCenter.y, pie.innerRadius, angle)\r\n              pieCenterCopy.x = newCoords.x\r\n              pieCenterCopy.y = newCoords.y\r\n            }\r\n\r\n            var dims = helpers.getDimensions(pie.cssPrefix + 'labelGroup' + i + '-inner')\r\n            var xOffset = dims.w / 2\r\n            var yOffset = dims.h / 4 // confusing! Why 4? should be 2, but it doesn't look right\r\n\r\n            x = pieCenterCopy.x + (pie.lineCoordGroups[i][0].x - pieCenterCopy.x) / 1.8\r\n            y = pieCenterCopy.y + (pie.lineCoordGroups[i][0].y - pieCenterCopy.y) / 1.8\r\n\r\n            x = x - xOffset\r\n            y = y + yOffset\r\n          }\r\n\r\n          return 'translate(' + x + ',' + y + ')'\r\n        })\r\n    },\r\n\r\n    fadeInLabelsAndLines: function (pie) {\r\n      // fade in the labels when the load effect is complete - or immediately if there's no load effect\r\n      var loadSpeed = pie.options.effects.load.effect === 'default' ? pie.options.effects.load.speed : 1\r\n      setTimeout(function () {\r\n        var labelFadeInTime = pie.options.effects.load.effect === 'default' ? 400 : 1 // 400 is hardcoded for the present\r\n\r\n        d3.selectAll('.' + pie.cssPrefix + 'labelGroup-outer')\r\n          .transition()\r\n          .duration(labelFadeInTime)\r\n          .style('opacity', function (d, i) {\r\n            var percentage = pie.options.labels.outer.hideWhenLessThanPercentage\r\n            var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\r\n            return percentage !== null && segmentPercentage < percentage ? 0 : 1\r\n          })\r\n\r\n        d3.selectAll('.' + pie.cssPrefix + 'labelGroup-inner')\r\n          .transition()\r\n          .duration(labelFadeInTime)\r\n          .style('opacity', function (d, i) {\r\n            var percentage = pie.options.labels.inner.hideWhenLessThanPercentage\r\n            var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\r\n            return percentage !== null && segmentPercentage < percentage ? 0 : 1\r\n          })\r\n\r\n        d3.selectAll('g.' + pie.cssPrefix + 'lineGroups')\r\n          .transition()\r\n          .duration(labelFadeInTime)\r\n          .style('opacity', 1)\r\n\r\n        // once everything's done loading, trigger the onload callback if defined\r\n        if (helpers.isFunction(pie.options.callbacks.onload)) {\r\n          setTimeout(function () {\r\n            try {\r\n              pie.options.callbacks.onload()\r\n            } catch (e) {}\r\n          }, labelFadeInTime)\r\n        }\r\n      }, loadSpeed)\r\n    },\r\n\r\n    getIncludes: function (val) {\r\n      var addMainLabel = false\r\n      var addValue = false\r\n      var addPercentage = false\r\n\r\n      switch (val) {\r\n        case 'label':\r\n          addMainLabel = true\r\n          break\r\n        case 'value':\r\n          addValue = true\r\n          break\r\n        case 'percentage':\r\n          addPercentage = true\r\n          break\r\n        case 'label-value1':\r\n        case 'label-value2':\r\n          addMainLabel = true\r\n          addValue = true\r\n          break\r\n        case 'label-percentage1':\r\n        case 'label-percentage2':\r\n          addMainLabel = true\r\n          addPercentage = true\r\n          break\r\n      }\r\n      return {\r\n        mainLabel: addMainLabel,\r\n        value: addValue,\r\n        percentage: addPercentage\r\n      }\r\n    },\r\n\r\n    /**\r\n     * This does the heavy-lifting to compute the actual coordinates for the outer label groups. It does two things:\r\n     * 1. Make a first pass and position them in the ideal positions, based on the pie sizes\r\n     * 2. Do some basic collision avoidance.\r\n     */\r\n    computeOuterLabelCoords: function (pie) {\r\n      // 1. figure out the ideal positions for the outer labels\r\n      pie.svg.selectAll('.' + pie.cssPrefix + 'labelGroup-outer').each(function (d, i) {\r\n        return labels.getIdealOuterLabelPositions(pie, i)\r\n      })\r\n\r\n      // 2. now adjust those positions to try to accommodate conflicts\r\n      labels.resolveOuterLabelCollisions(pie)\r\n    },\r\n\r\n    /**\r\n     * This attempts to resolve label positioning collisions.\r\n     */\r\n    resolveOuterLabelCollisions: function (pie) {\r\n      if (pie.options.labels.outer.format === 'none') {\r\n        return\r\n      }\r\n\r\n      var size = pie.options.data.content.length\r\n      labels.checkConflict(pie, 0, 'clockwise', size)\r\n      labels.checkConflict(pie, size - 1, 'anticlockwise', size)\r\n    },\r\n\r\n    checkConflict: function (pie, currIndex, direction, size) {\r\n      var i, curr\r\n\r\n      if (size <= 1) {\r\n        return\r\n      }\r\n\r\n      var currIndexHemisphere = pie.outerLabelGroupData[currIndex].hs\r\n      if (direction === 'clockwise' && currIndexHemisphere !== 'right') {\r\n        return\r\n      }\r\n      if (direction === 'anticlockwise' && currIndexHemisphere !== 'left') {\r\n        return\r\n      }\r\n      var nextIndex = direction === 'clockwise' ? currIndex + 1 : currIndex - 1\r\n\r\n      // this is the current label group being looked at. We KNOW it's positioned properly (the first item\r\n      // is always correct)\r\n      var currLabelGroup = pie.outerLabelGroupData[currIndex]\r\n\r\n      // this one we don't know about. That's the one we're going to look at and move if necessary\r\n      var examinedLabelGroup = pie.outerLabelGroupData[nextIndex]\r\n\r\n      var info = {\r\n        labelHeights: pie.outerLabelGroupData[0].h,\r\n        center: pie.pieCenter,\r\n        lineLength: pie.outerRadius + pie.options.labels.outer.pieDistance,\r\n        heightChange: pie.outerLabelGroupData[0].h + 1 // 1 = padding\r\n      }\r\n\r\n      // loop through *ALL* label groups examined so far to check for conflicts. This is because when they're\r\n      // very tightly fitted, a later label group may still appear high up on the page\r\n      if (direction === 'clockwise') {\r\n        i = 0\r\n        for (; i <= currIndex; i++) {\r\n          curr = pie.outerLabelGroupData[i]\r\n\r\n          // if there's a conflict with this label group, shift the label to be AFTER the last known\r\n          // one that's been properly placed\r\n          if (helpers.rectIntersect(curr, examinedLabelGroup)) {\r\n            labels.adjustLabelPos(pie, nextIndex, currLabelGroup, info)\r\n            break\r\n          }\r\n        }\r\n      } else {\r\n        i = size - 1\r\n        for (; i >= currIndex; i--) {\r\n          curr = pie.outerLabelGroupData[i]\r\n\r\n          // if there's a conflict with this label group, shift the label to be AFTER the last known\r\n          // one that's been properly placed\r\n          if (helpers.rectIntersect(curr, examinedLabelGroup)) {\r\n            labels.adjustLabelPos(pie, nextIndex, currLabelGroup, info)\r\n            break\r\n          }\r\n        }\r\n      }\r\n      labels.checkConflict(pie, nextIndex, direction, size)\r\n    },\r\n\r\n    // does a little math to shift a label into a new position based on the last properly placed one\r\n    adjustLabelPos: function (pie, nextIndex, lastCorrectlyPositionedLabel, info) {\r\n      var xDiff, yDiff, newXPos, newYPos\r\n      newYPos = lastCorrectlyPositionedLabel.y + info.heightChange\r\n      yDiff = info.center.y - newYPos\r\n\r\n      if (Math.abs(info.lineLength) > Math.abs(yDiff)) {\r\n        xDiff = Math.sqrt(info.lineLength * info.lineLength - yDiff * yDiff)\r\n      } else {\r\n        xDiff = Math.sqrt(yDiff * yDiff - info.lineLength * info.lineLength)\r\n      }\r\n\r\n      if (lastCorrectlyPositionedLabel.hs === 'right') {\r\n        newXPos = info.center.x + xDiff\r\n      } else {\r\n        newXPos = info.center.x - xDiff - pie.outerLabelGroupData[nextIndex].w\r\n      }\r\n\r\n      pie.outerLabelGroupData[nextIndex].x = newXPos\r\n      pie.outerLabelGroupData[nextIndex].y = newYPos\r\n    },\r\n\r\n    /**\r\n     * @param i 0-N where N is the dataset size - 1.\r\n     */\r\n    getIdealOuterLabelPositions: function (pie, i) {\r\n      var labelGroupNode = d3.select('#' + pie.cssPrefix + 'labelGroup' + i + '-outer').node()\r\n      if (!labelGroupNode) {\r\n        return\r\n      }\r\n      var labelGroupDims = labelGroupNode.getBBox()\r\n      var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true })\r\n\r\n      var originalX = pie.pieCenter.x\r\n      var originalY = pie.pieCenter.y - (pie.outerRadius + pie.options.labels.outer.pieDistance)\r\n      var newCoords = math.rotate(originalX, originalY, pie.pieCenter.x, pie.pieCenter.y, angle)\r\n\r\n      // if the label is on the left half of the pie, adjust the values\r\n      var hemisphere = 'right' // hemisphere\r\n      if (angle > 180) {\r\n        newCoords.x -= labelGroupDims.width + 8\r\n        hemisphere = 'left'\r\n      } else {\r\n        newCoords.x += 8\r\n      }\r\n\r\n      pie.outerLabelGroupData[i] = {\r\n        x: newCoords.x,\r\n        y: newCoords.y,\r\n        w: labelGroupDims.width,\r\n        h: labelGroupDims.height,\r\n        hs: hemisphere\r\n      }\r\n    }\r\n  }\r\n\r\n  //// --------- segments.js -----------\r\n  var segments = {\r\n    /**\r\n     * Creates the pie chart segments and displays them according to the desired load effect.\r\n     * @private\r\n     */\r\n    create: function (pie) {\r\n      var pieCenter = pie.pieCenter\r\n      var colors = pie.options.colors\r\n      var loadEffects = pie.options.effects.load\r\n      var segmentStroke = pie.options.misc.colors.segmentStroke\r\n\r\n      // we insert the pie chart BEFORE the title, to ensure the title overlaps the pie\r\n      var pieChartElement = pie.svg\r\n        .insert('g', '#' + pie.cssPrefix + 'title')\r\n        .attr('transform', function () {\r\n          return math.getPieTranslateCenter(pieCenter)\r\n        })\r\n        .attr('class', pie.cssPrefix + 'pieChart')\r\n\r\n      var arc = d3.svg\r\n        .arc()\r\n        .innerRadius(pie.innerRadius)\r\n        .outerRadius(pie.outerRadius)\r\n        .startAngle(0)\r\n        .endAngle(function (d) {\r\n          return (d.value / pie.totalSize) * 2 * Math.PI\r\n        })\r\n\r\n      var g = pieChartElement\r\n        .selectAll('.' + pie.cssPrefix + 'arc')\r\n        .data(pie.options.data.content)\r\n        .enter()\r\n        .append('g')\r\n        .attr('class', pie.cssPrefix + 'arc')\r\n\r\n      // if we're not fading in the pie, just set the load speed to 0\r\n      var loadSpeed = loadEffects.speed\r\n      if (loadEffects.effect === 'none') {\r\n        loadSpeed = 0\r\n      }\r\n\r\n      g.append('path')\r\n        .attr('id', function (d, i) {\r\n          return pie.cssPrefix + 'segment' + i\r\n        })\r\n        .attr('fill', function (d, i) {\r\n          var color = colors[i]\r\n          if (pie.options.misc.gradient.enabled) {\r\n            color = 'url(#' + pie.cssPrefix + 'grad' + i + ')'\r\n          }\r\n          return color\r\n        })\r\n        .style('stroke', segmentStroke)\r\n        .style('stroke-width', 1)\r\n        .transition()\r\n        .ease('cubic-in-out')\r\n        .duration(loadSpeed)\r\n        .attr('data-index', function (d, i) {\r\n          return i\r\n        })\r\n        .attrTween('d', function (b) {\r\n          var i = d3.interpolate({ value: 0 }, b)\r\n          return function (t) {\r\n            return pie.arc(i(t))\r\n          }\r\n        })\r\n\r\n      pie.svg.selectAll('g.' + pie.cssPrefix + 'arc').attr('transform', function (d, i) {\r\n        var angle = 0\r\n        if (i > 0) {\r\n          angle = segments.getSegmentAngle(i - 1, pie.options.data.content, pie.totalSize)\r\n        }\r\n        return 'rotate(' + angle + ')'\r\n      })\r\n      pie.arc = arc\r\n    },\r\n\r\n    addGradients: function (pie) {\r\n      var grads = pie.svg\r\n        .append('defs')\r\n        .selectAll('radialGradient')\r\n        .data(pie.options.data.content)\r\n        .enter()\r\n        .append('radialGradient')\r\n        .attr('gradientUnits', 'userSpaceOnUse')\r\n        .attr('cx', 0)\r\n        .attr('cy', 0)\r\n        .attr('r', '120%')\r\n        .attr('id', function (d, i) {\r\n          return pie.cssPrefix + 'grad' + i\r\n        })\r\n\r\n      grads\r\n        .append('stop')\r\n        .attr('offset', '0%')\r\n        .style('stop-color', function (d, i) {\r\n          return pie.options.colors[i]\r\n        })\r\n      grads\r\n        .append('stop')\r\n        .attr('offset', pie.options.misc.gradient.percentage + '%')\r\n        .style('stop-color', pie.options.misc.gradient.color)\r\n    },\r\n\r\n    addSegmentEventHandlers: function (pie) {\r\n      var arc = d3.selectAll(\r\n        '.' + pie.cssPrefix + 'arc,.' + pie.cssPrefix + 'labelGroup-inner,.' + pie.cssPrefix + 'labelGroup-outer'\r\n      )\r\n\r\n      arc.on('click', function () {\r\n        var currentEl = d3.select(this)\r\n        var segment\r\n\r\n        // mouseover works on both the segments AND the segment labels, hence the following\r\n        if (currentEl.attr('class') === pie.cssPrefix + 'arc') {\r\n          segment = currentEl.select('path')\r\n        } else {\r\n          var index = currentEl.attr('data-index')\r\n          segment = d3.select('#' + pie.cssPrefix + 'segment' + index)\r\n        }\r\n        var isExpanded = segment.attr('class') === pie.cssPrefix + 'expanded'\r\n        segments.onSegmentEvent(pie, pie.options.callbacks.onClickSegment, segment, isExpanded)\r\n        if (pie.options.effects.pullOutSegmentOnClick.effect !== 'none') {\r\n          if (isExpanded) {\r\n            segments.closeSegment(pie, segment.node())\r\n          } else {\r\n            segments.openSegment(pie, segment.node())\r\n          }\r\n        }\r\n      })\r\n\r\n      arc.on('mouseover', function () {\r\n        var currentEl = d3.select(this)\r\n        var segment, index\r\n\r\n        if (currentEl.attr('class') === pie.cssPrefix + 'arc') {\r\n          segment = currentEl.select('path')\r\n        } else {\r\n          index = currentEl.attr('data-index')\r\n          segment = d3.select('#' + pie.cssPrefix + 'segment' + index)\r\n        }\r\n\r\n        if (pie.options.effects.highlightSegmentOnMouseover) {\r\n          index = segment.attr('data-index')\r\n          var segColor = pie.options.colors[index]\r\n          segment.style('fill', helpers.getColorShade(segColor, pie.options.effects.highlightLuminosity))\r\n        }\r\n\r\n        if (pie.options.tooltips.enabled) {\r\n          index = segment.attr('data-index')\r\n          tt.showTooltip(pie, index)\r\n        }\r\n\r\n        var isExpanded = segment.attr('class') === pie.cssPrefix + 'expanded'\r\n        segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoverSegment, segment, isExpanded)\r\n      })\r\n\r\n      arc.on('mousemove', function () {\r\n        tt.moveTooltip(pie)\r\n      })\r\n\r\n      arc.on('mouseout', function () {\r\n        var currentEl = d3.select(this)\r\n        var segment, index\r\n\r\n        if (currentEl.attr('class') === pie.cssPrefix + 'arc') {\r\n          segment = currentEl.select('path')\r\n        } else {\r\n          index = currentEl.attr('data-index')\r\n          segment = d3.select('#' + pie.cssPrefix + 'segment' + index)\r\n        }\r\n\r\n        if (pie.options.effects.highlightSegmentOnMouseover) {\r\n          index = segment.attr('data-index')\r\n          var color = pie.options.colors[index]\r\n          if (pie.options.misc.gradient.enabled) {\r\n            color = 'url(#' + pie.cssPrefix + 'grad' + index + ')'\r\n          }\r\n          segment.style('fill', color)\r\n        }\r\n\r\n        if (pie.options.tooltips.enabled) {\r\n          index = segment.attr('data-index')\r\n          tt.hideTooltip(pie, index)\r\n        }\r\n\r\n        var isExpanded = segment.attr('class') === pie.cssPrefix + 'expanded'\r\n        segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoutSegment, segment, isExpanded)\r\n      })\r\n    },\r\n\r\n    // helper function used to call the click, mouseover, mouseout segment callback functions\r\n    onSegmentEvent: function (pie, func, segment, isExpanded) {\r\n      if (!helpers.isFunction(func)) {\r\n        return\r\n      }\r\n      var index = parseInt(segment.attr('data-index'), 10)\r\n      func({\r\n        segment: segment.node(),\r\n        index: index,\r\n        expanded: isExpanded,\r\n        data: pie.options.data.content[index]\r\n      })\r\n    },\r\n\r\n    openSegment: function (pie, segment) {\r\n      if (pie.isOpeningSegment) {\r\n        return\r\n      }\r\n      pie.isOpeningSegment = true\r\n\r\n      // close any open segments\r\n      if (d3.selectAll('.' + pie.cssPrefix + 'expanded').length > 0) {\r\n        segments.closeSegment(pie, d3.select('.' + pie.cssPrefix + 'expanded').node())\r\n      }\r\n\r\n      d3.select(segment)\r\n        .transition()\r\n        .ease(pie.options.effects.pullOutSegmentOnClick.effect)\r\n        .duration(pie.options.effects.pullOutSegmentOnClick.speed)\r\n        .attr('transform', function (d, i) {\r\n          var c = pie.arc.centroid(d),\r\n            x = c[0],\r\n            y = c[1],\r\n            h = Math.sqrt(x * x + y * y),\r\n            pullOutSize = parseInt(pie.options.effects.pullOutSegmentOnClick.size, 10)\r\n\r\n          return 'translate(' + (x / h) * pullOutSize + ',' + (y / h) * pullOutSize + ')'\r\n        })\r\n        .each('end', function (d, i) {\r\n          pie.currentlyOpenSegment = segment\r\n          pie.isOpeningSegment = false\r\n          d3.select(this).attr('class', pie.cssPrefix + 'expanded')\r\n        })\r\n    },\r\n\r\n    closeSegment: function (pie, segment) {\r\n      d3.select(segment)\r\n        .transition()\r\n        .duration(400)\r\n        .attr('transform', 'translate(0,0)')\r\n        .each('end', function (d, i) {\r\n          d3.select(this).attr('class', '')\r\n          pie.currentlyOpenSegment = null\r\n        })\r\n    },\r\n\r\n    getCentroid: function (el) {\r\n      var bbox = el.getBBox()\r\n      return {\r\n        x: bbox.x + bbox.width / 2,\r\n        y: bbox.y + bbox.height / 2\r\n      }\r\n    },\r\n\r\n    /**\r\n     * General helper function to return a segment's angle, in various different ways.\r\n     * @param index\r\n     * @param opts optional object for fine-tuning exactly what you want.\r\n     */\r\n    getSegmentAngle: function (index, data, totalSize, opts) {\r\n      var options = extend(\r\n        {\r\n          // if true, this returns the full angle from the origin. Otherwise it returns the single segment angle\r\n          compounded: true,\r\n\r\n          // optionally returns the midpoint of the angle instead of the full angle\r\n          midpoint: false\r\n        },\r\n        opts\r\n      )\r\n\r\n      var currValue = data[index].value\r\n      var fullValue\r\n      if (options.compounded) {\r\n        fullValue = 0\r\n\r\n        // get all values up to and including the specified index\r\n        for (var i = 0; i <= index; i++) {\r\n          fullValue += data[i].value\r\n        }\r\n      }\r\n\r\n      if (typeof fullValue === 'undefined') {\r\n        fullValue = currValue\r\n      }\r\n\r\n      // now convert the full value to an angle\r\n      var angle = (fullValue / totalSize) * 360\r\n\r\n      // lastly, if we want the midpoint, factor that sucker in\r\n      if (options.midpoint) {\r\n        var currAngle = (currValue / totalSize) * 360\r\n        angle -= currAngle / 2\r\n      }\r\n\r\n      return angle\r\n    },\r\n\r\n    getPercentage: function (pie, index, decimalPlaces) {\r\n      var relativeAmount = pie.options.data.content[index].value / pie.totalSize\r\n      if (decimalPlaces <= 0) {\r\n        return Math.round(relativeAmount * 100)\r\n      } else {\r\n        return (relativeAmount * 100).toFixed(decimalPlaces)\r\n      }\r\n    }\r\n  }\r\n\r\n  //// --------- text.js -----------\r\n  var text = {\r\n    offscreenCoord: -10000,\r\n\r\n    addTitle: function (pie) {\r\n      var title = pie.svg\r\n        .selectAll('.' + pie.cssPrefix + 'title')\r\n        .data([pie.options.header.title])\r\n        .enter()\r\n        .append('text')\r\n        .text(function (d) {\r\n          return d.text\r\n        })\r\n        .attr({\r\n          id: pie.cssPrefix + 'title',\r\n          class: pie.cssPrefix + 'title',\r\n          x: text.offscreenCoord,\r\n          y: text.offscreenCoord\r\n        })\r\n        .attr('text-anchor', function () {\r\n          var location\r\n          if (pie.options.header.location === 'top-center' || pie.options.header.location === 'pie-center') {\r\n            location = 'middle'\r\n          } else {\r\n            location = 'left'\r\n          }\r\n          return location\r\n        })\r\n        .attr('fill', function (d) {\r\n          return d.color\r\n        })\r\n        .style('font-size', function (d) {\r\n          return d.fontSize + 'px'\r\n        })\r\n        .style('font-family', function (d) {\r\n          return d.font\r\n        })\r\n    },\r\n\r\n    positionTitle: function (pie) {\r\n      var textComponents = pie.textComponents\r\n      var headerLocation = pie.options.header.location\r\n      var canvasPadding = pie.options.misc.canvasPadding\r\n      var canvasWidth = pie.options.size.canvasWidth\r\n      var titleSubtitlePadding = pie.options.header.titleSubtitlePadding\r\n\r\n      var x\r\n      if (headerLocation === 'top-left') {\r\n        x = canvasPadding.left\r\n      } else {\r\n        x = (canvasWidth - canvasPadding.right) / 2 + canvasPadding.left\r\n      }\r\n\r\n      // add whatever offset has been added by user\r\n      x += pie.options.misc.pieCenterOffset.x\r\n\r\n      var y = canvasPadding.top + textComponents.title.h\r\n\r\n      if (headerLocation === 'pie-center') {\r\n        y = pie.pieCenter.y\r\n\r\n        // still not fully correct\r\n        if (textComponents.subtitle.exists) {\r\n          var totalTitleHeight = textComponents.title.h + titleSubtitlePadding + textComponents.subtitle.h\r\n          y = y - totalTitleHeight / 2 + textComponents.title.h\r\n        } else {\r\n          y += textComponents.title.h / 4\r\n        }\r\n      }\r\n\r\n      pie.svg\r\n        .select('#' + pie.cssPrefix + 'title')\r\n        .attr('x', x)\r\n        .attr('y', y)\r\n    },\r\n\r\n    addSubtitle: function (pie) {\r\n      var headerLocation = pie.options.header.location\r\n\r\n      pie.svg\r\n        .selectAll('.' + pie.cssPrefix + 'subtitle')\r\n        .data([pie.options.header.subtitle])\r\n        .enter()\r\n        .append('text')\r\n        .text(function (d) {\r\n          return d.text\r\n        })\r\n        .attr('x', text.offscreenCoord)\r\n        .attr('y', text.offscreenCoord)\r\n        .attr('id', pie.cssPrefix + 'subtitle')\r\n        .attr('class', pie.cssPrefix + 'subtitle')\r\n        .attr('text-anchor', function () {\r\n          var location\r\n          if (headerLocation === 'top-center' || headerLocation === 'pie-center') {\r\n            location = 'middle'\r\n          } else {\r\n            location = 'left'\r\n          }\r\n          return location\r\n        })\r\n        .attr('fill', function (d) {\r\n          return d.color\r\n        })\r\n        .style('font-size', function (d) {\r\n          return d.fontSize + 'px'\r\n        })\r\n        .style('font-family', function (d) {\r\n          return d.font\r\n        })\r\n    },\r\n\r\n    positionSubtitle: function (pie) {\r\n      var canvasPadding = pie.options.misc.canvasPadding\r\n      var canvasWidth = pie.options.size.canvasWidth\r\n\r\n      var x\r\n      if (pie.options.header.location === 'top-left') {\r\n        x = canvasPadding.left\r\n      } else {\r\n        x = (canvasWidth - canvasPadding.right) / 2 + canvasPadding.left\r\n      }\r\n\r\n      // add whatever offset has been added by user\r\n      x += pie.options.misc.pieCenterOffset.x\r\n\r\n      var y = text.getHeaderHeight(pie)\r\n      pie.svg\r\n        .select('#' + pie.cssPrefix + 'subtitle')\r\n        .attr('x', x)\r\n        .attr('y', y)\r\n    },\r\n\r\n    addFooter: function (pie) {\r\n      pie.svg\r\n        .selectAll('.' + pie.cssPrefix + 'footer')\r\n        .data([pie.options.footer])\r\n        .enter()\r\n        .append('text')\r\n        .text(function (d) {\r\n          return d.text\r\n        })\r\n        .attr('x', text.offscreenCoord)\r\n        .attr('y', text.offscreenCoord)\r\n        .attr('id', pie.cssPrefix + 'footer')\r\n        .attr('class', pie.cssPrefix + 'footer')\r\n        .attr('text-anchor', function () {\r\n          var location = 'left'\r\n          if (pie.options.footer.location === 'bottom-center') {\r\n            location = 'middle'\r\n          } else if (pie.options.footer.location === 'bottom-right') {\r\n            location = 'left' // on purpose. We have to change the x-coord to make it properly right-aligned\r\n          }\r\n          return location\r\n        })\r\n        .attr('fill', function (d) {\r\n          return d.color\r\n        })\r\n        .style('font-size', function (d) {\r\n          return d.fontSize + 'px'\r\n        })\r\n        .style('font-family', function (d) {\r\n          return d.font\r\n        })\r\n    },\r\n\r\n    positionFooter: function (pie) {\r\n      var footerLocation = pie.options.footer.location\r\n      var footerWidth = pie.textComponents.footer.w\r\n      var canvasWidth = pie.options.size.canvasWidth\r\n      var canvasHeight = pie.options.size.canvasHeight\r\n      var canvasPadding = pie.options.misc.canvasPadding\r\n\r\n      var x\r\n      if (footerLocation === 'bottom-left') {\r\n        x = canvasPadding.left\r\n      } else if (footerLocation === 'bottom-right') {\r\n        x = canvasWidth - footerWidth - canvasPadding.right\r\n      } else {\r\n        x = canvasWidth / 2 // TODO - shouldn't this also take into account padding?\r\n      }\r\n\r\n      pie.svg\r\n        .select('#' + pie.cssPrefix + 'footer')\r\n        .attr('x', x)\r\n        .attr('y', canvasHeight - canvasPadding.bottom)\r\n    },\r\n\r\n    getHeaderHeight: function (pie) {\r\n      var h\r\n      if (pie.textComponents.title.exists) {\r\n        // if the subtitle isn't defined, it'll be set to 0\r\n        var totalTitleHeight =\r\n          pie.textComponents.title.h + pie.options.header.titleSubtitlePadding + pie.textComponents.subtitle.h\r\n        if (pie.options.header.location === 'pie-center') {\r\n          h = pie.pieCenter.y - totalTitleHeight / 2 + totalTitleHeight\r\n        } else {\r\n          h = totalTitleHeight + pie.options.misc.canvasPadding.top\r\n        }\r\n      } else {\r\n        if (pie.options.header.location === 'pie-center') {\r\n          var footerPlusPadding = pie.options.misc.canvasPadding.bottom + pie.textComponents.footer.h\r\n          h =\r\n            (pie.options.size.canvasHeight - footerPlusPadding) / 2 +\r\n            pie.options.misc.canvasPadding.top +\r\n            pie.textComponents.subtitle.h / 2\r\n        } else {\r\n          h = pie.options.misc.canvasPadding.top + pie.textComponents.subtitle.h\r\n        }\r\n      }\r\n      return h\r\n    }\r\n  }\r\n\r\n  //// --------- validate.js -----------\r\n  var tt = {\r\n    addTooltips: function (pie) {\r\n      // group the label groups (label, percentage, value) into a single element for simpler positioning\r\n      var tooltips = pie.svg.insert('g').attr('class', pie.cssPrefix + 'tooltips')\r\n\r\n      tooltips\r\n        .selectAll('.' + pie.cssPrefix + 'tooltip')\r\n        .data(pie.options.data.content)\r\n        .enter()\r\n        .append('g')\r\n        .attr('class', pie.cssPrefix + 'tooltip')\r\n        .attr('id', function (d, i) {\r\n          return pie.cssPrefix + 'tooltip' + i\r\n        })\r\n        .style('opacity', 0)\r\n        .append('rect')\r\n        .attr({\r\n          rx: pie.options.tooltips.styles.borderRadius,\r\n          ry: pie.options.tooltips.styles.borderRadius,\r\n          x: -pie.options.tooltips.styles.padding,\r\n          opacity: pie.options.tooltips.styles.backgroundOpacity\r\n        })\r\n        .style('fill', pie.options.tooltips.styles.backgroundColor)\r\n\r\n      tooltips\r\n        .selectAll('.' + pie.cssPrefix + 'tooltip')\r\n        .data(pie.options.data.content)\r\n        .append('text')\r\n        .attr('fill', function (d) {\r\n          return pie.options.tooltips.styles.color\r\n        })\r\n        .style('font-size', function (d) {\r\n          return pie.options.tooltips.styles.fontSize\r\n        })\r\n        .style('font-family', function (d) {\r\n          return pie.options.tooltips.styles.font\r\n        })\r\n        .text(function (d, i) {\r\n          var caption = pie.options.tooltips.string\r\n          if (pie.options.tooltips.type === 'caption') {\r\n            caption = d.caption\r\n          }\r\n          return tt.replacePlaceholders(pie, caption, i, {\r\n            label: d.label,\r\n            value: d.value,\r\n            percentage: segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\r\n          })\r\n        })\r\n\r\n      tooltips.selectAll('.' + pie.cssPrefix + 'tooltip rect').attr({\r\n        width: function (d, i) {\r\n          var dims = helpers.getDimensions(pie.cssPrefix + 'tooltip' + i)\r\n          return dims.w + 2 * pie.options.tooltips.styles.padding\r\n        },\r\n        height: function (d, i) {\r\n          var dims = helpers.getDimensions(pie.cssPrefix + 'tooltip' + i)\r\n          return dims.h + 2 * pie.options.tooltips.styles.padding\r\n        },\r\n        y: function (d, i) {\r\n          var dims = helpers.getDimensions(pie.cssPrefix + 'tooltip' + i)\r\n          return -(dims.h / 2) + 1\r\n        }\r\n      })\r\n    },\r\n\r\n    showTooltip: function (pie, index) {\r\n      var fadeInSpeed = pie.options.tooltips.styles.fadeInSpeed\r\n      if (tt.currentTooltip === index) {\r\n        fadeInSpeed = 1\r\n      }\r\n\r\n      tt.currentTooltip = index\r\n      d3.select('#' + pie.cssPrefix + 'tooltip' + index)\r\n        .transition()\r\n        .duration(fadeInSpeed)\r\n        .style('opacity', function () {\r\n          return 1\r\n        })\r\n\r\n      tt.moveTooltip(pie)\r\n    },\r\n\r\n    moveTooltip: function (pie) {\r\n      d3.selectAll('#' + pie.cssPrefix + 'tooltip' + tt.currentTooltip).attr('transform', function (d) {\r\n        var mouseCoords = d3.mouse(this.parentNode)\r\n        var x = mouseCoords[0] + pie.options.tooltips.styles.padding + 2\r\n        var y = mouseCoords[1] - 2 * pie.options.tooltips.styles.padding - 2\r\n        return 'translate(' + x + ',' + y + ')'\r\n      })\r\n    },\r\n\r\n    hideTooltip: function (pie, index) {\r\n      d3.select('#' + pie.cssPrefix + 'tooltip' + index).style('opacity', function () {\r\n        return 0\r\n      })\r\n\r\n      // move the tooltip offscreen. This ensures that when the user next mouseovers the segment the hidden\r\n      // element won't interfere\r\n      d3.select('#' + pie.cssPrefix + 'tooltip' + tt.currentTooltip).attr('transform', function (d, i) {\r\n        // klutzy, but it accounts for tooltip padding which could push it onscreen\r\n        var x = pie.options.size.canvasWidth + 1000\r\n        var y = pie.options.size.canvasHeight + 1000\r\n        return 'translate(' + x + ',' + y + ')'\r\n      })\r\n    },\r\n\r\n    replacePlaceholders: function (pie, str, index, replacements) {\r\n      // if the user has defined a placeholderParser function, call it before doing the replacements\r\n      if (helpers.isFunction(pie.options.tooltips.placeholderParser)) {\r\n        pie.options.tooltips.placeholderParser(index, replacements)\r\n      }\r\n\r\n      var replacer = function () {\r\n        return function (match) {\r\n          var placeholder = arguments[1]\r\n          if (replacements.hasOwnProperty(placeholder)) {\r\n            return replacements[arguments[1]]\r\n          } else {\r\n            return arguments[0]\r\n          }\r\n        }\r\n      }\r\n      return str.replace(/\\{(\\w+)\\}/g, replacer(replacements))\r\n    }\r\n  }\r\n\r\n  // --------------------------------------------------------------------------------------------\r\n\r\n  // our constructor\r\n  var d3pie = function (element, options) {\r\n    // element can be an ID or DOM element\r\n    this.element = element\r\n    if (typeof element === 'string') {\r\n      var el = element.replace(/^#/, '') // replace any jQuery-like ID hash char\r\n      this.element = document.getElementById(el)\r\n    }\r\n\r\n    var opts = {}\r\n    extend(true, opts, defaultSettings, options)\r\n    this.options = opts\r\n\r\n    // if the user specified a custom CSS element prefix (ID, class), use it\r\n    if (this.options.misc.cssPrefix !== null) {\r\n      this.cssPrefix = this.options.misc.cssPrefix\r\n    } else {\r\n      this.cssPrefix = 'p' + _uniqueIDCounter + '_'\r\n      _uniqueIDCounter++\r\n    }\r\n\r\n    // now run some validation on the user-defined info\r\n    if (!validate.initialCheck(this)) {\r\n      return\r\n    }\r\n\r\n    // add a data-role to the DOM node to let anyone know that it contains a d3pie instance, and the d3pie version\r\n    d3.select(this.element).attr(_scriptName, _version)\r\n\r\n    // things that are done once\r\n    this.options.data.content = math.sortPieData(this)\r\n    if (this.options.data.smallSegmentGrouping.enabled) {\r\n      this.options.data.content = helpers.applySmallSegmentGrouping(\r\n        this.options.data.content,\r\n        this.options.data.smallSegmentGrouping\r\n      )\r\n    }\r\n    this.options.colors = helpers.initSegmentColors(this)\r\n    this.totalSize = math.getTotalPieSize(this.options.data.content)\r\n\r\n    _init.call(this)\r\n  }\r\n\r\n  d3pie.prototype.recreate = function () {\r\n    // now run some validation on the user-defined info\r\n    if (!validate.initialCheck(this)) {\r\n      return\r\n    }\r\n    this.options.data.content = math.sortPieData(this)\r\n    if (this.options.data.smallSegmentGrouping.enabled) {\r\n      this.options.data.content = helpers.applySmallSegmentGrouping(\r\n        this.options.data.content,\r\n        this.options.data.smallSegmentGrouping\r\n      )\r\n    }\r\n    this.options.colors = helpers.initSegmentColors(this)\r\n    this.totalSize = math.getTotalPieSize(this.options.data.content)\r\n\r\n    _init.call(this)\r\n  }\r\n\r\n  d3pie.prototype.redraw = function () {\r\n    this.element.innerHTML = ''\r\n    _init.call(this)\r\n  }\r\n\r\n  d3pie.prototype.destroy = function () {\r\n    this.element.innerHTML = '' // clear out the SVG\r\n    d3.select(this.element).attr(_scriptName, null) // remove the data attr\r\n  }\r\n\r\n  /**\r\n   * Returns all pertinent info about the current open info. Returns null if nothing's open, or if one is, an object of\r\n   * the following form:\r\n   * \t{\r\n   * \t  element: DOM NODE,\r\n   * \t  index: N,\r\n   * \t  data: {}\r\n   * \t}\r\n   */\r\n  d3pie.prototype.getOpenSegment = function () {\r\n    var segment = this.currentlyOpenSegment\r\n    if (segment !== null && typeof segment !== 'undefined') {\r\n      var index = parseInt(d3.select(segment).attr('data-index'), 10)\r\n      return {\r\n        element: segment,\r\n        index: index,\r\n        data: this.options.data.content[index]\r\n      }\r\n    } else {\r\n      return null\r\n    }\r\n  }\r\n\r\n  d3pie.prototype.openSegment = function (index) {\r\n    index = parseInt(index, 10)\r\n    if (index < 0 || index > this.options.data.content.length - 1) {\r\n      return\r\n    }\r\n    segments.openSegment(this, d3.select('#' + this.cssPrefix + 'segment' + index).node())\r\n  }\r\n\r\n  d3pie.prototype.closeSegment = function () {\r\n    var segment = this.currentlyOpenSegment\r\n    if (segment) {\r\n      segments.closeSegment(this, segment)\r\n    }\r\n  }\r\n\r\n  // this let's the user dynamically update aspects of the pie chart without causing a complete redraw. It\r\n  // intelligently re-renders only the part of the pie that the user specifies. Some things cause a repaint, others\r\n  // just redraw the single element\r\n  d3pie.prototype.updateProp = function (propKey, value) {\r\n    switch (propKey) {\r\n      case 'header.title.text':\r\n        var oldVal = helpers.processObj(this.options, propKey)\r\n        helpers.processObj(this.options, propKey, value)\r\n        d3.select('#' + this.cssPrefix + 'title').html(value)\r\n        if ((oldVal === '' && value !== '') || (oldVal !== '' && value === '')) {\r\n          this.redraw()\r\n        }\r\n        break\r\n\r\n      case 'header.subtitle.text':\r\n        var oldValue = helpers.processObj(this.options, propKey)\r\n        helpers.processObj(this.options, propKey, value)\r\n        d3.select('#' + this.cssPrefix + 'subtitle').html(value)\r\n        if ((oldValue === '' && value !== '') || (oldValue !== '' && value === '')) {\r\n          this.redraw()\r\n        }\r\n        break\r\n\r\n      case 'callbacks.onload':\r\n      case 'callbacks.onMouseoverSegment':\r\n      case 'callbacks.onMouseoutSegment':\r\n      case 'callbacks.onClickSegment':\r\n      case 'effects.pullOutSegmentOnClick.effect':\r\n      case 'effects.pullOutSegmentOnClick.speed':\r\n      case 'effects.pullOutSegmentOnClick.size':\r\n      case 'effects.highlightSegmentOnMouseover':\r\n      case 'effects.highlightLuminosity':\r\n        helpers.processObj(this.options, propKey, value)\r\n        break\r\n\r\n      // everything else, attempt to update it & do a repaint\r\n      default:\r\n        helpers.processObj(this.options, propKey, value)\r\n\r\n        this.destroy()\r\n        this.recreate()\r\n        break\r\n    }\r\n  }\r\n\r\n  // ------------------------------------------------------------------------------------------------\r\n\r\n  var _init = function () {\r\n    // prep-work\r\n    this.svg = helpers.addSVGSpace(this)\r\n\r\n    // store info about the main text components as part of the d3pie object instance\r\n    this.textComponents = {\r\n      headerHeight: 0,\r\n      title: {\r\n        exists: this.options.header.title.text !== '',\r\n        h: 0,\r\n        w: 0\r\n      },\r\n      subtitle: {\r\n        exists: this.options.header.subtitle.text !== '',\r\n        h: 0,\r\n        w: 0\r\n      },\r\n      footer: {\r\n        exists: this.options.footer.text !== '',\r\n        h: 0,\r\n        w: 0\r\n      }\r\n    }\r\n\r\n    this.outerLabelGroupData = []\r\n\r\n    // add the key text components offscreen (title, subtitle, footer). We need to know their widths/heights for later computation\r\n    if (this.textComponents.title.exists) {\r\n      text.addTitle(this)\r\n    }\r\n    if (this.textComponents.subtitle.exists) {\r\n      text.addSubtitle(this)\r\n    }\r\n    text.addFooter(this)\r\n\r\n    // the footer never moves. Put it in place now\r\n    var self = this\r\n    helpers.whenIdExists(this.cssPrefix + 'footer', function () {\r\n      text.positionFooter(self)\r\n      var d3 = helpers.getDimensions(self.cssPrefix + 'footer')\r\n      self.textComponents.footer.h = d3.h\r\n      self.textComponents.footer.w = d3.w\r\n    })\r\n\r\n    // now create the pie chart and position everything accordingly\r\n    var reqEls = []\r\n    if (this.textComponents.title.exists) {\r\n      reqEls.push(this.cssPrefix + 'title')\r\n    }\r\n    if (this.textComponents.subtitle.exists) {\r\n      reqEls.push(this.cssPrefix + 'subtitle')\r\n    }\r\n    if (this.textComponents.footer.exists) {\r\n      reqEls.push(this.cssPrefix + 'footer')\r\n    }\r\n\r\n    helpers.whenElementsExist(reqEls, function () {\r\n      if (self.textComponents.title.exists) {\r\n        var d1 = helpers.getDimensions(self.cssPrefix + 'title')\r\n        self.textComponents.title.h = d1.h\r\n        self.textComponents.title.w = d1.w\r\n      }\r\n      if (self.textComponents.subtitle.exists) {\r\n        var d2 = helpers.getDimensions(self.cssPrefix + 'subtitle')\r\n        self.textComponents.subtitle.h = d2.h\r\n        self.textComponents.subtitle.w = d2.w\r\n      }\r\n      // now compute the full header height\r\n      if (self.textComponents.title.exists || self.textComponents.subtitle.exists) {\r\n        var headerHeight = 0\r\n        if (self.textComponents.title.exists) {\r\n          headerHeight += self.textComponents.title.h\r\n          if (self.textComponents.subtitle.exists) {\r\n            headerHeight += self.options.header.titleSubtitlePadding\r\n          }\r\n        }\r\n        if (self.textComponents.subtitle.exists) {\r\n          headerHeight += self.textComponents.subtitle.h\r\n        }\r\n        self.textComponents.headerHeight = headerHeight\r\n      }\r\n\r\n      // at this point, all main text component dimensions have been calculated\r\n      math.computePieRadius(self)\r\n\r\n      // this value is used all over the place for placing things and calculating locations. We figure it out ONCE\r\n      // and store it as part of the object\r\n      math.calculatePieCenter(self)\r\n\r\n      // position the title and subtitle\r\n      text.positionTitle(self)\r\n      text.positionSubtitle(self)\r\n\r\n      // now create the pie chart segments, and gradients if the user desired\r\n      if (self.options.misc.gradient.enabled) {\r\n        segments.addGradients(self)\r\n      }\r\n      segments.create(self) // also creates this.arc\r\n      labels.add(self, 'inner', self.options.labels.inner.format)\r\n      labels.add(self, 'outer', self.options.labels.outer.format)\r\n\r\n      // position the label elements relatively within their individual group (label, percentage, value)\r\n      labels.positionLabelElements(self, 'inner', self.options.labels.inner.format)\r\n      labels.positionLabelElements(self, 'outer', self.options.labels.outer.format)\r\n      labels.computeOuterLabelCoords(self)\r\n\r\n      // this is (and should be) dumb. It just places the outer groups at their calculated, collision-free positions\r\n      labels.positionLabelGroups(self, 'outer')\r\n\r\n      // we use the label line positions for many other calculations, so ALWAYS compute them\r\n      labels.computeLabelLinePositions(self)\r\n\r\n      // only add them if they're actually enabled\r\n      if (self.options.labels.lines.enabled && self.options.labels.outer.format !== 'none') {\r\n        labels.addLabelLines(self)\r\n      }\r\n\r\n      labels.positionLabelGroups(self, 'inner')\r\n      labels.fadeInLabelsAndLines(self)\r\n\r\n      // add and position the tooltips\r\n      if (self.options.tooltips.enabled) {\r\n        tt.addTooltips(self)\r\n      }\r\n\r\n      segments.addSegmentEventHandlers(self)\r\n    })\r\n  }\r\n\r\n  return d3pie\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/d3pie/d3pie.min.js?");

/***/ }),

/***/ 27:
/*!****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.grouping.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/*\r\n * File:        jquery.dataTables.grouping.js\r\n * Version:     1.2.9.\r\n * Author:      Jovan Popovic\r\n *\r\n * Copyright 2013 Jovan Popovic, all rights reserved.\r\n *\r\n * This source file is free software, under either the GPL v2 license or a\r\n * BSD style license, as supplied with this software.\r\n *\r\n * This source file is distributed in the hope that it will be useful, but\r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n * or FITNESS FOR A PARTICULAR PURPOSE.\r\n * Parameters:\r\n * @iGroupingColumnIndex                                 Integer             Index of the column that will be used for grouping - default 0\r\n * @sGroupingColumnSortDirection                         Enumeration         Sort direction of the group\r\n * @iGroupingOrderByColumnIndex                          Integer             Index of the column that will be used for ordering groups\r\n * @sGroupingClass                                       String              Class that will be associated to the group row. Default - \"group\"\r\n * @sGroupItemClass                                      String              Class that will be associated to the group row of group items. Default - \"group-item\"\r\n * @bSetGroupingClassOnTR                                Boolean             If set class will be set to the TR instead of the TD withing the grouping TR\r\n * @bHideGroupingColumn                                  Boolean             Hide column used for grouping once results are grouped. Default - true\r\n * @bHideGroupingOrderByColumn                           Boolean             Hide column used for ordering groups once results are grouped. Default - true\r\n * @sGroupBy                                             Enumeration         Type of grouping that should be applied. Values \"name\"(default), \"letter\", \"year\"\r\n * @sGroupLabelPrefix                                    String              Prefix that will be added to each group cell\r\n * @bExpandableGrouping                                  Boolean             Attach expand/collapse handlers to the grouping rows\r\n * @bExpandSingleGroup                                   Boolean             Use accordon grouping\r\n * @iExpandGroupOffset                                   Integer             Number of pixels to set scroll position above the currently selected group. If -1 scroll will be alligned to the table\r\n * General settings\r\n * @sDateFormat: \"dd/MM/yyyy\"                            String              Date format used for grouping\r\n * @sEmptyGroupLabel                                     String              Lable that will be placed as group if grouping cells are empty. Default \"-\"\r\n\r\n * Parameters used in the second level grouping\r\n * @iGroupingColumnIndex2                                Integer             Index of the secondary column that will be used for grouping - default 0\r\n * @sGroupingColumnSortDirection2                        Enumeration         Sort direction of the secondary group\r\n * @iGroupingOrderByColumnIndex2                         Integer             Index of the column that will be used for ordering secondary groups\r\n * @sGroupingClass2                                      String              Class that will be associated to the secondary group row. Default \"subgroup\"\r\n * @sGroupItemClass2                                     String              Class that will be associated to the secondary group row of group items. Default \"subgroup-item\"\r\n * @bHideGroupingColumn2                                 Boolean             Hide column used for secondary grouping once results are grouped. Default - true,\r\n * @bHideGroupingOrderByColumn2                          Boolean             Hide column used for ordering secondary groups once results are grouped. Default - true,\r\n * @sGroupBy2                                            Enumeration         Type of grouping that should be applied to secondary column. Values \"name\"(default), \"letter\", \"year\",\r\n * @sGroupLabelPrefix2                                   String              Prefix that will be added to each secondary group cell\r\n * @fnOnGrouped                                          Function            Function that is called when grouping is finished. Function has no parameters.\r\n */\r\n;(function (a) {\r\n  a.fn.rowGrouping = function (e) {\r\n    function b () {}\r\n    function c (j, h, i) {}\r\n    function d (j, h, i) {}\r\n    function g (i) {\r\n      var h = [\r\n        'January',\r\n        'February',\r\n        'March',\r\n        'April',\r\n        'May',\r\n        'June',\r\n        'July',\r\n        'August',\r\n        'September',\r\n        'October',\r\n        'November',\r\n        'December'\r\n      ]\r\n      return h[i - 1]\r\n    }\r\n    var f = {\r\n      iGroupingColumnIndex: 0,\r\n      sGroupingColumnSortDirection: '',\r\n      iGroupingOrderByColumnIndex: -1,\r\n      sGroupingClass: 'group',\r\n      sGroupItemClass: 'group-item',\r\n      bHideGroupingColumn: true,\r\n      bHideGroupingOrderByColumn: true,\r\n      sGroupBy: 'name',\r\n      sGroupLabelPrefix: '',\r\n      fnGroupLabelFormat: function (h) {\r\n        return h\r\n      },\r\n      bExpandableGrouping: false,\r\n      bExpandSingleGroup: false,\r\n      iExpandGroupOffset: 100,\r\n      asExpandedGroups: null,\r\n      sDateFormat: 'dd/MM/yyyy',\r\n      sEmptyGroupLabel: '-',\r\n      bSetGroupingClassOnTR: false,\r\n      iGroupingColumnIndex2: -1,\r\n      sGroupingColumnSortDirection2: '',\r\n      iGroupingOrderByColumnIndex2: -1,\r\n      sGroupingClass2: 'subgroup',\r\n      sGroupItemClass2: 'subgroup-item',\r\n      bHideGroupingColumn2: true,\r\n      bHideGroupingOrderByColumn2: true,\r\n      sGroupBy2: 'name',\r\n      sGroupLabelPrefix2: '',\r\n      fnGroupLabelFormat2: function (h) {\r\n        return h\r\n      },\r\n      bExpandableGrouping2: false,\r\n      fnOnGrouped: b,\r\n      fnOnGroupCreated: c,\r\n      fnOnGroupCompleted: d,\r\n      oHideEffect: null,\r\n      oShowEffect: null,\r\n      bUseFilteringForGrouping: false\r\n    }\r\n    return this.each(function (s, J) {\r\n      var E = a(J).dataTable()\r\n      var B = new Array()\r\n      a(this).dataTableExt.aoGroups = B\r\n      function q (T, i, P) {\r\n        var R = document.createElement('tr')\r\n        var S = document.createElement('td')\r\n        R.id = 'group-id-' + E.attr('id') + '_' + T\r\n        var Q = {\r\n          id: R.id,\r\n          key: T,\r\n          text: i,\r\n          level: 0,\r\n          groupItemClass: '.group-item-' + T,\r\n          dataGroup: T,\r\n          aoSubgroups: new Array()\r\n        }\r\n        if (t.bSetGroupingClassOnTR) {\r\n          R.className = t.sGroupingClass + ' ' + T\r\n        } else {\r\n          S.className = t.sGroupingClass + ' ' + T\r\n        }\r\n        S.colSpan = P\r\n        S.innerHTML = t.sGroupLabelPrefix + t.fnGroupLabelFormat(i == '' ? t.sEmptyGroupLabel : i, Q)\r\n        if (t.bExpandableGrouping) {\r\n          if (!I(T)) {\r\n            S.className += ' expanded-group'\r\n            Q.state = 'expanded'\r\n          } else {\r\n            S.className += ' collapsed-group'\r\n            Q.state = 'collapsed'\r\n          }\r\n          S.className += ' group-item-expander'\r\n          a(S).attr('data-group', Q.dataGroup)\r\n          a(S).attr('data-group-level', Q.level)\r\n          a(S).click(h)\r\n        }\r\n        R.appendChild(S)\r\n        B[T] = Q\r\n        Q.nGroup = R\r\n        t.fnOnGroupCreated(Q, T, 1)\r\n        return Q\r\n      }\r\n      function w (R, Q, P, T) {\r\n        var i = document.createElement('tr')\r\n        i.id = T.id + '_' + R\r\n        var V = document.createElement('td')\r\n        var U = T.dataGroup + '_' + R\r\n        var S = {\r\n          id: i.id,\r\n          key: R,\r\n          text: Q,\r\n          level: T.level + 1,\r\n          groupItemClass: '.group-item-' + U,\r\n          dataGroup: U,\r\n          aoSubgroups: new Array()\r\n        }\r\n        if (t.bSetGroupingClassOnTR) {\r\n          i.className = t.sGroupingClass2 + ' ' + R\r\n        } else {\r\n          V.className = t.sGroupingClass2 + ' ' + R\r\n        }\r\n        V.colSpan = P\r\n        V.innerHTML = t.sGroupLabelPrefix2 + t.fnGroupLabelFormat2(Q == '' ? t.sEmptyGroupLabel : Q, S)\r\n        if (t.bExpandableGrouping) {\r\n          i.className += ' group-item-' + T.dataGroup\r\n        }\r\n        if (t.bExpandableGrouping && t.bExpandableGrouping2) {\r\n          if (!I(S.dataGroup)) {\r\n            V.className += ' expanded-group'\r\n            S.state = 'expanded'\r\n          } else {\r\n            V.className += ' collapsed-group'\r\n            S.state = 'collapsed'\r\n          }\r\n          V.className += ' group-item-expander'\r\n          a(V).attr('data-group', S.dataGroup)\r\n          a(V).attr('data-group-level', S.level)\r\n          a(V).click(h)\r\n        }\r\n        i.appendChild(V)\r\n        T.aoSubgroups[S.dataGroup] = S\r\n        B[S.dataGroup] = S\r\n        S.nGroup = i\r\n        t.fnOnGroupCreated(S, R, 2)\r\n        return S\r\n      }\r\n      function I (i) {\r\n        if (B[i] != null) {\r\n          return B[i].state == 'collapsed'\r\n        } else {\r\n          if (i.indexOf('_') > -1) {\r\n            true\r\n          } else {\r\n            if (l && (j == null || j.length == 0)) {\r\n              return false\r\n            } else {\r\n              return a.inArray(i, j) == -1\r\n            }\r\n          }\r\n        }\r\n      }\r\n      function L (i) {\r\n        if (i.length < x + K) {\r\n          return i\r\n        } else {\r\n          return i.substr(x, K)\r\n        }\r\n      }\r\n      function y (i) {\r\n        return i\r\n      }\r\n      function M (i) {\r\n        return i.substr(0, 1)\r\n      }\r\n      function O (i) {\r\n        return L(i)\r\n      }\r\n      function C (i) {\r\n        return i.substr(x, K) + ' ' + g(i.substr(r, H))\r\n      }\r\n      function u (i) {\r\n        if (i === '') {\r\n          return '-'\r\n        }\r\n        return i.toLowerCase().replace(/[^a-zA-Z0-9\\u0080-\\uFFFF]+/g, '-')\r\n      }\r\n      function D (R, P, i) {\r\n        if (R.nTable.id !== E[0].id) {\r\n          return true\r\n        }\r\n        var Q = P[t.iGroupingColumnIndex]\r\n        if (typeof Q === 'undefined') {\r\n          Q = P[R.aoColumns[t.iGroupingColumnIndex].mDataProp]\r\n        }\r\n        if (I(u(Q))) {\r\n          if (E.fnIsOpen(E.fnGetNodes(i))) {\r\n            if (t.fnOnRowClosed != null) {\r\n              t.fnOnRowClosed(this)\r\n            }\r\n            E.fnClose(E.fnGetNodes(i))\r\n          }\r\n          return false\r\n        }\r\n        return true\r\n      }\r\n      function p (i) {\r\n        B[i].state = 'expanded'\r\n        a(\"td[data-group^='\" + i + \"']\").removeClass('collapsed-group')\r\n        a(\"td[data-group^='\" + i + \"']\").addClass('expanded-group')\r\n        if (t.bUseFilteringForGrouping) {\r\n          E.fnDraw()\r\n          return\r\n        }\r\n        if (jQuery.inArray(i, j) == -1) {\r\n          j.push(i)\r\n        }\r\n        if (t.oHideEffect != null) {\r\n          a('.group-item-' + i, E)[t.oShowEffect.method](t.oShowEffect.duration, t.oShowEffect.easing, function () {})\r\n        } else {\r\n          a('.group-item-' + i, E).show()\r\n        }\r\n      }\r\n      function m (i) {\r\n        B[i].state = 'collapsed'\r\n        a(\"td[data-group^='\" + i + \"']\").removeClass('expanded-group')\r\n        a(\"td[data-group^='\" + i + \"']\").addClass('collapsed-group')\r\n        if (t.bUseFilteringForGrouping) {\r\n          E.fnDraw()\r\n          return\r\n        }\r\n        a('.group-item-' + i).each(function () {\r\n          if (E.fnIsOpen(this)) {\r\n            if (t.fnOnRowClosed != null) {\r\n              t.fnOnRowClosed(this)\r\n            }\r\n            E.fnClose(this)\r\n          }\r\n        })\r\n        if (t.oHideEffect != null) {\r\n          a('.group-item-' + i, E)[t.oHideEffect.method](t.oHideEffect.duration, t.oHideEffect.easing, function () {})\r\n        } else {\r\n          a('.group-item-' + i, E).hide()\r\n        }\r\n      }\r\n      function h (T) {\r\n        var Q = a(this).attr('data-group')\r\n        var S = a(this).attr('data-group-level')\r\n        var R = !I(Q)\r\n        if (t.bExpandSingleGroup) {\r\n          if (!R) {\r\n            var P = a('td.expanded-group').attr('data-group')\r\n            m(P)\r\n            p(Q)\r\n            if (t.iExpandGroupOffset != -1) {\r\n              var i = a('#group-id-' + E.attr('id') + '_' + Q).offset().top - t.iExpandGroupOffset\r\n              window.scroll(0, i)\r\n            } else {\r\n              var i = E.offset().top\r\n              window.scroll(0, i)\r\n            }\r\n          }\r\n        } else {\r\n          if (R) {\r\n            m(Q)\r\n          } else {\r\n            p(Q)\r\n          }\r\n        }\r\n        T.preventDefault()\r\n      }\r\n      function A (V) {\r\n        if (E.fnSettings().oFeatures.bServerSide) {\r\n          l = true\r\n        }\r\n        var Z = false\r\n        if (t.iGroupingColumnIndex2 != -1) {\r\n          Z = true\r\n        }\r\n        if (V.aiDisplayMaster.length == 0) {\r\n          return\r\n        }\r\n        var T = a('tbody tr', E)\r\n        var Q = 0\r\n        for (var ae = 0; ae < V.aoColumns.length; ae++) {\r\n          if (V.aoColumns[ae].bVisible) {\r\n            Q += 1\r\n          }\r\n        }\r\n        var ah = null\r\n        var aa = null\r\n        if (V.aiDisplay.length > 0) {\r\n          for (var ag = 0; ag < T.length; ag++) {\r\n            var U = V._iDisplayStart + ag\r\n            if (E.fnSettings().oFeatures.bServerSide) {\r\n              U = ag\r\n            }\r\n            var S = ''\r\n            var af = null\r\n            var P = ''\r\n            var Y = null\r\n            S = this.fnGetData(T[ag], t.iGroupingColumnIndex)\r\n            var af = S\r\n            if (t.sGroupBy != 'year') {\r\n              af = N(S)\r\n            }\r\n            if (Z) {\r\n              P = V.aoData[V.aiDisplay[U]]._aData[t.iGroupingColumnIndex2]\r\n              if (P == undefined) {\r\n                P = V.aoData[V.aiDisplay[U]]._aData[V.aoColumns[t.iGroupingColumnIndex2].mDataProp]\r\n              }\r\n              if (t.sGroupBy2 != 'year') {\r\n                Y = N(P)\r\n              }\r\n            }\r\n            if (ah == null || u(af) != u(ah)) {\r\n              var ab = u(af)\r\n              if (ah != null) {\r\n                t.fnOnGroupCompleted(B[u(ah)])\r\n              }\r\n              if (t.bAddAllGroupsAsExpanded && jQuery.inArray(ab, j) == -1) {\r\n                j.push(ab)\r\n              }\r\n              var W = q(ab, af, Q)\r\n              var R = W.nGroup\r\n              if (T[ag].parentNode != null) {\r\n                T[ag].parentNode.insertBefore(R, T[ag])\r\n              } else {\r\n                a(T[ag]).before(R)\r\n              }\r\n              ah = af\r\n              aa = null\r\n            }\r\n            a(T[ag]).attr('data-group', B[ab].dataGroup)\r\n            a(T[ag]).addClass(t.sGroupItemClass)\r\n            a(T[ag]).addClass('group-item-' + ab)\r\n            if (t.bExpandableGrouping) {\r\n              if (I(ab) && !t.bUseFilteringForGrouping) {\r\n                a(T[ag]).hide()\r\n              }\r\n            }\r\n            if (Z) {\r\n              if (aa == null || u(Y) != u(aa)) {\r\n                var X = u(af) + '-' + u(Y)\r\n                var ac = w(X, Y, Q, B[ab])\r\n                var ad = ac.nGroup\r\n                T[ag].parentNode.insertBefore(ad, T[ag])\r\n                aa = Y\r\n              }\r\n              a(T[ag])\r\n                .attr('data-group', ac.dataGroup)\r\n                .addClass(t.sGroupItemClass2)\r\n                .addClass('group-item-' + ac.dataGroup)\r\n            }\r\n          }\r\n        }\r\n        if (ah != null) {\r\n          t.fnOnGroupCompleted(B[u(ah)])\r\n        }\r\n        t.fnOnGrouped(B)\r\n        l = false\r\n      }\r\n      var x = 6\r\n      var K = 4\r\n      var j = new Array()\r\n      var l = true\r\n      var t = a.extend(f, e)\r\n      if (t.iGroupingOrderByColumnIndex == -1) {\r\n        t.bCustomColumnOrdering = false\r\n        t.iGroupingOrderByColumnIndex = t.iGroupingColumnIndex\r\n      } else {\r\n        t.bCustomColumnOrdering = true\r\n      }\r\n      if (t.sGroupingColumnSortDirection == '') {\r\n        if (t.sGroupBy == 'year') {\r\n          t.sGroupingColumnSortDirection = 'desc'\r\n        } else {\r\n          t.sGroupingColumnSortDirection = 'asc'\r\n        }\r\n      }\r\n      if (t.iGroupingOrderByColumnIndex2 == -1) {\r\n        t.bCustomColumnOrdering2 = false\r\n        t.iGroupingOrderByColumnIndex2 = t.iGroupingColumnIndex2\r\n      } else {\r\n        t.bCustomColumnOrdering2 = true\r\n      }\r\n      if (t.sGroupingColumnSortDirection2 == '') {\r\n        if (t.sGroupBy2 == 'year') {\r\n          t.sGroupingColumnSortDirection2 = 'desc'\r\n        } else {\r\n          t.sGroupingColumnSortDirection2 = 'asc'\r\n        }\r\n      }\r\n      x = t.sDateFormat.toLowerCase().indexOf('yy')\r\n      K = t.sDateFormat.toLowerCase().lastIndexOf('y') - t.sDateFormat.toLowerCase().indexOf('y') + 1\r\n      var r = t.sDateFormat.toLowerCase().indexOf('mm')\r\n      var H = t.sDateFormat.toLowerCase().lastIndexOf('m') - t.sDateFormat.toLowerCase().indexOf('m') + 1\r\n      var N = y\r\n      switch (t.sGroupBy) {\r\n        case 'letter':\r\n          N = M\r\n          break\r\n        case 'year':\r\n          N = O\r\n          break\r\n        case 'month':\r\n          N = C\r\n          break\r\n        default:\r\n          N = y\r\n          break\r\n      }\r\n      if (t.asExpandedGroups != null) {\r\n        if (t.asExpandedGroups == 'NONE') {\r\n          t.asExpandedGroups = []\r\n          j = t.asExpandedGroups\r\n          l = false\r\n        } else {\r\n          if (t.asExpandedGroups == 'ALL') {\r\n            t.bAddAllGroupsAsExpanded = true\r\n          } else {\r\n            if (t.asExpandedGroups.constructor == String) {\r\n              var k = t.asExpandedGroups\r\n              t.asExpandedGroups = new Array()\r\n              t.asExpandedGroups.push(u(k))\r\n              j = t.asExpandedGroups\r\n              l = false\r\n            } else {\r\n              if (t.asExpandedGroups.constructor == Array) {\r\n                for (var G = 0; G < t.asExpandedGroups.length; G++) {\r\n                  j.push(u(t.asExpandedGroups[G]))\r\n                  if (t.bExpandSingleGroup) {\r\n                    break\r\n                  }\r\n                }\r\n                l = false\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        t.asExpandedGroups = new Array()\r\n        t.bAddAllGroupsAsExpanded = true\r\n      }\r\n      if (t.bExpandSingleGroup) {\r\n        var o = a('tbody tr', E)\r\n        var n = E.fnGetData(o[0], t.iGroupingColumnIndex)\r\n        var F = n\r\n        if (t.sGroupBy != 'year') {\r\n          F = N(n)\r\n        }\r\n        var z = u(F)\r\n        t.asExpandedGroups = new Array()\r\n        t.asExpandedGroups.push(z)\r\n      }\r\n      E.fnSetColumnVis(t.iGroupingColumnIndex, !t.bHideGroupingColumn)\r\n      if (t.bCustomColumnOrdering) {\r\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex, !t.bHideGroupingOrderByColumn)\r\n      }\r\n      if (t.iGroupingColumnIndex2 != -1) {\r\n        E.fnSetColumnVis(t.iGroupingColumnIndex2, !t.bHideGroupingColumn2)\r\n      }\r\n      if (t.bCustomColumnOrdering2) {\r\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex2, !t.bHideGroupingOrderByColumn2)\r\n      }\r\n      E.fnSettings().aoDrawCallback.push({ fn: A, sName: 'fnRowGrouping' })\r\n      var v = new Array()\r\n      v.push([t.iGroupingOrderByColumnIndex, t.sGroupingColumnSortDirection])\r\n      if (t.iGroupingColumnIndex2 != -1) {\r\n        v.push([t.iGroupingOrderByColumnIndex2, t.sGroupingColumnSortDirection2])\r\n      }\r\n      E.fnSettings().aaSortingFixed = v\r\n      switch (t.sGroupBy) {\r\n        case 'name':\r\n          break\r\n        case 'letter':\r\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-letter'\r\n          a.fn.dataTableExt.afnSortData['rg-letter'] = function (Q, P) {\r\n            var i = []\r\n            a('td:eq(' + P + ')', Q.oApi._fnGetTrNodes(Q)).each(function () {\r\n              i.push(M(this.innerHTML))\r\n            })\r\n            return i\r\n          }\r\n          break\r\n        case 'year':\r\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-date'\r\n          a.fn.dataTableExt.afnSortData['rg-date'] = function (R, P) {\r\n            var i = []\r\n            var Q = R.oApi._fnGetTrNodes(R)\r\n            for (G = 0; G < Q.length; G++) {\r\n              i.push(L(E.fnGetData(Q[G], P)))\r\n            }\r\n            return i\r\n          }\r\n          break\r\n        default:\r\n          break\r\n      }\r\n      if (t.bUseFilteringForGrouping) {\r\n        a.fn.dataTableExt.afnFiltering.push(D)\r\n      }\r\n      E.fnDraw()\r\n    })\r\n  }\r\n})(jQuery)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/dataTables.grouping.js?");

/***/ }),

/***/ 26:
/*!******************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.responsive.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 1.0.1\r\n * 2014 SpryMedia Ltd - datatables.net/license\r\n */\r\n\r\n/**\r\n * @summary     Responsive\r\n * @description Responsive tables plug-in for DataTables\r\n * @version     1.0.1\r\n * @file        dataTables.responsive.js\r\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\r\n * @contact     www.sprymedia.co.uk/contact\r\n * @copyright   Copyright 2014 SpryMedia Ltd.\r\n *\r\n * This source file is free software, available under the following license:\r\n *   MIT license - http://datatables.net/license/mit\r\n *\r\n * This source file is distributed in the hope that it will be useful, but\r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\r\n *\r\n * For details please refer to: http://www.datatables.net\r\n */\r\n\r\n;(function (window, document, undefined) {\r\n  var factory = function ($, DataTable) {\r\n    'use strict'\r\n\r\n    /**\r\n     * Responsive is a plug-in for the DataTables library that makes use of\r\n     * DataTables' ability to change the visibility of columns, changing the\r\n     * visibility of columns so the displayed columns fit into the table container.\r\n     * The end result is that complex tables will be dynamically adjusted to fit\r\n     * into the viewport, be it on a desktop, tablet or mobile browser.\r\n     *\r\n     * Responsive for DataTables has two modes of operation, which can used\r\n     * individually or combined:\r\n     *\r\n     * * Class name based control - columns assigned class names that match the\r\n     *   breakpoint logic can be shown / hidden as required for each breakpoint.\r\n     * * Automatic control - columns are automatically hidden when there is no\r\n     *   room left to display them. Columns removed from the right.\r\n     *\r\n     * In additional to column visibility control, Responsive also has built into\r\n     * options to use DataTables' child row display to show / hide the information\r\n     * from the table that has been hidden. There are also two modes of operation\r\n     * for this child row display:\r\n     *\r\n     * * Inline - when the control element that the user can use to show / hide\r\n     *   child rows is displayed inside the first column of the table.\r\n     * * Column - where a whole column is dedicated to be the show / hide control.\r\n     *\r\n     * Initialisation of Responsive is performed by:\r\n     *\r\n     * * Adding the class `responsive` or `dt-responsive` to the table. In this case\r\n     *   Responsive will automatically be initialised with the default configuration\r\n     *   options when the DataTable is created.\r\n     * * Using the `responsive` option in the DataTables configuration options. This\r\n     *   can also be used to specify the configuration options, or simply set to\r\n     *   `true` to use the defaults.\r\n     *\r\n     *  @class\r\n     *  @param {object} settings DataTables settings object for the host table\r\n     *  @param {object} [opts] Configuration options\r\n     *  @requires jQuery 1.7+\r\n     *  @requires DataTables 1.10.1+\r\n     *\r\n     *  @example\r\n     *      $('#example').DataTable( {\r\n     *        responsive: true\r\n     *      } );\r\n     *    } );\r\n     */\r\n    var Responsive = function (settings, opts) {\r\n      // Sanity check that we are using DataTables 1.10 or newer\r\n      if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.1')) {\r\n        throw 'DataTables Responsive requires DataTables 1.10.1 or newer'\r\n      } else if (settings.responsive) {\r\n        return\r\n      }\r\n\r\n      this.s = {\r\n        dt: new DataTable.Api(settings),\r\n        columns: []\r\n      }\r\n\r\n      // details is an object, but for simplicity the user can give it as a string\r\n      if (opts && typeof opts.details === 'string') {\r\n        opts.details = { type: opts.details }\r\n      }\r\n\r\n      this.c = $.extend(true, {}, Responsive.defaults, opts)\r\n      settings.responsive = this\r\n      this._constructor()\r\n    }\r\n\r\n    Responsive.prototype = {\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Constructor\r\n       */\r\n\r\n      /**\r\n       * Initialise the Responsive instance\r\n       *\r\n       * @private\r\n       */\r\n      _constructor: function () {\r\n        var that = this\r\n        var dt = this.s.dt\r\n\r\n        dt.settings()[0]._responsive = this\r\n\r\n        // Use DataTables' private throttle function to avoid processor thrashing\r\n        $(window).on(\r\n          'resize.dtr orientationchange.dtr',\r\n          dt.settings()[0].oApi._fnThrottle(function () {\r\n            that._resize()\r\n          })\r\n        )\r\n\r\n        // Destroy event handler\r\n        dt.on('destroy.dtr', function () {\r\n          $(window).off('resize.dtr orientationchange.dtr')\r\n        })\r\n\r\n        // Reorder the breakpoints array here in case they have been added out\r\n        // of order\r\n        this.c.breakpoints.sort(function (a, b) {\r\n          return a.width < b.width ? 1 : a.width > b.width ? -1 : 0\r\n        })\r\n\r\n        this._classLogic()\r\n        this._resizeAuto()\r\n\r\n        // First pass - draw the table for the current viewport size\r\n        this._resize()\r\n\r\n        // Details handler\r\n        var details = this.c.details\r\n        if (details.type) {\r\n          that._detailsInit()\r\n          this._detailsVis()\r\n\r\n          dt.on('column-visibility.dtr', function () {\r\n            that._detailsVis()\r\n          })\r\n\r\n          $(dt.table().node()).addClass('dtr-' + details.type)\r\n        }\r\n      },\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Private methods\r\n       */\r\n\r\n      /**\r\n       * Calculate the visibility for the columns in a table for a given\r\n       * breakpoint. The result is pre-determined based on the class logic if\r\n       * class names are used to control all columns, but the width of the table\r\n       * is also used if there are columns which are to be automatically shown\r\n       * and hidden.\r\n       *\r\n       * @param  {string} breakpoint Breakpoint name to use for the calculation\r\n       * @return {array} Array of boolean values initiating the visibility of each\r\n       *   column.\r\n       *  @private\r\n       */\r\n      _columnsVisiblity: function (breakpoint) {\r\n        var dt = this.s.dt\r\n        var columns = this.s.columns\r\n        var i, ien\r\n\r\n        // Class logic - determine which columns are in this breakpoint based\r\n        // on the classes. If no class control (i.e. `auto`) then `-` is used\r\n        // to indicate this to the rest of the function\r\n        var display = $.map(columns, function (col) {\r\n          return col.auto && col.minWidth === null\r\n            ? false\r\n            : col.auto === true\r\n            ? '-'\r\n            : col.includeIn.indexOf(breakpoint) !== -1\r\n        })\r\n\r\n        // Auto column control - first pass: how much width is taken by the\r\n        // ones that must be included from the non-auto columns\r\n        var requiredWidth = 0\r\n        for (i = 0, ien = display.length; i < ien; i++) {\r\n          if (display[i] === true) {\r\n            requiredWidth += columns[i].minWidth\r\n          }\r\n        }\r\n\r\n        // Second pass, use up any remaining width for other columns\r\n        var widthAvailable = dt.table().container().offsetWidth\r\n        var usedWidth = widthAvailable - requiredWidth\r\n\r\n        for (i = 0, ien = display.length; i < ien; i++) {\r\n          // Control column needs to always be included. This makes it sub-\r\n          // optimal in terms of using the available with, but to stop layout\r\n          // thrashing or overflow\r\n          if (columns[i].control) {\r\n            usedWidth -= columns[i].minWidth\r\n          } else if (display[i] === '-') {\r\n            // Otherwise, remove the width\r\n            display[i] = usedWidth - columns[i].minWidth < 0 ? false : true\r\n\r\n            // Continue counting down the width, so a smaller column to the\r\n            // left won't be shown\r\n            usedWidth -= columns[i].minWidth\r\n          }\r\n        }\r\n\r\n        // Determine if the 'control' column should be shown (if there is one).\r\n        // This is the case when there is a hidden column (that is not the\r\n        // control column). The two loops look inefficient here, but they are\r\n        // trivial and will fly through. We need to know the outcome from the\r\n        // first , before the action in the second can be taken\r\n        var showControl = false\r\n\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          if (!columns[i].control && !display[i]) {\r\n            showControl = true\r\n            break\r\n          }\r\n        }\r\n\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          if (columns[i].control) {\r\n            display[i] = showControl\r\n          }\r\n        }\r\n\r\n        return display\r\n      },\r\n\r\n      /**\r\n       * Create the internal `columns` array with information about the columns\r\n       * for the table. This includes determining which breakpoints the column\r\n       * will appear in, based upon class names in the column, which makes up the\r\n       * vast majority of this method.\r\n       *\r\n       * @private\r\n       */\r\n      _classLogic: function () {\r\n        var that = this\r\n        var calc = {}\r\n        var breakpoints = this.c.breakpoints\r\n        var columns = this.s.dt\r\n          .columns()\r\n          .eq(0)\r\n          .map(function (i) {\r\n            return {\r\n              className: this.column(i).header().className,\r\n              includeIn: [],\r\n              auto: false,\r\n              control: false\r\n            }\r\n          })\r\n\r\n        // Simply add a breakpoint to `includeIn` array, ensuring that there are\r\n        // no duplicates\r\n        var add = function (colIdx, name) {\r\n          var includeIn = columns[colIdx].includeIn\r\n\r\n          if (includeIn.indexOf(name) === -1) {\r\n            includeIn.push(name)\r\n          }\r\n        }\r\n\r\n        var column = function (colIdx, name, operator, matched) {\r\n          var size, i, ien\r\n\r\n          if (!operator) {\r\n            columns[colIdx].includeIn.push(name)\r\n          } else if (operator === 'max-') {\r\n            // Add this breakpoint and all smaller\r\n            size = that._find(name).width\r\n\r\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\r\n              if (breakpoints[i].width <= size) {\r\n                add(colIdx, breakpoints[i].name)\r\n              }\r\n            }\r\n          } else if (operator === 'min-') {\r\n            // Add this breakpoint and all larger\r\n            size = that._find(name).width\r\n\r\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\r\n              if (breakpoints[i].width >= size) {\r\n                add(colIdx, breakpoints[i].name)\r\n              }\r\n            }\r\n          } else if (operator === 'not-') {\r\n            // Add all but this breakpoint (xxx need extra information)\r\n\r\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\r\n              if (breakpoints[i].name.indexOf(matched) === -1) {\r\n                add(colIdx, breakpoints[i].name)\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Loop over each column and determine if it has a responsive control\r\n        // class\r\n        columns.each(function (col, i) {\r\n          var classNames = col.className.split(' ')\r\n          var hasClass = false\r\n\r\n          // Split the class name up so multiple rules can be applied if needed\r\n          for (var k = 0, ken = classNames.length; k < ken; k++) {\r\n            var className = $.trim(classNames[k])\r\n\r\n            if (className === 'all') {\r\n              // Include in all\r\n              hasClass = true\r\n              col.includeIn = $.map(breakpoints, function (a) {\r\n                return a.name\r\n              })\r\n              return\r\n            } else if (className === 'none') {\r\n              // Include in none (default) and no auto\r\n              hasClass = true\r\n              return\r\n            } else if (className === 'control') {\r\n              // Special column that is only visible, when one of the other\r\n              // columns is hidden. This is used for the details control\r\n              hasClass = true\r\n              col.control = true\r\n              return\r\n            }\r\n\r\n            $.each(breakpoints, function (j, breakpoint) {\r\n              // Does this column have a class that matches this breakpoint?\r\n              var brokenPoint = breakpoint.name.split('-')\r\n              var re = new RegExp('(min\\\\-|max\\\\-|not\\\\-)?(' + brokenPoint[0] + ')(\\\\-[_a-zA-Z0-9])?')\r\n              var match = className.match(re)\r\n\r\n              if (match) {\r\n                hasClass = true\r\n\r\n                if (match[2] === brokenPoint[0] && match[3] === '-' + brokenPoint[1]) {\r\n                  // Class name matches breakpoint name fully\r\n                  column(i, breakpoint.name, match[1], match[2] + match[3])\r\n                } else if (match[2] === brokenPoint[0] && !match[3]) {\r\n                  // Class name matched primary breakpoint name with no qualifier\r\n                  column(i, breakpoint.name, match[1], match[2])\r\n                }\r\n              }\r\n            })\r\n          }\r\n\r\n          // If there was no control class, then automatic sizing is used\r\n          if (!hasClass) {\r\n            col.auto = true\r\n          }\r\n        })\r\n\r\n        this.s.columns = columns\r\n      },\r\n\r\n      /**\r\n       * Initialisation for the details handler\r\n       *\r\n       * @private\r\n       */\r\n      _detailsInit: function () {\r\n        var that = this\r\n        var dt = this.s.dt\r\n        var details = this.c.details\r\n\r\n        // The inline type always uses the first child as the target\r\n        if (details.type === 'inline') {\r\n          details.target = 'td:first-child'\r\n        }\r\n\r\n        // type.target can be a string jQuery selector or a column index\r\n        var target = details.target\r\n        var selector = typeof target === 'string' ? target : 'td'\r\n\r\n        // Click handler to show / hide the details rows when they are available\r\n        $(dt.table().body()).on('click', selector, function (e) {\r\n          // If the table is not collapsed (i.e. there is no hidden columns)\r\n          // then take no action\r\n          if (!$(dt.table().node()).hasClass('collapsed')) {\r\n            return\r\n          }\r\n\r\n          // For column index, we determine if we should act or not in the\r\n          // handler - otherwise it is already okay\r\n          if (typeof target === 'number') {\r\n            var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target\r\n\r\n            if (dt.cell(this).index().column !== targetIdx) {\r\n              return\r\n            }\r\n          }\r\n\r\n          // $().closest() includes itself in its check\r\n          var row = dt.row($(this).closest('tr'))\r\n\r\n          if (row.child.isShown()) {\r\n            row.child(false)\r\n            $(row.node()).removeClass('parent')\r\n          } else {\r\n            var info = that.c.details.renderer(dt, row[0])\r\n            row.child(info, 'child').show()\r\n            $(row.node()).addClass('parent')\r\n          }\r\n        })\r\n      },\r\n\r\n      /**\r\n       * Update the child rows in the table whenever the column visibility changes\r\n       *\r\n       * @private\r\n       */\r\n      _detailsVis: function () {\r\n        var that = this\r\n        var dt = this.s.dt\r\n\r\n        var hiddenColumns = dt\r\n          .columns(':hidden')\r\n          .indexes()\r\n          .flatten()\r\n        var haveHidden = true\r\n\r\n        if (hiddenColumns.length === 0 || (hiddenColumns.length === 1 && this.s.columns[hiddenColumns[0]].control)) {\r\n          haveHidden = false\r\n        }\r\n\r\n        if (haveHidden) {\r\n          // Got hidden columns\r\n          $(dt.table().node()).addClass('collapsed')\r\n\r\n          // Show all existing child rows\r\n          dt.rows()\r\n            .eq(0)\r\n            .each(function (idx) {\r\n              var row = dt.row(idx)\r\n\r\n              if (row.child()) {\r\n                var info = that.c.details.renderer(dt, row[0])\r\n\r\n                // The renderer can return false to have no child row\r\n                if (info === false) {\r\n                  row.child.hide()\r\n                } else {\r\n                  row.child(info, 'child').show()\r\n                }\r\n              }\r\n            })\r\n        } else {\r\n          // No hidden columns\r\n          $(dt.table().node()).removeClass('collapsed')\r\n\r\n          // Hide all existing child rows\r\n          dt.rows()\r\n            .eq(0)\r\n            .each(function (idx) {\r\n              dt.row(idx).child.hide()\r\n            })\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Find a breakpoint object from a name\r\n       * @param  {string} name Breakpoint name to find\r\n       * @return {object}      Breakpoint description object\r\n       */\r\n      _find: function (name) {\r\n        var breakpoints = this.c.breakpoints\r\n\r\n        for (var i = 0, ien = breakpoints.length; i < ien; i++) {\r\n          if (breakpoints[i].name === name) {\r\n            return breakpoints[i]\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Alter the table display for a resized viewport. This involves first\r\n       * determining what breakpoint the window currently is in, getting the\r\n       * column visibilities to apply and then setting them.\r\n       *\r\n       * @private\r\n       */\r\n      _resize: function () {\r\n        var dt = this.s.dt\r\n        var width = $(window).width()\r\n        var breakpoints = this.c.breakpoints\r\n        var breakpoint = breakpoints[0].name\r\n\r\n        // Determine what breakpoint we are currently at\r\n        for (var i = breakpoints.length - 1; i >= 0; i--) {\r\n          if (width <= breakpoints[i].width) {\r\n            breakpoint = breakpoints[i].name\r\n            break\r\n          }\r\n        }\r\n\r\n        // Show the columns for that break point\r\n        var columns = this._columnsVisiblity(breakpoint)\r\n\r\n        dt.columns()\r\n          .eq(0)\r\n          .each(function (colIdx, i) {\r\n            dt.column(colIdx).visible(columns[i])\r\n          })\r\n      },\r\n\r\n      /**\r\n       * Determine the width of each column in the table so the auto column hiding\r\n       * has that information to work with. This method is never going to be 100%\r\n       * perfect since column widths can change slightly per page, but without\r\n       * seriously compromising performance this is quite effective.\r\n       *\r\n       * @private\r\n       */\r\n      _resizeAuto: function () {\r\n        var dt = this.s.dt\r\n        var columns = this.s.columns\r\n\r\n        // Are we allowed to do auto sizing?\r\n        if (!this.c.auto) {\r\n          return\r\n        }\r\n\r\n        // Are there any columns that actually need auto-sizing, or do they all\r\n        // have classes defined\r\n        if (\r\n          $.inArray(\r\n            true,\r\n            $.map(columns, function (c) {\r\n              return c.auto\r\n            })\r\n          ) === -1\r\n        ) {\r\n          return\r\n        }\r\n\r\n        // Clone the table with the current data in it\r\n        var tableWidth = dt.table().node().offsetWidth\r\n        var columnWidths = dt.columns\r\n        var clonedTable = dt\r\n          .table()\r\n          .node()\r\n          .cloneNode(false)\r\n        var clonedHeader = $(\r\n          dt\r\n            .table()\r\n            .header()\r\n            .cloneNode(false)\r\n        ).appendTo(clonedTable)\r\n        var clonedBody = $(\r\n          dt\r\n            .table()\r\n            .body()\r\n            .cloneNode(false)\r\n        ).appendTo(clonedTable)\r\n\r\n        // This is a bit slow, but we need to get a clone of each row that\r\n        // includes all columns. As such, try to do this as little as possible.\r\n        dt.rows({ page: 'current' })\r\n          .indexes()\r\n          .each(function (idx) {\r\n            var clone = dt\r\n              .row(idx)\r\n              .node()\r\n              .cloneNode(true)\r\n\r\n            if (dt.columns(':hidden').flatten().length) {\r\n              $(clone).append(\r\n                dt\r\n                  .cells(idx, ':hidden')\r\n                  .nodes()\r\n                  .to$()\r\n                  .clone()\r\n              )\r\n            }\r\n\r\n            $(clone).appendTo(clonedBody)\r\n          })\r\n\r\n        var cells = dt\r\n          .columns()\r\n          .header()\r\n          .to$()\r\n          .clone(false)\r\n          .wrapAll('tr')\r\n          .appendTo(clonedHeader)\r\n        var inserted = $('<div/>')\r\n          .css({\r\n            width: 1,\r\n            height: 1,\r\n            overflow: 'hidden'\r\n          })\r\n          .append(clonedTable)\r\n          .insertBefore(dt.table().node())\r\n\r\n        // The cloned header now contains the smallest that each column can be\r\n        dt.columns()\r\n          .eq(0)\r\n          .each(function (idx) {\r\n            columns[idx].minWidth = cells[idx].offsetWidth || 0\r\n          })\r\n\r\n        inserted.remove()\r\n      }\r\n    }\r\n\r\n    /**\r\n     * List of default breakpoints. Each item in the array is an object with two\r\n     * properties:\r\n     *\r\n     * * `name` - the breakpoint name.\r\n     * * `width` - the breakpoint width\r\n     *\r\n     * @name Responsive.breakpoints\r\n     * @static\r\n     */\r\n    Responsive.breakpoints = [\r\n      { name: 'desktop', width: Infinity },\r\n      { name: 'tablet-l', width: 1024 },\r\n      { name: 'tablet-p', width: 768 },\r\n      { name: 'mobile-l', width: 480 },\r\n      { name: 'mobile-p', width: 320 }\r\n    ]\r\n\r\n    /**\r\n     * Responsive default settings for initialisation\r\n     *\r\n     * @namespace\r\n     * @name Responsive.defaults\r\n     * @static\r\n     */\r\n    Responsive.defaults = {\r\n      /**\r\n       * List of breakpoints for the instance. Note that this means that each\r\n       * instance can have its own breakpoints. Additionally, the breakpoints\r\n       * cannot be changed once an instance has been creased.\r\n       *\r\n       * @type {Array}\r\n       * @default Takes the value of `Responsive.breakpoints`\r\n       */\r\n      breakpoints: Responsive.breakpoints,\r\n\r\n      /**\r\n       * Enable / disable auto hiding calculations. It can help to increase\r\n       * performance slightly if you disable this option, but all columns would\r\n       * need to have breakpoint classes assigned to them\r\n       *\r\n       * @type {Boolean}\r\n       * @default  `true`\r\n       */\r\n      auto: true,\r\n\r\n      /**\r\n       * Details control. If given as a string value, the `type` property of the\r\n       * default object is set to that value, and the defaults used for the rest\r\n       * of the object - this is for ease of implementation.\r\n       *\r\n       * The object consists of the following properties:\r\n       *\r\n       * * `renderer` - function that is called for display of the child row data.\r\n       *   The default function will show the data from the hidden columns\r\n       * * `target` - Used as the selector for what objects to attach the child\r\n       *   open / close to\r\n       * * `type` - `false` to disable the details display, `inline` or `column`\r\n       *   for the two control types\r\n       *\r\n       * @type {Object|string}\r\n       */\r\n      details: {\r\n        renderer: function (api, rowIdx) {\r\n          var data = api\r\n            .cells(rowIdx, ':hidden')\r\n            .eq(0)\r\n            .map(function (cell) {\r\n              var header = $(api.column(cell.column).header())\r\n\r\n              if (header.hasClass('control')) {\r\n                return ''\r\n              }\r\n\r\n              return (\r\n                '<li>' +\r\n                '<span class=\"dtr-title\">' +\r\n                header.text() +\r\n                ':' +\r\n                '</span> ' +\r\n                '<span class=\"dtr-data\">' +\r\n                api.cell(cell).data() +\r\n                '</span>' +\r\n                '</li>'\r\n              )\r\n            })\r\n            .toArray()\r\n            .join('')\r\n\r\n          return data ? $('<ul/>').append(data) : false\r\n        },\r\n\r\n        target: 0,\r\n\r\n        type: 'inline'\r\n      }\r\n    }\r\n\r\n    /*\r\n     * API\r\n     */\r\n    var Api = $.fn.dataTable.Api\r\n\r\n    // Doesn't do anything - work around for a bug in DT... Not documented\r\n    Api.register('responsive()', function () {\r\n      return this\r\n    })\r\n\r\n    Api.register('responsive.recalc()', function (rowIdx, intParse, virtual) {\r\n      this.iterator('table', function (ctx) {\r\n        if (ctx._responsive) {\r\n          ctx._responsive._resizeAuto()\r\n          ctx._responsive._resize()\r\n        }\r\n      })\r\n    })\r\n\r\n    /**\r\n     * Version information\r\n     *\r\n     * @name Responsive.version\r\n     * @static\r\n     */\r\n    Responsive.version = '1.0.1'\r\n\r\n    $.fn.dataTable.Responsive = Responsive\r\n    $.fn.DataTable.Responsive = Responsive\r\n\r\n    // Attach a listener to the document which listens for DataTables initialisation\r\n    // events so we can automatically initialise\r\n    $(document).on('init.dt.dtr', function (e, settings, json) {\r\n      if (\r\n        $(settings.nTable).hasClass('responsive') ||\r\n        $(settings.nTable).hasClass('dt-responsive') ||\r\n        settings.oInit.responsive\r\n      ) {\r\n        var init = settings.oInit.responsive\r\n\r\n        if (init !== false) {\r\n          new Responsive(settings, $.isPlainObject(init) ? init : {})\r\n        }\r\n      }\r\n    })\r\n\r\n    return Responsive\r\n  } // /factory\r\n\r\n  // Define as an AMD module if possible\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! datatables */ 3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else {}\r\n})(window, document)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/dataTables.responsive.js?");

/***/ }),

/***/ 28:
/*!****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.scroller.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n Scroller 1.2.2\r\n 2011-2014 SpryMedia Ltd - datatables.net/license\r\n */\r\n;(function (m, n, k) {\r\n  var l = function (e) {\r\n    var g = function (a, b) {\r\n      !this instanceof g\r\n        ? alert(\"Scroller warning: Scroller must be initialised with the 'new' keyword.\")\r\n        : ('undefined' == typeof b && (b = {}),\r\n          (this.s = {\r\n            dt: a,\r\n            tableTop: 0,\r\n            tableBottom: 0,\r\n            redrawTop: 0,\r\n            redrawBottom: 0,\r\n            autoHeight: !0,\r\n            viewportRows: 0,\r\n            stateTO: null,\r\n            drawTO: null,\r\n            heights: { jump: null, page: null, virtual: null, scroll: null, row: null, viewport: null },\r\n            topRowFloat: 0,\r\n            scrollDrawDiff: null,\r\n            loaderVisible: !1\r\n          }),\r\n          (this.s = e.extend(this.s, g.oDefaults, b)),\r\n          (this.s.heights.row = this.s.rowHeight),\r\n          (this.dom = { force: n.createElement('div'), scroller: null, table: null, loader: null }),\r\n          (this.s.dt.oScroller = this),\r\n          this._fnConstruct())\r\n    }\r\n    g.prototype = {\r\n      fnRowToPixels: function (a, b, c) {\r\n        a = c\r\n          ? this._domain('virtualToPhysical', a * this.s.heights.row)\r\n          : this.s.baseScrollTop + (a - this.s.baseRowTop) * this.s.heights.row\r\n        return b || b === k ? parseInt(a, 10) : a\r\n      },\r\n      fnPixelsToRow: function (a, b, c) {\r\n        var d = a - this.s.baseScrollTop,\r\n          a = c ? this._domain('physicalToVirtual', a) / this.s.heights.row : d / this.s.heights.row + this.s.baseRowTop\r\n        return b || b === k ? parseInt(a, 10) : a\r\n      },\r\n      fnScrollToRow: function (a, b) {\r\n        var c = this,\r\n          d = !1,\r\n          f = this.fnRowToPixels(a),\r\n          h = a - ((this.s.displayBuffer - 1) / 2) * this.s.viewportRows\r\n        0 > h && (h = 0)\r\n        if ((f > this.s.redrawBottom || f < this.s.redrawTop) && this.s.dt._iDisplayStart !== h)\r\n          (d = !0), (f = this.fnRowToPixels(a, !1, !0))\r\n        'undefined' == typeof b || b\r\n          ? ((this.s.ani = d),\r\n            e(this.dom.scroller).animate({ scrollTop: f }, function () {\r\n              setTimeout(function () {\r\n                c.s.ani = !1\r\n              }, 25)\r\n            }))\r\n          : e(this.dom.scroller).scrollTop(f)\r\n      },\r\n      fnMeasure: function (a) {\r\n        this.s.autoHeight && this._fnCalcRowHeight()\r\n        var b = this.s.heights\r\n        b.viewport = e(this.dom.scroller).height()\r\n        this.s.viewportRows = parseInt(b.viewport / b.row, 10) + 1\r\n        this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer\r\n        ;(a === k || a) && this.s.dt.oInstance.fnDraw()\r\n      },\r\n      _fnConstruct: function () {\r\n        var a = this\r\n        if (this.s.dt.oFeatures.bPaginate) {\r\n          this.dom.force.style.position = 'absolute'\r\n          this.dom.force.style.top = '0px'\r\n          this.dom.force.style.left = '0px'\r\n          this.dom.force.style.width = '1px'\r\n          this.dom.scroller = e('div.' + this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0]\r\n          this.dom.scroller.appendChild(this.dom.force)\r\n          this.dom.scroller.style.position = 'relative'\r\n          this.dom.table = e('>table', this.dom.scroller)[0]\r\n          this.dom.table.style.position = 'absolute'\r\n          this.dom.table.style.top = '0px'\r\n          this.dom.table.style.left = '0px'\r\n          e(this.s.dt.nTableWrapper).addClass('DTS')\r\n          this.s.loadingIndicator &&\r\n            ((this.dom.loader = e('<div class=\"DTS_Loading\">' + this.s.dt.oLanguage.sLoadingRecords + '</div>').css(\r\n              'display',\r\n              'none'\r\n            )),\r\n            e(this.dom.scroller.parentNode)\r\n              .css('position', 'relative')\r\n              .append(this.dom.loader))\r\n          this.s.heights.row && 'auto' != this.s.heights.row && (this.s.autoHeight = !1)\r\n          this.fnMeasure(!1)\r\n          this.s.ingnoreScroll = !0\r\n          this.s.stateSaveThrottle = this.s.dt.oApi._fnThrottle(function () {\r\n            a.s.dt.oApi._fnSaveState(a.s.dt)\r\n          }, 500)\r\n          e(this.dom.scroller).on('scroll.DTS', function () {\r\n            a._fnScroll.call(a)\r\n          })\r\n          e(this.dom.scroller).on('touchstart.DTS', function () {\r\n            a._fnScroll.call(a)\r\n          })\r\n          this.s.dt.aoDrawCallback.push({\r\n            fn: function () {\r\n              a.s.dt.bInitialised && a._fnDrawCallback.call(a)\r\n            },\r\n            sName: 'Scroller'\r\n          })\r\n          e(m).on('resize.DTS', function () {\r\n            a.fnMeasure(false)\r\n            a._fnInfo()\r\n          })\r\n          var b = !0\r\n          this.s.dt.oApi._fnCallbackReg(\r\n            this.s.dt,\r\n            'aoStateSaveParams',\r\n            function (c, d) {\r\n              if (b && a.s.dt.oLoadedState) {\r\n                d.iScroller = a.s.dt.oLoadedState.iScroller\r\n                d.iScrollerTopRow = a.s.dt.oLoadedState.iScrollerTopRow\r\n                b = false\r\n              } else {\r\n                d.iScroller = a.dom.scroller.scrollTop\r\n                d.iScrollerTopRow = a.s.topRowFloat\r\n              }\r\n            },\r\n            'Scroller_State'\r\n          )\r\n          this.s.dt.oLoadedState && (this.s.topRowFloat = this.s.dt.oLoadedState.iScrollerTopRow || 0)\r\n          this.s.dt.aoDestroyCallback.push({\r\n            sName: 'Scroller',\r\n            fn: function () {\r\n              e(m).off('resize.DTS')\r\n              e(a.dom.scroller).off('touchstart.DTS scroll.DTS')\r\n              e(a.s.dt.nTableWrapper).removeClass('DTS')\r\n              e('div.DTS_Loading', a.dom.scroller.parentNode).remove()\r\n              a.dom.table.style.position = ''\r\n              a.dom.table.style.top = ''\r\n              a.dom.table.style.left = ''\r\n            }\r\n          })\r\n        } else this.s.dt.oApi._fnLog(this.s.dt, 0, 'Pagination must be enabled for Scroller')\r\n      },\r\n      _fnScroll: function () {\r\n        var a = this,\r\n          b = this.s.heights,\r\n          c = this.dom.scroller.scrollTop,\r\n          d\r\n        if (!this.s.skip && !this.s.ingnoreScroll)\r\n          if (this.s.dt.bFiltered || this.s.dt.bSorted) this.s.lastScrollTop = 0\r\n          else {\r\n            this._fnInfo()\r\n            clearTimeout(this.s.stateTO)\r\n            this.s.stateTO = setTimeout(function () {\r\n              a.s.dt.oApi._fnSaveState(a.s.dt)\r\n            }, 250)\r\n            if (c < this.s.redrawTop || c > this.s.redrawBottom) {\r\n              var f = Math.ceil(((this.s.displayBuffer - 1) / 2) * this.s.viewportRows)\r\n              Math.abs(c - this.s.lastScrollTop) > b.viewport || this.s.ani\r\n                ? ((d = parseInt(this._domain('physicalToVirtual', c) / b.row, 10) - f),\r\n                  (this.s.topRowFloat = this._domain('physicalToVirtual', c) / b.row))\r\n                : ((d = this.fnPixelsToRow(c) - f), (this.s.topRowFloat = this.fnPixelsToRow(c, !1)))\r\n              0 >= d\r\n                ? (d = 0)\r\n                : d + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay()\r\n                ? ((d = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength), 0 > d && (d = 0))\r\n                : 0 !== d % 2 && d++\r\n              if (\r\n                d != this.s.dt._iDisplayStart &&\r\n                ((this.s.tableTop = e(this.s.dt.nTable).offset().top),\r\n                (this.s.tableBottom = e(this.s.dt.nTable).height() + this.s.tableTop),\r\n                (b = function () {\r\n                  if (a.s.scrollDrawReq === null) a.s.scrollDrawReq = c\r\n                  a.s.dt._iDisplayStart = d\r\n                  a.s.dt.oApi._fnCalculateEnd && a.s.dt.oApi._fnCalculateEnd(a.s.dt)\r\n                  a.s.dt.oApi._fnDraw(a.s.dt)\r\n                }),\r\n                this.s.dt.oFeatures.bServerSide\r\n                  ? (clearTimeout(this.s.drawTO), (this.s.drawTO = setTimeout(b, this.s.serverWait)))\r\n                  : b(),\r\n                this.dom.loader && !this.s.loaderVisible)\r\n              )\r\n                this.dom.loader.css('display', 'block'), (this.s.loaderVisible = !0)\r\n            }\r\n            this.s.lastScrollTop = c\r\n            this.s.stateSaveThrottle()\r\n          }\r\n      },\r\n      _domain: function (a, b) {\r\n        var c = this.s.heights,\r\n          d\r\n        if (c.virtual === c.scroll) {\r\n          d = (c.virtual - c.viewport) / (c.scroll - c.viewport)\r\n          if ('virtualToPhysical' === a) return b / d\r\n          if ('physicalToVirtual' === a) return b * d\r\n        }\r\n        var e = (c.scroll - c.viewport) / 2,\r\n          h = (c.virtual - c.viewport) / 2\r\n        d = h / (e * e)\r\n        if ('virtualToPhysical' === a) {\r\n          if (b < h) return Math.pow(b / d, 0.5)\r\n          b = 2 * h - b\r\n          return 0 > b ? c.scroll : 2 * e - Math.pow(b / d, 0.5)\r\n        }\r\n        if ('physicalToVirtual' === a) {\r\n          if (b < e) return b * b * d\r\n          b = 2 * e - b\r\n          return 0 > b ? c.virtual : 2 * h - b * b * d\r\n        }\r\n      },\r\n      _fnDrawCallback: function () {\r\n        var a = this,\r\n          b = this.s.heights,\r\n          c = this.dom.scroller.scrollTop,\r\n          d = e(this.s.dt.nTable).height(),\r\n          f = this.s.dt._iDisplayStart,\r\n          h = this.s.dt._iDisplayLength,\r\n          g = this.s.dt.fnRecordsDisplay()\r\n        this.s.skip = !0\r\n        this._fnScrollForce()\r\n        c =\r\n          0 === f\r\n            ? this.s.topRowFloat * b.row\r\n            : f + h >= g\r\n            ? b.scroll - (g - this.s.topRowFloat) * b.row\r\n            : this._domain('virtualToPhysical', this.s.topRowFloat * b.row)\r\n        this.dom.scroller.scrollTop = c\r\n        this.s.baseScrollTop = c\r\n        this.s.baseRowTop = this.s.topRowFloat\r\n        var j = c - (this.s.topRowFloat - f) * b.row\r\n        0 === f ? (j = 0) : f + h >= g && (j = b.scroll - d)\r\n        this.dom.table.style.top = j + 'px'\r\n        this.s.tableTop = j\r\n        this.s.tableBottom = d + this.s.tableTop\r\n        d = (c - this.s.tableTop) * this.s.boundaryScale\r\n        this.s.redrawTop = c - d\r\n        this.s.redrawBottom = c + d\r\n        this.s.skip = !1\r\n        this.s.dt.oFeatures.bStateSave &&\r\n        null !== this.s.dt.oLoadedState &&\r\n        'undefined' != typeof this.s.dt.oLoadedState.iScroller\r\n          ? (((c = (this.s.dt.sAjaxSource || a.s.dt.ajax) && !this.s.dt.oFeatures.bServerSide ? !0 : !1) &&\r\n              2 == this.s.dt.iDraw) ||\r\n              (!c && 1 == this.s.dt.iDraw)) &&\r\n            setTimeout(function () {\r\n              e(a.dom.scroller).scrollTop(a.s.dt.oLoadedState.iScroller)\r\n              a.s.redrawTop = a.s.dt.oLoadedState.iScroller - b.viewport / 2\r\n              setTimeout(function () {\r\n                a.s.ingnoreScroll = !1\r\n              }, 0)\r\n            }, 0)\r\n          : (a.s.ingnoreScroll = !1)\r\n        setTimeout(function () {\r\n          a._fnInfo.call(a)\r\n        }, 0)\r\n        this.dom.loader && this.s.loaderVisible && (this.dom.loader.css('display', 'none'), (this.s.loaderVisible = !1))\r\n      },\r\n      _fnScrollForce: function () {\r\n        var a = this.s.heights\r\n        a.virtual = a.row * this.s.dt.fnRecordsDisplay()\r\n        a.scroll = a.virtual\r\n        1e6 < a.scroll && (a.scroll = 1e6)\r\n        this.dom.force.style.height = a.scroll + 'px'\r\n      },\r\n      _fnCalcRowHeight: function () {\r\n        var a = this.s.dt,\r\n          b = a.nTable,\r\n          c = b.cloneNode(!1),\r\n          d = e('<tbody/>').appendTo(c),\r\n          f = e(\r\n            '<div class=\"' +\r\n              a.oClasses.sWrapper +\r\n              ' DTS\"><div class=\"' +\r\n              a.oClasses.sScrollWrapper +\r\n              '\"><div class=\"' +\r\n              a.oClasses.sScrollBody +\r\n              '\"></div></div></div>'\r\n          )\r\n        for (\r\n          e('tbody tr:lt(4)', b)\r\n            .clone()\r\n            .appendTo(d);\r\n          3 > e('tr', d).length;\r\n\r\n        )\r\n          d.append('<tr><td>&nbsp;</td></tr>')\r\n        e('div.' + a.oClasses.sScrollBody, f).append(c)\r\n        a._bInitComplete\r\n          ? (a = b.parentNode)\r\n          : (this.s.dt.nHolding || (this.s.dt.nHolding = e('<div></div>').insertBefore(this.s.dt.nTable)),\r\n            (a = this.s.dt.nHolding))\r\n        f.appendTo(a)\r\n        this.s.heights.row = e('tr', d)\r\n          .eq(1)\r\n          .outerHeight()\r\n        f.remove()\r\n      },\r\n      _fnInfo: function () {\r\n        if (this.s.dt.oFeatures.bInfo) {\r\n          var a = this.s.dt,\r\n            b = a.oLanguage,\r\n            c = this.dom.scroller.scrollTop,\r\n            d = Math.floor(this.fnPixelsToRow(c, !1, this.s.ani) + 1),\r\n            f = a.fnRecordsTotal(),\r\n            h = a.fnRecordsDisplay(),\r\n            c = Math.ceil(this.fnPixelsToRow(c + this.s.heights.viewport, !1, this.s.ani)),\r\n            c = h < c ? h : c,\r\n            g = a.fnFormatNumber(d),\r\n            j = a.fnFormatNumber(c),\r\n            i = a.fnFormatNumber(f),\r\n            k = a.fnFormatNumber(h),\r\n            g =\r\n              0 === a.fnRecordsDisplay() && a.fnRecordsDisplay() == a.fnRecordsTotal()\r\n                ? b.sInfoEmpty + b.sInfoPostFix\r\n                : 0 === a.fnRecordsDisplay()\r\n                ? b.sInfoEmpty + ' ' + b.sInfoFiltered.replace('_MAX_', i) + b.sInfoPostFix\r\n                : a.fnRecordsDisplay() == a.fnRecordsTotal()\r\n                ? b.sInfo\r\n                    .replace('_START_', g)\r\n                    .replace('_END_', j)\r\n                    .replace('_MAX_', i)\r\n                    .replace('_TOTAL_', k) + b.sInfoPostFix\r\n                : b.sInfo\r\n                    .replace('_START_', g)\r\n                    .replace('_END_', j)\r\n                    .replace('_MAX_', i)\r\n                    .replace('_TOTAL_', k) +\r\n                  ' ' +\r\n                  b.sInfoFiltered.replace('_MAX_', a.fnFormatNumber(a.fnRecordsTotal())) +\r\n                  b.sInfoPostFix\r\n          ;(b = b.fnInfoCallback) && (g = b.call(a.oInstance, a, d, c, f, h, g))\r\n          a = a.aanFeatures.i\r\n          if ('undefined' != typeof a) {\r\n            d = 0\r\n            for (f = a.length; d < f; d++) e(a[d]).html(g)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    g.defaults = {\r\n      trace: !1,\r\n      rowHeight: 'auto',\r\n      serverWait: 200,\r\n      displayBuffer: 9,\r\n      boundaryScale: 0.5,\r\n      loadingIndicator: !1\r\n    }\r\n    g.oDefaults = g.defaults\r\n    g.version = '1.2.2'\r\n    'function' == typeof e.fn.dataTable &&\r\n    'function' == typeof e.fn.dataTableExt.fnVersionCheck &&\r\n    e.fn.dataTableExt.fnVersionCheck('1.9.0')\r\n      ? e.fn.dataTableExt.aoFeatures.push({\r\n          fnInit: function (a) {\r\n            var b = a.oInit\r\n            return new g(a, b.scroller || b.oScroller || {}).dom.wrapper\r\n          },\r\n          cFeature: 'S',\r\n          sFeature: 'Scroller'\r\n        })\r\n      : alert('Warning: Scroller requires DataTables 1.9.0 or greater - www.datatables.net/download')\r\n    e.fn.dataTable.Scroller = g\r\n    e.fn.DataTable.Scroller = g\r\n    if (e.fn.dataTable.Api) {\r\n      var i = e.fn.dataTable.Api\r\n      i.register('scroller()', function () {\r\n        return this\r\n      })\r\n      i.register('scroller().rowToPixels()', function (a, b, c) {\r\n        var d = this.context\r\n        if (d.length && d[0].oScroller) return d[0].oScroller.fnRowToPixels(a, b, c)\r\n      })\r\n      i.register('scroller().pixelsToRow()', function (a, b, c) {\r\n        var d = this.context\r\n        if (d.length && d[0].oScroller) return d[0].oScroller.fnPixelsToRow(a, b, c)\r\n      })\r\n      i.register('scroller().scrollToRow()', function (a, b) {\r\n        this.iterator('table', function (c) {\r\n          c.oScroller && c.oScroller.fnScrollToRow(a, b)\r\n        })\r\n        return this\r\n      })\r\n      i.register('scroller().measure()', function (a) {\r\n        this.iterator('table', function (b) {\r\n          b.oScroller && b.oScroller.fnMeasure(a)\r\n        })\r\n        return this\r\n      })\r\n    }\r\n    return g\r\n  }\r\n   true\r\n    ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! datatables */ 3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (l),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n    : 0\r\n})(window, document)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/dataTables.scroller.js?");

/***/ }),

/***/ 3:
/*!**************************************************************!*\
  !*** ./src/public/js/vendor/datatables/jquery.dataTables.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.2\r\n * 2008-2014 SpryMedia Ltd - datatables.net/license\r\n */\r\n\r\n/**\r\n * @summary     DataTables\r\n * @description Paginate, search and order HTML tables\r\n * @version     1.10.2\r\n * @file        jquery.dataTables.js\r\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\r\n * @contact     www.sprymedia.co.uk/contact\r\n * @copyright   Copyright 2008-2014 SpryMedia Ltd.\r\n *\r\n * This source file is free software, available under the following license:\r\n *   MIT license - http://datatables.net/license\r\n *\r\n * This source file is distributed in the hope that it will be useful, but\r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\r\n *\r\n * For details please refer to: http://www.datatables.net\r\n */\r\n\r\n/*jslint evil: true, undef: true, browser: true */\r\n/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidateRow,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/\r\n\r\n/** @lends <global> */ ;(function (window, document, undefined) {\r\n  ;(function (factory) {\r\n    'use strict'\r\n\r\n    if (true) {\r\n      // Define as an AMD module if possible\r\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n    } else {}\r\n  })(\r\n    /** @lends <global> */ function ($) {\r\n      'use strict'\r\n\r\n      /**\r\n       * DataTables is a plug-in for the jQuery Javascript library. It is a highly\r\n       * flexible tool, based upon the foundations of progressive enhancement,\r\n       * which will add advanced interaction controls to any HTML table. For a\r\n       * full list of features please refer to\r\n       * [DataTables.net](href=\"http://datatables.net).\r\n       *\r\n       * Note that the `DataTable` object is not a global variable but is aliased\r\n       * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may\r\n       * be  accessed.\r\n       *\r\n       *  @class\r\n       *  @param {object} [init={}] Configuration object for DataTables. Options\r\n       *    are defined by {@link DataTable.defaults}\r\n       *  @requires jQuery 1.7+\r\n       *\r\n       *  @example\r\n       *    // Basic initialisation\r\n       *    $(document).ready( function {\r\n       *      $('#example').dataTable();\r\n       *    } );\r\n       *\r\n       *  @example\r\n       *    // Initialisation with configuration options - in this case, disable\r\n       *    // pagination and sorting.\r\n       *    $(document).ready( function {\r\n       *      $('#example').dataTable( {\r\n       *        \"paginate\": false,\r\n       *        \"sort\": false\r\n       *      } );\r\n       *    } );\r\n       */\r\n      var DataTable\r\n\r\n      /*\r\n       * It is useful to have variables which are scoped locally so only the\r\n       * DataTables functions can access them and they don't leak into global space.\r\n       * At the same time these functions are often useful over multiple files in the\r\n       * core and API, so we list, or at least document, all variables which are used\r\n       * by DataTables as private variables here. This also ensures that there is no\r\n       * clashing of variable names and that they can easily referenced for reuse.\r\n       */\r\n\r\n      // Defined else where\r\n      //  _selector_run\r\n      //  _selector_opts\r\n      //  _selector_first\r\n      //  _selector_row_indexes\r\n\r\n      var _ext // DataTable.ext\r\n      var _Api // DataTable.Api\r\n      var _api_register // DataTable.Api.register\r\n      var _api_registerPlural // DataTable.Api.registerPlural\r\n\r\n      var _re_dic = {}\r\n      var _re_new_lines = /[\\r\\n]/g\r\n      var _re_html = /<.*?>/g\r\n      var _re_date_start = /^[\\w\\+\\-]/\r\n      var _re_date_end = /[\\w\\+\\-]$/\r\n\r\n      // Escape regular expression special characters\r\n      var _re_escape_regex = new RegExp(\r\n        '(\\\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-'].join('|\\\\') + ')',\r\n        'g'\r\n      )\r\n\r\n      // U+2009 is thin space and U+202F is narrow no-break space, both used in many\r\n      // standards as thousands separators\r\n      var _re_formatted_numeric = /[',$%\\u2009\\u202F]/g\r\n\r\n      var _empty = function (d) {\r\n        return !d || d === true || d === '-' ? true : false\r\n      }\r\n\r\n      var _intVal = function (s) {\r\n        var integer = parseInt(s, 10)\r\n        return !isNaN(integer) && isFinite(s) ? integer : null\r\n      }\r\n\r\n      // Convert from a formatted number with characters other than `.` as the\r\n      // decimal place, to a Javascript number\r\n      var _numToDecimal = function (num, decimalPoint) {\r\n        // Cache created regular expressions for speed as this function is called often\r\n        if (!_re_dic[decimalPoint]) {\r\n          _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g')\r\n        }\r\n        return typeof num === 'string' ? num.replace(/\\./g, '').replace(_re_dic[decimalPoint], '.') : num\r\n      }\r\n\r\n      var _isNumber = function (d, decimalPoint, formatted) {\r\n        var strType = typeof d === 'string'\r\n\r\n        if (decimalPoint && strType) {\r\n          d = _numToDecimal(d, decimalPoint)\r\n        }\r\n\r\n        if (formatted && strType) {\r\n          d = d.replace(_re_formatted_numeric, '')\r\n        }\r\n\r\n        return _empty(d) || (!isNaN(parseFloat(d)) && isFinite(d))\r\n      }\r\n\r\n      // A string without HTML in it can be considered to be HTML still\r\n      var _isHtml = function (d) {\r\n        return _empty(d) || typeof d === 'string'\r\n      }\r\n\r\n      var _htmlNumeric = function (d, decimalPoint, formatted) {\r\n        if (_empty(d)) {\r\n          return true\r\n        }\r\n\r\n        var html = _isHtml(d)\r\n        return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null\r\n      }\r\n\r\n      var _pluck = function (a, prop, prop2) {\r\n        var out = []\r\n        var i = 0,\r\n          ien = a.length\r\n\r\n        // Could have the test in the loop for slightly smaller code, but speed\r\n        // is essential here\r\n        if (prop2 !== undefined) {\r\n          for (; i < ien; i++) {\r\n            if (a[i] && a[i][prop]) {\r\n              out.push(a[i][prop][prop2])\r\n            }\r\n          }\r\n        } else {\r\n          for (; i < ien; i++) {\r\n            if (a[i]) {\r\n              out.push(a[i][prop])\r\n            }\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      // Basically the same as _pluck, but rather than looping over `a` we use `order`\r\n      // as the indexes to pick from `a`\r\n      var _pluck_order = function (a, order, prop, prop2) {\r\n        var out = []\r\n        var i = 0,\r\n          ien = order.length\r\n\r\n        // Could have the test in the loop for slightly smaller code, but speed\r\n        // is essential here\r\n        if (prop2 !== undefined) {\r\n          for (; i < ien; i++) {\r\n            out.push(a[order[i]][prop][prop2])\r\n          }\r\n        } else {\r\n          for (; i < ien; i++) {\r\n            out.push(a[order[i]][prop])\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      var _range = function (len, start) {\r\n        var out = []\r\n        var end\r\n\r\n        if (start === undefined) {\r\n          start = 0\r\n          end = len\r\n        } else {\r\n          end = start\r\n          start = len\r\n        }\r\n\r\n        for (var i = start; i < end; i++) {\r\n          out.push(i)\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      var _stripHtml = function (d) {\r\n        return d.replace(_re_html, '')\r\n      }\r\n\r\n      /**\r\n       * Find the unique elements in a source array.\r\n       *\r\n       * @param  {array} src Source array\r\n       * @return {array} Array of unique items\r\n       * @ignore\r\n       */\r\n      var _unique = function (src) {\r\n        // A faster unique method is to use object keys to identify used values,\r\n        // but this doesn't work with arrays or objects, which we must also\r\n        // consider. See jsperf.com/compare-array-unique-versions/4 for more\r\n        // information.\r\n        var out = [],\r\n          val,\r\n          i,\r\n          ien = src.length,\r\n          j,\r\n          k = 0\r\n\r\n        again: for (i = 0; i < ien; i++) {\r\n          val = src[i]\r\n\r\n          for (j = 0; j < k; j++) {\r\n            if (out[j] === val) {\r\n              continue again\r\n            }\r\n          }\r\n\r\n          out.push(val)\r\n          k++\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      /**\r\n       * Create a mapping object that allows camel case parameters to be looked up\r\n       * for their Hungarian counterparts. The mapping is stored in a private\r\n       * parameter called `_hungarianMap` which can be accessed on the source object.\r\n       *  @param {object} o\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnHungarianMap (o) {\r\n        var hungarian = 'a aa ai ao as b fn i m o s ',\r\n          match,\r\n          newKey,\r\n          map = {}\r\n\r\n        $.each(o, function (key, val) {\r\n          match = key.match(/^([^A-Z]+?)([A-Z])/)\r\n\r\n          if (match && hungarian.indexOf(match[1] + ' ') !== -1) {\r\n            newKey = key.replace(match[0], match[2].toLowerCase())\r\n            map[newKey] = key\r\n\r\n            //console.log( key, match );\r\n            if (match[1] === 'o') {\r\n              _fnHungarianMap(o[key])\r\n            }\r\n          }\r\n        })\r\n\r\n        o._hungarianMap = map\r\n      }\r\n\r\n      /**\r\n       * Convert from camel case parameters to Hungarian, based on a Hungarian map\r\n       * created by _fnHungarianMap.\r\n       *  @param {object} src The model object which holds all parameters that can be\r\n       *    mapped.\r\n       *  @param {object} user The object to convert from camel case to Hungarian.\r\n       *  @param {boolean} force When set to `true`, properties which already have a\r\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\r\n       *    won't be.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCamelToHungarian (src, user, force) {\r\n        if (!src._hungarianMap) {\r\n          _fnHungarianMap(src)\r\n        }\r\n\r\n        var hungarianKey\r\n\r\n        $.each(user, function (key, val) {\r\n          hungarianKey = src._hungarianMap[key]\r\n\r\n          if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {\r\n            // For objects, we need to buzz down into the object to copy parameters\r\n            if (hungarianKey.charAt(0) === 'o') {\r\n              // Copy the camelCase options over to the hungarian\r\n              if (!user[hungarianKey]) {\r\n                user[hungarianKey] = {}\r\n              }\r\n              $.extend(true, user[hungarianKey], user[key])\r\n\r\n              _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force)\r\n            } else {\r\n              user[hungarianKey] = user[key]\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Language compatibility - when certain options are given, and others aren't, we\r\n       * need to duplicate the values over, in order to provide backwards compatibility\r\n       * with older language files.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnLanguageCompat (lang) {\r\n        var defaults = DataTable.defaults.oLanguage\r\n        var zeroRecords = lang.sZeroRecords\r\n\r\n        /* Backwards compatibility - if there is no sEmptyTable given, then use the same as\r\n         * sZeroRecords - assuming that is given.\r\n         */\r\n        if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === 'No data available in table') {\r\n          _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable')\r\n        }\r\n\r\n        /* Likewise with loading records */\r\n        if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === 'Loading...') {\r\n          _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords')\r\n        }\r\n\r\n        // Old parameter name of the thousands separator mapped onto the new\r\n        if (lang.sInfoThousands) {\r\n          lang.sThousands = lang.sInfoThousands\r\n        }\r\n\r\n        var decimal = lang.sDecimal\r\n        if (decimal) {\r\n          _addNumericSort(decimal)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Map one parameter onto another\r\n       *  @param {object} o Object to map\r\n       *  @param {*} knew The new parameter name\r\n       *  @param {*} old The old parameter name\r\n       */\r\n      var _fnCompatMap = function (o, knew, old) {\r\n        if (o[knew] !== undefined) {\r\n          o[old] = o[knew]\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Provide backwards compatibility for the main DT options. Note that the new\r\n       * options are mapped onto the old parameters, so this is an external interface\r\n       * change only.\r\n       *  @param {object} init Object to map\r\n       */\r\n      function _fnCompatOpts (init) {\r\n        _fnCompatMap(init, 'ordering', 'bSort')\r\n        _fnCompatMap(init, 'orderMulti', 'bSortMulti')\r\n        _fnCompatMap(init, 'orderClasses', 'bSortClasses')\r\n        _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop')\r\n        _fnCompatMap(init, 'order', 'aaSorting')\r\n        _fnCompatMap(init, 'orderFixed', 'aaSortingFixed')\r\n        _fnCompatMap(init, 'paging', 'bPaginate')\r\n        _fnCompatMap(init, 'pagingType', 'sPaginationType')\r\n        _fnCompatMap(init, 'pageLength', 'iDisplayLength')\r\n        _fnCompatMap(init, 'searching', 'bFilter')\r\n\r\n        // Column search objects are in an array, so it needs to be converted\r\n        // element by element\r\n        var searchCols = init.aoSearchCols\r\n\r\n        if (searchCols) {\r\n          for (var i = 0, ien = searchCols.length; i < ien; i++) {\r\n            if (searchCols[i]) {\r\n              _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i])\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Provide backwards compatibility for column options. Note that the new options\r\n       * are mapped onto the old parameters, so this is an external interface change\r\n       * only.\r\n       *  @param {object} init Object to map\r\n       */\r\n      function _fnCompatCols (init) {\r\n        _fnCompatMap(init, 'orderable', 'bSortable')\r\n        _fnCompatMap(init, 'orderData', 'aDataSort')\r\n        _fnCompatMap(init, 'orderSequence', 'asSorting')\r\n        _fnCompatMap(init, 'orderDataType', 'sortDataType')\r\n      }\r\n\r\n      /**\r\n       * Browser feature detection for capabilities, quirks\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnBrowserDetect (settings) {\r\n        var browser = settings.oBrowser\r\n\r\n        // Scrolling feature / quirks detection\r\n        var n = $('<div/>')\r\n          .css({\r\n            position: 'absolute',\r\n            top: 0,\r\n            left: 0,\r\n            height: 1,\r\n            width: 1,\r\n            overflow: 'hidden'\r\n          })\r\n          .append(\r\n            $('<div/>')\r\n              .css({\r\n                position: 'absolute',\r\n                top: 1,\r\n                left: 1,\r\n                width: 100,\r\n                overflow: 'scroll'\r\n              })\r\n              .append(\r\n                $('<div class=\"test\"/>').css({\r\n                  width: '100%',\r\n                  height: 10\r\n                })\r\n              )\r\n          )\r\n          .appendTo('body')\r\n\r\n        var test = n.find('.test')\r\n\r\n        // IE6/7 will oversize a width 100% element inside a scrolling element, to\r\n        // include the width of the scrollbar, while other browsers ensure the inner\r\n        // element is contained without forcing scrolling\r\n        browser.bScrollOversize = test[0].offsetWidth === 100\r\n\r\n        // In rtl text layout, some browsers (most, but not all) will place the\r\n        // scrollbar on the left, rather than the right.\r\n        browser.bScrollbarLeft = test.offset().left !== 1\r\n\r\n        n.remove()\r\n      }\r\n\r\n      /**\r\n       * Array.prototype reduce[Right] method, used for browsers which don't support\r\n       * JS 1.6. Done this way to reduce code size, since we iterate either way\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnReduce (that, fn, init, start, end, inc) {\r\n        var i = start,\r\n          value,\r\n          isSet = false\r\n\r\n        if (init !== undefined) {\r\n          value = init\r\n          isSet = true\r\n        }\r\n\r\n        while (i !== end) {\r\n          if (!that.hasOwnProperty(i)) {\r\n            continue\r\n          }\r\n\r\n          value = isSet ? fn(value, that[i], i, that) : that[i]\r\n\r\n          isSet = true\r\n          i += inc\r\n        }\r\n\r\n        return value\r\n      }\r\n\r\n      /**\r\n       * Add a column to the list used for the table with default values\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} nTh The th element for this column\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddColumn (oSettings, nTh) {\r\n        // Add column to aoColumns array\r\n        var oDefaults = DataTable.defaults.column\r\n        var iCol = oSettings.aoColumns.length\r\n        var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {\r\n          nTh: nTh ? nTh : document.createElement('th'),\r\n          sTitle: oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',\r\n          aDataSort: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\r\n          mData: oDefaults.mData ? oDefaults.mData : iCol,\r\n          idx: iCol\r\n        })\r\n        oSettings.aoColumns.push(oCol)\r\n\r\n        // Add search object for column specific search. Note that the `searchCols[ iCol ]`\r\n        // passed into extend can be undefined. This allows the user to give a default\r\n        // with only some of the parameters defined, and also not give a default\r\n        var searchCols = oSettings.aoPreSearchCols\r\n        searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol])\r\n\r\n        // Use the default column options function to initialise classes etc\r\n        _fnColumnOptions(oSettings, iCol, null)\r\n      }\r\n\r\n      /**\r\n       * Apply options for a column\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iCol column index to consider\r\n       *  @param {object} oOptions object with sType, bVisible and bSearchable etc\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnColumnOptions (oSettings, iCol, oOptions) {\r\n        var oCol = oSettings.aoColumns[iCol]\r\n        var oClasses = oSettings.oClasses\r\n        var th = $(oCol.nTh)\r\n\r\n        // Try to get width information from the DOM. We can't get it from CSS\r\n        // as we'd need to parse the CSS stylesheet. `width` option can override\r\n        if (!oCol.sWidthOrig) {\r\n          // Width attribute\r\n          oCol.sWidthOrig = th.attr('width') || null\r\n\r\n          // Style attribute\r\n          var t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/)\r\n          if (t) {\r\n            oCol.sWidthOrig = t[1]\r\n          }\r\n        }\r\n\r\n        /* User specified column options */\r\n        if (oOptions !== undefined && oOptions !== null) {\r\n          // Backwards compatibility\r\n          _fnCompatCols(oOptions)\r\n\r\n          // Map camel case parameters to their Hungarian counterparts\r\n          _fnCamelToHungarian(DataTable.defaults.column, oOptions)\r\n\r\n          /* Backwards compatibility for mDataProp */\r\n          if (oOptions.mDataProp !== undefined && !oOptions.mData) {\r\n            oOptions.mData = oOptions.mDataProp\r\n          }\r\n\r\n          if (oOptions.sType) {\r\n            oCol._sManualType = oOptions.sType\r\n          }\r\n\r\n          // `class` is a reserved word in Javascript, so we need to provide\r\n          // the ability to use a valid name for the camel case input\r\n          if (oOptions.className && !oOptions.sClass) {\r\n            oOptions.sClass = oOptions.className\r\n          }\r\n\r\n          $.extend(oCol, oOptions)\r\n          _fnMap(oCol, oOptions, 'sWidth', 'sWidthOrig')\r\n\r\n          /* iDataSort to be applied (backwards compatibility), but aDataSort will take\r\n           * priority if defined\r\n           */\r\n          if (typeof oOptions.iDataSort === 'number') {\r\n            oCol.aDataSort = [oOptions.iDataSort]\r\n          }\r\n          _fnMap(oCol, oOptions, 'aDataSort')\r\n        }\r\n\r\n        /* Cache the data get and set functions for speed */\r\n        var mDataSrc = oCol.mData\r\n        var mData = _fnGetObjectDataFn(mDataSrc)\r\n        var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null\r\n\r\n        var attrTest = function (src) {\r\n          return typeof src === 'string' && src.indexOf('@') !== -1\r\n        }\r\n        oCol._bAttrSrc =\r\n          $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter))\r\n\r\n        oCol.fnGetData = function (rowData, type, meta) {\r\n          var innerData = mData(rowData, type, undefined, meta)\r\n\r\n          return mRender && type ? mRender(innerData, type, rowData, meta) : innerData\r\n        }\r\n        oCol.fnSetData = function (rowData, val, meta) {\r\n          return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta)\r\n        }\r\n\r\n        /* Feature sorting overrides column specific when off */\r\n        if (!oSettings.oFeatures.bSort) {\r\n          oCol.bSortable = false\r\n          th.addClass(oClasses.sSortableNone) // Have to add class here as order event isn't called\r\n        }\r\n\r\n        /* Check that the class assignment is correct for sorting */\r\n        var bAsc = $.inArray('asc', oCol.asSorting) !== -1\r\n        var bDesc = $.inArray('desc', oCol.asSorting) !== -1\r\n        if (!oCol.bSortable || (!bAsc && !bDesc)) {\r\n          oCol.sSortingClass = oClasses.sSortableNone\r\n          oCol.sSortingClassJUI = ''\r\n        } else if (bAsc && !bDesc) {\r\n          oCol.sSortingClass = oClasses.sSortableAsc\r\n          oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed\r\n        } else if (!bAsc && bDesc) {\r\n          oCol.sSortingClass = oClasses.sSortableDesc\r\n          oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed\r\n        } else {\r\n          oCol.sSortingClass = oClasses.sSortable\r\n          oCol.sSortingClassJUI = oClasses.sSortJUI\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Adjust the table column widths for new data. Note: you would probably want to\r\n       * do a redraw after calling this function!\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAdjustColumnSizing (settings) {\r\n        /* Not interested in doing column width calculation if auto-width is disabled */\r\n        if (settings.oFeatures.bAutoWidth !== false) {\r\n          var columns = settings.aoColumns\r\n\r\n          _fnCalculateColumnWidths(settings)\r\n          for (var i = 0, iLen = columns.length; i < iLen; i++) {\r\n            columns[i].nTh.style.width = columns[i].sWidth\r\n          }\r\n        }\r\n\r\n        var scroll = settings.oScroll\r\n        if (scroll.sY !== '' || scroll.sX !== '') {\r\n          _fnScrollDraw(settings)\r\n        }\r\n\r\n        _fnCallbackFire(settings, null, 'column-sizing', [settings])\r\n      }\r\n\r\n      /**\r\n       * Covert the index of a visible column to the index in the data array (take account\r\n       * of hidden columns)\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iMatch Visible column index to lookup\r\n       *  @returns {int} i the data index\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnVisibleToColumnIndex (oSettings, iMatch) {\r\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\r\n\r\n        return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null\r\n      }\r\n\r\n      /**\r\n       * Covert the index of an index in the data array and convert it to the visible\r\n       *   column index (take account of hidden columns)\r\n       *  @param {int} iMatch Column index to lookup\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {int} i the data index\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnColumnIndexToVisible (oSettings, iMatch) {\r\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\r\n        var iPos = $.inArray(iMatch, aiVis)\r\n\r\n        return iPos !== -1 ? iPos : null\r\n      }\r\n\r\n      /**\r\n       * Get the number of visible columns\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {int} i the number of visible columns\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnVisbleColumns (oSettings) {\r\n        return _fnGetColumns(oSettings, 'bVisible').length\r\n      }\r\n\r\n      /**\r\n       * Get an array of column indexes that match a given property\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {string} sParam Parameter in aoColumns to look for - typically\r\n       *    bVisible or bSearchable\r\n       *  @returns {array} Array of indexes with matched properties\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetColumns (oSettings, sParam) {\r\n        var a = []\r\n\r\n        $.map(oSettings.aoColumns, function (val, i) {\r\n          if (val[sParam]) {\r\n            a.push(i)\r\n          }\r\n        })\r\n\r\n        return a\r\n      }\r\n\r\n      /**\r\n       * Calculate the 'type' of a column\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnColumnTypes (settings) {\r\n        var columns = settings.aoColumns\r\n        var data = settings.aoData\r\n        var types = DataTable.ext.type.detect\r\n        var i, ien, j, jen, k, ken\r\n        var col, cell, detectedType, cache\r\n\r\n        // For each column, spin over the\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          col = columns[i]\r\n          cache = []\r\n\r\n          if (!col.sType && col._sManualType) {\r\n            col.sType = col._sManualType\r\n          } else if (!col.sType) {\r\n            for (j = 0, jen = types.length; j < jen; j++) {\r\n              for (k = 0, ken = data.length; k < ken; k++) {\r\n                // Use a cache array so we only need to get the type data\r\n                // from the formatter once (when using multiple detectors)\r\n                if (cache[k] === undefined) {\r\n                  cache[k] = _fnGetCellData(settings, k, i, 'type')\r\n                }\r\n\r\n                detectedType = types[j](cache[k], settings)\r\n\r\n                // Doesn't match, so break early, since this type can't\r\n                // apply to this column. Also, HTML is a special case since\r\n                // it is so similar to `string`. Just a single match is\r\n                // needed for a column to be html type\r\n                if (!detectedType || detectedType === 'html') {\r\n                  break\r\n                }\r\n              }\r\n\r\n              // Type is valid for all data points in the column - use this\r\n              // type\r\n              if (detectedType) {\r\n                col.sType = detectedType\r\n                break\r\n              }\r\n            }\r\n\r\n            // Fall back - if no type was detected, always use string\r\n            if (!col.sType) {\r\n              col.sType = 'string'\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Take the column definitions and static columns arrays and calculate how\r\n       * they relate to column indexes. The callback function will then apply the\r\n       * definition found for a column to a suitable configuration object.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\r\n       *  @param {array} aoCols The aoColumns array that defines columns individually\r\n       *  @param {function} fn Callback function - takes two parameters, the calculated\r\n       *    column index and the definition for that column.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnApplyColumnDefs (oSettings, aoColDefs, aoCols, fn) {\r\n        var i, iLen, j, jLen, k, kLen, def\r\n        var columns = oSettings.aoColumns\r\n\r\n        // Column definitions with aTargets\r\n        if (aoColDefs) {\r\n          /* Loop over the definitions array - loop in reverse so first instance has priority */\r\n          for (i = aoColDefs.length - 1; i >= 0; i--) {\r\n            def = aoColDefs[i]\r\n\r\n            /* Each definition can target multiple columns, as it is an array */\r\n            var aTargets = def.targets !== undefined ? def.targets : def.aTargets\r\n\r\n            if (!$.isArray(aTargets)) {\r\n              aTargets = [aTargets]\r\n            }\r\n\r\n            for (j = 0, jLen = aTargets.length; j < jLen; j++) {\r\n              if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {\r\n                /* Add columns that we don't yet know about */\r\n                while (columns.length <= aTargets[j]) {\r\n                  _fnAddColumn(oSettings)\r\n                }\r\n\r\n                /* Integer, basic index */\r\n                fn(aTargets[j], def)\r\n              } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {\r\n                /* Negative integer, right to left column counting */\r\n                fn(columns.length + aTargets[j], def)\r\n              } else if (typeof aTargets[j] === 'string') {\r\n                /* Class name matching on TH element */\r\n                for (k = 0, kLen = columns.length; k < kLen; k++) {\r\n                  if (aTargets[j] == '_all' || $(columns[k].nTh).hasClass(aTargets[j])) {\r\n                    fn(k, def)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Statically defined columns array\r\n        if (aoCols) {\r\n          for (i = 0, iLen = aoCols.length; i < iLen; i++) {\r\n            fn(i, aoCols[i])\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Add a data array to the table, creating DOM node etc. This is the parallel to\r\n       * _fnGatherData, but for adding rows from a Javascript source, rather than a\r\n       * DOM source.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {array} aData data array to be added\r\n       *  @param {node} [nTr] TR element to add to the table - optional. If not given,\r\n       *    DataTables will create a row automatically\r\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\r\n       *    if nTr is.\r\n       *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddData (oSettings, aDataIn, nTr, anTds) {\r\n        /* Create the object for storing information about this new row */\r\n        var iRow = oSettings.aoData.length\r\n        var oData = $.extend(true, {}, DataTable.models.oRow, {\r\n          src: nTr ? 'dom' : 'data'\r\n        })\r\n\r\n        oData._aData = aDataIn\r\n        oSettings.aoData.push(oData)\r\n\r\n        /* Create the cells */\r\n        var nTd, sThisType\r\n        var columns = oSettings.aoColumns\r\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\r\n          // When working with a row, the data source object must be populated. In\r\n          // all other cases, the data source object is already populated, so we\r\n          // don't overwrite it, which might break bindings etc\r\n          if (nTr) {\r\n            _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i))\r\n          }\r\n          columns[i].sType = null\r\n        }\r\n\r\n        /* Add to the display array */\r\n        oSettings.aiDisplayMaster.push(iRow)\r\n\r\n        /* Create the DOM information, or register it if already present */\r\n        if (nTr || !oSettings.oFeatures.bDeferRender) {\r\n          _fnCreateTr(oSettings, iRow, nTr, anTds)\r\n        }\r\n\r\n        return iRow\r\n      }\r\n\r\n      /**\r\n       * Add one or more TR elements to the table. Generally we'd expect to\r\n       * use this for reading data from a DOM sourced table, but it could be\r\n       * used for an TR element. Note that if a TR is given, it is used (i.e.\r\n       * it is not cloned).\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {array|node|jQuery} trs The TR element(s) to add to the table\r\n       *  @returns {array} Array of indexes for the added rows\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddTr (settings, trs) {\r\n        var row\r\n\r\n        // Allow an individual node to be passed in\r\n        if (!(trs instanceof $)) {\r\n          trs = $(trs)\r\n        }\r\n\r\n        return trs.map(function (i, el) {\r\n          row = _fnGetRowElements(settings, el)\r\n          return _fnAddData(settings, row.data, el, row.cells)\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Take a TR element and convert it to an index in aoData\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} n the TR element to find\r\n       *  @returns {int} index if the node is found, null if not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnNodeToDataIndex (oSettings, n) {\r\n        return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null\r\n      }\r\n\r\n      /**\r\n       * Take a TD element and convert it into a column data index (not the visible index)\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iRow The row number the TD/TH can be found in\r\n       *  @param {node} n The TD/TH element to find\r\n       *  @returns {int} index if the node is found, -1 if not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnNodeToColumnIndex (oSettings, iRow, n) {\r\n        return $.inArray(n, oSettings.aoData[iRow].anCells)\r\n      }\r\n\r\n      /**\r\n       * Get the data for a given cell from the internal cache, taking into account data mapping\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} rowIdx aoData row id\r\n       *  @param {int} colIdx Column index\r\n       *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\r\n       *  @returns {*} Cell data\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetCellData (settings, rowIdx, colIdx, type) {\r\n        var draw = settings.iDraw\r\n        var col = settings.aoColumns[colIdx]\r\n        var rowData = settings.aoData[rowIdx]._aData\r\n        var defaultContent = col.sDefaultContent\r\n        var cellData = col.fnGetData(rowData, type, {\r\n          settings: settings,\r\n          row: rowIdx,\r\n          col: colIdx\r\n        })\r\n\r\n        if (cellData === undefined) {\r\n          if (settings.iDrawError != draw && defaultContent === null) {\r\n            _fnLog(\r\n              settings,\r\n              0,\r\n              'Requested unknown parameter ' +\r\n                (typeof col.mData == 'function' ? '{function}' : \"'\" + col.mData + \"'\") +\r\n                ' for row ' +\r\n                rowIdx,\r\n              4\r\n            )\r\n            settings.iDrawError = draw\r\n          }\r\n          return defaultContent\r\n        }\r\n\r\n        /* When the data source is null, we can use default column data */\r\n        if ((cellData === rowData || cellData === null) && defaultContent !== null) {\r\n          cellData = defaultContent\r\n        } else if (typeof cellData === 'function') {\r\n          // If the data source is a function, then we run it and use the return,\r\n          // executing in the scope of the data object (for instances)\r\n          return cellData.call(rowData)\r\n        }\r\n\r\n        if (cellData === null && type == 'display') {\r\n          return ''\r\n        }\r\n        return cellData\r\n      }\r\n\r\n      /**\r\n       * Set the value for a specific cell, into the internal data cache\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} rowIdx aoData row id\r\n       *  @param {int} colIdx Column index\r\n       *  @param {*} val Value to set\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSetCellData (settings, rowIdx, colIdx, val) {\r\n        var col = settings.aoColumns[colIdx]\r\n        var rowData = settings.aoData[rowIdx]._aData\r\n\r\n        col.fnSetData(rowData, val, {\r\n          settings: settings,\r\n          row: rowIdx,\r\n          col: colIdx\r\n        })\r\n      }\r\n\r\n      // Private variable that is used to match action syntax in the data property object\r\n      var __reArray = /\\[.*?\\]$/\r\n      var __reFn = /\\(\\)$/\r\n\r\n      /**\r\n       * Split string on periods, taking into account escaped periods\r\n       * @param  {string} str String to split\r\n       * @return {array} Split string\r\n       */\r\n      function _fnSplitObjNotation (str) {\r\n        return $.map(str.match(/(\\\\.|[^\\.])+/g), function (s) {\r\n          return s.replace(/\\\\./g, '.')\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Return a function that can be used to get data from a source object, taking\r\n       * into account the ability to use nested objects as a source\r\n       *  @param {string|int|function} mSource The data source for the object\r\n       *  @returns {function} Data get function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetObjectDataFn (mSource) {\r\n        if ($.isPlainObject(mSource)) {\r\n          /* Build an object of get functions, and wrap them in a single call */\r\n          var o = {}\r\n          $.each(mSource, function (key, val) {\r\n            if (val) {\r\n              o[key] = _fnGetObjectDataFn(val)\r\n            }\r\n          })\r\n\r\n          return function (data, type, row, meta) {\r\n            var t = o[type] || o._\r\n            return t !== undefined ? t(data, type, row, meta) : data\r\n          }\r\n        } else if (mSource === null) {\r\n          /* Give an empty string for rendering / sorting etc */\r\n          return function (data) {\r\n            // type, row and meta also passed, but not used\r\n            return data\r\n          }\r\n        } else if (typeof mSource === 'function') {\r\n          return function (data, type, row, meta) {\r\n            return mSource(data, type, row, meta)\r\n          }\r\n        } else if (\r\n          typeof mSource === 'string' &&\r\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\r\n        ) {\r\n          /* If there is a . in the source string then the data source is in a\r\n           * nested object so we loop over the data for each level to get the next\r\n           * level down. On each loop we test for undefined, and if found immediately\r\n           * return. This allows entire objects to be missing and sDefaultContent to\r\n           * be used if defined, rather than throwing an error\r\n           */\r\n          var fetchData = function (data, type, src) {\r\n            var arrayNotation, funcNotation, out, innerSrc\r\n\r\n            if (src !== '') {\r\n              var a = _fnSplitObjNotation(src)\r\n\r\n              for (var i = 0, iLen = a.length; i < iLen; i++) {\r\n                // Check if we are dealing with special notation\r\n                arrayNotation = a[i].match(__reArray)\r\n                funcNotation = a[i].match(__reFn)\r\n\r\n                if (arrayNotation) {\r\n                  // Array notation\r\n                  a[i] = a[i].replace(__reArray, '')\r\n\r\n                  // Condition allows simply [] to be passed in\r\n                  if (a[i] !== '') {\r\n                    data = data[a[i]]\r\n                  }\r\n                  out = []\r\n\r\n                  // Get the remainder of the nested object to get\r\n                  a.splice(0, i + 1)\r\n                  innerSrc = a.join('.')\r\n\r\n                  // Traverse each entry in the array getting the properties requested\r\n                  for (var j = 0, jLen = data.length; j < jLen; j++) {\r\n                    out.push(fetchData(data[j], type, innerSrc))\r\n                  }\r\n\r\n                  // If a string is given in between the array notation indicators, that\r\n                  // is used to join the strings together, otherwise an array is returned\r\n                  var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1)\r\n                  data = join === '' ? out : out.join(join)\r\n\r\n                  // The inner call to fetchData has already traversed through the remainder\r\n                  // of the source requested, so we exit from the loop\r\n                  break\r\n                } else if (funcNotation) {\r\n                  // Function call\r\n                  a[i] = a[i].replace(__reFn, '')\r\n                  data = data[a[i]]()\r\n                  continue\r\n                }\r\n\r\n                if (data === null || data[a[i]] === undefined) {\r\n                  return undefined\r\n                }\r\n                data = data[a[i]]\r\n              }\r\n            }\r\n\r\n            return data\r\n          }\r\n\r\n          return function (data, type) {\r\n            // row and meta also passed, but not used\r\n            return fetchData(data, type, mSource)\r\n          }\r\n        } else {\r\n          /* Array or flat object mapping */\r\n          return function (data, type) {\r\n            // row and meta also passed, but not used\r\n            return data[mSource]\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Return a function that can be used to set data from a source object, taking\r\n       * into account the ability to use nested objects as a source\r\n       *  @param {string|int|function} mSource The data source for the object\r\n       *  @returns {function} Data set function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSetObjectDataFn (mSource) {\r\n        if ($.isPlainObject(mSource)) {\r\n          /* Unlike get, only the underscore (global) option is used for for\r\n           * setting data since we don't know the type here. This is why an object\r\n           * option is not documented for `mData` (which is read/write), but it is\r\n           * for `mRender` which is read only.\r\n           */\r\n          return _fnSetObjectDataFn(mSource._)\r\n        } else if (mSource === null) {\r\n          /* Nothing to do when the data source is null */\r\n          return function () {}\r\n        } else if (typeof mSource === 'function') {\r\n          return function (data, val, meta) {\r\n            mSource(data, 'set', val, meta)\r\n          }\r\n        } else if (\r\n          typeof mSource === 'string' &&\r\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\r\n        ) {\r\n          /* Like the get, we need to get data from a nested object */\r\n          var setData = function (data, val, src) {\r\n            var a = _fnSplitObjNotation(src),\r\n              b\r\n            var aLast = a[a.length - 1]\r\n            var arrayNotation, funcNotation, o, innerSrc\r\n\r\n            for (var i = 0, iLen = a.length - 1; i < iLen; i++) {\r\n              // Check if we are dealing with an array notation request\r\n              arrayNotation = a[i].match(__reArray)\r\n              funcNotation = a[i].match(__reFn)\r\n\r\n              if (arrayNotation) {\r\n                a[i] = a[i].replace(__reArray, '')\r\n                data[a[i]] = []\r\n\r\n                // Get the remainder of the nested object to set so we can recurse\r\n                b = a.slice()\r\n                b.splice(0, i + 1)\r\n                innerSrc = b.join('.')\r\n\r\n                // Traverse each entry in the array setting the properties requested\r\n                for (var j = 0, jLen = val.length; j < jLen; j++) {\r\n                  o = {}\r\n                  setData(o, val[j], innerSrc)\r\n                  data[a[i]].push(o)\r\n                }\r\n\r\n                // The inner call to setData has already traversed through the remainder\r\n                // of the source and has set the data, thus we can exit here\r\n                return\r\n              } else if (funcNotation) {\r\n                // Function call\r\n                a[i] = a[i].replace(__reFn, '')\r\n                data = data[a[i]](val)\r\n              }\r\n\r\n              // If the nested object doesn't currently exist - since we are\r\n              // trying to set the value - create it\r\n              if (data[a[i]] === null || data[a[i]] === undefined) {\r\n                data[a[i]] = {}\r\n              }\r\n              data = data[a[i]]\r\n            }\r\n\r\n            // Last item in the input - i.e, the actual set\r\n            if (aLast.match(__reFn)) {\r\n              // Function call\r\n              data = data[aLast.replace(__reFn, '')](val)\r\n            } else {\r\n              // If array notation is used, we just want to strip it and use the property name\r\n              // and assign the value. If it isn't used, then we get the result we want anyway\r\n              data[aLast.replace(__reArray, '')] = val\r\n            }\r\n          }\r\n\r\n          return function (data, val) {\r\n            // meta is also passed in, but not used\r\n            return setData(data, val, mSource)\r\n          }\r\n        } else {\r\n          /* Array or flat object mapping */\r\n          return function (data, val) {\r\n            // meta is also passed in, but not used\r\n            data[mSource] = val\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Return an array with the full table data\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns array {array} aData Master data array\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetDataMaster (settings) {\r\n        return _pluck(settings.aoData, '_aData')\r\n      }\r\n\r\n      /**\r\n       * Nuke the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnClearTable (settings) {\r\n        settings.aoData.length = 0\r\n        settings.aiDisplayMaster.length = 0\r\n        settings.aiDisplay.length = 0\r\n      }\r\n\r\n      /**\r\n       * Take an array of integers (index array) and remove a target integer (value - not\r\n       * the key!)\r\n       *  @param {array} a Index array to target\r\n       *  @param {int} iTarget value to find\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDeleteIndex (a, iTarget, splice) {\r\n        var iTargetIndex = -1\r\n\r\n        for (var i = 0, iLen = a.length; i < iLen; i++) {\r\n          if (a[i] == iTarget) {\r\n            iTargetIndex = i\r\n          } else if (a[i] > iTarget) {\r\n            a[i]--\r\n          }\r\n        }\r\n\r\n        if (iTargetIndex != -1 && splice === undefined) {\r\n          a.splice(iTargetIndex, 1)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Mark cached data as invalid such that a re-read of the data will occur when\r\n       * the cached data is next requested. Also update from the data source object.\r\n       *\r\n       * @param {object} settings DataTables settings object\r\n       * @param  {int}    rowIdx   Row index to invalidate\r\n       * @memberof DataTable#oApi\r\n       *\r\n       * @todo For the modularisation of v1.11 this will need to become a callback, so\r\n       *   the sort and filter methods can subscribe to it. That will required\r\n       *   initialisation options for sorting, which is why it is not already baked in\r\n       */\r\n      function _fnInvalidateRow (settings, rowIdx, src, column) {\r\n        var row = settings.aoData[rowIdx]\r\n        var i, ien\r\n\r\n        // Are we reading last data from DOM or the data object?\r\n        if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {\r\n          // Read the data from the DOM\r\n          row._aData = _fnGetRowElements(settings, row).data\r\n        } else {\r\n          // Reading from data object, update the DOM\r\n          var cells = row.anCells\r\n          var cell\r\n\r\n          if (cells) {\r\n            for (i = 0, ien = cells.length; i < ien; i++) {\r\n              cell = cells[i]\r\n\r\n              // This is very frustrating, but in IE if you just write directly\r\n              // to innerHTML, and elements that are overwritten are GC'ed,\r\n              // even if there is a reference to them elsewhere\r\n              while (cell.childNodes.length) {\r\n                cell.removeChild(cell.firstChild)\r\n              }\r\n\r\n              cells[i].innerHTML = _fnGetCellData(settings, rowIdx, i, 'display')\r\n            }\r\n          }\r\n        }\r\n\r\n        row._aSortData = null\r\n        row._aFilterData = null\r\n\r\n        // Invalidate the type for a specific column (if given) or all columns since\r\n        // the data might have changed\r\n        var cols = settings.aoColumns\r\n        if (column !== undefined) {\r\n          cols[column].sType = null\r\n        } else {\r\n          for (i = 0, ien = cols.length; i < ien; i++) {\r\n            cols[i].sType = null\r\n          }\r\n        }\r\n\r\n        // Update DataTables special `DT_*` attributes for the row\r\n        _fnRowAttributes(row)\r\n      }\r\n\r\n      /**\r\n       * Build a data source object from an HTML row, reading the contents of the\r\n       * cells that are in the row.\r\n       *\r\n       * @param {object} settings DataTables settings object\r\n       * @param {node|object} TR element from which to read data or existing row\r\n       *   object from which to re-read the data from the cells\r\n       * @returns {object} Object with two parameters: `data` the data read, in\r\n       *   document order, and `cells` and array of nodes (they can be useful to the\r\n       *   caller, so rather than needing a second traversal to get them, just return\r\n       *   them from here).\r\n       * @memberof DataTable#oApi\r\n       */\r\n      function _fnGetRowElements (settings, row) {\r\n        var d = [],\r\n          tds = [],\r\n          td = row.firstChild,\r\n          name,\r\n          col,\r\n          o,\r\n          i = 0,\r\n          contents,\r\n          columns = settings.aoColumns\r\n\r\n        var attr = function (str, data, td) {\r\n          if (typeof str === 'string') {\r\n            var idx = str.indexOf('@')\r\n\r\n            if (idx !== -1) {\r\n              var src = str.substring(idx + 1)\r\n              o['@' + src] = td.getAttribute(src)\r\n            }\r\n          }\r\n        }\r\n\r\n        var cellProcess = function (cell) {\r\n          col = columns[i]\r\n          contents = $.trim(cell.innerHTML)\r\n\r\n          if (col && col._bAttrSrc) {\r\n            o = {\r\n              display: contents\r\n            }\r\n\r\n            attr(col.mData.sort, o, cell)\r\n            attr(col.mData.type, o, cell)\r\n            attr(col.mData.filter, o, cell)\r\n\r\n            d.push(o)\r\n          } else {\r\n            d.push(contents)\r\n          }\r\n\r\n          i++\r\n        }\r\n\r\n        if (td) {\r\n          // `tr` element passed in\r\n          while (td) {\r\n            name = td.nodeName.toUpperCase()\r\n\r\n            if (name == 'TD' || name == 'TH') {\r\n              cellProcess(td)\r\n              tds.push(td)\r\n            }\r\n\r\n            td = td.nextSibling\r\n          }\r\n        } else {\r\n          // Existing row object passed in\r\n          tds = row.anCells\r\n\r\n          for (var j = 0, jen = tds.length; j < jen; j++) {\r\n            cellProcess(tds[j])\r\n          }\r\n        }\r\n\r\n        return {\r\n          data: d,\r\n          cells: tds\r\n        }\r\n      }\r\n      /**\r\n       * Create a new TR element (and it's TD children) for a row\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iRow Row to consider\r\n       *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\r\n       *    DataTables will create a row automatically\r\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\r\n       *    if nTr is.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCreateTr (oSettings, iRow, nTrIn, anTds) {\r\n        var row = oSettings.aoData[iRow],\r\n          rowData = row._aData,\r\n          cells = [],\r\n          nTr,\r\n          nTd,\r\n          oCol,\r\n          i,\r\n          iLen\r\n\r\n        if (row.nTr === null) {\r\n          nTr = nTrIn || document.createElement('tr')\r\n\r\n          row.nTr = nTr\r\n          row.anCells = cells\r\n\r\n          /* Use a private property on the node to allow reserve mapping from the node\r\n           * to the aoData array for fast look up\r\n           */\r\n          nTr._DT_RowIndex = iRow\r\n\r\n          /* Special parameters can be given by the data source to be used on the row */\r\n          _fnRowAttributes(row)\r\n\r\n          /* Process each column */\r\n          for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {\r\n            oCol = oSettings.aoColumns[i]\r\n\r\n            nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType)\r\n            cells.push(nTd)\r\n\r\n            // Need to create the HTML if new, or if a rendering function is defined\r\n            if (!nTrIn || oCol.mRender || oCol.mData !== i) {\r\n              nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display')\r\n            }\r\n\r\n            /* Add user defined class */\r\n            if (oCol.sClass) {\r\n              nTd.className += ' ' + oCol.sClass\r\n            }\r\n\r\n            // Visibility - add or remove as required\r\n            if (oCol.bVisible && !nTrIn) {\r\n              nTr.appendChild(nTd)\r\n            } else if (!oCol.bVisible && nTrIn) {\r\n              nTd.parentNode.removeChild(nTd)\r\n            }\r\n\r\n            if (oCol.fnCreatedCell) {\r\n              oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i)\r\n            }\r\n          }\r\n\r\n          _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow])\r\n        }\r\n\r\n        // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved\r\n        // and deployed\r\n        row.nTr.setAttribute('role', 'row')\r\n      }\r\n\r\n      /**\r\n       * Add attributes to a row based on the special `DT_*` parameters in a data\r\n       * source object.\r\n       *  @param {object} DataTables row object for the row to be modified\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnRowAttributes (row) {\r\n        var tr = row.nTr\r\n        var data = row._aData\r\n\r\n        if (tr) {\r\n          if (data.DT_RowId) {\r\n            tr.id = data.DT_RowId\r\n          }\r\n\r\n          if (data.DT_RowClass) {\r\n            // Remove any classes added by DT_RowClass before\r\n            var a = data.DT_RowClass.split(' ')\r\n            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a\r\n\r\n            $(tr)\r\n              .removeClass(row.__rowc.join(' '))\r\n              .addClass(data.DT_RowClass)\r\n          }\r\n\r\n          if (data.DT_RowData) {\r\n            $(tr).data(data.DT_RowData)\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Create the HTML header for the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnBuildHead (oSettings) {\r\n        var i, ien, cell, row, column\r\n        var thead = oSettings.nTHead\r\n        var tfoot = oSettings.nTFoot\r\n        var createHeader = $('th, td', thead).length === 0\r\n        var classes = oSettings.oClasses\r\n        var columns = oSettings.aoColumns\r\n\r\n        if (createHeader) {\r\n          row = $('<tr/>').appendTo(thead)\r\n        }\r\n\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          column = columns[i]\r\n          cell = $(column.nTh).addClass(column.sClass)\r\n\r\n          if (createHeader) {\r\n            cell.appendTo(row)\r\n          }\r\n\r\n          // 1.11 move into sorting\r\n          if (oSettings.oFeatures.bSort) {\r\n            cell.addClass(column.sSortingClass)\r\n\r\n            if (column.bSortable !== false) {\r\n              cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId)\r\n\r\n              _fnSortAttachListener(oSettings, column.nTh, i)\r\n            }\r\n          }\r\n\r\n          if (column.sTitle != cell.html()) {\r\n            cell.html(column.sTitle)\r\n          }\r\n\r\n          _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes)\r\n        }\r\n\r\n        if (createHeader) {\r\n          _fnDetectHeader(oSettings.aoHeader, thead)\r\n        }\r\n\r\n        /* ARIA role for the rows */\r\n        $(thead)\r\n          .find('>tr')\r\n          .attr('role', 'row')\r\n\r\n        /* Deal with the footer - add classes if required */\r\n        $(thead)\r\n          .find('>tr>th, >tr>td')\r\n          .addClass(classes.sHeaderTH)\r\n        $(tfoot)\r\n          .find('>tr>th, >tr>td')\r\n          .addClass(classes.sFooterTH)\r\n\r\n        // Cache the footer cells. Note that we only take the cells from the first\r\n        // row in the footer. If there is more than one row the user wants to\r\n        // interact with, they need to use the table().foot() method. Note also this\r\n        // allows cells to be used for multiple columns using colspan\r\n        if (tfoot !== null) {\r\n          var cells = oSettings.aoFooter[0]\r\n\r\n          for (i = 0, ien = cells.length; i < ien; i++) {\r\n            column = columns[i]\r\n            column.nTf = cells[i].cell\r\n\r\n            if (column.sClass) {\r\n              $(column.nTf).addClass(column.sClass)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Draw the header (or footer) element based on the column visibility states. The\r\n       * methodology here is to use the layout array from _fnDetectHeader, modified for\r\n       * the instantaneous column visibility, to construct the new layout. The grid is\r\n       * traversed over cell at a time in a rows x columns grid fashion, although each\r\n       * cell insert can cover multiple elements in the grid - which is tracks using the\r\n       * aApplied array. Cell inserts in the grid will only occur where there isn't\r\n       * already a cell in that position.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param array {objects} aoSource Layout array from _fnDetectHeader\r\n       *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDrawHead (oSettings, aoSource, bIncludeHidden) {\r\n        var i, iLen, j, jLen, k, kLen, n, nLocalTr\r\n        var aoLocal = []\r\n        var aApplied = []\r\n        var iColumns = oSettings.aoColumns.length\r\n        var iRowspan, iColspan\r\n\r\n        if (!aoSource) {\r\n          return\r\n        }\r\n\r\n        if (bIncludeHidden === undefined) {\r\n          bIncludeHidden = false\r\n        }\r\n\r\n        /* Make a copy of the master layout array, but without the visible columns in it */\r\n        for (i = 0, iLen = aoSource.length; i < iLen; i++) {\r\n          aoLocal[i] = aoSource[i].slice()\r\n          aoLocal[i].nTr = aoSource[i].nTr\r\n\r\n          /* Remove any columns which are currently hidden */\r\n          for (j = iColumns - 1; j >= 0; j--) {\r\n            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {\r\n              aoLocal[i].splice(j, 1)\r\n            }\r\n          }\r\n\r\n          /* Prep the applied array - it needs an element for each row */\r\n          aApplied.push([])\r\n        }\r\n\r\n        for (i = 0, iLen = aoLocal.length; i < iLen; i++) {\r\n          nLocalTr = aoLocal[i].nTr\r\n\r\n          /* All cells are going to be replaced, so empty out the row */\r\n          if (nLocalTr) {\r\n            while ((n = nLocalTr.firstChild)) {\r\n              nLocalTr.removeChild(n)\r\n            }\r\n          }\r\n\r\n          for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {\r\n            iRowspan = 1\r\n            iColspan = 1\r\n\r\n            /* Check to see if there is already a cell (row/colspan) covering our target\r\n             * insert point. If there is, then there is nothing to do.\r\n             */\r\n            if (aApplied[i][j] === undefined) {\r\n              nLocalTr.appendChild(aoLocal[i][j].cell)\r\n              aApplied[i][j] = 1\r\n\r\n              /* Expand the cell to cover as many rows as needed */\r\n              while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {\r\n                aApplied[i + iRowspan][j] = 1\r\n                iRowspan++\r\n              }\r\n\r\n              /* Expand the cell to cover as many columns as needed */\r\n              while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {\r\n                /* Must update the applied array over the rows for the columns */\r\n                for (k = 0; k < iRowspan; k++) {\r\n                  aApplied[i + k][j + iColspan] = 1\r\n                }\r\n                iColspan++\r\n              }\r\n\r\n              /* Do the actual expansion in the DOM */\r\n              $(aoLocal[i][j].cell)\r\n                .attr('rowspan', iRowspan)\r\n                .attr('colspan', iColspan)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Insert the required TR nodes into the table for display\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDraw (oSettings) {\r\n        /* Provide a pre-callback function which can be used to cancel the draw is false is returned */\r\n        var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings])\r\n        if ($.inArray(false, aPreDraw) !== -1) {\r\n          _fnProcessingDisplay(oSettings, false)\r\n          return\r\n        }\r\n\r\n        var i, iLen, n\r\n        var anRows = []\r\n        var iRowCount = 0\r\n        var asStripeClasses = oSettings.asStripeClasses\r\n        var iStripes = asStripeClasses.length\r\n        var iOpenRows = oSettings.aoOpenRows.length\r\n        var oLang = oSettings.oLanguage\r\n        var iInitDisplayStart = oSettings.iInitDisplayStart\r\n        var bServerSide = _fnDataSource(oSettings) == 'ssp'\r\n        var aiDisplay = oSettings.aiDisplay\r\n\r\n        oSettings.bDrawing = true\r\n\r\n        /* Check and see if we have an initial draw position from state saving */\r\n        if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {\r\n          oSettings._iDisplayStart = bServerSide\r\n            ? iInitDisplayStart\r\n            : iInitDisplayStart >= oSettings.fnRecordsDisplay()\r\n            ? 0\r\n            : iInitDisplayStart\r\n\r\n          oSettings.iInitDisplayStart = -1\r\n        }\r\n\r\n        var iDisplayStart = oSettings._iDisplayStart\r\n        var iDisplayEnd = oSettings.fnDisplayEnd()\r\n\r\n        /* Server-side processing draw intercept */\r\n        if (oSettings.bDeferLoading) {\r\n          oSettings.bDeferLoading = false\r\n          oSettings.iDraw++\r\n          _fnProcessingDisplay(oSettings, false)\r\n        } else if (!bServerSide) {\r\n          oSettings.iDraw++\r\n        } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {\r\n          return\r\n        }\r\n\r\n        if (aiDisplay.length !== 0) {\r\n          var iStart = bServerSide ? 0 : iDisplayStart\r\n          var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd\r\n\r\n          for (var j = iStart; j < iEnd; j++) {\r\n            var iDataIndex = aiDisplay[j]\r\n            var aoData = oSettings.aoData[iDataIndex]\r\n            if (aoData.nTr === null) {\r\n              _fnCreateTr(oSettings, iDataIndex)\r\n            }\r\n\r\n            var nRow = aoData.nTr\r\n\r\n            /* Remove the old striping classes and then add the new one */\r\n            if (iStripes !== 0) {\r\n              var sStripe = asStripeClasses[iRowCount % iStripes]\r\n              if (aoData._sRowStripe != sStripe) {\r\n                $(nRow)\r\n                  .removeClass(aoData._sRowStripe)\r\n                  .addClass(sStripe)\r\n                aoData._sRowStripe = sStripe\r\n              }\r\n            }\r\n\r\n            /* Row callback functions - might want to manipulate the row */\r\n            _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j])\r\n\r\n            anRows.push(nRow)\r\n            iRowCount++\r\n          }\r\n        } else {\r\n          /* Table is empty - create a row with an empty message in it */\r\n          var sZero = oLang.sZeroRecords\r\n          if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {\r\n            sZero = oLang.sLoadingRecords\r\n          } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {\r\n            sZero = oLang.sEmptyTable\r\n          }\r\n\r\n          anRows[0] = $('<tr/>', { class: iStripes ? asStripeClasses[0] : '' }).append(\r\n            $('<td />', {\r\n              valign: 'top',\r\n              colSpan: _fnVisbleColumns(oSettings),\r\n              class: oSettings.oClasses.sRowEmpty\r\n            }).html(sZero)\r\n          )[0]\r\n        }\r\n\r\n        /* Header and footer callbacks */\r\n        _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [\r\n          $(oSettings.nTHead).children('tr')[0],\r\n          _fnGetDataMaster(oSettings),\r\n          iDisplayStart,\r\n          iDisplayEnd,\r\n          aiDisplay\r\n        ])\r\n\r\n        _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [\r\n          $(oSettings.nTFoot).children('tr')[0],\r\n          _fnGetDataMaster(oSettings),\r\n          iDisplayStart,\r\n          iDisplayEnd,\r\n          aiDisplay\r\n        ])\r\n\r\n        var body = $(oSettings.nTBody)\r\n\r\n        body.children().detach()\r\n        body.append($(anRows))\r\n\r\n        /* Call all required callback functions for the end of a draw */\r\n        _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings])\r\n\r\n        /* Draw is complete, sorting and filtering must be as well */\r\n        oSettings.bSorted = false\r\n        oSettings.bFiltered = false\r\n        oSettings.bDrawing = false\r\n      }\r\n\r\n      /**\r\n       * Redraw the table - taking account of the various features which are enabled\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {boolean} [holdPosition] Keep the current paging position. By default\r\n       *    the paging is reset to the first page\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnReDraw (settings, holdPosition) {\r\n        var features = settings.oFeatures,\r\n          sort = features.bSort,\r\n          filter = features.bFilter\r\n\r\n        if (sort) {\r\n          _fnSort(settings)\r\n        }\r\n\r\n        if (filter) {\r\n          _fnFilterComplete(settings, settings.oPreviousSearch)\r\n        } else {\r\n          // No filtering, so we want to just use the display master\r\n          settings.aiDisplay = settings.aiDisplayMaster.slice()\r\n        }\r\n\r\n        if (holdPosition !== true) {\r\n          settings._iDisplayStart = 0\r\n        }\r\n\r\n        // Let any modules know about the draw hold position state (used by\r\n        // scrolling internally)\r\n        settings._drawHold = holdPosition\r\n\r\n        _fnDraw(settings)\r\n\r\n        settings._drawHold = false\r\n      }\r\n\r\n      /**\r\n       * Add the options to the page HTML for the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddOptionsHtml (oSettings) {\r\n        var classes = oSettings.oClasses\r\n        var table = $(oSettings.nTable)\r\n        var holding = $('<div/>').insertBefore(table) // Holding element for speed\r\n        var features = oSettings.oFeatures\r\n\r\n        // All DataTables are wrapped in a div\r\n        var insert = $('<div/>', {\r\n          id: oSettings.sTableId + '_wrapper',\r\n          class: classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)\r\n        })\r\n\r\n        oSettings.nHolding = holding[0]\r\n        oSettings.nTableWrapper = insert[0]\r\n        oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling\r\n\r\n        /* Loop over the user set positioning and place the elements as needed */\r\n        var aDom = oSettings.sDom.split('')\r\n        var featureNode, cOption, nNewNode, cNext, sAttr, j\r\n        for (var i = 0; i < aDom.length; i++) {\r\n          featureNode = null\r\n          cOption = aDom[i]\r\n\r\n          if (cOption == '<') {\r\n            /* New container div */\r\n            nNewNode = $('<div/>')[0]\r\n\r\n            /* Check to see if we should append an id and/or a class name to the container */\r\n            cNext = aDom[i + 1]\r\n            if (cNext == \"'\" || cNext == '\"') {\r\n              sAttr = ''\r\n              j = 2\r\n              while (aDom[i + j] != cNext) {\r\n                sAttr += aDom[i + j]\r\n                j++\r\n              }\r\n\r\n              /* Replace jQuery UI constants @todo depreciated */\r\n              if (sAttr == 'H') {\r\n                sAttr = classes.sJUIHeader\r\n              } else if (sAttr == 'F') {\r\n                sAttr = classes.sJUIFooter\r\n              }\r\n\r\n              /* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\r\n               * breaks the string into parts and applies them as needed\r\n               */\r\n              if (sAttr.indexOf('.') != -1) {\r\n                var aSplit = sAttr.split('.')\r\n                nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1)\r\n                nNewNode.className = aSplit[1]\r\n              } else if (sAttr.charAt(0) == '#') {\r\n                nNewNode.id = sAttr.substr(1, sAttr.length - 1)\r\n              } else {\r\n                nNewNode.className = sAttr\r\n              }\r\n\r\n              i += j /* Move along the position array */\r\n            }\r\n\r\n            insert.append(nNewNode)\r\n            insert = $(nNewNode)\r\n          } else if (cOption == '>') {\r\n            /* End container div */\r\n            insert = insert.parent()\r\n          }\r\n          // @todo Move options into their own plugins?\r\n          else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {\r\n            /* Length */\r\n            featureNode = _fnFeatureHtmlLength(oSettings)\r\n          } else if (cOption == 'f' && features.bFilter) {\r\n            /* Filter */\r\n            featureNode = _fnFeatureHtmlFilter(oSettings)\r\n          } else if (cOption == 'r' && features.bProcessing) {\r\n            /* pRocessing */\r\n            featureNode = _fnFeatureHtmlProcessing(oSettings)\r\n          } else if (cOption == 't') {\r\n            /* Table */\r\n            featureNode = _fnFeatureHtmlTable(oSettings)\r\n          } else if (cOption == 'i' && features.bInfo) {\r\n            /* Info */\r\n            featureNode = _fnFeatureHtmlInfo(oSettings)\r\n          } else if (cOption == 'p' && features.bPaginate) {\r\n            /* Pagination */\r\n            featureNode = _fnFeatureHtmlPaginate(oSettings)\r\n          } else if (DataTable.ext.feature.length !== 0) {\r\n            /* Plug-in features */\r\n            var aoFeatures = DataTable.ext.feature\r\n            for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {\r\n              if (cOption == aoFeatures[k].cFeature) {\r\n                featureNode = aoFeatures[k].fnInit(oSettings)\r\n                break\r\n              }\r\n            }\r\n          }\r\n\r\n          /* Add to the 2D features array */\r\n          if (featureNode) {\r\n            var aanFeatures = oSettings.aanFeatures\r\n\r\n            if (!aanFeatures[cOption]) {\r\n              aanFeatures[cOption] = []\r\n            }\r\n\r\n            aanFeatures[cOption].push(featureNode)\r\n            insert.append(featureNode)\r\n          }\r\n        }\r\n\r\n        /* Built our DOM structure - replace the holding div with what we want */\r\n        holding.replaceWith(insert)\r\n      }\r\n\r\n      /**\r\n       * Use the DOM source to create up an array of header cells. The idea here is to\r\n       * create a layout grid (array) of rows x columns, which contains a reference\r\n       * to the cell that that point in the grid (regardless of col/rowspan), such that\r\n       * any column / row could be removed and the new grid constructed\r\n       *  @param array {object} aLayout Array to store the calculated layout in\r\n       *  @param {node} nThead The header/footer element for the table\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDetectHeader (aLayout, nThead) {\r\n        var nTrs = $(nThead).children('tr')\r\n        var nTr, nCell\r\n        var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan\r\n        var bUnique\r\n        var fnShiftCol = function (a, i, j) {\r\n          var k = a[i]\r\n          while (k[j]) {\r\n            j++\r\n          }\r\n          return j\r\n        }\r\n\r\n        aLayout.splice(0, aLayout.length)\r\n\r\n        /* We know how many rows there are in the layout - so prep it */\r\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\r\n          aLayout.push([])\r\n        }\r\n\r\n        /* Calculate a layout array */\r\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\r\n          nTr = nTrs[i]\r\n          iColumn = 0\r\n\r\n          /* For every cell in the row... */\r\n          nCell = nTr.firstChild\r\n          while (nCell) {\r\n            if (nCell.nodeName.toUpperCase() == 'TD' || nCell.nodeName.toUpperCase() == 'TH') {\r\n              /* Get the col and rowspan attributes from the DOM and sanitise them */\r\n              iColspan = nCell.getAttribute('colspan') * 1\r\n              iRowspan = nCell.getAttribute('rowspan') * 1\r\n              iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan\r\n              iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan\r\n\r\n              /* There might be colspan cells already in this row, so shift our target\r\n               * accordingly\r\n               */\r\n              iColShifted = fnShiftCol(aLayout, i, iColumn)\r\n\r\n              /* Cache calculation for unique columns */\r\n              bUnique = iColspan === 1 ? true : false\r\n\r\n              /* If there is col / rowspan, copy the information into the layout grid */\r\n              for (l = 0; l < iColspan; l++) {\r\n                for (k = 0; k < iRowspan; k++) {\r\n                  aLayout[i + k][iColShifted + l] = {\r\n                    cell: nCell,\r\n                    unique: bUnique\r\n                  }\r\n                  aLayout[i + k].nTr = nTr\r\n                }\r\n              }\r\n            }\r\n            nCell = nCell.nextSibling\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get an array of unique th elements, one for each column\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} nHeader automatically detect the layout from this node - optional\r\n       *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\r\n       *  @returns array {node} aReturn list of unique th's\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetUniqueThs (oSettings, nHeader, aLayout) {\r\n        var aReturn = []\r\n        if (!aLayout) {\r\n          aLayout = oSettings.aoHeader\r\n          if (nHeader) {\r\n            aLayout = []\r\n            _fnDetectHeader(aLayout, nHeader)\r\n          }\r\n        }\r\n\r\n        for (var i = 0, iLen = aLayout.length; i < iLen; i++) {\r\n          for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {\r\n            if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {\r\n              aReturn[j] = aLayout[i][j].cell\r\n            }\r\n          }\r\n        }\r\n\r\n        return aReturn\r\n      }\r\n\r\n      /**\r\n       * Create an Ajax call based on the table's settings, taking into account that\r\n       * parameters can have multiple forms, and backwards compatibility.\r\n       *\r\n       * @param {object} oSettings dataTables settings object\r\n       * @param {array} data Data to send to the server, required by\r\n       *     DataTables - may be augmented by developer callbacks\r\n       * @param {function} fn Callback function to run when data is obtained\r\n       */\r\n      function _fnBuildAjax (oSettings, data, fn) {\r\n        // Compatibility with 1.9-, allow fnServerData and event to manipulate\r\n        _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data])\r\n\r\n        // Convert to object based for 1.10+ if using the old array scheme which can\r\n        // come from server-side processing or serverParams\r\n        if (data && $.isArray(data)) {\r\n          var tmp = {}\r\n          var rbracket = /(.*?)\\[\\]$/\r\n\r\n          $.each(data, function (key, val) {\r\n            var match = val.name.match(rbracket)\r\n\r\n            if (match) {\r\n              // Support for arrays\r\n              var name = match[0]\r\n\r\n              if (!tmp[name]) {\r\n                tmp[name] = []\r\n              }\r\n              tmp[name].push(val.value)\r\n            } else {\r\n              tmp[val.name] = val.value\r\n            }\r\n          })\r\n          data = tmp\r\n        }\r\n\r\n        var ajaxData\r\n        var ajax = oSettings.ajax\r\n        var instance = oSettings.oInstance\r\n\r\n        if ($.isPlainObject(ajax) && ajax.data) {\r\n          ajaxData = ajax.data\r\n\r\n          var newData = $.isFunction(ajaxData)\r\n            ? ajaxData(data) // fn can manipulate data or return an object\r\n            : ajaxData // object or array to merge\r\n\r\n          // If the function returned an object, use that alone\r\n          data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData)\r\n\r\n          // Remove the data property as we've resolved it already and don't want\r\n          // jQuery to do it again (it is restored at the end of the function)\r\n          delete ajax.data\r\n        }\r\n\r\n        var baseAjax = {\r\n          data: data,\r\n          success: function (json) {\r\n            var error = json.error || json.sError\r\n            if (error) {\r\n              oSettings.oApi._fnLog(oSettings, 0, error)\r\n            }\r\n\r\n            oSettings.json = json\r\n            _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json])\r\n            fn(json)\r\n          },\r\n          dataType: 'json',\r\n          cache: false,\r\n          type: oSettings.sServerMethod,\r\n          error: function (xhr, error, thrown) {\r\n            var log = oSettings.oApi._fnLog\r\n\r\n            if (error == 'parsererror') {\r\n              log(oSettings, 0, 'Invalid JSON response', 1)\r\n            } else if (xhr.readyState === 4) {\r\n              log(oSettings, 0, 'Ajax error', 7)\r\n            }\r\n\r\n            _fnProcessingDisplay(oSettings, false)\r\n          }\r\n        }\r\n\r\n        // Store the data submitted for the API\r\n        oSettings.oAjaxData = data\r\n\r\n        // Allow plug-ins and external processes to modify the data\r\n        _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data])\r\n\r\n        if (oSettings.fnServerData) {\r\n          // DataTables 1.9- compatibility\r\n          oSettings.fnServerData.call(\r\n            instance,\r\n            oSettings.sAjaxSource,\r\n            $.map(data, function (val, key) {\r\n              // Need to convert back to 1.9 trad format\r\n              return { name: key, value: val }\r\n            }),\r\n            fn,\r\n            oSettings\r\n          )\r\n        } else if (oSettings.sAjaxSource || typeof ajax === 'string') {\r\n          // DataTables 1.9- compatibility\r\n          oSettings.jqXHR = $.ajax(\r\n            $.extend(baseAjax, {\r\n              url: ajax || oSettings.sAjaxSource\r\n            })\r\n          )\r\n        } else if ($.isFunction(ajax)) {\r\n          // Is a function - let the caller define what needs to be done\r\n          oSettings.jqXHR = ajax.call(instance, data, fn, oSettings)\r\n        } else {\r\n          // Object to extend the base settings\r\n          oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax))\r\n\r\n          // Restore for next time around\r\n          ajax.data = ajaxData\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Update the table using an Ajax call\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {boolean} Block the table drawing or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAjaxUpdate (settings) {\r\n        if (settings.bAjaxDataGet) {\r\n          settings.iDraw++\r\n          _fnProcessingDisplay(settings, true)\r\n\r\n          _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {\r\n            _fnAjaxUpdateDraw(settings, json)\r\n          })\r\n\r\n          return false\r\n        }\r\n        return true\r\n      }\r\n\r\n      /**\r\n       * Build up the parameters in an object needed for a server-side processing\r\n       * request. Note that this is basically done twice, is different ways - a modern\r\n       * method which is used by default in DataTables 1.10 which uses objects and\r\n       * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\r\n       * the sAjaxSource option is used in the initialisation, or the legacyAjax\r\n       * option is set.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {bool} block the table drawing or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAjaxParameters (settings) {\r\n        var columns = settings.aoColumns,\r\n          columnCount = columns.length,\r\n          features = settings.oFeatures,\r\n          preSearch = settings.oPreviousSearch,\r\n          preColSearch = settings.aoPreSearchCols,\r\n          i,\r\n          data = [],\r\n          dataProp,\r\n          column,\r\n          columnSearch,\r\n          sort = _fnSortFlatten(settings),\r\n          displayStart = settings._iDisplayStart,\r\n          displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1\r\n\r\n        var param = function (name, value) {\r\n          data.push({ name: name, value: value })\r\n        }\r\n\r\n        // DataTables 1.9- compatible method\r\n        param('sEcho', settings.iDraw)\r\n        param('iColumns', columnCount)\r\n        param('sColumns', _pluck(columns, 'sName').join(','))\r\n        param('iDisplayStart', displayStart)\r\n        param('iDisplayLength', displayLength)\r\n\r\n        // DataTables 1.10+ method\r\n        var d = {\r\n          draw: settings.iDraw,\r\n          columns: [],\r\n          order: [],\r\n          start: displayStart,\r\n          length: displayLength,\r\n          search: {\r\n            value: preSearch.sSearch,\r\n            regex: preSearch.bRegex\r\n          }\r\n        }\r\n\r\n        for (i = 0; i < columnCount; i++) {\r\n          column = columns[i]\r\n          columnSearch = preColSearch[i]\r\n          dataProp = typeof column.mData == 'function' ? 'function' : column.mData\r\n\r\n          d.columns.push({\r\n            data: dataProp,\r\n            name: column.sName,\r\n            searchable: column.bSearchable,\r\n            orderable: column.bSortable,\r\n            search: {\r\n              value: columnSearch.sSearch,\r\n              regex: columnSearch.bRegex\r\n            }\r\n          })\r\n\r\n          param('mDataProp_' + i, dataProp)\r\n\r\n          if (features.bFilter) {\r\n            param('sSearch_' + i, columnSearch.sSearch)\r\n            param('bRegex_' + i, columnSearch.bRegex)\r\n            param('bSearchable_' + i, column.bSearchable)\r\n          }\r\n\r\n          if (features.bSort) {\r\n            param('bSortable_' + i, column.bSortable)\r\n          }\r\n        }\r\n\r\n        if (features.bFilter) {\r\n          param('sSearch', preSearch.sSearch)\r\n          param('bRegex', preSearch.bRegex)\r\n        }\r\n\r\n        if (features.bSort) {\r\n          $.each(sort, function (i, val) {\r\n            d.order.push({ column: val.col, dir: val.dir })\r\n\r\n            param('iSortCol_' + i, val.col)\r\n            param('sSortDir_' + i, val.dir)\r\n          })\r\n\r\n          param('iSortingCols', sort.length)\r\n        }\r\n\r\n        // If the legacy.ajax parameter is null, then we automatically decide which\r\n        // form to use, based on sAjaxSource\r\n        var legacy = DataTable.ext.legacy.ajax\r\n        if (legacy === null) {\r\n          return settings.sAjaxSource ? data : d\r\n        }\r\n\r\n        // Otherwise, if legacy has been specified then we use that to decide on the\r\n        // form\r\n        return legacy ? data : d\r\n      }\r\n\r\n      /**\r\n       * Data the data from the server (nuking the old) and redraw the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} json json data return from the server.\r\n       *  @param {string} json.sEcho Tracking flag for DataTables to match requests\r\n       *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\r\n       *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\r\n       *  @param {array} json.aaData The data to display on this page\r\n       *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAjaxUpdateDraw (settings, json) {\r\n        // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\r\n        // Support both\r\n        var compat = function (old, modern) {\r\n          return json[old] !== undefined ? json[old] : json[modern]\r\n        }\r\n\r\n        var draw = compat('sEcho', 'draw')\r\n        var recordsTotal = compat('iTotalRecords', 'recordsTotal')\r\n        var rocordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered')\r\n\r\n        if (draw) {\r\n          // Protect against out of sequence returns\r\n          if (draw * 1 < settings.iDraw) {\r\n            return\r\n          }\r\n          settings.iDraw = draw * 1\r\n        }\r\n\r\n        _fnClearTable(settings)\r\n        settings._iRecordsTotal = parseInt(recordsTotal, 10)\r\n        settings._iRecordsDisplay = parseInt(rocordsFiltered, 10)\r\n\r\n        var data = _fnAjaxDataSrc(settings, json)\r\n        for (var i = 0, ien = data.length; i < ien; i++) {\r\n          _fnAddData(settings, data[i])\r\n        }\r\n        settings.aiDisplay = settings.aiDisplayMaster.slice()\r\n\r\n        settings.bAjaxDataGet = false\r\n        _fnDraw(settings)\r\n\r\n        if (!settings._bInitComplete) {\r\n          _fnInitComplete(settings, json)\r\n        }\r\n\r\n        settings.bAjaxDataGet = true\r\n        _fnProcessingDisplay(settings, false)\r\n      }\r\n\r\n      /**\r\n       * Get the data from the JSON data source to use for drawing a table. Using\r\n       * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\r\n       * source object, or from a processing function.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param  {object} json Data source object / array from the server\r\n       *  @return {array} Array of data to use\r\n       */\r\n      function _fnAjaxDataSrc (oSettings, json) {\r\n        var dataSrc =\r\n          $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined\r\n            ? oSettings.ajax.dataSrc\r\n            : oSettings.sAjaxDataProp // Compatibility with 1.9-.\r\n\r\n        // Compatibility with 1.9-. In order to read from aaData, check if the\r\n        // default has been changed, if not, check for aaData\r\n        if (dataSrc === 'data') {\r\n          return json.aaData || json[dataSrc]\r\n        }\r\n\r\n        return dataSrc !== '' ? _fnGetObjectDataFn(dataSrc)(json) : json\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for filtering text\r\n       *  @returns {node} Filter control element\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlFilter (settings) {\r\n        var classes = settings.oClasses\r\n        var tableId = settings.sTableId\r\n        var language = settings.oLanguage\r\n        var previousSearch = settings.oPreviousSearch\r\n        var features = settings.aanFeatures\r\n        var input = '<input type=\"search\" class=\"' + classes.sFilterInput + '\"/>'\r\n\r\n        var str = language.sSearch\r\n        str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input\r\n\r\n        var filter = $('<div/>', {\r\n          id: !features.f ? tableId + '_filter' : null,\r\n          class: classes.sFilter\r\n        }).append($('<label/>').append(str))\r\n\r\n        var searchFn = function () {\r\n          /* Update all other filter input elements for the new display */\r\n          var n = features.f\r\n          var val = !this.value ? '' : this.value // mental IE8 fix :-(\r\n\r\n          /* Now do the filter */\r\n          if (val != previousSearch.sSearch) {\r\n            _fnFilterComplete(settings, {\r\n              sSearch: val,\r\n              bRegex: previousSearch.bRegex,\r\n              bSmart: previousSearch.bSmart,\r\n              bCaseInsensitive: previousSearch.bCaseInsensitive\r\n            })\r\n\r\n            // Need to redraw, without resorting\r\n            settings._iDisplayStart = 0\r\n            _fnDraw(settings)\r\n          }\r\n        }\r\n        var jqFilter = $('input', filter)\r\n          .val(previousSearch.sSearch)\r\n          .attr('placeholder', language.sSearchPlaceholder)\r\n          .bind(\r\n            'keyup.DT search.DT input.DT paste.DT cut.DT',\r\n            _fnDataSource(settings) === 'ssp' ? _fnThrottle(searchFn, 400) : searchFn\r\n          )\r\n          .bind('keypress.DT', function (e) {\r\n            /* Prevent form submission */\r\n            if (e.keyCode == 13) {\r\n              return false\r\n            }\r\n          })\r\n          .attr('aria-controls', tableId)\r\n\r\n        // Update the input elements whenever the table is filtered\r\n        $(settings.nTable).on('search.dt.DT', function (ev, s) {\r\n          if (settings === s) {\r\n            // IE9 throws an 'unknown error' if document.activeElement is used\r\n            // inside an iframe or frame...\r\n            try {\r\n              if (jqFilter[0] !== document.activeElement) {\r\n                jqFilter.val(previousSearch.sSearch)\r\n              }\r\n            } catch (e) {}\r\n          }\r\n        })\r\n\r\n        return filter[0]\r\n      }\r\n\r\n      /**\r\n       * Filter the table using both the global filter and column based filtering\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} oSearch search information\r\n       *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterComplete (oSettings, oInput, iForce) {\r\n        var oPrevSearch = oSettings.oPreviousSearch\r\n        var aoPrevSearch = oSettings.aoPreSearchCols\r\n        var fnSaveFilter = function (oFilter) {\r\n          /* Save the filtering values */\r\n          oPrevSearch.sSearch = oFilter.sSearch\r\n          oPrevSearch.bRegex = oFilter.bRegex\r\n          oPrevSearch.bSmart = oFilter.bSmart\r\n          oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive\r\n        }\r\n        var fnRegex = function (o) {\r\n          // Backwards compatibility with the bEscapeRegex option\r\n          return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex\r\n        }\r\n\r\n        // Resolve any column types that are unknown due to addition or invalidation\r\n        // @todo As per sort - can this be moved into an event handler?\r\n        _fnColumnTypes(oSettings)\r\n\r\n        /* In server-side processing all filtering is done by the server, so no point hanging around here */\r\n        if (_fnDataSource(oSettings) != 'ssp') {\r\n          /* Global filter */\r\n          _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive)\r\n          fnSaveFilter(oInput)\r\n\r\n          /* Now do the individual column filter */\r\n          for (var i = 0; i < aoPrevSearch.length; i++) {\r\n            _fnFilterColumn(\r\n              oSettings,\r\n              aoPrevSearch[i].sSearch,\r\n              i,\r\n              fnRegex(aoPrevSearch[i]),\r\n              aoPrevSearch[i].bSmart,\r\n              aoPrevSearch[i].bCaseInsensitive\r\n            )\r\n          }\r\n\r\n          /* Custom filtering */\r\n          _fnFilterCustom(oSettings)\r\n        } else {\r\n          fnSaveFilter(oInput)\r\n        }\r\n\r\n        /* Tell the draw function we have been filtering */\r\n        oSettings.bFiltered = true\r\n        _fnCallbackFire(oSettings, null, 'search', [oSettings])\r\n      }\r\n\r\n      /**\r\n       * Apply custom filtering functions\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterCustom (settings) {\r\n        var filters = DataTable.ext.search\r\n        var displayRows = settings.aiDisplay\r\n        var row, rowIdx\r\n\r\n        for (var i = 0, ien = filters.length; i < ien; i++) {\r\n          var rows = []\r\n\r\n          // Loop over each row and see if it should be included\r\n          for (var j = 0, jen = displayRows.length; j < jen; j++) {\r\n            rowIdx = displayRows[j]\r\n            row = settings.aoData[rowIdx]\r\n\r\n            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {\r\n              rows.push(rowIdx)\r\n            }\r\n          }\r\n\r\n          // So the array reference doesn't break set the results into the\r\n          // existing array\r\n          displayRows.length = 0\r\n          displayRows.push.apply(displayRows, rows)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Filter the table on a per-column basis\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {string} sInput string to filter on\r\n       *  @param {int} iColumn column to filter\r\n       *  @param {bool} bRegex treat search string as a regular expression or not\r\n       *  @param {bool} bSmart use smart filtering or not\r\n       *  @param {bool} bCaseInsensitive Do case insenstive matching or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterColumn (settings, searchStr, colIdx, regex, smart, caseInsensitive) {\r\n        if (searchStr === '') {\r\n          return\r\n        }\r\n\r\n        var data\r\n        var display = settings.aiDisplay\r\n        var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive)\r\n\r\n        for (var i = display.length - 1; i >= 0; i--) {\r\n          data = settings.aoData[display[i]]._aFilterData[colIdx]\r\n\r\n          if (!rpSearch.test(data)) {\r\n            display.splice(i, 1)\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Filter the data table based on user input and draw the table\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {string} input string to filter on\r\n       *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\r\n       *  @param {bool} regex treat as a regular expression or not\r\n       *  @param {bool} smart perform smart filtering or not\r\n       *  @param {bool} caseInsensitive Do case insenstive matching or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilter (settings, input, force, regex, smart, caseInsensitive) {\r\n        var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive)\r\n        var prevSearch = settings.oPreviousSearch.sSearch\r\n        var displayMaster = settings.aiDisplayMaster\r\n        var display, invalidated, i\r\n\r\n        // Need to take account of custom filtering functions - always filter\r\n        if (DataTable.ext.search.length !== 0) {\r\n          force = true\r\n        }\r\n\r\n        // Check if any of the rows were invalidated\r\n        invalidated = _fnFilterData(settings)\r\n\r\n        // If the input is blank - we just want the full data set\r\n        if (input.length <= 0) {\r\n          settings.aiDisplay = displayMaster.slice()\r\n        } else {\r\n          // New search - start from the master array\r\n          if (\r\n            invalidated ||\r\n            force ||\r\n            prevSearch.length > input.length ||\r\n            input.indexOf(prevSearch) !== 0 ||\r\n            settings.bSorted // On resort, the display master needs to be\r\n            // re-filtered since indexes will have changed\r\n          ) {\r\n            settings.aiDisplay = displayMaster.slice()\r\n          }\r\n\r\n          // Search the display array\r\n          display = settings.aiDisplay\r\n\r\n          for (i = display.length - 1; i >= 0; i--) {\r\n            if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {\r\n              display.splice(i, 1)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Build a regular expression object suitable for searching a table\r\n       *  @param {string} sSearch string to search for\r\n       *  @param {bool} bRegex treat as a regular expression or not\r\n       *  @param {bool} bSmart perform smart filtering or not\r\n       *  @param {bool} bCaseInsensitive Do case insensitive matching or not\r\n       *  @returns {RegExp} constructed object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterCreateSearch (search, regex, smart, caseInsensitive) {\r\n        search = regex ? search : _fnEscapeRegex(search)\r\n\r\n        if (smart) {\r\n          /* For smart filtering we want to allow the search to work regardless of\r\n           * word order. We also want double quoted text to be preserved, so word\r\n           * order is important - a la google. So this is what we want to\r\n           * generate:\r\n           *\r\n           * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\r\n           */\r\n          var a = $.map(search.match(/\"[^\"]+\"|[^ ]+/g) || '', function (word) {\r\n            return word.charAt(0) === '\"' ? word.match(/^\"(.*)\"$/)[1] : word\r\n          })\r\n\r\n          search = '^(?=.*?' + a.join(')(?=.*?') + ').*$'\r\n        }\r\n\r\n        return new RegExp(search, caseInsensitive ? 'i' : '')\r\n      }\r\n\r\n      /**\r\n       * scape a string such that it can be used in a regular expression\r\n       *  @param {string} sVal string to escape\r\n       *  @returns {string} escaped string\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnEscapeRegex (sVal) {\r\n        return sVal.replace(_re_escape_regex, '\\\\$1')\r\n      }\r\n\r\n      var __filter_div = $('<div>')[0]\r\n      var __filter_div_textContent = __filter_div.textContent !== undefined\r\n\r\n      // Update the filtering data for each row if needed (by invalidation or first run)\r\n      function _fnFilterData (settings) {\r\n        var columns = settings.aoColumns\r\n        var column\r\n        var i, j, ien, jen, filterData, cellData, row\r\n        var fomatters = DataTable.ext.type.search\r\n        var wasInvalidated = false\r\n\r\n        for (i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n          row = settings.aoData[i]\r\n\r\n          if (!row._aFilterData) {\r\n            filterData = []\r\n\r\n            for (j = 0, jen = columns.length; j < jen; j++) {\r\n              column = columns[j]\r\n\r\n              if (column.bSearchable) {\r\n                cellData = _fnGetCellData(settings, i, j, 'filter')\r\n\r\n                if (fomatters[column.sType]) {\r\n                  cellData = fomatters[column.sType](cellData)\r\n                }\r\n\r\n                // Search in DataTables 1.10 is string based. In 1.11 this\r\n                // should be altered to also allow strict type checking.\r\n                if (cellData === null) {\r\n                  cellData = ''\r\n                }\r\n\r\n                if (typeof cellData !== 'string' && cellData.toString) {\r\n                  cellData = cellData.toString()\r\n                }\r\n              } else {\r\n                cellData = ''\r\n              }\r\n\r\n              // If it looks like there is an HTML entity in the string,\r\n              // attempt to decode it so sorting works as expected. Note that\r\n              // we could use a single line of jQuery to do this, but the DOM\r\n              // method used here is much faster http://jsperf.com/html-decode\r\n              if (cellData.indexOf && cellData.indexOf('&') !== -1) {\r\n                __filter_div.innerHTML = cellData\r\n                cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText\r\n              }\r\n\r\n              if (cellData.replace) {\r\n                cellData = cellData.replace(/[\\r\\n]/g, '')\r\n              }\r\n\r\n              filterData.push(cellData)\r\n            }\r\n\r\n            row._aFilterData = filterData\r\n            row._sFilterRow = filterData.join('  ')\r\n            wasInvalidated = true\r\n          }\r\n        }\r\n\r\n        return wasInvalidated\r\n      }\r\n\r\n      /**\r\n       * Convert from the internal Hungarian notation to camelCase for external\r\n       * interaction\r\n       *  @param {object} obj Object to convert\r\n       *  @returns {object} Inverted object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSearchToCamel (obj) {\r\n        return {\r\n          search: obj.sSearch,\r\n          smart: obj.bSmart,\r\n          regex: obj.bRegex,\r\n          caseInsensitive: obj.bCaseInsensitive\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Convert from camelCase notation to the internal Hungarian. We could use the\r\n       * Hungarian convert function here, but this is cleaner\r\n       *  @param {object} obj Object to convert\r\n       *  @returns {object} Inverted object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSearchToHung (obj) {\r\n        return {\r\n          sSearch: obj.search,\r\n          bSmart: obj.smart,\r\n          bRegex: obj.regex,\r\n          bCaseInsensitive: obj.caseInsensitive\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for the info display\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {node} Information element\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlInfo (settings) {\r\n        var tid = settings.sTableId,\r\n          nodes = settings.aanFeatures.i,\r\n          n = $('<div/>', {\r\n            class: settings.oClasses.sInfo,\r\n            id: !nodes ? tid + '_info' : null\r\n          })\r\n\r\n        if (!nodes) {\r\n          // Update display on each draw\r\n          settings.aoDrawCallback.push({\r\n            fn: _fnUpdateInfo,\r\n            sName: 'information'\r\n          })\r\n\r\n          n.attr('role', 'status').attr('aria-live', 'polite')\r\n\r\n          // Table is described by our info div\r\n          $(settings.nTable).attr('aria-describedby', tid + '_info')\r\n        }\r\n\r\n        return n[0]\r\n      }\r\n\r\n      /**\r\n       * Update the information elements in the display\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnUpdateInfo (settings) {\r\n        /* Show information about the table */\r\n        var nodes = settings.aanFeatures.i\r\n        if (nodes.length === 0) {\r\n          return\r\n        }\r\n\r\n        var lang = settings.oLanguage,\r\n          start = settings._iDisplayStart + 1,\r\n          end = settings.fnDisplayEnd(),\r\n          max = settings.fnRecordsTotal(),\r\n          total = settings.fnRecordsDisplay(),\r\n          out = total ? lang.sInfo : lang.sInfoEmpty\r\n\r\n        if (total !== max) {\r\n          /* Record set after filtering */\r\n          out += ' ' + lang.sInfoFiltered\r\n        }\r\n\r\n        // Convert the macros\r\n        out += lang.sInfoPostFix\r\n        out = _fnInfoMacros(settings, out)\r\n\r\n        var callback = lang.fnInfoCallback\r\n        if (callback !== null) {\r\n          out = callback.call(settings.oInstance, settings, start, end, max, total, out)\r\n        }\r\n\r\n        $(nodes).html(out)\r\n      }\r\n\r\n      function _fnInfoMacros (settings, str) {\r\n        // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\r\n        // internally\r\n        var formatter = settings.fnFormatNumber,\r\n          start = settings._iDisplayStart + 1,\r\n          len = settings._iDisplayLength,\r\n          vis = settings.fnRecordsDisplay(),\r\n          all = len === -1\r\n\r\n        return str\r\n          .replace(/_START_/g, formatter.call(settings, start))\r\n          .replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd()))\r\n          .replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal()))\r\n          .replace(/_TOTAL_/g, formatter.call(settings, vis))\r\n          .replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len)))\r\n          .replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)))\r\n      }\r\n\r\n      /**\r\n       * Draw the table for the first time, adding all required features\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnInitialise (settings) {\r\n        var i,\r\n          iLen,\r\n          iAjaxStart = settings.iInitDisplayStart\r\n        var columns = settings.aoColumns,\r\n          column\r\n        var features = settings.oFeatures\r\n\r\n        /* Ensure that the table data is fully initialised */\r\n        if (!settings.bInitialised) {\r\n          setTimeout(function () {\r\n            _fnInitialise(settings)\r\n          }, 200)\r\n          return\r\n        }\r\n\r\n        /* Show the display HTML options */\r\n        _fnAddOptionsHtml(settings)\r\n\r\n        /* Build and draw the header / footer for the table */\r\n        _fnBuildHead(settings)\r\n        _fnDrawHead(settings, settings.aoHeader)\r\n        _fnDrawHead(settings, settings.aoFooter)\r\n\r\n        /* Okay to show that something is going on now */\r\n        _fnProcessingDisplay(settings, true)\r\n\r\n        /* Calculate sizes for columns */\r\n        if (features.bAutoWidth) {\r\n          _fnCalculateColumnWidths(settings)\r\n        }\r\n\r\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\r\n          column = columns[i]\r\n\r\n          if (column.sWidth) {\r\n            column.nTh.style.width = _fnStringToCss(column.sWidth)\r\n          }\r\n        }\r\n\r\n        // If there is default sorting required - let's do it. The sort function\r\n        // will do the drawing for us. Otherwise we draw the table regardless of the\r\n        // Ajax source - this allows the table to look initialised for Ajax sourcing\r\n        // data (show 'loading' message possibly)\r\n        _fnReDraw(settings)\r\n\r\n        // Server-side processing init complete is done by _fnAjaxUpdateDraw\r\n        var dataSrc = _fnDataSource(settings)\r\n        if (dataSrc != 'ssp') {\r\n          // if there is an ajax source load the data\r\n          if (dataSrc == 'ajax') {\r\n            _fnBuildAjax(\r\n              settings,\r\n              [],\r\n              function (json) {\r\n                var aData = _fnAjaxDataSrc(settings, json)\r\n\r\n                // Got the data - add it to the table\r\n                for (i = 0; i < aData.length; i++) {\r\n                  _fnAddData(settings, aData[i])\r\n                }\r\n\r\n                // Reset the init display for cookie saving. We've already done\r\n                // a filter, and therefore cleared it before. So we need to make\r\n                // it appear 'fresh'\r\n                settings.iInitDisplayStart = iAjaxStart\r\n\r\n                _fnReDraw(settings)\r\n\r\n                _fnProcessingDisplay(settings, false)\r\n                _fnInitComplete(settings, json)\r\n              },\r\n              settings\r\n            )\r\n          } else {\r\n            _fnProcessingDisplay(settings, false)\r\n            _fnInitComplete(settings)\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Draw the table for the first time, adding all required features\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\r\n       *    with client-side processing (optional)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnInitComplete (settings, json) {\r\n        settings._bInitComplete = true\r\n\r\n        // On an Ajax load we now have data and therefore want to apply the column\r\n        // sizing\r\n        if (json) {\r\n          _fnAdjustColumnSizing(settings)\r\n        }\r\n\r\n        _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json])\r\n      }\r\n\r\n      function _fnLengthChange (settings, val) {\r\n        var len = parseInt(val, 10)\r\n        settings._iDisplayLength = len\r\n\r\n        _fnLengthOverflow(settings)\r\n\r\n        // Fire length change event\r\n        _fnCallbackFire(settings, null, 'length', [settings, len])\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for user display length changing\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {node} Display length feature node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlLength (settings) {\r\n        var classes = settings.oClasses,\r\n          tableId = settings.sTableId,\r\n          menu = settings.aLengthMenu,\r\n          d2 = $.isArray(menu[0]),\r\n          lengths = d2 ? menu[0] : menu,\r\n          language = d2 ? menu[1] : menu\r\n\r\n        var select = $('<select/>', {\r\n          name: tableId + '_length',\r\n          'aria-controls': tableId,\r\n          class: classes.sLengthSelect\r\n        })\r\n\r\n        for (var i = 0, ien = lengths.length; i < ien; i++) {\r\n          select[0][i] = new Option(language[i], lengths[i])\r\n        }\r\n\r\n        var div = $('<div><label/></div>').addClass(classes.sLength)\r\n        if (!settings.aanFeatures.l) {\r\n          div[0].id = tableId + '_length'\r\n        }\r\n\r\n        div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML))\r\n\r\n        // Can't use `select` variable as user might provide their own and the\r\n        // reference is broken by the use of outerHTML\r\n        $('select', div)\r\n          .val(settings._iDisplayLength)\r\n          .bind('change.DT', function (e) {\r\n            _fnLengthChange(settings, $(this).val())\r\n            _fnDraw(settings)\r\n          })\r\n\r\n        // Update node value whenever anything changes the table's length\r\n        $(settings.nTable).bind('length.dt.DT', function (e, s, len) {\r\n          if (settings === s) {\r\n            $('select', div).val(len)\r\n          }\r\n        })\r\n\r\n        return div[0]\r\n      }\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Note that most of the paging logic is done in\r\n       * DataTable.ext.pager\r\n       */\r\n\r\n      /**\r\n       * Generate the node required for default pagination\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {node} Pagination feature node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlPaginate (settings) {\r\n        var type = settings.sPaginationType,\r\n          plugin = DataTable.ext.pager[type],\r\n          modern = typeof plugin === 'function',\r\n          redraw = function (settings) {\r\n            _fnDraw(settings)\r\n          },\r\n          node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],\r\n          features = settings.aanFeatures\r\n\r\n        if (!modern) {\r\n          plugin.fnInit(settings, node, redraw)\r\n        }\r\n\r\n        /* Add a draw callback for the pagination on first instance, to update the paging display */\r\n        if (!features.p) {\r\n          node.id = settings.sTableId + '_paginate'\r\n\r\n          settings.aoDrawCallback.push({\r\n            fn: function (settings) {\r\n              if (modern) {\r\n                var start = settings._iDisplayStart,\r\n                  len = settings._iDisplayLength,\r\n                  visRecords = settings.fnRecordsDisplay(),\r\n                  all = len === -1,\r\n                  page = all ? 0 : Math.ceil(start / len),\r\n                  pages = all ? 1 : Math.ceil(visRecords / len),\r\n                  buttons = plugin(page, pages),\r\n                  i,\r\n                  ien\r\n\r\n                for (i = 0, ien = features.p.length; i < ien; i++) {\r\n                  _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages)\r\n                }\r\n              } else {\r\n                plugin.fnUpdate(settings, redraw)\r\n              }\r\n            },\r\n            sName: 'pagination'\r\n          })\r\n        }\r\n\r\n        return node\r\n      }\r\n\r\n      /**\r\n       * Alter the display settings to change the page\r\n       *  @param {object} settings DataTables settings object\r\n       *  @param {string|int} action Paging action to take: \"first\", \"previous\",\r\n       *    \"next\" or \"last\" or page number to jump to (integer)\r\n       *  @param [bool] redraw Automatically draw the update or not\r\n       *  @returns {bool} true page has changed, false - no change\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnPageChange (settings, action, redraw) {\r\n        var start = settings._iDisplayStart,\r\n          len = settings._iDisplayLength,\r\n          records = settings.fnRecordsDisplay()\r\n\r\n        if (records === 0 || len === -1) {\r\n          start = 0\r\n        } else if (typeof action === 'number') {\r\n          start = action * len\r\n\r\n          if (start > records) {\r\n            start = 0\r\n          }\r\n        } else if (action == 'first') {\r\n          start = 0\r\n        } else if (action == 'previous') {\r\n          start = len >= 0 ? start - len : 0\r\n\r\n          if (start < 0) {\r\n            start = 0\r\n          }\r\n        } else if (action == 'next') {\r\n          if (start + len < records) {\r\n            start += len\r\n          }\r\n        } else if (action == 'last') {\r\n          start = Math.floor((records - 1) / len) * len\r\n        } else {\r\n          _fnLog(settings, 0, 'Unknown paging action: ' + action, 5)\r\n        }\r\n\r\n        var changed = settings._iDisplayStart !== start\r\n        settings._iDisplayStart = start\r\n\r\n        if (changed) {\r\n          _fnCallbackFire(settings, null, 'page', [settings])\r\n\r\n          if (redraw) {\r\n            _fnDraw(settings)\r\n          }\r\n        }\r\n\r\n        return changed\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for the processing node\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {node} Processing element\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlProcessing (settings) {\r\n        return $('<div/>', {\r\n          id: !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,\r\n          class: settings.oClasses.sProcessing\r\n        })\r\n          .html(settings.oLanguage.sProcessing)\r\n          .insertBefore(settings.nTable)[0]\r\n      }\r\n\r\n      /**\r\n       * Display or hide the processing indicator\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {bool} show Show the processing indicator (true) or not (false)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnProcessingDisplay (settings, show) {\r\n        if (settings.oFeatures.bProcessing) {\r\n          $(settings.aanFeatures.r).css('display', show ? 'block' : 'none')\r\n        }\r\n\r\n        _fnCallbackFire(settings, null, 'processing', [settings, show])\r\n      }\r\n\r\n      /**\r\n       * Add any control elements for the table - specifically scrolling\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {node} Node to add to the DOM\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlTable (settings) {\r\n        var table = $(settings.nTable)\r\n\r\n        // Add the ARIA grid role to the table\r\n        table.attr('role', 'grid')\r\n\r\n        // Scrolling from here on in\r\n        var scroll = settings.oScroll\r\n\r\n        if (scroll.sX === '' && scroll.sY === '') {\r\n          return settings.nTable\r\n        }\r\n\r\n        var scrollX = scroll.sX\r\n        var scrollY = scroll.sY\r\n        var classes = settings.oClasses\r\n        var caption = table.children('caption')\r\n        var captionSide = caption.length ? caption[0]._captionSide : null\r\n        var headerClone = $(table[0].cloneNode(false))\r\n        var footerClone = $(table[0].cloneNode(false))\r\n        var footer = table.children('tfoot')\r\n        var _div = '<div/>'\r\n        var size = function (s) {\r\n          return !s ? null : _fnStringToCss(s)\r\n        }\r\n\r\n        // This is fairly messy, but with x scrolling enabled, if the table has a\r\n        // width attribute, regardless of any width applied using the column width\r\n        // options, the browser will shrink or grow the table as needed to fit into\r\n        // that 100%. That would make the width options useless. So we remove it.\r\n        // This is okay, under the assumption that width:100% is applied to the\r\n        // table in CSS (it is in the default stylesheet) which will set the table\r\n        // width as appropriate (the attribute and css behave differently...)\r\n        if (scroll.sX && table.attr('width') === '100%') {\r\n          table.removeAttr('width')\r\n        }\r\n\r\n        if (!footer.length) {\r\n          footer = null\r\n        }\r\n\r\n        /*\r\n         * The HTML structure that we want to generate in this function is:\r\n         *  div - scroller\r\n         *    div - scroll head\r\n         *      div - scroll head inner\r\n         *        table - scroll head table\r\n         *          thead - thead\r\n         *    div - scroll body\r\n         *      table - table (master table)\r\n         *        thead - thead clone for sizing\r\n         *        tbody - tbody\r\n         *    div - scroll foot\r\n         *      div - scroll foot inner\r\n         *        table - scroll foot table\r\n         *          tfoot - tfoot\r\n         */\r\n        var scroller = $(_div, { class: classes.sScrollWrapper })\r\n          .append(\r\n            $(_div, { class: classes.sScrollHead })\r\n              .css({\r\n                overflow: 'hidden',\r\n                position: 'relative',\r\n                border: 0,\r\n                width: scrollX ? size(scrollX) : '100%'\r\n              })\r\n              .append(\r\n                $(_div, { class: classes.sScrollHeadInner })\r\n                  .css({\r\n                    'box-sizing': 'content-box',\r\n                    width: scroll.sXInner || '100%'\r\n                  })\r\n                  .append(\r\n                    headerClone\r\n                      .removeAttr('id')\r\n                      .css('margin-left', 0)\r\n                      .append(table.children('thead'))\r\n                  )\r\n              )\r\n              .append(captionSide === 'top' ? caption : null)\r\n          )\r\n          .append(\r\n            $(_div, { class: classes.sScrollBody })\r\n              .css({\r\n                overflow: 'auto',\r\n                height: size(scrollY),\r\n                width: size(scrollX)\r\n              })\r\n              .append(table)\r\n          )\r\n\r\n        if (footer) {\r\n          scroller.append(\r\n            $(_div, { class: classes.sScrollFoot })\r\n              .css({\r\n                overflow: 'hidden',\r\n                border: 0,\r\n                width: scrollX ? size(scrollX) : '100%'\r\n              })\r\n              .append(\r\n                $(_div, { class: classes.sScrollFootInner }).append(\r\n                  footerClone\r\n                    .removeAttr('id')\r\n                    .css('margin-left', 0)\r\n                    .append(table.children('tfoot'))\r\n                )\r\n              )\r\n              .append(captionSide === 'bottom' ? caption : null)\r\n          )\r\n        }\r\n\r\n        var children = scroller.children()\r\n        var scrollHead = children[0]\r\n        var scrollBody = children[1]\r\n        var scrollFoot = footer ? children[2] : null\r\n\r\n        // When the body is scrolled, then we also want to scroll the headers\r\n        if (scrollX) {\r\n          $(scrollBody).scroll(function (e) {\r\n            var scrollLeft = this.scrollLeft\r\n\r\n            scrollHead.scrollLeft = scrollLeft\r\n\r\n            if (footer) {\r\n              scrollFoot.scrollLeft = scrollLeft\r\n            }\r\n          })\r\n        }\r\n\r\n        settings.nScrollHead = scrollHead\r\n        settings.nScrollBody = scrollBody\r\n        settings.nScrollFoot = scrollFoot\r\n\r\n        // On redraw - align columns\r\n        settings.aoDrawCallback.push({\r\n          fn: _fnScrollDraw,\r\n          sName: 'scrolling'\r\n        })\r\n\r\n        return scroller[0]\r\n      }\r\n\r\n      /**\r\n       * Update the header, footer and body tables for resizing - i.e. column\r\n       * alignment.\r\n       *\r\n       * Welcome to the most horrible function DataTables. The process that this\r\n       * function follows is basically:\r\n       *   1. Re-create the table inside the scrolling div\r\n       *   2. Take live measurements from the DOM\r\n       *   3. Apply the measurements to align the columns\r\n       *   4. Clean up\r\n       *\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnScrollDraw (settings) {\r\n        // Given that this is such a monster function, a lot of variables are use\r\n        // to try and keep the minimised size as small as possible\r\n        var scroll = settings.oScroll,\r\n          scrollX = scroll.sX,\r\n          scrollXInner = scroll.sXInner,\r\n          scrollY = scroll.sY,\r\n          barWidth = scroll.iBarWidth,\r\n          divHeader = $(settings.nScrollHead),\r\n          divHeaderStyle = divHeader[0].style,\r\n          divHeaderInner = divHeader.children('div'),\r\n          divHeaderInnerStyle = divHeaderInner[0].style,\r\n          divHeaderTable = divHeaderInner.children('table'),\r\n          divBodyEl = settings.nScrollBody,\r\n          divBody = $(divBodyEl),\r\n          divBodyStyle = divBodyEl.style,\r\n          divFooter = $(settings.nScrollFoot),\r\n          divFooterInner = divFooter.children('div'),\r\n          divFooterTable = divFooterInner.children('table'),\r\n          header = $(settings.nTHead),\r\n          table = $(settings.nTable),\r\n          tableEl = table[0],\r\n          tableStyle = tableEl.style,\r\n          footer = settings.nTFoot ? $(settings.nTFoot) : null,\r\n          browser = settings.oBrowser,\r\n          ie67 = browser.bScrollOversize,\r\n          headerTrgEls,\r\n          footerTrgEls,\r\n          headerSrcEls,\r\n          footerSrcEls,\r\n          headerCopy,\r\n          footerCopy,\r\n          headerWidths = [],\r\n          footerWidths = [],\r\n          headerContent = [],\r\n          idx,\r\n          correction,\r\n          sanityWidth,\r\n          zeroOut = function (nSizer) {\r\n            var style = nSizer.style\r\n            style.paddingTop = '0'\r\n            style.paddingBottom = '0'\r\n            style.borderTopWidth = '0'\r\n            style.borderBottomWidth = '0'\r\n            style.height = 0\r\n          }\r\n\r\n        /*\r\n         * 1. Re-create the table inside the scrolling div\r\n         */\r\n\r\n        // Remove the old minimised thead and tfoot elements in the inner table\r\n        table.children('thead, tfoot').remove()\r\n\r\n        // Clone the current header and footer elements and then place it into the inner table\r\n        headerCopy = header.clone().prependTo(table)\r\n        headerTrgEls = header.find('tr') // original header is in its own table\r\n        headerSrcEls = headerCopy.find('tr')\r\n        headerCopy.find('th, td').removeAttr('tabindex')\r\n\r\n        if (footer) {\r\n          footerCopy = footer.clone().prependTo(table)\r\n          footerTrgEls = footer.find('tr') // the original tfoot is in its own table and must be sized\r\n          footerSrcEls = footerCopy.find('tr')\r\n        }\r\n\r\n        /*\r\n         * 2. Take live measurements from the DOM - do not alter the DOM itself!\r\n         */\r\n\r\n        // Remove old sizing and apply the calculated column widths\r\n        // Get the unique column headers in the newly created (cloned) header. We want to apply the\r\n        // calculated sizes to this header\r\n        if (!scrollX) {\r\n          divBodyStyle.width = '100%'\r\n          divHeader[0].style.width = '100%'\r\n        }\r\n\r\n        $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {\r\n          idx = _fnVisibleToColumnIndex(settings, i)\r\n          el.style.width = settings.aoColumns[idx].sWidth\r\n        })\r\n\r\n        if (footer) {\r\n          _fnApplyToChildren(function (n) {\r\n            n.style.width = ''\r\n          }, footerSrcEls)\r\n        }\r\n\r\n        // If scroll collapse is enabled, when we put the headers back into the body for sizing, we\r\n        // will end up forcing the scrollbar to appear, making our measurements wrong for when we\r\n        // then hide it (end of this function), so add the header height to the body scroller.\r\n        if (scroll.bCollapse && scrollY !== '') {\r\n          divBodyStyle.height = divBody[0].offsetHeight + header[0].offsetHeight + 'px'\r\n        }\r\n\r\n        // Size the table as a whole\r\n        sanityWidth = table.outerWidth()\r\n        if (scrollX === '') {\r\n          // No x scrolling\r\n          tableStyle.width = '100%'\r\n\r\n          // IE7 will make the width of the table when 100% include the scrollbar\r\n          // - which is shouldn't. When there is a scrollbar we need to take this\r\n          // into account.\r\n          if (\r\n            ie67 &&\r\n            (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')\r\n          ) {\r\n            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth)\r\n          }\r\n        } else {\r\n          // x scrolling\r\n          if (scrollXInner !== '') {\r\n            // x scroll inner has been given - use it\r\n            tableStyle.width = _fnStringToCss(scrollXInner)\r\n          } else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {\r\n            // There is y-scrolling - try to take account of the y scroll bar\r\n            tableStyle.width = _fnStringToCss(sanityWidth - barWidth)\r\n            if (table.outerWidth() > sanityWidth - barWidth) {\r\n              // Not possible to take account of it\r\n              tableStyle.width = _fnStringToCss(sanityWidth)\r\n            }\r\n          } else {\r\n            // When all else fails\r\n            tableStyle.width = _fnStringToCss(sanityWidth)\r\n          }\r\n        }\r\n\r\n        // Recalculate the sanity width - now that we've applied the required width,\r\n        // before it was a temporary variable. This is required because the column\r\n        // width calculation is done before this table DOM is created.\r\n        sanityWidth = table.outerWidth()\r\n\r\n        // Hidden header should have zero height, so remove padding and borders. Then\r\n        // set the width based on the real headers\r\n\r\n        // Apply all styles in one pass\r\n        _fnApplyToChildren(zeroOut, headerSrcEls)\r\n\r\n        // Read all widths in next pass\r\n        _fnApplyToChildren(function (nSizer) {\r\n          headerContent.push(nSizer.innerHTML)\r\n          headerWidths.push(_fnStringToCss($(nSizer).css('width')))\r\n        }, headerSrcEls)\r\n\r\n        // Apply all widths in final pass\r\n        _fnApplyToChildren(function (nToSize, i) {\r\n          nToSize.style.width = headerWidths[i]\r\n        }, headerTrgEls)\r\n\r\n        $(headerSrcEls).height(0)\r\n\r\n        /* Same again with the footer if we have one */\r\n        if (footer) {\r\n          _fnApplyToChildren(zeroOut, footerSrcEls)\r\n\r\n          _fnApplyToChildren(function (nSizer) {\r\n            footerWidths.push(_fnStringToCss($(nSizer).css('width')))\r\n          }, footerSrcEls)\r\n\r\n          _fnApplyToChildren(function (nToSize, i) {\r\n            nToSize.style.width = footerWidths[i]\r\n          }, footerTrgEls)\r\n\r\n          $(footerSrcEls).height(0)\r\n        }\r\n\r\n        /*\r\n         * 3. Apply the measurements\r\n         */\r\n\r\n        // \"Hide\" the header and footer that we used for the sizing. We need to keep\r\n        // the content of the cell so that the width applied to the header and body\r\n        // both match, but we want to hide it completely. We want to also fix their\r\n        // width to what they currently are\r\n        _fnApplyToChildren(function (nSizer, i) {\r\n          nSizer.innerHTML =\r\n            '<div class=\"dataTables_sizing\" style=\"height:0;overflow:hidden;\">' + headerContent[i] + '</div>'\r\n          nSizer.style.width = headerWidths[i]\r\n        }, headerSrcEls)\r\n\r\n        if (footer) {\r\n          _fnApplyToChildren(function (nSizer, i) {\r\n            nSizer.innerHTML = ''\r\n            nSizer.style.width = footerWidths[i]\r\n          }, footerSrcEls)\r\n        }\r\n\r\n        // Sanity check that the table is of a sensible width. If not then we are going to get\r\n        // misalignment - try to prevent this by not allowing the table to shrink below its min width\r\n        if (table.outerWidth() < sanityWidth) {\r\n          // The min width depends upon if we have a vertical scrollbar visible or not */\r\n          correction =\r\n            divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll'\r\n              ? sanityWidth + barWidth\r\n              : sanityWidth\r\n\r\n          // IE6/7 are a law unto themselves...\r\n          if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')) {\r\n            tableStyle.width = _fnStringToCss(correction - barWidth)\r\n          }\r\n\r\n          // And give the user a warning that we've stopped the table getting too small\r\n          if (scrollX === '' || scrollXInner !== '') {\r\n            _fnLog(settings, 1, 'Possible column misalignment', 6)\r\n          }\r\n        } else {\r\n          correction = '100%'\r\n        }\r\n\r\n        // Apply to the container elements\r\n        divBodyStyle.width = _fnStringToCss(correction)\r\n        divHeaderStyle.width = _fnStringToCss(correction)\r\n\r\n        if (footer) {\r\n          settings.nScrollFoot.style.width = _fnStringToCss(correction)\r\n        }\r\n\r\n        /*\r\n         * 4. Clean up\r\n         */\r\n        if (!scrollY) {\r\n          /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\r\n           * the scrollbar height from the visible display, rather than adding it on. We need to\r\n           * set the height in order to sort this. Don't want to do it in any other browsers.\r\n           */\r\n          if (ie67) {\r\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth)\r\n          }\r\n        }\r\n\r\n        if (scrollY && scroll.bCollapse) {\r\n          divBodyStyle.height = _fnStringToCss(scrollY)\r\n\r\n          var iExtra = scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth ? barWidth : 0\r\n\r\n          if (tableEl.offsetHeight < divBodyEl.offsetHeight) {\r\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra)\r\n          }\r\n        }\r\n\r\n        /* Finally set the width's of the header and footer tables */\r\n        var iOuterWidth = table.outerWidth()\r\n        divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth)\r\n        divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth)\r\n\r\n        // Figure out if there are scrollbar present - if so then we need a the header and footer to\r\n        // provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\r\n        var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == 'scroll'\r\n        var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right')\r\n        divHeaderInnerStyle[padding] = bScrolling ? barWidth + 'px' : '0px'\r\n\r\n        if (footer) {\r\n          divFooterTable[0].style.width = _fnStringToCss(iOuterWidth)\r\n          divFooterInner[0].style.width = _fnStringToCss(iOuterWidth)\r\n          divFooterInner[0].style[padding] = bScrolling ? barWidth + 'px' : '0px'\r\n        }\r\n\r\n        /* Adjust the position of the header in case we loose the y-scrollbar */\r\n        divBody.scroll()\r\n\r\n        // If sorting or filtering has occurred, jump the scrolling back to the top\r\n        // only if we aren't holding the position\r\n        if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {\r\n          divBodyEl.scrollTop = 0\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Apply a given function to the display child nodes of an element array (typically\r\n       * TD children of TR rows\r\n       *  @param {function} fn Method to apply to the objects\r\n       *  @param array {nodes} an1 List of elements to look through for display children\r\n       *  @param array {nodes} an2 Another list (identical structure to the first) - optional\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnApplyToChildren (fn, an1, an2) {\r\n        var index = 0,\r\n          i = 0,\r\n          iLen = an1.length\r\n        var nNode1, nNode2\r\n\r\n        while (i < iLen) {\r\n          nNode1 = an1[i].firstChild\r\n          nNode2 = an2 ? an2[i].firstChild : null\r\n\r\n          while (nNode1) {\r\n            if (nNode1.nodeType === 1) {\r\n              if (an2) {\r\n                fn(nNode1, nNode2, index)\r\n              } else {\r\n                fn(nNode1, index)\r\n              }\r\n\r\n              index++\r\n            }\r\n\r\n            nNode1 = nNode1.nextSibling\r\n            nNode2 = an2 ? nNode2.nextSibling : null\r\n          }\r\n\r\n          i++\r\n        }\r\n      }\r\n\r\n      var __re_html_remove = /<.*?>/g\r\n\r\n      /**\r\n       * Calculate the width of columns for the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCalculateColumnWidths (oSettings) {\r\n        var table = oSettings.nTable,\r\n          columns = oSettings.aoColumns,\r\n          scroll = oSettings.oScroll,\r\n          scrollY = scroll.sY,\r\n          scrollX = scroll.sX,\r\n          scrollXInner = scroll.sXInner,\r\n          columnCount = columns.length,\r\n          visibleColumns = _fnGetColumns(oSettings, 'bVisible'),\r\n          headerCells = $('th', oSettings.nTHead),\r\n          tableWidthAttr = table.getAttribute('width'),\r\n          tableContainer = table.parentNode,\r\n          userInputs = false,\r\n          i,\r\n          column,\r\n          columnIdx,\r\n          width,\r\n          outerWidth\r\n\r\n        /* Convert any user input sizes into pixel sizes */\r\n        for (i = 0; i < visibleColumns.length; i++) {\r\n          column = columns[visibleColumns[i]]\r\n\r\n          if (column.sWidth !== null) {\r\n            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer)\r\n\r\n            userInputs = true\r\n          }\r\n        }\r\n\r\n        /* If the number of columns in the DOM equals the number that we have to\r\n         * process in DataTables, then we can use the offsets that are created by\r\n         * the web- browser. No custom sizes can be set in order for this to happen,\r\n         * nor scrolling used\r\n         */\r\n        if (\r\n          !userInputs &&\r\n          !scrollX &&\r\n          !scrollY &&\r\n          columnCount == _fnVisbleColumns(oSettings) &&\r\n          columnCount == headerCells.length\r\n        ) {\r\n          for (i = 0; i < columnCount; i++) {\r\n            columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width())\r\n          }\r\n        } else {\r\n          // Otherwise construct a single row table with the widest node in the\r\n          // data, assign any user defined widths, then insert it into the DOM and\r\n          // allow the browser to do all the hard work of calculating table widths\r\n          var tmpTable = $(table)\r\n            .clone() // don't use cloneNode - IE8 will remove events on the main table\r\n            .empty()\r\n            .css('visibility', 'hidden')\r\n            .removeAttr('id')\r\n            .append($(oSettings.nTHead).clone(false))\r\n            .append($(oSettings.nTFoot).clone(false))\r\n            .append($('<tbody><tr/></tbody>'))\r\n\r\n          // Remove any assigned widths from the footer (from scrolling)\r\n          tmpTable.find('tfoot th, tfoot td').css('width', '')\r\n\r\n          var tr = tmpTable.find('tbody tr')\r\n\r\n          // Apply custom sizing to the cloned header\r\n          headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0])\r\n\r\n          for (i = 0; i < visibleColumns.length; i++) {\r\n            column = columns[visibleColumns[i]]\r\n\r\n            headerCells[i].style.width =\r\n              column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''\r\n          }\r\n\r\n          // Find the widest cell for each column and put it into the table\r\n          if (oSettings.aoData.length) {\r\n            for (i = 0; i < visibleColumns.length; i++) {\r\n              columnIdx = visibleColumns[i]\r\n              column = columns[columnIdx]\r\n\r\n              $(_fnGetWidestNode(oSettings, columnIdx))\r\n                .clone(false)\r\n                .append(column.sContentPadding)\r\n                .appendTo(tr)\r\n            }\r\n          }\r\n\r\n          // Table has been built, attach to the document so we can work with it\r\n          tmpTable.appendTo(tableContainer)\r\n\r\n          // When scrolling (X or Y) we want to set the width of the table as\r\n          // appropriate. However, when not scrolling leave the table width as it\r\n          // is. This results in slightly different, but I think correct behaviour\r\n          if (scrollX && scrollXInner) {\r\n            tmpTable.width(scrollXInner)\r\n          } else if (scrollX) {\r\n            tmpTable.css('width', 'auto')\r\n\r\n            if (tmpTable.width() < tableContainer.offsetWidth) {\r\n              tmpTable.width(tableContainer.offsetWidth)\r\n            }\r\n          } else if (scrollY) {\r\n            tmpTable.width(tableContainer.offsetWidth)\r\n          } else if (tableWidthAttr) {\r\n            tmpTable.width(tableWidthAttr)\r\n          }\r\n\r\n          // Take into account the y scrollbar\r\n          _fnScrollingWidthAdjust(oSettings, tmpTable[0])\r\n\r\n          // Browsers need a bit of a hand when a width is assigned to any columns\r\n          // when x-scrolling as they tend to collapse the table to the min-width,\r\n          // even if we sent the column widths. So we need to keep track of what\r\n          // the table width should be by summing the user given values, and the\r\n          // automatic values\r\n          if (scrollX) {\r\n            var total = 0\r\n\r\n            for (i = 0; i < visibleColumns.length; i++) {\r\n              column = columns[visibleColumns[i]]\r\n              outerWidth = $(headerCells[i]).outerWidth()\r\n\r\n              total +=\r\n                column.sWidthOrig === null\r\n                  ? outerWidth\r\n                  : parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width()\r\n            }\r\n\r\n            tmpTable.width(_fnStringToCss(total))\r\n            table.style.width = _fnStringToCss(total)\r\n          }\r\n\r\n          // Get the width of each column in the constructed table\r\n          for (i = 0; i < visibleColumns.length; i++) {\r\n            column = columns[visibleColumns[i]]\r\n            width = $(headerCells[i]).width()\r\n\r\n            if (width) {\r\n              column.sWidth = _fnStringToCss(width)\r\n            }\r\n          }\r\n\r\n          table.style.width = _fnStringToCss(tmpTable.css('width'))\r\n\r\n          // Finished with the table - ditch it\r\n          tmpTable.remove()\r\n        }\r\n\r\n        // If there is a width attr, we want to attach an event listener which\r\n        // allows the table sizing to automatically adjust when the window is\r\n        // resized. Use the width attr rather than CSS, since we can't know if the\r\n        // CSS is a relative value or absolute - DOM read is always px.\r\n        if (tableWidthAttr) {\r\n          table.style.width = _fnStringToCss(tableWidthAttr)\r\n        }\r\n\r\n        if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {\r\n          $(window).bind(\r\n            'resize.DT-' + oSettings.sInstance,\r\n            _fnThrottle(function () {\r\n              _fnAdjustColumnSizing(oSettings)\r\n            })\r\n          )\r\n\r\n          oSettings._reszEvt = true\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Throttle the calls to a function. Arguments and context are maintained for\r\n       * the throttled function\r\n       *  @param {function} fn Function to be called\r\n       *  @param {int} [freq=200] call frequency in mS\r\n       *  @returns {function} wrapped function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnThrottle (fn, freq) {\r\n        var frequency = freq || 200,\r\n          last,\r\n          timer\r\n\r\n        return function () {\r\n          var that = this,\r\n            now = +new Date(),\r\n            args = arguments\r\n\r\n          if (last && now < last + frequency) {\r\n            clearTimeout(timer)\r\n\r\n            timer = setTimeout(function () {\r\n              last = undefined\r\n              fn.apply(that, args)\r\n            }, frequency)\r\n          } else if (last) {\r\n            last = now\r\n            fn.apply(that, args)\r\n          } else {\r\n            last = now\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Convert a CSS unit width to pixels (e.g. 2em)\r\n       *  @param {string} width width to be converted\r\n       *  @param {node} parent parent to get the with for (required for relative widths) - optional\r\n       *  @returns {int} width in pixels\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnConvertToWidth (width, parent) {\r\n        if (!width) {\r\n          return 0\r\n        }\r\n\r\n        var n = $('<div/>')\r\n          .css('width', _fnStringToCss(width))\r\n          .appendTo(parent || document.body)\r\n\r\n        var val = n[0].offsetWidth\r\n        n.remove()\r\n\r\n        return val\r\n      }\r\n\r\n      /**\r\n       * Adjust a table's width to take account of vertical scroll bar\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} n table node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n\r\n      function _fnScrollingWidthAdjust (settings, n) {\r\n        var scroll = settings.oScroll\r\n\r\n        if (scroll.sX || scroll.sY) {\r\n          // When y-scrolling only, we want to remove the width of the scroll bar\r\n          // so the table + scroll bar will fit into the area available, otherwise\r\n          // we fix the table at its current size with no adjustment\r\n          var correction = !scroll.sX ? scroll.iBarWidth : 0\r\n          n.style.width = _fnStringToCss($(n).outerWidth() - correction)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get the widest node\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} colIdx column of interest\r\n       *  @returns {node} widest table node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetWidestNode (settings, colIdx) {\r\n        var idx = _fnGetMaxLenString(settings, colIdx)\r\n        if (idx < 0) {\r\n          return null\r\n        }\r\n\r\n        var data = settings.aoData[idx]\r\n        return !data.nTr // Might not have been created when deferred rendering\r\n          ? $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0]\r\n          : data.anCells[colIdx]\r\n      }\r\n\r\n      /**\r\n       * Get the maximum strlen for each data column\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} colIdx column of interest\r\n       *  @returns {string} max string length for each column\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetMaxLenString (settings, colIdx) {\r\n        var s,\r\n          max = -1,\r\n          maxIdx = -1\r\n\r\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n          s = _fnGetCellData(settings, i, colIdx, 'display') + ''\r\n          s = s.replace(__re_html_remove, '')\r\n\r\n          if (s.length > max) {\r\n            max = s.length\r\n            maxIdx = i\r\n          }\r\n        }\r\n\r\n        return maxIdx\r\n      }\r\n\r\n      /**\r\n       * Append a CSS unit (only if required) to a string\r\n       *  @param {string} value to css-ify\r\n       *  @returns {string} value with css unit\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnStringToCss (s) {\r\n        if (s === null) {\r\n          return '0px'\r\n        }\r\n\r\n        if (typeof s == 'number') {\r\n          return s < 0 ? '0px' : s + 'px'\r\n        }\r\n\r\n        // Check it has a unit character already\r\n        return s.match(/\\d$/) ? s + 'px' : s\r\n      }\r\n\r\n      /**\r\n       * Get the width of a scroll bar in this browser being used\r\n       *  @returns {int} width in pixels\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnScrollBarWidth () {\r\n        // On first run a static variable is set, since this is only needed once.\r\n        // Subsequent runs will just use the previously calculated value\r\n        if (!DataTable.__scrollbarWidth) {\r\n          var inner = $('<p/>').css({\r\n            width: '100%',\r\n            height: 200,\r\n            padding: 0\r\n          })[0]\r\n\r\n          var outer = $('<div/>')\r\n            .css({\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: 200,\r\n              height: 150,\r\n              padding: 0,\r\n              overflow: 'hidden',\r\n              visibility: 'hidden'\r\n            })\r\n            .append(inner)\r\n            .appendTo('body')\r\n\r\n          var w1 = inner.offsetWidth\r\n          outer.css('overflow', 'scroll')\r\n          var w2 = inner.offsetWidth\r\n\r\n          if (w1 === w2) {\r\n            w2 = outer[0].clientWidth\r\n          }\r\n\r\n          outer.remove()\r\n\r\n          DataTable.__scrollbarWidth = w1 - w2\r\n        }\r\n\r\n        return DataTable.__scrollbarWidth\r\n      }\r\n\r\n      function _fnSortFlatten (settings) {\r\n        var i,\r\n          iLen,\r\n          k,\r\n          kLen,\r\n          aSort = [],\r\n          aiOrig = [],\r\n          aoColumns = settings.aoColumns,\r\n          aDataSort,\r\n          iCol,\r\n          sType,\r\n          srcCol,\r\n          fixed = settings.aaSortingFixed,\r\n          fixedObj = $.isPlainObject(fixed),\r\n          nestedSort = [],\r\n          add = function (a) {\r\n            if (a.length && !$.isArray(a[0])) {\r\n              // 1D array\r\n              nestedSort.push(a)\r\n            } else {\r\n              // 2D array\r\n              nestedSort.push.apply(nestedSort, a)\r\n            }\r\n          }\r\n\r\n        // Build the sort array, with pre-fix and post-fix options if they have been\r\n        // specified\r\n        if ($.isArray(fixed)) {\r\n          add(fixed)\r\n        }\r\n\r\n        if (fixedObj && fixed.pre) {\r\n          add(fixed.pre)\r\n        }\r\n\r\n        add(settings.aaSorting)\r\n\r\n        if (fixedObj && fixed.post) {\r\n          add(fixed.post)\r\n        }\r\n\r\n        for (i = 0; i < nestedSort.length; i++) {\r\n          srcCol = nestedSort[i][0]\r\n          aDataSort = aoColumns[srcCol].aDataSort\r\n\r\n          for (k = 0, kLen = aDataSort.length; k < kLen; k++) {\r\n            iCol = aDataSort[k]\r\n            sType = aoColumns[iCol].sType || 'string'\r\n\r\n            aSort.push({\r\n              src: srcCol,\r\n              col: iCol,\r\n              dir: nestedSort[i][1],\r\n              index: nestedSort[i][2],\r\n              type: sType,\r\n              formatter: DataTable.ext.type.order[sType + '-pre']\r\n            })\r\n          }\r\n        }\r\n\r\n        return aSort\r\n      }\r\n\r\n      /**\r\n       * Change the order of the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       *  @todo This really needs split up!\r\n       */\r\n      function _fnSort (oSettings) {\r\n        var i,\r\n          ien,\r\n          iLen,\r\n          j,\r\n          jLen,\r\n          k,\r\n          kLen,\r\n          sDataType,\r\n          nTh,\r\n          aiOrig = [],\r\n          oExtSort = DataTable.ext.type.order,\r\n          aoData = oSettings.aoData,\r\n          aoColumns = oSettings.aoColumns,\r\n          aDataSort,\r\n          data,\r\n          iCol,\r\n          sType,\r\n          oSort,\r\n          formatters = 0,\r\n          sortCol,\r\n          displayMaster = oSettings.aiDisplayMaster,\r\n          aSort\r\n\r\n        // Resolve any column types that are unknown due to addition or invalidation\r\n        // @todo Can this be moved into a 'data-ready' handler which is called when\r\n        //   data is going to be used in the table?\r\n        _fnColumnTypes(oSettings)\r\n\r\n        aSort = _fnSortFlatten(oSettings)\r\n\r\n        for (i = 0, ien = aSort.length; i < ien; i++) {\r\n          sortCol = aSort[i]\r\n\r\n          // Track if we can use the fast sort algorithm\r\n          if (sortCol.formatter) {\r\n            formatters++\r\n          }\r\n\r\n          // Load the data needed for the sort, for each cell\r\n          _fnSortData(oSettings, sortCol.col)\r\n        }\r\n\r\n        /* No sorting required if server-side or no sorting array */\r\n        if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {\r\n          // Create a value - key array of the current row positions such that we can use their\r\n          // current position during the sort, if values match, in order to perform stable sorting\r\n          for (i = 0, iLen = displayMaster.length; i < iLen; i++) {\r\n            aiOrig[displayMaster[i]] = i\r\n          }\r\n\r\n          /* Do the sort - here we want multi-column sorting based on a given data source (column)\r\n           * and sorting function (from oSort) in a certain direction. It's reasonably complex to\r\n           * follow on it's own, but this is what we want (example two column sorting):\r\n           *  fnLocalSorting = function(a,b){\r\n           *    var iTest;\r\n           *    iTest = oSort['string-asc']('data11', 'data12');\r\n           *      if (iTest !== 0)\r\n           *        return iTest;\r\n           *    iTest = oSort['numeric-desc']('data21', 'data22');\r\n           *    if (iTest !== 0)\r\n           *      return iTest;\r\n           *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\r\n           *  }\r\n           * Basically we have a test for each sorting column, if the data in that column is equal,\r\n           * test the next column. If all columns match, then we use a numeric sort on the row\r\n           * positions in the original data array to provide a stable sort.\r\n           *\r\n           * Note - I know it seems excessive to have two sorting methods, but the first is around\r\n           * 15% faster, so the second is only maintained for backwards compatibility with sorting\r\n           * methods which do not have a pre-sort formatting function.\r\n           */\r\n          if (formatters === aSort.length) {\r\n            // All sort types have formatting functions\r\n            displayMaster.sort(function (a, b) {\r\n              var x,\r\n                y,\r\n                k,\r\n                test,\r\n                sort,\r\n                len = aSort.length,\r\n                dataA = aoData[a]._aSortData,\r\n                dataB = aoData[b]._aSortData\r\n\r\n              for (k = 0; k < len; k++) {\r\n                sort = aSort[k]\r\n\r\n                x = dataA[sort.col]\r\n                y = dataB[sort.col]\r\n\r\n                test = x < y ? -1 : x > y ? 1 : 0\r\n                if (test !== 0) {\r\n                  return sort.dir === 'asc' ? test : -test\r\n                }\r\n              }\r\n\r\n              x = aiOrig[a]\r\n              y = aiOrig[b]\r\n              return x < y ? -1 : x > y ? 1 : 0\r\n            })\r\n          } else {\r\n            // Depreciated - remove in 1.11 (providing a plug-in option)\r\n            // Not all sort types have formatting methods, so we have to call their sorting\r\n            // methods.\r\n            displayMaster.sort(function (a, b) {\r\n              var x,\r\n                y,\r\n                k,\r\n                l,\r\n                test,\r\n                sort,\r\n                fn,\r\n                len = aSort.length,\r\n                dataA = aoData[a]._aSortData,\r\n                dataB = aoData[b]._aSortData\r\n\r\n              for (k = 0; k < len; k++) {\r\n                sort = aSort[k]\r\n\r\n                x = dataA[sort.col]\r\n                y = dataB[sort.col]\r\n\r\n                fn = oExtSort[sort.type + '-' + sort.dir] || oExtSort['string-' + sort.dir]\r\n                test = fn(x, y)\r\n                if (test !== 0) {\r\n                  return test\r\n                }\r\n              }\r\n\r\n              x = aiOrig[a]\r\n              y = aiOrig[b]\r\n              return x < y ? -1 : x > y ? 1 : 0\r\n            })\r\n          }\r\n        }\r\n\r\n        /* Tell the draw function that we have sorted the data */\r\n        oSettings.bSorted = true\r\n      }\r\n\r\n      function _fnSortAria (settings) {\r\n        var label\r\n        var nextSort\r\n        var columns = settings.aoColumns\r\n        var aSort = _fnSortFlatten(settings)\r\n        var oAria = settings.oLanguage.oAria\r\n\r\n        // ARIA attributes - need to loop all columns, to update all (removing old\r\n        // attributes as needed)\r\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\r\n          var col = columns[i]\r\n          var asSorting = col.asSorting\r\n          var sTitle = col.sTitle.replace(/<.*?>/g, '')\r\n          var th = col.nTh\r\n\r\n          // IE7 is throwing an error when setting these properties with jQuery's\r\n          // attr() and removeAttr() methods...\r\n          th.removeAttribute('aria-sort')\r\n\r\n          /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\r\n          if (col.bSortable) {\r\n            if (aSort.length > 0 && aSort[0].col == i) {\r\n              th.setAttribute('aria-sort', aSort[0].dir == 'asc' ? 'ascending' : 'descending')\r\n              nextSort = asSorting[aSort[0].index + 1] || asSorting[0]\r\n            } else {\r\n              nextSort = asSorting[0]\r\n            }\r\n\r\n            label = sTitle + (nextSort === 'asc' ? oAria.sSortAscending : oAria.sSortDescending)\r\n          } else {\r\n            label = sTitle\r\n          }\r\n\r\n          th.setAttribute('aria-label', label)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Function to run on user sort request\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {node} attachTo node to attach the handler to\r\n       *  @param {int} colIdx column sorting index\r\n       *  @param {boolean} [append=false] Append the requested sort to the existing\r\n       *    sort if true (i.e. multi-column sort)\r\n       *  @param {function} [callback] callback function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSortListener (settings, colIdx, append, callback) {\r\n        var col = settings.aoColumns[colIdx]\r\n        var sorting = settings.aaSorting\r\n        var asSorting = col.asSorting\r\n        var nextSortIdx\r\n        var next = function (a) {\r\n          var idx = a._idx\r\n          if (idx === undefined) {\r\n            idx = $.inArray(a[1], asSorting)\r\n          }\r\n\r\n          return idx + 1 >= asSorting.length ? 0 : idx + 1\r\n        }\r\n\r\n        // Convert to 2D array if needed\r\n        if (typeof sorting[0] === 'number') {\r\n          sorting = settings.aaSorting = [sorting]\r\n        }\r\n\r\n        // If appending the sort then we are multi-column sorting\r\n        if (append && settings.oFeatures.bSortMulti) {\r\n          // Are we already doing some kind of sort on this column?\r\n          var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'))\r\n\r\n          if (sortIdx !== -1) {\r\n            // Yes, modify the sort\r\n            nextSortIdx = next(sorting[sortIdx])\r\n\r\n            sorting[sortIdx][1] = asSorting[nextSortIdx]\r\n            sorting[sortIdx]._idx = nextSortIdx\r\n          } else {\r\n            // No sort on this column yet\r\n            sorting.push([colIdx, asSorting[0], 0])\r\n            sorting[sorting.length - 1]._idx = 0\r\n          }\r\n        } else if (sorting.length && sorting[0][0] == colIdx) {\r\n          // Single column - already sorting on this column, modify the sort\r\n          nextSortIdx = next(sorting[0])\r\n\r\n          sorting.length = 1\r\n          sorting[0][1] = asSorting[nextSortIdx]\r\n          sorting[0]._idx = nextSortIdx\r\n        } else {\r\n          // Single column - sort only on this column\r\n          sorting.length = 0\r\n          sorting.push([colIdx, asSorting[0]])\r\n          sorting[0]._idx = 0\r\n        }\r\n\r\n        // Run the sort by calling a full redraw\r\n        _fnReDraw(settings)\r\n\r\n        // callback used for async user interaction\r\n        if (typeof callback == 'function') {\r\n          callback(settings)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Attach a sort handler (click) to a node\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {node} attachTo node to attach the handler to\r\n       *  @param {int} colIdx column sorting index\r\n       *  @param {function} [callback] callback function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSortAttachListener (settings, attachTo, colIdx, callback) {\r\n        var col = settings.aoColumns[colIdx]\r\n\r\n        _fnBindAction(attachTo, {}, function (e) {\r\n          /* If the column is not sortable - don't to anything */\r\n          if (col.bSortable === false) {\r\n            return\r\n          }\r\n\r\n          // If processing is enabled use a timeout to allow the processing\r\n          // display to be shown - otherwise to it synchronously\r\n          if (settings.oFeatures.bProcessing) {\r\n            _fnProcessingDisplay(settings, true)\r\n\r\n            setTimeout(function () {\r\n              _fnSortListener(settings, colIdx, e.shiftKey, callback)\r\n\r\n              // In server-side processing, the draw callback will remove the\r\n              // processing display\r\n              if (_fnDataSource(settings) !== 'ssp') {\r\n                _fnProcessingDisplay(settings, false)\r\n              }\r\n            }, 0)\r\n          } else {\r\n            _fnSortListener(settings, colIdx, e.shiftKey, callback)\r\n          }\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Set the sorting classes on table's body, Note: it is safe to call this function\r\n       * when bSort and bSortClasses are false\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSortingClasses (settings) {\r\n        var oldSort = settings.aLastSort\r\n        var sortClass = settings.oClasses.sSortColumn\r\n        var sort = _fnSortFlatten(settings)\r\n        var features = settings.oFeatures\r\n        var i, ien, colIdx\r\n\r\n        if (features.bSort && features.bSortClasses) {\r\n          // Remove old sorting classes\r\n          for (i = 0, ien = oldSort.length; i < ien; i++) {\r\n            colIdx = oldSort[i].src\r\n\r\n            // Remove column sorting\r\n            $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3))\r\n          }\r\n\r\n          // Add new column sorting\r\n          for (i = 0, ien = sort.length; i < ien; i++) {\r\n            colIdx = sort[i].src\r\n\r\n            $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3))\r\n          }\r\n        }\r\n\r\n        settings.aLastSort = sort\r\n      }\r\n\r\n      // Get the data to sort a column, be it from cache, fresh (populating the\r\n      // cache), or from a sort formatter\r\n      function _fnSortData (settings, idx) {\r\n        // Custom sorting function - provided by the sort data type\r\n        var column = settings.aoColumns[idx]\r\n        var customSort = DataTable.ext.order[column.sSortDataType]\r\n        var customData\r\n\r\n        if (customSort) {\r\n          customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx))\r\n        }\r\n\r\n        // Use / populate cache\r\n        var row, cellData\r\n        var formatter = DataTable.ext.type.order[column.sType + '-pre']\r\n\r\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n          row = settings.aoData[i]\r\n\r\n          if (!row._aSortData) {\r\n            row._aSortData = []\r\n          }\r\n\r\n          if (!row._aSortData[idx] || customSort) {\r\n            cellData = customSort\r\n              ? customData[i] // If there was a custom sort function, use data from there\r\n              : _fnGetCellData(settings, i, idx, 'sort')\r\n\r\n            row._aSortData[idx] = formatter ? formatter(cellData) : cellData\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Save the state of a table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSaveState (settings) {\r\n        if (!settings.oFeatures.bStateSave || settings.bDestroying) {\r\n          return\r\n        }\r\n\r\n        /* Store the interesting variables */\r\n        var state = {\r\n          time: +new Date(),\r\n          start: settings._iDisplayStart,\r\n          length: settings._iDisplayLength,\r\n          order: $.extend(true, [], settings.aaSorting),\r\n          search: _fnSearchToCamel(settings.oPreviousSearch),\r\n          columns: $.map(settings.aoColumns, function (col, i) {\r\n            return {\r\n              visible: col.bVisible,\r\n              search: _fnSearchToCamel(settings.aoPreSearchCols[i])\r\n            }\r\n          })\r\n        }\r\n\r\n        _fnCallbackFire(settings, 'aoStateSaveParams', 'stateSaveParams', [settings, state])\r\n\r\n        settings.oSavedState = state\r\n        settings.fnStateSaveCallback.call(settings.oInstance, settings, state)\r\n      }\r\n\r\n      /**\r\n       * Attempt to load a saved table state\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} oInit DataTables init object so we can override settings\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnLoadState (settings, oInit) {\r\n        var i, ien\r\n        var columns = settings.aoColumns\r\n\r\n        if (!settings.oFeatures.bStateSave) {\r\n          return\r\n        }\r\n\r\n        var state = settings.fnStateLoadCallback.call(settings.oInstance, settings)\r\n        if (!state || !state.time) {\r\n          return\r\n        }\r\n\r\n        /* Allow custom and plug-in manipulation functions to alter the saved data set and\r\n         * cancelling of loading by returning false\r\n         */\r\n        var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state])\r\n        if ($.inArray(false, abStateLoad) !== -1) {\r\n          return\r\n        }\r\n\r\n        /* Reject old data */\r\n        var duration = settings.iStateDuration\r\n        if (duration > 0 && state.time < +new Date() - duration * 1000) {\r\n          return\r\n        }\r\n\r\n        // Number of columns have changed - all bets are off, no restore of settings\r\n        if (columns.length !== state.columns.length) {\r\n          return\r\n        }\r\n\r\n        // Store the saved state so it might be accessed at any time\r\n        settings.oLoadedState = $.extend(true, {}, state)\r\n\r\n        // Restore key features - todo - for 1.11 this needs to be done by\r\n        // subscribed events\r\n        settings._iDisplayStart = state.start\r\n        settings.iInitDisplayStart = state.start\r\n        settings._iDisplayLength = state.length\r\n        settings.aaSorting = []\r\n\r\n        // Order\r\n        $.each(state.order, function (i, col) {\r\n          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col)\r\n        })\r\n\r\n        // Search\r\n        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search))\r\n\r\n        // Columns\r\n        for (i = 0, ien = state.columns.length; i < ien; i++) {\r\n          var col = state.columns[i]\r\n\r\n          // Visibility\r\n          columns[i].bVisible = col.visible\r\n\r\n          // Search\r\n          $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search))\r\n        }\r\n\r\n        _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state])\r\n      }\r\n\r\n      /**\r\n       * Return the settings object for a particular table\r\n       *  @param {node} table table we are using as a dataTable\r\n       *  @returns {object} Settings object - or null if not found\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSettingsFromNode (table) {\r\n        var settings = DataTable.settings\r\n        var idx = $.inArray(table, _pluck(settings, 'nTable'))\r\n\r\n        return idx !== -1 ? settings[idx] : null\r\n      }\r\n\r\n      /**\r\n       * Log an error message\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} level log error messages, or display them to the user\r\n       *  @param {string} msg error message\r\n       *  @param {int} tn Technical note id to get more information about the error.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnLog (settings, level, msg, tn) {\r\n        msg = 'DataTables warning: ' + (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg\r\n\r\n        if (tn) {\r\n          msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn\r\n        }\r\n\r\n        if (!level) {\r\n          // Backwards compatibility pre 1.10\r\n          var ext = DataTable.ext\r\n          var type = ext.sErrMode || ext.errMode\r\n\r\n          if (type == 'alert') {\r\n            alert(msg)\r\n          } else {\r\n            throw new Error(msg)\r\n          }\r\n        } else if (window.console && console.log) {\r\n          console.log(msg)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * See if a property is defined on one object, if so assign it to the other object\r\n       *  @param {object} ret target object\r\n       *  @param {object} src source object\r\n       *  @param {string} name property\r\n       *  @param {string} [mappedName] name to map too - optional, name used if not given\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnMap (ret, src, name, mappedName) {\r\n        if ($.isArray(name)) {\r\n          $.each(name, function (i, val) {\r\n            if ($.isArray(val)) {\r\n              _fnMap(ret, src, val[0], val[1])\r\n            } else {\r\n              _fnMap(ret, src, val)\r\n            }\r\n          })\r\n\r\n          return\r\n        }\r\n\r\n        if (mappedName === undefined) {\r\n          mappedName = name\r\n        }\r\n\r\n        if (src[name] !== undefined) {\r\n          ret[mappedName] = src[name]\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Extend objects - very similar to jQuery.extend, but deep copy objects, and\r\n       * shallow copy arrays. The reason we need to do this, is that we don't want to\r\n       * deep copy array init values (such as aaSorting) since the dev wouldn't be\r\n       * able to override them, but we do want to deep copy arrays.\r\n       *  @param {object} out Object to extend\r\n       *  @param {object} extender Object from which the properties will be applied to\r\n       *      out\r\n       *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\r\n       *      independent copy with the exception of the `data` or `aaData` parameters\r\n       *      if they are present. This is so you can pass in a collection to\r\n       *      DataTables and have that used as your data source without breaking the\r\n       *      references\r\n       *  @returns {object} out Reference, just for convenience - out === the return.\r\n       *  @memberof DataTable#oApi\r\n       *  @todo This doesn't take account of arrays inside the deep copied objects.\r\n       */\r\n      function _fnExtend (out, extender, breakRefs) {\r\n        var val\r\n\r\n        for (var prop in extender) {\r\n          if (extender.hasOwnProperty(prop)) {\r\n            val = extender[prop]\r\n\r\n            if ($.isPlainObject(val)) {\r\n              if (!$.isPlainObject(out[prop])) {\r\n                out[prop] = {}\r\n              }\r\n              $.extend(true, out[prop], val)\r\n            } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {\r\n              out[prop] = val.slice()\r\n            } else {\r\n              out[prop] = val\r\n            }\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      /**\r\n       * Bind an event handers to allow a click or return key to activate the callback.\r\n       * This is good for accessibility since a return on the keyboard will have the\r\n       * same effect as a click, if the element has focus.\r\n       *  @param {element} n Element to bind the action to\r\n       *  @param {object} oData Data object to pass to the triggered function\r\n       *  @param {function} fn Callback function for when the event is triggered\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnBindAction (n, oData, fn) {\r\n        $(n)\r\n          .bind('click.DT', oData, function (e) {\r\n            n.blur() // Remove focus outline for mouse users\r\n            fn(e)\r\n          })\r\n          .bind('keypress.DT', oData, function (e) {\r\n            if (e.which === 13) {\r\n              e.preventDefault()\r\n              fn(e)\r\n            }\r\n          })\r\n          .bind('selectstart.DT', function () {\r\n            /* Take the brutal approach to cancelling text selection */\r\n            return false\r\n          })\r\n      }\r\n\r\n      /**\r\n       * Register a callback function. Easily allows a callback function to be added to\r\n       * an array store of callback functions that can then all be called together.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {string} sStore Name of the array storage for the callbacks in oSettings\r\n       *  @param {function} fn Function to be called back\r\n       *  @param {string} sName Identifying name for the callback (i.e. a label)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCallbackReg (oSettings, sStore, fn, sName) {\r\n        if (fn) {\r\n          oSettings[sStore].push({\r\n            fn: fn,\r\n            sName: sName\r\n          })\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Fire callback functions and trigger events. Note that the loop over the\r\n       * callback array store is done backwards! Further note that you do not want to\r\n       * fire off triggers in time sensitive applications (for example cell creation)\r\n       * as its slow.\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {string} callbackArr Name of the array storage for the callbacks in\r\n       *      oSettings\r\n       *  @param {string} event Name of the jQuery custom event to trigger. If null no\r\n       *      trigger is fired\r\n       *  @param {array} args Array of arguments to pass to the callback function /\r\n       *      trigger\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCallbackFire (settings, callbackArr, e, args) {\r\n        var ret = []\r\n\r\n        if (callbackArr) {\r\n          ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {\r\n            return val.fn.apply(settings.oInstance, args)\r\n          })\r\n        }\r\n\r\n        if (e !== null) {\r\n          $(settings.nTable).trigger(e + '.dt', args)\r\n        }\r\n\r\n        return ret\r\n      }\r\n\r\n      function _fnLengthOverflow (settings) {\r\n        var start = settings._iDisplayStart,\r\n          end = settings.fnDisplayEnd(),\r\n          len = settings._iDisplayLength\r\n\r\n        /* If we have space to show extra rows (backing up from the end point - then do so */\r\n        if (end === settings.fnRecordsDisplay()) {\r\n          start = end - len\r\n        }\r\n\r\n        if (len === -1 || start < 0) {\r\n          start = 0\r\n        }\r\n\r\n        settings._iDisplayStart = start\r\n      }\r\n\r\n      function _fnRenderer (settings, type) {\r\n        var renderer = settings.renderer\r\n        var host = DataTable.ext.renderer[type]\r\n\r\n        if ($.isPlainObject(renderer) && renderer[type]) {\r\n          // Specific renderer for this type. If available use it, otherwise use\r\n          // the default.\r\n          return host[renderer[type]] || host._\r\n        } else if (typeof renderer === 'string') {\r\n          // Common renderer - if there is one available for this type use it,\r\n          // otherwise use the default\r\n          return host[renderer] || host._\r\n        }\r\n\r\n        // Use the default\r\n        return host._\r\n      }\r\n\r\n      /**\r\n       * Detect the data source being used for the table. Used to simplify the code\r\n       * a little (ajax) and to make it compress a little smaller.\r\n       *\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {string} Data source\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDataSource (settings) {\r\n        if (settings.oFeatures.bServerSide) {\r\n          return 'ssp'\r\n        } else if (settings.ajax || settings.sAjaxSource) {\r\n          return 'ajax'\r\n        }\r\n        return 'dom'\r\n      }\r\n\r\n      DataTable = function (options) {\r\n        /**\r\n         * Perform a jQuery selector action on the table's TR elements (from the tbody) and\r\n         * return the resulting jQuery object.\r\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\r\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\r\n         *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\r\n         *    criterion (\"applied\") or all TR elements (i.e. no filter).\r\n         *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\r\n         *    Can be either 'current', whereby the current sorting of the table is used, or\r\n         *    'original' whereby the original order the data was read into the table is used.\r\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\r\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\r\n         *    'current' and filter is 'applied', regardless of what they might be given as.\r\n         *  @returns {object} jQuery object, filtered by the given selector.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Highlight every second row\r\n         *      oTable.$('tr:odd').css('backgroundColor', 'blue');\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Filter to rows with 'Webkit' in them, add a background colour and then\r\n         *      // remove the filter, thus highlighting the 'Webkit' rows only.\r\n         *      oTable.fnFilter('Webkit');\r\n         *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\r\n         *      oTable.fnFilter('');\r\n         *    } );\r\n         */\r\n        this.$ = function (sSelector, oOpts) {\r\n          return this.api(true).$(sSelector, oOpts)\r\n        }\r\n\r\n        /**\r\n         * Almost identical to $ in operation, but in this case returns the data for the matched\r\n         * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\r\n         * rather than any descendants, so the data can be obtained for the row/cell. If matching\r\n         * rows are found, the data returned is the original data array/object that was used to\r\n         * create the row (or a generated array if from a DOM source).\r\n         *\r\n         * This method is often useful in-combination with $ where both functions are given the\r\n         * same parameters and the array indexes will match identically.\r\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\r\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\r\n         *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\r\n         *    criterion (\"applied\") or all elements (i.e. no filter).\r\n         *  @param {string} [oOpts.order=current] Order of the data in the processed array.\r\n         *    Can be either 'current', whereby the current sorting of the table is used, or\r\n         *    'original' whereby the original order the data was read into the table is used.\r\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\r\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\r\n         *    'current' and filter is 'applied', regardless of what they might be given as.\r\n         *  @returns {array} Data for the matched elements. If any elements, as a result of the\r\n         *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\r\n         *    entry in the array.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Get the data from the first row in the table\r\n         *      var data = oTable._('tr:first');\r\n         *\r\n         *      // Do something useful with the data\r\n         *      alert( \"First cell is: \"+data[0] );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Filter to 'Webkit' and get all data for\r\n         *      oTable.fnFilter('Webkit');\r\n         *      var data = oTable._('tr', {\"search\": \"applied\"});\r\n         *\r\n         *      // Do something with the data\r\n         *      alert( data.length+\" rows matched the search\" );\r\n         *    } );\r\n         */\r\n        this._ = function (sSelector, oOpts) {\r\n          return this.api(true)\r\n            .rows(sSelector, oOpts)\r\n            .data()\r\n        }\r\n\r\n        /**\r\n         * Create a DataTables Api instance, with the currently selected tables for\r\n         * the Api's context.\r\n         * @param {boolean} [traditional=false] Set the API instance's context to be\r\n         *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\r\n         *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\r\n         *   or if all tables captured in the jQuery object should be used.\r\n         * @return {DataTables.Api}\r\n         */\r\n        this.api = function (traditional) {\r\n          return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this)\r\n        }\r\n\r\n        /**\r\n         * Add a single new row or multiple rows of data to the table. Please note\r\n         * that this is suitable for client-side processing only - if you are using\r\n         * server-side processing (i.e. \"bServerSide\": true), then to add data, you\r\n         * must add it to the data source, i.e. the server-side, through an Ajax call.\r\n         *  @param {array|object} data The data to be added to the table. This can be:\r\n         *    <ul>\r\n         *      <li>1D array of data - add a single row with the data provided</li>\r\n         *      <li>2D array of arrays - add multiple rows in a single call</li>\r\n         *      <li>object - data object when using <i>mData</i></li>\r\n         *      <li>array of objects - multiple data objects when using <i>mData</i></li>\r\n         *    </ul>\r\n         *  @param {bool} [redraw=true] redraw the table or not\r\n         *  @returns {array} An array of integers, representing the list of indexes in\r\n         *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\r\n         *    the table.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    // Global var for counter\r\n         *    var giCount = 2;\r\n         *\r\n         *    $(document).ready(function() {\r\n         *      $('#example').dataTable();\r\n         *    } );\r\n         *\r\n         *    function fnClickAddRow() {\r\n         *      $('#example').dataTable().fnAddData( [\r\n         *        giCount+\".1\",\r\n         *        giCount+\".2\",\r\n         *        giCount+\".3\",\r\n         *        giCount+\".4\" ]\r\n         *      );\r\n         *\r\n         *      giCount++;\r\n         *    }\r\n         */\r\n        this.fnAddData = function (data, redraw) {\r\n          var api = this.api(true)\r\n\r\n          /* Check if we want to add multiple rows or not */\r\n          var rows =\r\n            $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data)\r\n\r\n          if (redraw === undefined || redraw) {\r\n            api.draw()\r\n          }\r\n\r\n          return rows.flatten().toArray()\r\n        }\r\n\r\n        /**\r\n         * This function will make DataTables recalculate the column sizes, based on the data\r\n         * contained in the table and the sizes applied to the columns (in the DOM, CSS or\r\n         * through the sWidth parameter). This can be useful when the width of the table's\r\n         * parent element changes (for example a window resize).\r\n         *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable( {\r\n         *        \"sScrollY\": \"200px\",\r\n         *        \"bPaginate\": false\r\n         *      } );\r\n         *\r\n         *      $(window).bind('resize', function () {\r\n         *        oTable.fnAdjustColumnSizing();\r\n         *      } );\r\n         *    } );\r\n         */\r\n        this.fnAdjustColumnSizing = function (bRedraw) {\r\n          var api = this.api(true).columns.adjust()\r\n          var settings = api.settings()[0]\r\n          var scroll = settings.oScroll\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw(false)\r\n          } else if (scroll.sX !== '' || scroll.sY !== '') {\r\n            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\r\n            _fnScrollDraw(settings)\r\n          }\r\n        }\r\n\r\n        /**\r\n         * Quickly and simply clear a table\r\n         *  @param {bool} [bRedraw=true] redraw the table or not\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\r\n         *      oTable.fnClearTable();\r\n         *    } );\r\n         */\r\n        this.fnClearTable = function (bRedraw) {\r\n          var api = this.api(true).clear()\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw()\r\n          }\r\n        }\r\n\r\n        /**\r\n         * The exact opposite of 'opening' a row, this function will close any rows which\r\n         * are currently 'open'.\r\n         *  @param {node} nTr the table row to 'close'\r\n         *  @returns {int} 0 on success, or 1 if failed (can't find the row)\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable;\r\n         *\r\n         *      // 'open' an information row when a row is clicked on\r\n         *      $('#example tbody tr').click( function () {\r\n         *        if ( oTable.fnIsOpen(this) ) {\r\n         *          oTable.fnClose( this );\r\n         *        } else {\r\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\r\n         *        }\r\n         *      } );\r\n         *\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnClose = function (nTr) {\r\n          this.api(true)\r\n            .row(nTr)\r\n            .child.hide()\r\n        }\r\n\r\n        /**\r\n         * Remove a row for the table\r\n         *  @param {mixed} target The index of the row from aoData to be deleted, or\r\n         *    the TR element you want to delete\r\n         *  @param {function|null} [callBack] Callback function\r\n         *  @param {bool} [redraw=true] Redraw the table or not\r\n         *  @returns {array} The row that was deleted\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Immediately remove the first row\r\n         *      oTable.fnDeleteRow( 0 );\r\n         *    } );\r\n         */\r\n        this.fnDeleteRow = function (target, callback, redraw) {\r\n          var api = this.api(true)\r\n          var rows = api.rows(target)\r\n          var settings = rows.settings()[0]\r\n          var data = settings.aoData[rows[0][0]]\r\n\r\n          rows.remove()\r\n\r\n          if (callback) {\r\n            callback.call(this, settings, data)\r\n          }\r\n\r\n          if (redraw === undefined || redraw) {\r\n            api.draw()\r\n          }\r\n\r\n          return data\r\n        }\r\n\r\n        /**\r\n         * Restore the table to it's original state in the DOM by removing all of DataTables\r\n         * enhancements, alterations to the DOM structure of the table and event listeners.\r\n         *  @param {boolean} [remove=false] Completely remove the table from the DOM\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\r\n         *      var oTable = $('#example').dataTable();\r\n         *      oTable.fnDestroy();\r\n         *    } );\r\n         */\r\n        this.fnDestroy = function (remove) {\r\n          this.api(true).destroy(remove)\r\n        }\r\n\r\n        /**\r\n         * Redraw the table\r\n         *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\r\n         *      oTable.fnDraw();\r\n         *    } );\r\n         */\r\n        this.fnDraw = function (complete) {\r\n          // Note that this isn't an exact match to the old call to _fnDraw - it takes\r\n          // into account the new data, but can old position.\r\n          this.api(true).draw(!complete)\r\n        }\r\n\r\n        /**\r\n         * Filter the input based on data\r\n         *  @param {string} sInput String to filter the table on\r\n         *  @param {int|null} [iColumn] Column to limit filtering to\r\n         *  @param {bool} [bRegex=false] Treat as regular expression or not\r\n         *  @param {bool} [bSmart=true] Perform smart filtering or not\r\n         *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\r\n         *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Sometime later - filter...\r\n         *      oTable.fnFilter( 'test string' );\r\n         *    } );\r\n         */\r\n        this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {\r\n          var api = this.api(true)\r\n\r\n          if (iColumn === null || iColumn === undefined) {\r\n            api.search(sInput, bRegex, bSmart, bCaseInsensitive)\r\n          } else {\r\n            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive)\r\n          }\r\n\r\n          api.draw()\r\n        }\r\n\r\n        /**\r\n         * Get the data for the whole table, an individual row or an individual cell based on the\r\n         * provided parameters.\r\n         *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\r\n         *    a TR node then the data source for the whole row will be returned. If given as a\r\n         *    TD/TH cell node then iCol will be automatically calculated and the data for the\r\n         *    cell returned. If given as an integer, then this is treated as the aoData internal\r\n         *    data index for the row (see fnGetPosition) and the data for that row used.\r\n         *  @param {int} [col] Optional column index that you want the data of.\r\n         *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\r\n         *    returned. If mRow is defined, just data for that row, and is iCol is\r\n         *    defined, only data for the designated cell is returned.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    // Row data\r\n         *    $(document).ready(function() {\r\n         *      oTable = $('#example').dataTable();\r\n         *\r\n         *      oTable.$('tr').click( function () {\r\n         *        var data = oTable.fnGetData( this );\r\n         *        // ... do something with the array / object of data for the row\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Individual cell data\r\n         *    $(document).ready(function() {\r\n         *      oTable = $('#example').dataTable();\r\n         *\r\n         *      oTable.$('td').click( function () {\r\n         *        var sData = oTable.fnGetData( this );\r\n         *        alert( 'The cell clicked on had the value of '+sData );\r\n         *      } );\r\n         *    } );\r\n         */\r\n        this.fnGetData = function (src, col) {\r\n          var api = this.api(true)\r\n\r\n          if (src !== undefined) {\r\n            var type = src.nodeName ? src.nodeName.toLowerCase() : ''\r\n\r\n            return col !== undefined || type == 'td' || type == 'th'\r\n              ? api.cell(src, col).data()\r\n              : api.row(src).data() || null\r\n          }\r\n\r\n          return api.data().toArray()\r\n        }\r\n\r\n        /**\r\n         * Get an array of the TR nodes that are used in the table's body. Note that you will\r\n         * typically want to use the '$' API method in preference to this as it is more\r\n         * flexible.\r\n         *  @param {int} [iRow] Optional row index for the TR element you want\r\n         *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\r\n         *    in the table's body, or iRow is defined, just the TR element requested.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Get the nodes from the table\r\n         *      var nNodes = oTable.fnGetNodes( );\r\n         *    } );\r\n         */\r\n        this.fnGetNodes = function (iRow) {\r\n          var api = this.api(true)\r\n\r\n          return iRow !== undefined\r\n            ? api.row(iRow).node()\r\n            : api\r\n                .rows()\r\n                .nodes()\r\n                .flatten()\r\n                .toArray()\r\n        }\r\n\r\n        /**\r\n         * Get the array indexes of a particular cell from it's DOM element\r\n         * and column index including hidden columns\r\n         *  @param {node} node this can either be a TR, TD or TH in the table's body\r\n         *  @returns {int} If nNode is given as a TR, then a single index is returned, or\r\n         *    if given as a cell, an array of [row index, column index (visible),\r\n         *    column index (all)] is given.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      $('#example tbody td').click( function () {\r\n         *        // Get the position of the current data from the node\r\n         *        var aPos = oTable.fnGetPosition( this );\r\n         *\r\n         *        // Get the data array for this row\r\n         *        var aData = oTable.fnGetData( aPos[0] );\r\n         *\r\n         *        // Update the data array and return the value\r\n         *        aData[ aPos[1] ] = 'clicked';\r\n         *        this.innerHTML = 'clicked';\r\n         *      } );\r\n         *\r\n         *      // Init DataTables\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnGetPosition = function (node) {\r\n          var api = this.api(true)\r\n          var nodeName = node.nodeName.toUpperCase()\r\n\r\n          if (nodeName == 'TR') {\r\n            return api.row(node).index()\r\n          } else if (nodeName == 'TD' || nodeName == 'TH') {\r\n            var cell = api.cell(node).index()\r\n\r\n            return [cell.row, cell.columnVisible, cell.column]\r\n          }\r\n          return null\r\n        }\r\n\r\n        /**\r\n         * Check to see if a row is 'open' or not.\r\n         *  @param {node} nTr the table row to check\r\n         *  @returns {boolean} true if the row is currently open, false otherwise\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable;\r\n         *\r\n         *      // 'open' an information row when a row is clicked on\r\n         *      $('#example tbody tr').click( function () {\r\n         *        if ( oTable.fnIsOpen(this) ) {\r\n         *          oTable.fnClose( this );\r\n         *        } else {\r\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\r\n         *        }\r\n         *      } );\r\n         *\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnIsOpen = function (nTr) {\r\n          return this.api(true)\r\n            .row(nTr)\r\n            .child.isShown()\r\n        }\r\n\r\n        /**\r\n         * This function will place a new row directly after a row which is currently\r\n         * on display on the page, with the HTML contents that is passed into the\r\n         * function. This can be used, for example, to ask for confirmation that a\r\n         * particular record should be deleted.\r\n         *  @param {node} nTr The table row to 'open'\r\n         *  @param {string|node|jQuery} mHtml The HTML to put into the row\r\n         *  @param {string} sClass Class to give the new TD cell\r\n         *  @returns {node} The row opened. Note that if the table row passed in as the\r\n         *    first parameter, is not found in the table, this method will silently\r\n         *    return.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable;\r\n         *\r\n         *      // 'open' an information row when a row is clicked on\r\n         *      $('#example tbody tr').click( function () {\r\n         *        if ( oTable.fnIsOpen(this) ) {\r\n         *          oTable.fnClose( this );\r\n         *        } else {\r\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\r\n         *        }\r\n         *      } );\r\n         *\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnOpen = function (nTr, mHtml, sClass) {\r\n          return this.api(true)\r\n            .row(nTr)\r\n            .child(mHtml, sClass)\r\n            .show()\r\n            .child()[0]\r\n        }\r\n\r\n        /**\r\n         * Change the pagination - provides the internal logic for pagination in a simple API\r\n         * function. With this function you can have a DataTables table go to the next,\r\n         * previous, first or last pages.\r\n         *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\r\n         *    or page number to jump to (integer), note that page 0 is the first page.\r\n         *  @param {bool} [bRedraw=true] Redraw the table or not\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      oTable.fnPageChange( 'next' );\r\n         *    } );\r\n         */\r\n        this.fnPageChange = function (mAction, bRedraw) {\r\n          var api = this.api(true).page(mAction)\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw(false)\r\n          }\r\n        }\r\n\r\n        /**\r\n         * Show a particular column\r\n         *  @param {int} iCol The column whose display should be changed\r\n         *  @param {bool} bShow Show (true) or hide (false) the column\r\n         *  @param {bool} [bRedraw=true] Redraw the table or not\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Hide the second column after initialisation\r\n         *      oTable.fnSetColumnVis( 1, false );\r\n         *    } );\r\n         */\r\n        this.fnSetColumnVis = function (iCol, bShow, bRedraw) {\r\n          var api = this.api(true)\r\n            .column(iCol)\r\n            .visible(bShow)\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.columns.adjust().draw()\r\n          }\r\n        }\r\n\r\n        /**\r\n         * Get the settings for a particular table for external manipulation\r\n         *  @returns {object} DataTables settings object. See\r\n         *    {@link DataTable.models.oSettings}\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      var oSettings = oTable.fnSettings();\r\n         *\r\n         *      // Show an example parameter from the settings\r\n         *      alert( oSettings._iDisplayStart );\r\n         *    } );\r\n         */\r\n        this.fnSettings = function () {\r\n          return _fnSettingsFromNode(this[_ext.iApiIndex])\r\n        }\r\n\r\n        /**\r\n         * Sort the table by a particular column\r\n         *  @param {int} iCol the data index to sort on. Note that this will not match the\r\n         *    'display index' if you have hidden data entries\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Sort immediately with columns 0 and 1\r\n         *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\r\n         *    } );\r\n         */\r\n        this.fnSort = function (aaSort) {\r\n          this.api(true)\r\n            .order(aaSort)\r\n            .draw()\r\n        }\r\n\r\n        /**\r\n         * Attach a sort listener to an element for a given column\r\n         *  @param {node} nNode the element to attach the sort listener to\r\n         *  @param {int} iColumn the column that a click on this node will sort on\r\n         *  @param {function} [fnCallback] callback function when sort is run\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Sort on column 1, when 'sorter' is clicked on\r\n         *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\r\n         *    } );\r\n         */\r\n        this.fnSortListener = function (nNode, iColumn, fnCallback) {\r\n          this.api(true).order.listener(nNode, iColumn, fnCallback)\r\n        }\r\n\r\n        /**\r\n         * Update a table cell or row - this method will accept either a single value to\r\n         * update the cell with, an array of values with one element for each column or\r\n         * an object in the same format as the original data source. The function is\r\n         * self-referencing in order to make the multi column updates easier.\r\n         *  @param {object|array|string} mData Data to update the cell/row with\r\n         *  @param {node|int} mRow TR element you want to update or the aoData index\r\n         *  @param {int} [iColumn] The column to update, give as null or undefined to\r\n         *    update a whole row.\r\n         *  @param {bool} [bRedraw=true] Redraw the table or not\r\n         *  @param {bool} [bAction=true] Perform pre-draw actions or not\r\n         *  @returns {int} 0 on success, 1 on error\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\r\n         *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\r\n         *    } );\r\n         */\r\n        this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {\r\n          var api = this.api(true)\r\n\r\n          if (iColumn === undefined || iColumn === null) {\r\n            api.row(mRow).data(mData)\r\n          } else {\r\n            api.cell(mRow, iColumn).data(mData)\r\n          }\r\n\r\n          if (bAction === undefined || bAction) {\r\n            api.columns.adjust()\r\n          }\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw()\r\n          }\r\n          return 0\r\n        }\r\n\r\n        /**\r\n         * Provide a common method for plug-ins to check the version of DataTables being used, in order\r\n         * to ensure compatibility.\r\n         *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\r\n         *    formats \"X\" and \"X.Y\" are also acceptable.\r\n         *  @returns {boolean} true if this version of DataTables is greater or equal to the required\r\n         *    version, or false if this version of DataTales is not suitable\r\n         *  @method\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      alert( oTable.fnVersionCheck( '1.9.0' ) );\r\n         *    } );\r\n         */\r\n        this.fnVersionCheck = _ext.fnVersionCheck\r\n\r\n        var _that = this\r\n        var emptyInit = options === undefined\r\n        var len = this.length\r\n\r\n        if (emptyInit) {\r\n          options = {}\r\n        }\r\n\r\n        this.oApi = this.internal = _ext.internal\r\n\r\n        // Extend with old style plug-in API methods\r\n        for (var fn in DataTable.ext.internal) {\r\n          if (fn) {\r\n            this[fn] = _fnExternApiFunc(fn)\r\n          }\r\n        }\r\n\r\n        this.each(function () {\r\n          // For each initialisation we want to give it a clean initialisation\r\n          // object that can be bashed around\r\n          var o = {}\r\n          var oInit =\r\n            len > 1 // optimisation for single table case\r\n              ? _fnExtend(o, options, true)\r\n              : options\r\n\r\n          /*global oInit,_that,emptyInit*/\r\n          var i = 0,\r\n            iLen,\r\n            j,\r\n            jLen,\r\n            k,\r\n            kLen\r\n          var sId = this.getAttribute('id')\r\n          var bInitHandedOff = false\r\n          var defaults = DataTable.defaults\r\n\r\n          /* Sanity check */\r\n          if (this.nodeName.toLowerCase() != 'table') {\r\n            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2)\r\n            return\r\n          }\r\n\r\n          /* Backwards compatibility for the defaults */\r\n          _fnCompatOpts(defaults)\r\n          _fnCompatCols(defaults.column)\r\n\r\n          /* Convert the camel-case defaults to Hungarian */\r\n          _fnCamelToHungarian(defaults, defaults, true)\r\n          _fnCamelToHungarian(defaults.column, defaults.column, true)\r\n\r\n          /* Setting up the initialisation object */\r\n          _fnCamelToHungarian(defaults, oInit)\r\n\r\n          /* Check to see if we are re-initialising a table */\r\n          var allSettings = DataTable.settings\r\n          for (i = 0, iLen = allSettings.length; i < iLen; i++) {\r\n            /* Base check on table node */\r\n            if (allSettings[i].nTable == this) {\r\n              var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve\r\n              var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy\r\n\r\n              if (emptyInit || bRetrieve) {\r\n                return allSettings[i].oInstance\r\n              } else if (bDestroy) {\r\n                allSettings[i].oInstance.fnDestroy()\r\n                break\r\n              } else {\r\n                _fnLog(allSettings[i], 0, 'Cannot reinitialise DataTable', 3)\r\n                return\r\n              }\r\n            }\r\n\r\n            /* If the element we are initialising has the same ID as a table which was previously\r\n             * initialised, but the table nodes don't match (from before) then we destroy the old\r\n             * instance by simply deleting it. This is under the assumption that the table has been\r\n             * destroyed by other methods. Anyone using non-id selectors will need to do this manually\r\n             */\r\n            if (allSettings[i].sTableId == this.id) {\r\n              allSettings.splice(i, 1)\r\n              break\r\n            }\r\n          }\r\n\r\n          /* Ensure the table has an ID - required for accessibility */\r\n          if (sId === null || sId === '') {\r\n            sId = 'DataTables_Table_' + DataTable.ext._unique++\r\n            this.id = sId\r\n          }\r\n\r\n          /* Create the settings object for this table and set some of the default parameters */\r\n          var oSettings = $.extend(true, {}, DataTable.models.oSettings, {\r\n            nTable: this,\r\n            oApi: _that.internal,\r\n            oInit: oInit,\r\n            sDestroyWidth: $(this)[0].style.width,\r\n            sInstance: sId,\r\n            sTableId: sId\r\n          })\r\n          allSettings.push(oSettings)\r\n\r\n          // Need to add the instance after the instance after the settings object has been added\r\n          // to the settings array, so we can self reference the table instance if more than one\r\n          oSettings.oInstance = _that.length === 1 ? _that : $(this).dataTable()\r\n\r\n          // Backwards compatibility, before we apply all the defaults\r\n          _fnCompatOpts(oInit)\r\n\r\n          if (oInit.oLanguage) {\r\n            _fnLanguageCompat(oInit.oLanguage)\r\n          }\r\n\r\n          // If the length menu is given, but the init display length is not, use the length menu\r\n          if (oInit.aLengthMenu && !oInit.iDisplayLength) {\r\n            oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0]\r\n          }\r\n\r\n          // Apply the defaults and init options to make a single init object will all\r\n          // options defined from defaults and instance options.\r\n          oInit = _fnExtend($.extend(true, {}, defaults), oInit)\r\n\r\n          // Map the initialisation options onto the settings object\r\n          _fnMap(oSettings.oFeatures, oInit, [\r\n            'bPaginate',\r\n            'bLengthChange',\r\n            'bFilter',\r\n            'bSort',\r\n            'bSortMulti',\r\n            'bInfo',\r\n            'bProcessing',\r\n            'bAutoWidth',\r\n            'bSortClasses',\r\n            'bServerSide',\r\n            'bDeferRender'\r\n          ])\r\n          _fnMap(oSettings, oInit, [\r\n            'asStripeClasses',\r\n            'ajax',\r\n            'fnServerData',\r\n            'fnFormatNumber',\r\n            'sServerMethod',\r\n            'aaSorting',\r\n            'aaSortingFixed',\r\n            'aLengthMenu',\r\n            'sPaginationType',\r\n            'sAjaxSource',\r\n            'sAjaxDataProp',\r\n            'iStateDuration',\r\n            'sDom',\r\n            'bSortCellsTop',\r\n            'iTabIndex',\r\n            'fnStateLoadCallback',\r\n            'fnStateSaveCallback',\r\n            'renderer',\r\n            ['iCookieDuration', 'iStateDuration'], // backwards compat\r\n            ['oSearch', 'oPreviousSearch'],\r\n            ['aoSearchCols', 'aoPreSearchCols'],\r\n            ['iDisplayLength', '_iDisplayLength'],\r\n            ['bJQueryUI', 'bJUI']\r\n          ])\r\n          _fnMap(oSettings.oScroll, oInit, [\r\n            ['sScrollX', 'sX'],\r\n            ['sScrollXInner', 'sXInner'],\r\n            ['sScrollY', 'sY'],\r\n            ['bScrollCollapse', 'bCollapse']\r\n          ])\r\n          _fnMap(oSettings.oLanguage, oInit, 'fnInfoCallback')\r\n\r\n          /* Callback functions which are array driven */\r\n          _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user')\r\n          _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user')\r\n          _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user')\r\n          _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user')\r\n          _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user')\r\n          _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user')\r\n          _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user')\r\n\r\n          var oClasses = oSettings.oClasses\r\n\r\n          // @todo Remove in 1.11\r\n          if (oInit.bJQueryUI) {\r\n            /* Use the JUI classes object for display. You could clone the oStdClasses object if\r\n             * you want to have multiple tables with multiple independent classes\r\n             */\r\n            $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses)\r\n\r\n            if (oInit.sDom === defaults.sDom && defaults.sDom === 'lfrtip') {\r\n              /* Set the DOM to use a layout suitable for jQuery UI's theming */\r\n              oSettings.sDom = '<\"H\"lfr>t<\"F\"ip>'\r\n            }\r\n\r\n            if (!oSettings.renderer) {\r\n              oSettings.renderer = 'jqueryui'\r\n            } else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {\r\n              oSettings.renderer.header = 'jqueryui'\r\n            }\r\n          } else {\r\n            $.extend(oClasses, DataTable.ext.classes, oInit.oClasses)\r\n          }\r\n          $(this).addClass(oClasses.sTable)\r\n\r\n          /* Calculate the scroll bar width and cache it for use later on */\r\n          if (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '') {\r\n            oSettings.oScroll.iBarWidth = _fnScrollBarWidth()\r\n          }\r\n          if (oSettings.oScroll.sX === true) {\r\n            // Easy initialisation of x-scrolling\r\n            oSettings.oScroll.sX = '100%'\r\n          }\r\n\r\n          if (oSettings.iInitDisplayStart === undefined) {\r\n            /* Display start point, taking into account the save saving */\r\n            oSettings.iInitDisplayStart = oInit.iDisplayStart\r\n            oSettings._iDisplayStart = oInit.iDisplayStart\r\n          }\r\n\r\n          if (oInit.iDeferLoading !== null) {\r\n            oSettings.bDeferLoading = true\r\n            var tmp = $.isArray(oInit.iDeferLoading)\r\n            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading\r\n            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading\r\n          }\r\n\r\n          /* Language definitions */\r\n          if (oInit.oLanguage.sUrl !== '') {\r\n            /* Get the language definitions from a file - because this Ajax call makes the language\r\n             * get async to the remainder of this function we use bInitHandedOff to indicate that\r\n             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\r\n             */\r\n            oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl\r\n            $.getJSON(oSettings.oLanguage.sUrl, null, function (json) {\r\n              _fnLanguageCompat(json)\r\n              _fnCamelToHungarian(defaults.oLanguage, json)\r\n              $.extend(true, oSettings.oLanguage, oInit.oLanguage, json)\r\n              _fnInitialise(oSettings)\r\n            })\r\n            bInitHandedOff = true\r\n          } else {\r\n            $.extend(true, oSettings.oLanguage, oInit.oLanguage)\r\n          }\r\n\r\n          /*\r\n           * Stripes\r\n           */\r\n          if (oInit.asStripeClasses === null) {\r\n            oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven]\r\n          }\r\n\r\n          /* Remove row stripe classes if they are already on the table row */\r\n          var stripeClasses = oSettings.asStripeClasses\r\n          var rowOne = $('tbody tr:eq(0)', this)\r\n          if (\r\n            $.inArray(\r\n              true,\r\n              $.map(stripeClasses, function (el, i) {\r\n                return rowOne.hasClass(el)\r\n              })\r\n            ) !== -1\r\n          ) {\r\n            $('tbody tr', this).removeClass(stripeClasses.join(' '))\r\n            oSettings.asDestroyStripes = stripeClasses.slice()\r\n          }\r\n\r\n          /*\r\n           * Columns\r\n           * See if we should load columns automatically or use defined ones\r\n           */\r\n          var anThs = []\r\n          var aoColumnsInit\r\n          var nThead = this.getElementsByTagName('thead')\r\n          if (nThead.length !== 0) {\r\n            _fnDetectHeader(oSettings.aoHeader, nThead[0])\r\n            anThs = _fnGetUniqueThs(oSettings)\r\n          }\r\n\r\n          /* If not given a column array, generate one with nulls */\r\n          if (oInit.aoColumns === null) {\r\n            aoColumnsInit = []\r\n            for (i = 0, iLen = anThs.length; i < iLen; i++) {\r\n              aoColumnsInit.push(null)\r\n            }\r\n          } else {\r\n            aoColumnsInit = oInit.aoColumns\r\n          }\r\n\r\n          /* Add the columns */\r\n          for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {\r\n            _fnAddColumn(oSettings, anThs ? anThs[i] : null)\r\n          }\r\n\r\n          /* Apply the column definitions */\r\n          _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\r\n            _fnColumnOptions(oSettings, iCol, oDef)\r\n          })\r\n\r\n          /* HTML5 attribute detection - build an mData object automatically if the\r\n           * attributes are found\r\n           */\r\n          if (rowOne.length) {\r\n            var a = function (cell, name) {\r\n              return cell.getAttribute('data-' + name) ? name : null\r\n            }\r\n\r\n            $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {\r\n              var col = oSettings.aoColumns[i]\r\n\r\n              if (col.mData === i) {\r\n                var sort = a(cell, 'sort') || a(cell, 'order')\r\n                var filter = a(cell, 'filter') || a(cell, 'search')\r\n\r\n                if (sort !== null || filter !== null) {\r\n                  col.mData = {\r\n                    _: i + '.display',\r\n                    sort: sort !== null ? i + '.@data-' + sort : undefined,\r\n                    type: sort !== null ? i + '.@data-' + sort : undefined,\r\n                    filter: filter !== null ? i + '.@data-' + filter : undefined\r\n                  }\r\n\r\n                  _fnColumnOptions(oSettings, i)\r\n                }\r\n              }\r\n            })\r\n          }\r\n\r\n          var features = oSettings.oFeatures\r\n\r\n          /* Must be done after everything which can be overridden by the state saving! */\r\n          if (oInit.bStateSave) {\r\n            features.bStateSave = true\r\n            _fnLoadState(oSettings, oInit)\r\n            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save')\r\n          }\r\n\r\n          /*\r\n           * Sorting\r\n           * @todo For modularisation (1.11) this needs to do into a sort start up handler\r\n           */\r\n\r\n          // If aaSorting is not defined, then we use the first indicator in asSorting\r\n          // in case that has been altered, so the default sort reflects that option\r\n          if (oInit.aaSorting === undefined) {\r\n            var sorting = oSettings.aaSorting\r\n            for (i = 0, iLen = sorting.length; i < iLen; i++) {\r\n              sorting[i][1] = oSettings.aoColumns[i].asSorting[0]\r\n            }\r\n          }\r\n\r\n          /* Do a first pass on the sorting classes (allows any size changes to be taken into\r\n           * account, and also will apply sorting disabled classes if disabled\r\n           */\r\n          _fnSortingClasses(oSettings)\r\n\r\n          if (features.bSort) {\r\n            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {\r\n              if (oSettings.bSorted) {\r\n                var aSort = _fnSortFlatten(oSettings)\r\n                var sortedColumns = {}\r\n\r\n                $.each(aSort, function (i, val) {\r\n                  sortedColumns[val.src] = val.dir\r\n                })\r\n\r\n                _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns])\r\n                _fnSortAria(oSettings)\r\n              }\r\n            })\r\n          }\r\n\r\n          _fnCallbackReg(\r\n            oSettings,\r\n            'aoDrawCallback',\r\n            function () {\r\n              if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {\r\n                _fnSortingClasses(oSettings)\r\n              }\r\n            },\r\n            'sc'\r\n          )\r\n\r\n          /*\r\n           * Final init\r\n           * Cache the header, body and footer as required, creating them if needed\r\n           */\r\n\r\n          /* Browser support detection */\r\n          _fnBrowserDetect(oSettings)\r\n\r\n          // Work around for Webkit bug 83867 - store the caption-side before removing from doc\r\n          var captions = $(this)\r\n            .children('caption')\r\n            .each(function () {\r\n              this._captionSide = $(this).css('caption-side')\r\n            })\r\n\r\n          var thead = $(this).children('thead')\r\n          if (thead.length === 0) {\r\n            thead = $('<thead/>').appendTo(this)\r\n          }\r\n          oSettings.nTHead = thead[0]\r\n\r\n          var tbody = $(this).children('tbody')\r\n          if (tbody.length === 0) {\r\n            tbody = $('<tbody/>').appendTo(this)\r\n          }\r\n          oSettings.nTBody = tbody[0]\r\n\r\n          var tfoot = $(this).children('tfoot')\r\n          if (\r\n            tfoot.length === 0 &&\r\n            captions.length > 0 &&\r\n            (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '')\r\n          ) {\r\n            // If we are a scrolling table, and no footer has been given, then we need to create\r\n            // a tfoot element for the caption element to be appended to\r\n            tfoot = $('<tfoot/>').appendTo(this)\r\n          }\r\n\r\n          if (tfoot.length === 0 || tfoot.children().length === 0) {\r\n            $(this).addClass(oClasses.sNoFooter)\r\n          } else if (tfoot.length > 0) {\r\n            oSettings.nTFoot = tfoot[0]\r\n            _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot)\r\n          }\r\n\r\n          /* Check if there is data passing into the constructor */\r\n          if (oInit.aaData) {\r\n            for (i = 0; i < oInit.aaData.length; i++) {\r\n              _fnAddData(oSettings, oInit.aaData[i])\r\n            }\r\n          } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {\r\n            /* Grab the data from the page - only do this when deferred loading or no Ajax\r\n             * source since there is no point in reading the DOM data if we are then going\r\n             * to replace it with Ajax data\r\n             */\r\n            _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'))\r\n          }\r\n\r\n          /* Copy the data index array */\r\n          oSettings.aiDisplay = oSettings.aiDisplayMaster.slice()\r\n\r\n          /* Initialisation complete - table can be drawn */\r\n          oSettings.bInitialised = true\r\n\r\n          /* Check if we need to initialise the table (it might not have been handed off to the\r\n           * language processor)\r\n           */\r\n          if (bInitHandedOff === false) {\r\n            _fnInitialise(oSettings)\r\n          }\r\n        })\r\n        _that = null\r\n        return this\r\n      }\r\n\r\n      /**\r\n       * Computed structure of the DataTables API, defined by the options passed to\r\n       * `DataTable.Api.register()` when building the API.\r\n       *\r\n       * The structure is built in order to speed creation and extension of the Api\r\n       * objects since the extensions are effectively pre-parsed.\r\n       *\r\n       * The array is an array of objects with the following structure, where this\r\n       * base array represents the Api prototype base:\r\n       *\r\n       *     [\r\n       *       {\r\n       *         name:      'data'                -- string   - Property name\r\n       *         val:       function () {},       -- function - Api method (or undefined if just an object\r\n       *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\r\n       *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\r\n       *       },\r\n       *       {\r\n       *         name:     'row'\r\n       *         val:       {},\r\n       *         methodExt: [ ... ],\r\n       *         propExt:   [\r\n       *           {\r\n       *             name:      'data'\r\n       *             val:       function () {},\r\n       *             methodExt: [ ... ],\r\n       *             propExt:   [ ... ]\r\n       *           },\r\n       *           ...\r\n       *         ]\r\n       *       }\r\n       *     ]\r\n       *\r\n       * @type {Array}\r\n       * @ignore\r\n       */\r\n      var __apiStruct = []\r\n\r\n      /**\r\n       * `Array.prototype` reference.\r\n       *\r\n       * @type object\r\n       * @ignore\r\n       */\r\n      var __arrayProto = Array.prototype\r\n\r\n      /**\r\n       * Abstraction for `context` parameter of the `Api` constructor to allow it to\r\n       * take several different forms for ease of use.\r\n       *\r\n       * Each of the input parameter types will be converted to a DataTables settings\r\n       * object where possible.\r\n       *\r\n       * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\r\n       *   of:\r\n       *\r\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\r\n       *     with be found and used.\r\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\r\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\r\n       *   * `object` - DataTables settings object\r\n       *   * `DataTables.Api` - API instance\r\n       * @return {array|null} Matching DataTables settings objects. `null` or\r\n       *   `undefined` is returned if no matching DataTable is found.\r\n       * @ignore\r\n       */\r\n      var _toSettings = function (mixed) {\r\n        var idx, jq\r\n        var settings = DataTable.settings\r\n        var tables = $.map(settings, function (el, i) {\r\n          return el.nTable\r\n        })\r\n\r\n        if (!mixed) {\r\n          return []\r\n        } else if (mixed.nTable && mixed.oApi) {\r\n          // DataTables settings object\r\n          return [mixed]\r\n        } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {\r\n          // Table node\r\n          idx = $.inArray(mixed, tables)\r\n          return idx !== -1 ? [settings[idx]] : null\r\n        } else if (mixed && typeof mixed.settings === 'function') {\r\n          return mixed.settings().toArray()\r\n        } else if (typeof mixed === 'string') {\r\n          // jQuery selector\r\n          jq = $(mixed)\r\n        } else if (mixed instanceof $) {\r\n          // jQuery object (also DataTables instance)\r\n          jq = mixed\r\n        }\r\n\r\n        if (jq) {\r\n          return jq\r\n            .map(function (i) {\r\n              idx = $.inArray(this, tables)\r\n              return idx !== -1 ? settings[idx] : null\r\n            })\r\n            .toArray()\r\n        }\r\n      }\r\n\r\n      /**\r\n       * DataTables API class - used to control and interface with  one or more\r\n       * DataTables enhanced tables.\r\n       *\r\n       * The API class is heavily based on jQuery, presenting a chainable interface\r\n       * that you can use to interact with tables. Each instance of the API class has\r\n       * a \"context\" - i.e. the tables that it will operate on. This could be a single\r\n       * table, all tables on a page or a sub-set thereof.\r\n       *\r\n       * Additionally the API is designed to allow you to easily work with the data in\r\n       * the tables, retrieving and manipulating it as required. This is done by\r\n       * presenting the API class as an array like interface. The contents of the\r\n       * array depend upon the actions requested by each method (for example\r\n       * `rows().nodes()` will return an array of nodes, while `rows().data()` will\r\n       * return an array of objects or arrays depending upon your table's\r\n       * configuration). The API object has a number of array like methods (`push`,\r\n       * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\r\n       * `unique` etc) to assist your working with the data held in a table.\r\n       *\r\n       * Most methods (those which return an Api instance) are chainable, which means\r\n       * the return from a method call also has all of the methods available that the\r\n       * top level object had. For example, these two calls are equivalent:\r\n       *\r\n       *     // Not chained\r\n       *     api.row.add( {...} );\r\n       *     api.draw();\r\n       *\r\n       *     // Chained\r\n       *     api.row.add( {...} ).draw();\r\n       *\r\n       * @class DataTable.Api\r\n       * @param {array|object|string|jQuery} context DataTable identifier. This is\r\n       *   used to define which DataTables enhanced tables this API will operate on.\r\n       *   Can be one of:\r\n       *\r\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\r\n       *     with be found and used.\r\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\r\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\r\n       *   * `object` - DataTables settings object\r\n       * @param {array} [data] Data to initialise the Api instance with.\r\n       *\r\n       * @example\r\n       *   // Direct initialisation during DataTables construction\r\n       *   var api = $('#example').DataTable();\r\n       *\r\n       * @example\r\n       *   // Initialisation using a DataTables jQuery object\r\n       *   var api = $('#example').dataTable().api();\r\n       *\r\n       * @example\r\n       *   // Initialisation as a constructor\r\n       *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\r\n       */\r\n      _Api = function (context, data) {\r\n        if (!this instanceof _Api) {\r\n          throw 'DT API must be constructed as a new object'\r\n          // or should it do the 'new' for the caller?\r\n          // return new _Api.apply( this, arguments );\r\n        }\r\n\r\n        var settings = []\r\n        var ctxSettings = function (o) {\r\n          var a = _toSettings(o)\r\n          if (a) {\r\n            settings.push.apply(settings, a)\r\n          }\r\n        }\r\n\r\n        if ($.isArray(context)) {\r\n          for (var i = 0, ien = context.length; i < ien; i++) {\r\n            ctxSettings(context[i])\r\n          }\r\n        } else {\r\n          ctxSettings(context)\r\n        }\r\n\r\n        // Remove duplicates\r\n        this.context = _unique(settings)\r\n\r\n        // Initial data\r\n        if (data) {\r\n          this.push.apply(this, data.toArray ? data.toArray() : data)\r\n        }\r\n\r\n        // selector\r\n        this.selector = {\r\n          rows: null,\r\n          cols: null,\r\n          opts: null\r\n        }\r\n\r\n        _Api.extend(this, this, __apiStruct)\r\n      }\r\n\r\n      DataTable.Api = _Api\r\n\r\n      _Api.prototype = /** @lends DataTables.Api */ {\r\n        /**\r\n         * Return a new Api instance, comprised of the data held in the current\r\n         * instance, join with the other array(s) and/or value(s).\r\n         *\r\n         * An alias for `Array.prototype.concat`.\r\n         *\r\n         * @type method\r\n         * @param {*} value1 Arrays and/or values to concatenate.\r\n         * @param {*} [...] Additional arrays and/or values to concatenate.\r\n         * @returns {DataTables.Api} New API instance, comprising of the combined\r\n         *   array.\r\n         */\r\n        concat: __arrayProto.concat,\r\n\r\n        context: [], // array of table settings objects\r\n\r\n        each: function (fn) {\r\n          for (var i = 0, ien = this.length; i < ien; i++) {\r\n            fn.call(this, this[i], i, this)\r\n          }\r\n\r\n          return this\r\n        },\r\n\r\n        eq: function (idx) {\r\n          var ctx = this.context\r\n\r\n          return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null\r\n        },\r\n\r\n        filter: function (fn) {\r\n          var a = []\r\n\r\n          if (__arrayProto.filter) {\r\n            a = __arrayProto.filter.call(this, fn, this)\r\n          } else {\r\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\r\n            for (var i = 0, ien = this.length; i < ien; i++) {\r\n              if (fn.call(this, this[i], i, this)) {\r\n                a.push(this[i])\r\n              }\r\n            }\r\n          }\r\n\r\n          return new _Api(this.context, a)\r\n        },\r\n\r\n        flatten: function () {\r\n          var a = []\r\n          return new _Api(this.context, a.concat.apply(a, this.toArray()))\r\n        },\r\n\r\n        join: __arrayProto.join,\r\n\r\n        indexOf:\r\n          __arrayProto.indexOf ||\r\n          function (obj, start) {\r\n            for (var i = start || 0, ien = this.length; i < ien; i++) {\r\n              if (this[i] === obj) {\r\n                return i\r\n              }\r\n            }\r\n            return -1\r\n          },\r\n\r\n        // Internal only at the moment - relax?\r\n        iterator: function (flatten, type, fn) {\r\n          var a = [],\r\n            ret,\r\n            i,\r\n            ien,\r\n            j,\r\n            jen,\r\n            context = this.context,\r\n            rows,\r\n            items,\r\n            item,\r\n            selector = this.selector\r\n\r\n          // Argument shifting\r\n          if (typeof flatten === 'string') {\r\n            fn = type\r\n            type = flatten\r\n            flatten = false\r\n          }\r\n\r\n          for (i = 0, ien = context.length; i < ien; i++) {\r\n            if (type === 'table') {\r\n              ret = fn(context[i], i)\r\n\r\n              if (ret !== undefined) {\r\n                a.push(ret)\r\n              }\r\n            } else if (type === 'columns' || type === 'rows') {\r\n              // this has same length as context - one entry for each table\r\n              ret = fn(context[i], this[i], i)\r\n\r\n              if (ret !== undefined) {\r\n                a.push(ret)\r\n              }\r\n            } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {\r\n              // columns and rows share the same structure.\r\n              // 'this' is an array of column indexes for each context\r\n              items = this[i]\r\n\r\n              if (type === 'column-rows') {\r\n                rows = _selector_row_indexes(context[i], selector.opts)\r\n              }\r\n\r\n              for (j = 0, jen = items.length; j < jen; j++) {\r\n                item = items[j]\r\n\r\n                if (type === 'cell') {\r\n                  ret = fn(context[i], item.row, item.column, i, j)\r\n                } else {\r\n                  ret = fn(context[i], item, i, j, rows)\r\n                }\r\n\r\n                if (ret !== undefined) {\r\n                  a.push(ret)\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (a.length) {\r\n            var api = new _Api(context, flatten ? a.concat.apply([], a) : a)\r\n            var apiSelector = api.selector\r\n            apiSelector.rows = selector.rows\r\n            apiSelector.cols = selector.cols\r\n            apiSelector.opts = selector.opts\r\n            return api\r\n          }\r\n          return this\r\n        },\r\n\r\n        lastIndexOf:\r\n          __arrayProto.lastIndexOf ||\r\n          function (obj, start) {\r\n            // Bit cheeky...\r\n            return this.indexOf.apply(this.toArray.reverse(), arguments)\r\n          },\r\n\r\n        length: 0,\r\n\r\n        map: function (fn) {\r\n          var a = []\r\n\r\n          if (__arrayProto.map) {\r\n            a = __arrayProto.map.call(this, fn, this)\r\n          } else {\r\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\r\n            for (var i = 0, ien = this.length; i < ien; i++) {\r\n              a.push(fn.call(this, this[i], i))\r\n            }\r\n          }\r\n\r\n          return new _Api(this.context, a)\r\n        },\r\n\r\n        pluck: function (prop) {\r\n          return this.map(function (el) {\r\n            return el[prop]\r\n          })\r\n        },\r\n\r\n        pop: __arrayProto.pop,\r\n\r\n        push: __arrayProto.push,\r\n\r\n        // Does not return an API instance\r\n        reduce:\r\n          __arrayProto.reduce ||\r\n          function (fn, init) {\r\n            return _fnReduce(this, fn, init, 0, this.length, 1)\r\n          },\r\n\r\n        reduceRight:\r\n          __arrayProto.reduceRight ||\r\n          function (fn, init) {\r\n            return _fnReduce(this, fn, init, this.length - 1, -1, -1)\r\n          },\r\n\r\n        reverse: __arrayProto.reverse,\r\n\r\n        // Object with rows, columns and opts\r\n        selector: null,\r\n\r\n        shift: __arrayProto.shift,\r\n\r\n        sort: __arrayProto.sort, // ? name - order?\r\n\r\n        splice: __arrayProto.splice,\r\n\r\n        toArray: function () {\r\n          return __arrayProto.slice.call(this)\r\n        },\r\n\r\n        to$: function () {\r\n          return $(this)\r\n        },\r\n\r\n        toJQuery: function () {\r\n          return $(this)\r\n        },\r\n\r\n        unique: function () {\r\n          return new _Api(this.context, _unique(this))\r\n        },\r\n\r\n        unshift: __arrayProto.unshift\r\n      }\r\n\r\n      _Api.extend = function (scope, obj, ext) {\r\n        // Only extend API instances and static properties of the API\r\n        if (!obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {\r\n          return\r\n        }\r\n\r\n        var i,\r\n          ien,\r\n          j,\r\n          jen,\r\n          struct,\r\n          inner,\r\n          methodScoping = function (scope, fn, struc) {\r\n            return function () {\r\n              var ret = fn.apply(scope, arguments)\r\n\r\n              // Method extension\r\n              _Api.extend(ret, ret, struc.methodExt)\r\n              return ret\r\n            }\r\n          }\r\n\r\n        for (i = 0, ien = ext.length; i < ien; i++) {\r\n          struct = ext[i]\r\n\r\n          // Value\r\n          obj[struct.name] =\r\n            typeof struct.val === 'function'\r\n              ? methodScoping(scope, struct.val, struct)\r\n              : $.isPlainObject(struct.val)\r\n              ? {}\r\n              : struct.val\r\n\r\n          obj[struct.name].__dt_wrapper = true\r\n\r\n          // Property extension\r\n          _Api.extend(scope, obj[struct.name], struct.propExt)\r\n        }\r\n      }\r\n\r\n      // @todo - Is there need for an augment function?\r\n      // _Api.augment = function ( inst, name )\r\n      // {\r\n      // \t// Find src object in the structure from the name\r\n      // \tvar parts = name.split('.');\r\n\r\n      // \t_Api.extend( inst, obj );\r\n      // };\r\n\r\n      //     [\r\n      //       {\r\n      //         name:      'data'                -- string   - Property name\r\n      //         val:       function () {},       -- function - Api method (or undefined if just an object\r\n      //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\r\n      //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\r\n      //       },\r\n      //       {\r\n      //         name:     'row'\r\n      //         val:       {},\r\n      //         methodExt: [ ... ],\r\n      //         propExt:   [\r\n      //           {\r\n      //             name:      'data'\r\n      //             val:       function () {},\r\n      //             methodExt: [ ... ],\r\n      //             propExt:   [ ... ]\r\n      //           },\r\n      //           ...\r\n      //         ]\r\n      //       }\r\n      //     ]\r\n\r\n      _Api.register = _api_register = function (name, val) {\r\n        if ($.isArray(name)) {\r\n          for (var j = 0, jen = name.length; j < jen; j++) {\r\n            _Api.register(name[j], val)\r\n          }\r\n          return\r\n        }\r\n\r\n        var i,\r\n          ien,\r\n          heir = name.split('.'),\r\n          struct = __apiStruct,\r\n          key,\r\n          method\r\n\r\n        var find = function (src, name) {\r\n          for (var i = 0, ien = src.length; i < ien; i++) {\r\n            if (src[i].name === name) {\r\n              return src[i]\r\n            }\r\n          }\r\n          return null\r\n        }\r\n\r\n        for (i = 0, ien = heir.length; i < ien; i++) {\r\n          method = heir[i].indexOf('()') !== -1\r\n          key = method ? heir[i].replace('()', '') : heir[i]\r\n\r\n          var src = find(struct, key)\r\n          if (!src) {\r\n            src = {\r\n              name: key,\r\n              val: {},\r\n              methodExt: [],\r\n              propExt: []\r\n            }\r\n            struct.push(src)\r\n          }\r\n\r\n          if (i === ien - 1) {\r\n            src.val = val\r\n          } else {\r\n            struct = method ? src.methodExt : src.propExt\r\n          }\r\n        }\r\n      }\r\n\r\n      _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {\r\n        _Api.register(pluralName, val)\r\n\r\n        _Api.register(singularName, function () {\r\n          var ret = val.apply(this, arguments)\r\n\r\n          if (ret === this) {\r\n            // Returned item is the API instance that was passed in, return it\r\n            return this\r\n          } else if (ret instanceof _Api) {\r\n            // New API instance returned, want the value from the first item\r\n            // in the returned array for the singular result.\r\n            return ret.length\r\n              ? $.isArray(ret[0])\r\n                ? new _Api(ret.context, ret[0]) // Array results are 'enhanced'\r\n                : ret[0]\r\n              : undefined\r\n          }\r\n\r\n          // Non-API return - just fire it back\r\n          return ret\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Selector for HTML tables. Apply the given selector to the give array of\r\n       * DataTables settings objects.\r\n       *\r\n       * @param {string|integer} [selector] jQuery selector string or integer\r\n       * @param  {array} Array of DataTables settings objects to be filtered\r\n       * @return {array}\r\n       * @ignore\r\n       */\r\n      var __table_selector = function (selector, a) {\r\n        // Integer is used to pick out a table by index\r\n        if (typeof selector === 'number') {\r\n          return [a[selector]]\r\n        }\r\n\r\n        // Perform a jQuery selector on the table nodes\r\n        var nodes = $.map(a, function (el, i) {\r\n          return el.nTable\r\n        })\r\n\r\n        return $(nodes)\r\n          .filter(selector)\r\n          .map(function (i) {\r\n            // Need to translate back from the table node to the settings\r\n            var idx = $.inArray(this, nodes)\r\n            return a[idx]\r\n          })\r\n          .toArray()\r\n      }\r\n\r\n      /**\r\n       * Context selector for the API's context (i.e. the tables the API instance\r\n       * refers to.\r\n       *\r\n       * @name    DataTable.Api#tables\r\n       * @param {string|integer} [selector] Selector to pick which tables the iterator\r\n       *   should operate on. If not given, all tables in the current context are\r\n       *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\r\n       *   select multiple tables or as an integer to select a single table.\r\n       * @returns {DataTable.Api} Returns a new API instance if a selector is given.\r\n       */\r\n      _api_register('tables()', function (selector) {\r\n        // A new instance is created if there was a selector specified\r\n        return selector ? new _Api(__table_selector(selector, this.context)) : this\r\n      })\r\n\r\n      _api_register('table()', function (selector) {\r\n        var tables = this.tables(selector)\r\n        var ctx = tables.context\r\n\r\n        // Truncate to the first matched table\r\n        return ctx.length ? new _Api(ctx[0]) : tables\r\n      })\r\n\r\n      _api_registerPlural('tables().nodes()', 'table().node()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTable\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().body()', 'table().body()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTBody\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().header()', 'table().header()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTHead\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().footer()', 'table().footer()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTFoot\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().containers()', 'table().container()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTableWrapper\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Redraw the tables in the current context.\r\n       *\r\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\r\n       *   position. A full re-sort and re-filter is performed when this method is\r\n       *   called, which is why the pagination reset is the default action.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('draw()', function (resetPaging) {\r\n        return this.iterator('table', function (settings) {\r\n          _fnReDraw(settings, resetPaging === false)\r\n        })\r\n      })\r\n      /**\r\n       * Set the current page.\r\n       *\r\n       * Note that if you attempt to show a page which does not exist, DataTables will\r\n       * not throw an error, but rather reset the paging.\r\n       *\r\n       * @param {integer|string} action The paging action to take. This can be one of:\r\n       *  * `integer` - The page index to jump to\r\n       *  * `string` - An action to take:\r\n       *    * `first` - Jump to first page.\r\n       *    * `next` - Jump to the next page\r\n       *    * `previous` - Jump to previous page\r\n       *    * `last` - Jump to the last page.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get the current page index.\r\n       *\r\n       * @return {integer} Current page index (zero based)\r\n       */ _api_register('page()', function (action) {\r\n        if (action === undefined) {\r\n          return this.page.info().page // not an expensive call\r\n        }\r\n\r\n        // else, have an action to take on all tables\r\n        return this.iterator('table', function (settings) {\r\n          _fnPageChange(settings, action)\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Paging information for the first table in the current context.\r\n       *\r\n       * If you require paging information for another table, use the `table()` method\r\n       * with a suitable selector.\r\n       *\r\n       * @return {object} Object with the following properties set:\r\n       *  * `page` - Current page index (zero based - i.e. the first page is `0`)\r\n       *  * `pages` - Total number of pages\r\n       *  * `start` - Display index for the first record shown on the current page\r\n       *  * `end` - Display index for the last record shown on the current page\r\n       *  * `length` - Display length (number of records). Note that generally `start\r\n       *    + length = end`, but this is not always true, for example if there are\r\n       *    only 2 records to show on the final page, with a length of 10.\r\n       *  * `recordsTotal` - Full data set length\r\n       *  * `recordsDisplay` - Data set length once the current filtering criterion\r\n       *    are applied.\r\n       */\r\n      _api_register('page.info()', function (action) {\r\n        if (this.context.length === 0) {\r\n          return undefined\r\n        }\r\n\r\n        var settings = this.context[0],\r\n          start = settings._iDisplayStart,\r\n          len = settings._iDisplayLength,\r\n          visRecords = settings.fnRecordsDisplay(),\r\n          all = len === -1\r\n\r\n        return {\r\n          page: all ? 0 : Math.floor(start / len),\r\n          pages: all ? 1 : Math.ceil(visRecords / len),\r\n          start: start,\r\n          end: settings.fnDisplayEnd(),\r\n          length: len,\r\n          recordsTotal: settings.fnRecordsTotal(),\r\n          recordsDisplay: visRecords\r\n        }\r\n      })\r\n      /**\r\n       * Set the current page length.\r\n       *\r\n       * @param {integer} Page length to set. Use `-1` to show all records.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get the current page length.\r\n       *\r\n       * @return {integer} Current page length. Note `-1` indicates that all records\r\n       *   are to be shown.\r\n       */ _api_register('page.len()', function (len) {\r\n        // Note that we can't call this function 'length()' because `length`\r\n        // is a Javascript property of functions which defines how many arguments\r\n        // the function expects.\r\n        if (len === undefined) {\r\n          return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined\r\n        }\r\n\r\n        // else, set the page length\r\n        return this.iterator('table', function (settings) {\r\n          _fnLengthChange(settings, len)\r\n        })\r\n      })\r\n\r\n      var __reload = function (settings, holdPosition, callback) {\r\n        if (_fnDataSource(settings) == 'ssp') {\r\n          _fnReDraw(settings, holdPosition)\r\n        } else {\r\n          // Trigger xhr\r\n          _fnProcessingDisplay(settings, true)\r\n\r\n          _fnBuildAjax(settings, [], function (json) {\r\n            _fnClearTable(settings)\r\n\r\n            var data = _fnAjaxDataSrc(settings, json)\r\n            for (var i = 0, ien = data.length; i < ien; i++) {\r\n              _fnAddData(settings, data[i])\r\n            }\r\n\r\n            _fnReDraw(settings, holdPosition)\r\n            _fnProcessingDisplay(settings, false)\r\n          })\r\n        }\r\n\r\n        // Use the draw event to trigger a callback, regardless of if it is an async\r\n        // or sync draw\r\n        if (callback) {\r\n          var api = new _Api(settings)\r\n\r\n          api.one('draw', function () {\r\n            callback(api.ajax.json())\r\n          })\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get the JSON response from the last Ajax request that DataTables made to the\r\n       * server. Note that this returns the JSON from the first table in the current\r\n       * context.\r\n       *\r\n       * @return {object} JSON received from the server.\r\n       */\r\n      _api_register('ajax.json()', function () {\r\n        var ctx = this.context\r\n\r\n        if (ctx.length > 0) {\r\n          return ctx[0].json\r\n        }\r\n\r\n        // else return undefined;\r\n      })\r\n\r\n      /**\r\n       * Get the data submitted in the last Ajax request\r\n       */\r\n      _api_register('ajax.params()', function () {\r\n        var ctx = this.context\r\n\r\n        if (ctx.length > 0) {\r\n          return ctx[0].oAjaxData\r\n        }\r\n\r\n        // else return undefined;\r\n      })\r\n\r\n      /**\r\n       * Reload tables from the Ajax data source. Note that this function will\r\n       * automatically re-draw the table when the remote data has been loaded.\r\n       *\r\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\r\n       *   position. A full re-sort and re-filter is performed when this method is\r\n       *   called, which is why the pagination reset is the default action.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('ajax.reload()', function (callback, resetPaging) {\r\n        return this.iterator('table', function (settings) {\r\n          __reload(settings, resetPaging === false, callback)\r\n        })\r\n      })\r\n      /**\r\n       * Set the Ajax URL. Note that this will set the URL for all tables in the\r\n       * current context.\r\n       *\r\n       * @param {string} url URL to set.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get the current Ajax URL. Note that this returns the URL from the first\r\n       * table in the current context.\r\n       *\r\n       * @return {string} Current Ajax source URL\r\n       */ _api_register('ajax.url()', function (url) {\r\n        var ctx = this.context\r\n\r\n        if (url === undefined) {\r\n          // get\r\n          if (ctx.length === 0) {\r\n            return undefined\r\n          }\r\n          ctx = ctx[0]\r\n\r\n          return ctx.ajax ? ($.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax) : ctx.sAjaxSource\r\n        }\r\n\r\n        // set\r\n        return this.iterator('table', function (settings) {\r\n          if ($.isPlainObject(settings.ajax)) {\r\n            settings.ajax.url = url\r\n          } else {\r\n            settings.ajax = url\r\n          }\r\n          // No need to consider sAjaxSource here since DataTables gives priority\r\n          // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\r\n          // value of `sAjaxSource` redundant.\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Load data from the newly set Ajax URL. Note that this method is only\r\n       * available when `ajax.url()` is used to set a URL. Additionally, this method\r\n       * has the same effect as calling `ajax.reload()` but is provided for\r\n       * convenience when setting a new URL. Like `ajax.reload()` it will\r\n       * automatically redraw the table once the remote data has been loaded.\r\n       *\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('ajax.url().load()', function (callback, resetPaging) {\r\n        // Same as a reload, but makes sense to present it for easy access after a\r\n        // url change\r\n        return this.iterator('table', function (ctx) {\r\n          __reload(ctx, resetPaging === false, callback)\r\n        })\r\n      })\r\n\r\n      var _selector_run = function (selector, select) {\r\n        var out = [],\r\n          res,\r\n          a,\r\n          i,\r\n          ien,\r\n          j,\r\n          jen\r\n\r\n        // Can't just check for isArray here, as an API or jQuery instance might be\r\n        // given with their array like look\r\n        if (!selector || typeof selector === 'string' || selector.length === undefined) {\r\n          selector = [selector]\r\n        }\r\n\r\n        for (i = 0, ien = selector.length; i < ien; i++) {\r\n          a = selector[i] && selector[i].split ? selector[i].split(',') : [selector[i]]\r\n\r\n          for (j = 0, jen = a.length; j < jen; j++) {\r\n            res = select(typeof a[j] === 'string' ? $.trim(a[j]) : a[j])\r\n\r\n            if (res && res.length) {\r\n              out.push.apply(out, res)\r\n            }\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      var _selector_opts = function (opts) {\r\n        if (!opts) {\r\n          opts = {}\r\n        }\r\n\r\n        // Backwards compatibility for 1.9- which used the terminology filter rather\r\n        // than search\r\n        if (opts.filter && !opts.search) {\r\n          opts.search = opts.filter\r\n        }\r\n\r\n        return {\r\n          search: opts.search || 'none',\r\n          order: opts.order || 'current',\r\n          page: opts.page || 'all'\r\n        }\r\n      }\r\n\r\n      var _selector_first = function (inst) {\r\n        // Reduce the API instance to the first item found\r\n        for (var i = 0, ien = inst.length; i < ien; i++) {\r\n          if (inst[i].length > 0) {\r\n            // Assign the first element to the first item in the instance\r\n            // and truncate the instance and context\r\n            inst[0] = inst[i]\r\n            inst.length = 1\r\n            inst.context = [inst.context[i]]\r\n\r\n            return inst\r\n          }\r\n        }\r\n\r\n        // Not found - return an empty instance\r\n        inst.length = 0\r\n        return inst\r\n      }\r\n\r\n      var _selector_row_indexes = function (settings, opts) {\r\n        var i,\r\n          ien,\r\n          tmp,\r\n          a = [],\r\n          displayFiltered = settings.aiDisplay,\r\n          displayMaster = settings.aiDisplayMaster\r\n\r\n        var search = opts.search, // none, applied, removed\r\n          order = opts.order, // applied, current, index (original - compatibility with 1.9)\r\n          page = opts.page // all, current\r\n\r\n        if (_fnDataSource(settings) == 'ssp') {\r\n          // In server-side processing mode, most options are irrelevant since\r\n          // rows not shown don't exist and the index order is the applied order\r\n          // Removed is a special case - for consistency just return an empty\r\n          // array\r\n          return search === 'removed' ? [] : _range(0, displayMaster.length)\r\n        } else if (page == 'current') {\r\n          // Current page implies that order=current and fitler=applied, since it is\r\n          // fairly senseless otherwise, regardless of what order and search actually\r\n          // are\r\n          for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {\r\n            a.push(displayFiltered[i])\r\n          }\r\n        } else if (order == 'current' || order == 'applied') {\r\n          a =\r\n            search == 'none'\r\n              ? displayMaster.slice() // no search\r\n              : search == 'applied'\r\n              ? displayFiltered.slice() // applied search\r\n              : $.map(displayMaster, function (el, i) {\r\n                  // removed search\r\n                  return $.inArray(el, displayFiltered) === -1 ? el : null\r\n                })\r\n        } else if (order == 'index' || order == 'original') {\r\n          for (i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n            if (search == 'none') {\r\n              a.push(i)\r\n            } else {\r\n              // applied | removed\r\n              tmp = $.inArray(i, displayFiltered)\r\n\r\n              if ((tmp === -1 && search == 'removed') || (tmp >= 0 && search == 'applied')) {\r\n                a.push(i)\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        return a\r\n      }\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Rows\r\n       *\r\n       * {}          - no selector - use all available rows\r\n       * {integer}   - row aoData index\r\n       * {node}      - TR node\r\n       * {string}    - jQuery selector to apply to the TR elements\r\n       * {array}     - jQuery array of nodes, or simply an array of TR nodes\r\n       *\r\n       */\r\n\r\n      var __row_selector = function (settings, selector, opts) {\r\n        return _selector_run(selector, function (sel) {\r\n          var selInt = _intVal(sel)\r\n\r\n          // Short cut - selector is a number and no options provided (default is\r\n          // all records, so no need to check if the index is in there, since it\r\n          // must be - dev error if the index doesn't exist).\r\n          if (selInt !== null && !opts) {\r\n            return [selInt]\r\n          }\r\n\r\n          var rows = _selector_row_indexes(settings, opts)\r\n\r\n          if (selInt !== null && $.inArray(selInt, rows) !== -1) {\r\n            // Selector - integer\r\n            return [selInt]\r\n          } else if (!sel) {\r\n            // Selector - none\r\n            return rows\r\n          }\r\n\r\n          // Get nodes in the order from the `rows` array (can't use `pluck`) @todo - use pluck_order\r\n          var nodes = []\r\n          for (var i = 0, ien = rows.length; i < ien; i++) {\r\n            nodes.push(settings.aoData[rows[i]].nTr)\r\n          }\r\n\r\n          if (sel.nodeName) {\r\n            // Selector - node\r\n            if ($.inArray(sel, nodes) !== -1) {\r\n              return [sel._DT_RowIndex] // sel is a TR node that is in the table\r\n              // and DataTables adds a prop for fast lookup\r\n            }\r\n          }\r\n\r\n          // Selector - jQuery selector string, array of nodes or jQuery object/\r\n          // As jQuery's .filter() allows jQuery objects to be passed in filter,\r\n          // it also allows arrays, so this will cope with all three options\r\n          return $(nodes)\r\n            .filter(sel)\r\n            .map(function () {\r\n              return this._DT_RowIndex\r\n            })\r\n            .toArray()\r\n        })\r\n      }\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('rows()', function (selector, opts) {\r\n        // argument shifting\r\n        if (selector === undefined) {\r\n          selector = ''\r\n        } else if ($.isPlainObject(selector)) {\r\n          opts = selector\r\n          selector = ''\r\n        }\r\n\r\n        opts = _selector_opts(opts)\r\n\r\n        var inst = this.iterator('table', function (settings) {\r\n          return __row_selector(settings, selector, opts)\r\n        })\r\n\r\n        // Want argument shifting here and in __row_selector?\r\n        inst.selector.rows = selector\r\n        inst.selector.opts = opts\r\n\r\n        return inst\r\n      })\r\n\r\n      _api_register('rows().nodes()', function () {\r\n        return this.iterator('row', function (settings, row) {\r\n          return settings.aoData[row].nTr || undefined\r\n        })\r\n      })\r\n\r\n      _api_register('rows().data()', function () {\r\n        return this.iterator(true, 'rows', function (settings, rows) {\r\n          return _pluck_order(settings.aoData, rows, '_aData')\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().cache()', 'row().cache()', function (type) {\r\n        return this.iterator('row', function (settings, row) {\r\n          var r = settings.aoData[row]\r\n          return type === 'search' ? r._aFilterData : r._aSortData\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {\r\n        return this.iterator('row', function (settings, row) {\r\n          _fnInvalidateRow(settings, row, src)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().indexes()', 'row().index()', function () {\r\n        return this.iterator('row', function (settings, row) {\r\n          return row\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().remove()', 'row().remove()', function () {\r\n        var that = this\r\n\r\n        return this.iterator('row', function (settings, row, thatIdx) {\r\n          var data = settings.aoData\r\n\r\n          data.splice(row, 1)\r\n\r\n          // Update the _DT_RowIndex parameter on all rows in the table\r\n          for (var i = 0, ien = data.length; i < ien; i++) {\r\n            if (data[i].nTr !== null) {\r\n              data[i].nTr._DT_RowIndex = i\r\n            }\r\n          }\r\n\r\n          // Remove the target row from the search array\r\n          var displayIndex = $.inArray(row, settings.aiDisplay)\r\n\r\n          // Delete from the display arrays\r\n          _fnDeleteIndex(settings.aiDisplayMaster, row)\r\n          _fnDeleteIndex(settings.aiDisplay, row)\r\n          _fnDeleteIndex(that[thatIdx], row, false) // maintain local indexes\r\n\r\n          // Check for an 'overflow' they case for displaying the table\r\n          _fnLengthOverflow(settings)\r\n        })\r\n      })\r\n\r\n      _api_register('rows.add()', function (rows) {\r\n        var newRows = this.iterator('table', function (settings) {\r\n          var row, i, ien\r\n          var out = []\r\n\r\n          for (i = 0, ien = rows.length; i < ien; i++) {\r\n            row = rows[i]\r\n\r\n            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\r\n              out.push(_fnAddTr(settings, row)[0])\r\n            } else {\r\n              out.push(_fnAddData(settings, row))\r\n            }\r\n          }\r\n\r\n          return out\r\n        })\r\n\r\n        // Return an Api.rows() extended instance, so rows().nodes() etc can be used\r\n        var modRows = this.rows(-1)\r\n        modRows.pop()\r\n        modRows.push.apply(modRows, newRows.toArray())\r\n\r\n        return modRows\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('row()', function (selector, opts) {\r\n        return _selector_first(this.rows(selector, opts))\r\n      })\r\n\r\n      _api_register('row().data()', function (data) {\r\n        var ctx = this.context\r\n\r\n        if (data === undefined) {\r\n          // Get\r\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined\r\n        }\r\n\r\n        // Set\r\n        ctx[0].aoData[this[0]]._aData = data\r\n\r\n        // Automatically invalidate\r\n        _fnInvalidateRow(ctx[0], this[0], 'data')\r\n\r\n        return this\r\n      })\r\n\r\n      _api_register('row().node()', function () {\r\n        var ctx = this.context\r\n\r\n        return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null\r\n      })\r\n\r\n      _api_register('row.add()', function (row) {\r\n        // Allow a jQuery object to be passed in - only a single row is added from\r\n        // it though - the first element in the set\r\n        if (row instanceof $ && row.length) {\r\n          row = row[0]\r\n        }\r\n\r\n        var rows = this.iterator('table', function (settings) {\r\n          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\r\n            return _fnAddTr(settings, row)[0]\r\n          }\r\n          return _fnAddData(settings, row)\r\n        })\r\n\r\n        // Return an Api.rows() extended instance, with the newly added row selected\r\n        return this.row(rows[0])\r\n      })\r\n\r\n      var __details_add = function (ctx, row, data, klass) {\r\n        // Convert to array of TR elements\r\n        var rows = []\r\n        var addRow = function (r, k) {\r\n          // If we get a TR element, then just add it directly - up to the dev\r\n          // to add the correct number of columns etc\r\n          if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {\r\n            rows.push(r)\r\n          } else {\r\n            // Otherwise create a row with a wrapper\r\n            var created = $('<tr><td/></tr>').addClass(k)\r\n            $('td', created)\r\n              .addClass(k)\r\n              .html(r)[0].colSpan = _fnVisbleColumns(ctx)\r\n\r\n            rows.push(created[0])\r\n          }\r\n        }\r\n\r\n        if ($.isArray(data) || data instanceof $) {\r\n          for (var i = 0, ien = data.length; i < ien; i++) {\r\n            addRow(data[i], klass)\r\n          }\r\n        } else {\r\n          addRow(data, klass)\r\n        }\r\n\r\n        if (row._details) {\r\n          row._details.remove()\r\n        }\r\n\r\n        row._details = $(rows)\r\n\r\n        // If the children were already shown, that state should be retained\r\n        if (row._detailsShow) {\r\n          row._details.insertAfter(row.nTr)\r\n        }\r\n      }\r\n\r\n      var __details_remove = function (api) {\r\n        var ctx = api.context\r\n\r\n        if (ctx.length && api.length) {\r\n          var row = ctx[0].aoData[api[0]]\r\n\r\n          if (row._details) {\r\n            row._details.remove()\r\n\r\n            row._detailsShow = undefined\r\n            row._details = undefined\r\n          }\r\n        }\r\n      }\r\n\r\n      var __details_display = function (api, show) {\r\n        var ctx = api.context\r\n\r\n        if (ctx.length && api.length) {\r\n          var row = ctx[0].aoData[api[0]]\r\n\r\n          if (row._details) {\r\n            row._detailsShow = show\r\n\r\n            if (show) {\r\n              row._details.insertAfter(row.nTr)\r\n            } else {\r\n              row._details.detach()\r\n            }\r\n\r\n            __details_events(ctx[0])\r\n          }\r\n        }\r\n      }\r\n\r\n      var __details_events = function (settings) {\r\n        var api = new _Api(settings)\r\n        var namespace = '.dt.DT_details'\r\n        var drawEvent = 'draw' + namespace\r\n        var colvisEvent = 'column-visibility' + namespace\r\n        var destroyEvent = 'destroy' + namespace\r\n        var data = settings.aoData\r\n\r\n        api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent)\r\n\r\n        if (_pluck(data, '_details').length > 0) {\r\n          // On each draw, insert the required elements into the document\r\n          api.on(drawEvent, function (e, ctx) {\r\n            if (settings !== ctx) {\r\n              return\r\n            }\r\n\r\n            api\r\n              .rows({ page: 'current' })\r\n              .eq(0)\r\n              .each(function (idx) {\r\n                // Internal data grab\r\n                var row = data[idx]\r\n\r\n                if (row._detailsShow) {\r\n                  row._details.insertAfter(row.nTr)\r\n                }\r\n              })\r\n          })\r\n\r\n          // Column visibility change - update the colspan\r\n          api.on(colvisEvent, function (e, ctx, idx, vis) {\r\n            if (settings !== ctx) {\r\n              return\r\n            }\r\n\r\n            // Update the colspan for the details rows (note, only if it already has\r\n            // a colspan)\r\n            var row,\r\n              visible = _fnVisbleColumns(ctx)\r\n\r\n            for (var i = 0, ien = data.length; i < ien; i++) {\r\n              row = data[i]\r\n\r\n              if (row._details) {\r\n                row._details.children('td[colspan]').attr('colspan', visible)\r\n              }\r\n            }\r\n          })\r\n\r\n          // Table destroyed - nuke any child rows\r\n          api.on(destroyEvent, function (e, ctx) {\r\n            if (settings !== ctx) {\r\n              return\r\n            }\r\n\r\n            for (var i = 0, ien = data.length; i < ien; i++) {\r\n              if (data[i]._details) {\r\n                __details_remove(data[i])\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n\r\n      // Strings for the method names to help minification\r\n      var _emp = ''\r\n      var _child_obj = _emp + 'row().child'\r\n      var _child_mth = _child_obj + '()'\r\n\r\n      // data can be:\r\n      //  tr\r\n      //  string\r\n      //  jQuery or array of any of the above\r\n      _api_register(_child_mth, function (data, klass) {\r\n        var ctx = this.context\r\n\r\n        if (data === undefined) {\r\n          // get\r\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined\r\n        } else if (data === true) {\r\n          // show\r\n          this.child.show()\r\n        } else if (data === false) {\r\n          // remove\r\n          __details_remove(this)\r\n        } else if (ctx.length && this.length) {\r\n          // set\r\n          __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass)\r\n        }\r\n\r\n        return this\r\n      })\r\n\r\n      _api_register(\r\n        [\r\n          _child_obj + '.show()',\r\n          _child_mth + '.show()' // only when `child()` was called with parameters (without\r\n        ],\r\n        function (show) {\r\n          // it returns an object and this method is not executed)\r\n          __details_display(this, true)\r\n          return this\r\n        }\r\n      )\r\n\r\n      _api_register(\r\n        [\r\n          _child_obj + '.hide()',\r\n          _child_mth + '.hide()' // only when `child()` was called with parameters (without\r\n        ],\r\n        function () {\r\n          // it returns an object and this method is not executed)\r\n          __details_display(this, false)\r\n          return this\r\n        }\r\n      )\r\n\r\n      _api_register(\r\n        [\r\n          _child_obj + '.remove()',\r\n          _child_mth + '.remove()' // only when `child()` was called with parameters (without\r\n        ],\r\n        function () {\r\n          // it returns an object and this method is not executed)\r\n          __details_remove(this)\r\n          return this\r\n        }\r\n      )\r\n\r\n      _api_register(_child_obj + '.isShown()', function () {\r\n        var ctx = this.context\r\n\r\n        if (ctx.length && this.length) {\r\n          // _detailsShown as false or undefined will fall through to return false\r\n          return ctx[0].aoData[this[0]]._detailsShow || false\r\n        }\r\n        return false\r\n      })\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Columns\r\n       *\r\n       * {integer}           - column index (>=0 count from left, <0 count from right)\r\n       * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\r\n       * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\r\n       * \"{string}:name\"     - column name\r\n       * \"{string}\"          - jQuery selector on column header nodes\r\n       *\r\n       */\r\n\r\n      // can be an array of these items, comma separated list, or an array of comma\r\n      // separated lists\r\n\r\n      var __re_column_selector = /^(.+):(name|visIdx|visible)$/\r\n\r\n      var __column_selector = function (settings, selector, opts) {\r\n        var columns = settings.aoColumns,\r\n          names = _pluck(columns, 'sName'),\r\n          nodes = _pluck(columns, 'nTh')\r\n\r\n        return _selector_run(selector, function (s) {\r\n          var selInt = _intVal(s)\r\n\r\n          if (s === '') {\r\n            // All columns\r\n            return _range(columns.length)\r\n          } else if (selInt !== null) {\r\n            // Integer selector\r\n            return [\r\n              selInt >= 0\r\n                ? selInt // Count from left\r\n                : columns.length + selInt // Count from right (+ because its a negative value)\r\n            ]\r\n          } else {\r\n            var match = typeof s === 'string' ? s.match(__re_column_selector) : ''\r\n\r\n            if (match) {\r\n              switch (match[2]) {\r\n                case 'visIdx':\r\n                case 'visible':\r\n                  var idx = parseInt(match[1], 10)\r\n                  // Visible index given, convert to column index\r\n                  if (idx < 0) {\r\n                    // Counting from the right\r\n                    var visColumns = $.map(columns, function (col, i) {\r\n                      return col.bVisible ? i : null\r\n                    })\r\n                    return [visColumns[visColumns.length + idx]]\r\n                  }\r\n                  // Counting from the left\r\n                  return [_fnVisibleToColumnIndex(settings, idx)]\r\n\r\n                case 'name':\r\n                  // match by name. `names` is column index complete and in order\r\n                  return $.map(names, function (name, i) {\r\n                    return name === match[1] ? i : null\r\n                  })\r\n              }\r\n            } else {\r\n              // jQuery selector on the TH elements for the columns\r\n              return $(nodes)\r\n                .filter(s)\r\n                .map(function () {\r\n                  return $.inArray(this, nodes) // `nodes` is column index complete and in order\r\n                })\r\n                .toArray()\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      var __setColumnVis = function (settings, column, vis, recalc) {\r\n        var cols = settings.aoColumns,\r\n          col = cols[column],\r\n          data = settings.aoData,\r\n          row,\r\n          cells,\r\n          i,\r\n          ien,\r\n          tr\r\n\r\n        // Get\r\n        if (vis === undefined) {\r\n          return col.bVisible\r\n        }\r\n\r\n        // Set\r\n        // No change\r\n        if (col.bVisible === vis) {\r\n          return\r\n        }\r\n\r\n        if (vis) {\r\n          // Insert column\r\n          // Need to decide if we should use appendChild or insertBefore\r\n          var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1)\r\n\r\n          for (i = 0, ien = data.length; i < ien; i++) {\r\n            tr = data[i].nTr\r\n            cells = data[i].anCells\r\n\r\n            if (tr) {\r\n              // insertBefore can act like appendChild if 2nd arg is null\r\n              tr.insertBefore(cells[column], cells[insertBefore] || null)\r\n            }\r\n          }\r\n        } else {\r\n          // Remove column\r\n          $(_pluck(settings.aoData, 'anCells', column)).detach()\r\n        }\r\n\r\n        // Common actions\r\n        col.bVisible = vis\r\n        _fnDrawHead(settings, settings.aoHeader)\r\n        _fnDrawHead(settings, settings.aoFooter)\r\n\r\n        if (recalc === undefined || recalc) {\r\n          // Automatically adjust column sizing\r\n          _fnAdjustColumnSizing(settings)\r\n\r\n          // Realign columns for scrolling\r\n          if (settings.oScroll.sX || settings.oScroll.sY) {\r\n            _fnScrollDraw(settings)\r\n          }\r\n        }\r\n\r\n        _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis])\r\n\r\n        _fnSaveState(settings)\r\n      }\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('columns()', function (selector, opts) {\r\n        // argument shifting\r\n        if (selector === undefined) {\r\n          selector = ''\r\n        } else if ($.isPlainObject(selector)) {\r\n          opts = selector\r\n          selector = ''\r\n        }\r\n\r\n        opts = _selector_opts(opts)\r\n\r\n        var inst = this.iterator('table', function (settings) {\r\n          return __column_selector(settings, selector, opts)\r\n        })\r\n\r\n        // Want argument shifting here and in _row_selector?\r\n        inst.selector.cols = selector\r\n        inst.selector.opts = opts\r\n\r\n        return inst\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return settings.aoColumns[column].nTh\r\n        })\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return settings.aoColumns[column].nTf\r\n        })\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_registerPlural('columns().data()', 'column().data()', function () {\r\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\r\n          var a = []\r\n          for (var row = 0, ien = rows.length; row < ien; row++) {\r\n            a.push(_fnGetCellData(settings, rows[row], column, ''))\r\n          }\r\n          return a\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().cache()', 'column().cache()', function (type) {\r\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\r\n          return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().nodes()', 'column().nodes()', function () {\r\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\r\n          return _pluck_order(settings.aoData, rows, 'anCells', column)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return vis === undefined ? settings.aoColumns[column].bVisible : __setColumnVis(settings, column, vis, calc)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().indexes()', 'column().index()', function (type) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column\r\n        })\r\n      })\r\n\r\n      // _api_register( 'columns().show()', function () {\r\n      // \tvar selector = this.selector;\r\n      // \treturn this.columns( selector.cols, selector.opts ).visible( true );\r\n      // } );\r\n\r\n      // _api_register( 'columns().hide()', function () {\r\n      // \tvar selector = this.selector;\r\n      // \treturn this.columns( selector.cols, selector.opts ).visible( false );\r\n      // } );\r\n\r\n      _api_register('columns.adjust()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          _fnAdjustColumnSizing(settings)\r\n        })\r\n      })\r\n\r\n      // Convert from one column index type, to another type\r\n      _api_register('column.index()', function (type, idx) {\r\n        if (this.context.length !== 0) {\r\n          var ctx = this.context[0]\r\n\r\n          if (type === 'fromVisible' || type === 'toData') {\r\n            return _fnVisibleToColumnIndex(ctx, idx)\r\n          } else if (type === 'fromData' || type === 'toVisible') {\r\n            return _fnColumnIndexToVisible(ctx, idx)\r\n          }\r\n        }\r\n      })\r\n\r\n      _api_register('column()', function (selector, opts) {\r\n        return _selector_first(this.columns(selector, opts))\r\n      })\r\n\r\n      var __cell_selector = function (settings, selector, opts) {\r\n        var data = settings.aoData\r\n        var rows = _selector_row_indexes(settings, opts)\r\n        var cells = _pluck_order(data, rows, 'anCells')\r\n        var allCells = $([].concat.apply([], cells))\r\n        var row\r\n        var columns = settings.aoColumns.length\r\n        var a, i, ien, j\r\n\r\n        return _selector_run(selector, function (s) {\r\n          if (s === null || s === undefined) {\r\n            // All cells\r\n            a = []\r\n\r\n            for (i = 0, ien = rows.length; i < ien; i++) {\r\n              row = rows[i]\r\n\r\n              for (j = 0; j < columns; j++) {\r\n                a.push({\r\n                  row: row,\r\n                  column: j\r\n                })\r\n              }\r\n            }\r\n\r\n            return a\r\n          } else if ($.isPlainObject(s)) {\r\n            return [s]\r\n          }\r\n\r\n          // jQuery filtered cells\r\n          return allCells\r\n            .filter(s)\r\n            .map(function (i, el) {\r\n              row = el.parentNode._DT_RowIndex\r\n\r\n              return {\r\n                row: row,\r\n                column: $.inArray(el, data[row].anCells)\r\n              }\r\n            })\r\n            .toArray()\r\n        })\r\n      }\r\n\r\n      _api_register('cells()', function (rowSelector, columnSelector, opts) {\r\n        // Argument shifting\r\n        if ($.isPlainObject(rowSelector)) {\r\n          // Indexes\r\n          if (typeof rowSelector.row !== undefined) {\r\n            opts = columnSelector\r\n            columnSelector = null\r\n          } else {\r\n            opts = rowSelector\r\n            rowSelector = null\r\n          }\r\n        }\r\n        if ($.isPlainObject(columnSelector)) {\r\n          opts = columnSelector\r\n          columnSelector = null\r\n        }\r\n\r\n        // Cell selector\r\n        if (columnSelector === null || columnSelector === undefined) {\r\n          return this.iterator('table', function (settings) {\r\n            return __cell_selector(settings, rowSelector, _selector_opts(opts))\r\n          })\r\n        }\r\n\r\n        // Row + column selector\r\n        var columns = this.columns(columnSelector, opts)\r\n        var rows = this.rows(rowSelector, opts)\r\n        var a, i, ien, j, jen\r\n\r\n        var cells = this.iterator('table', function (settings, idx) {\r\n          a = []\r\n\r\n          for (i = 0, ien = rows[idx].length; i < ien; i++) {\r\n            for (j = 0, jen = columns[idx].length; j < jen; j++) {\r\n              a.push({\r\n                row: rows[idx][i],\r\n                column: columns[idx][j]\r\n              })\r\n            }\r\n          }\r\n\r\n          return a\r\n        })\r\n\r\n        $.extend(cells.selector, {\r\n          cols: columnSelector,\r\n          rows: rowSelector,\r\n          opts: opts\r\n        })\r\n\r\n        return cells\r\n      })\r\n\r\n      _api_registerPlural('cells().nodes()', 'cell().node()', function () {\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return settings.aoData[row].anCells[column]\r\n        })\r\n      })\r\n\r\n      _api_register('cells().data()', function () {\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return _fnGetCellData(settings, row, column)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {\r\n        type = type === 'search' ? '_aFilterData' : '_aSortData'\r\n\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return settings.aoData[row][type][column]\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('cells().indexes()', 'cell().index()', function () {\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return {\r\n            row: row,\r\n            column: column,\r\n            columnVisible: _fnColumnIndexToVisible(settings, column)\r\n          }\r\n        })\r\n      })\r\n\r\n      _api_register(['cells().invalidate()', 'cell().invalidate()'], function (src) {\r\n        var selector = this.selector\r\n\r\n        // Use the rows method of the instance to perform the invalidation, rather\r\n        // than doing it here. This avoids needing to handle duplicate rows from\r\n        // the cells.\r\n        this.rows(selector.rows, selector.opts).invalidate(src)\r\n\r\n        return this\r\n      })\r\n\r\n      _api_register('cell()', function (rowSelector, columnSelector, opts) {\r\n        return _selector_first(this.cells(rowSelector, columnSelector, opts))\r\n      })\r\n\r\n      _api_register('cell().data()', function (data) {\r\n        var ctx = this.context\r\n        var cell = this[0]\r\n\r\n        if (data === undefined) {\r\n          // Get\r\n          return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined\r\n        }\r\n\r\n        // Set\r\n        _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data)\r\n        _fnInvalidateRow(ctx[0], cell[0].row, 'data', cell[0].column)\r\n\r\n        return this\r\n      })\r\n      /**\r\n       * Set the ordering for the table.\r\n       *\r\n       * @param {array} order 2D array of sorting information to be applied.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      /**\r\n       * Set the ordering for the table.\r\n       *\r\n       * @param {integer} order Column index to sort upon.\r\n       * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      /**\r\n       * Set the ordering for the table.\r\n       *\r\n       * @param {array} order 1D array of sorting information to be applied.\r\n       * @param {array} [...] Optional additional sorting conditions\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get current ordering (sorting) that has been applied to the table.\r\n       *\r\n       * @returns {array} 2D array containing the sorting information for the first\r\n       *   table in the current context. Each element in the parent array represents\r\n       *   a column being sorted upon (i.e. multi-sorting with two columns would have\r\n       *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\r\n       *   the column index that the sorting condition applies to, the second is the\r\n       *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\r\n       *   index of the sorting order from the `column.sorting` initialisation array.\r\n       */ _api_register('order()', function (order, dir) {\r\n        var ctx = this.context\r\n\r\n        if (order === undefined) {\r\n          // get\r\n          return ctx.length !== 0 ? ctx[0].aaSorting : undefined\r\n        }\r\n\r\n        // set\r\n        if (typeof order === 'number') {\r\n          // Simple column / direction passed in\r\n          order = [[order, dir]]\r\n        } else if (!$.isArray(order[0])) {\r\n          // Arguments passed in (list of 1D arrays)\r\n          order = Array.prototype.slice.call(arguments)\r\n        }\r\n        // otherwise a 2D array was passed in\r\n\r\n        return this.iterator('table', function (settings) {\r\n          settings.aaSorting = order.slice()\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Attach a sort listener to an element for a given column\r\n       *\r\n       * @param {node|jQuery|string} node Identifier for the element(s) to attach the\r\n       *   listener to. This can take the form of a single DOM node, a jQuery\r\n       *   collection of nodes or a jQuery selector which will identify the node(s).\r\n       * @param {integer} column the column that a click on this node will sort on\r\n       * @param {function} [callback] callback function when sort is run\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('order.listener()', function (node, column, callback) {\r\n        return this.iterator('table', function (settings) {\r\n          _fnSortAttachListener(settings, node, column, callback)\r\n        })\r\n      })\r\n\r\n      // Order by the selected column(s)\r\n      _api_register(['columns().order()', 'column().order()'], function (dir) {\r\n        var that = this\r\n\r\n        return this.iterator('table', function (settings, i) {\r\n          var sort = []\r\n\r\n          $.each(that[i], function (j, col) {\r\n            sort.push([col, dir])\r\n          })\r\n\r\n          settings.aaSorting = sort\r\n        })\r\n      })\r\n\r\n      _api_register('search()', function (input, regex, smart, caseInsen) {\r\n        var ctx = this.context\r\n\r\n        if (input === undefined) {\r\n          // get\r\n          return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined\r\n        }\r\n\r\n        // set\r\n        return this.iterator('table', function (settings) {\r\n          if (!settings.oFeatures.bFilter) {\r\n            return\r\n          }\r\n\r\n          _fnFilterComplete(\r\n            settings,\r\n            $.extend({}, settings.oPreviousSearch, {\r\n              sSearch: input + '',\r\n              bRegex: regex === null ? false : regex,\r\n              bSmart: smart === null ? true : smart,\r\n              bCaseInsensitive: caseInsen === null ? true : caseInsen\r\n            }),\r\n            1\r\n          )\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {\r\n        return this.iterator('column', function (settings, column) {\r\n          var preSearch = settings.aoPreSearchCols\r\n\r\n          if (input === undefined) {\r\n            // get\r\n            return preSearch[column].sSearch\r\n          }\r\n\r\n          // set\r\n          if (!settings.oFeatures.bFilter) {\r\n            return\r\n          }\r\n\r\n          $.extend(preSearch[column], {\r\n            sSearch: input + '',\r\n            bRegex: regex === null ? false : regex,\r\n            bSmart: smart === null ? true : smart,\r\n            bCaseInsensitive: caseInsen === null ? true : caseInsen\r\n          })\r\n\r\n          _fnFilterComplete(settings, settings.oPreviousSearch, 1)\r\n        })\r\n      })\r\n\r\n      /*\r\n       * State API methods\r\n       */\r\n\r\n      _api_register('state()', function () {\r\n        return this.context.length ? this.context[0].oSavedState : null\r\n      })\r\n\r\n      _api_register('state.clear()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          // Save an empty object\r\n          settings.fnStateSaveCallback.call(settings.oInstance, settings, {})\r\n        })\r\n      })\r\n\r\n      _api_register('state.loaded()', function () {\r\n        return this.context.length ? this.context[0].oLoadedState : null\r\n      })\r\n\r\n      _api_register('state.save()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          _fnSaveState(settings)\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Provide a common method for plug-ins to check the version of DataTables being\r\n       * used, in order to ensure compatibility.\r\n       *\r\n       *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\r\n       *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\r\n       *  @returns {boolean} true if this version of DataTables is greater or equal to\r\n       *    the required version, or false if this version of DataTales is not\r\n       *    suitable\r\n       *  @static\r\n       *  @dtopt API-Static\r\n       *\r\n       *  @example\r\n       *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\r\n       */\r\n      DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {\r\n        var aThis = DataTable.version.split('.')\r\n        var aThat = version.split('.')\r\n        var iThis, iThat\r\n\r\n        for (var i = 0, iLen = aThat.length; i < iLen; i++) {\r\n          iThis = parseInt(aThis[i], 10) || 0\r\n          iThat = parseInt(aThat[i], 10) || 0\r\n\r\n          // Parts are the same, keep comparing\r\n          if (iThis === iThat) {\r\n            continue\r\n          }\r\n\r\n          // Parts are different, return immediately\r\n          return iThis > iThat\r\n        }\r\n\r\n        return true\r\n      }\r\n\r\n      /**\r\n       * Check if a `<table>` node is a DataTable table already or not.\r\n       *\r\n       *  @param {node|jquery|string} table Table node, jQuery object or jQuery\r\n       *      selector for the table to test. Note that if more than more than one\r\n       *      table is passed on, only the first will be checked\r\n       *  @returns {boolean} true the table given is a DataTable, or false otherwise\r\n       *  @static\r\n       *  @dtopt API-Static\r\n       *\r\n       *  @example\r\n       *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\r\n       *      $('#example').dataTable();\r\n       *    }\r\n       */\r\n      DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {\r\n        var t = $(table).get(0)\r\n        var is = false\r\n\r\n        $.each(DataTable.settings, function (i, o) {\r\n          if (o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t) {\r\n            is = true\r\n          }\r\n        })\r\n\r\n        return is\r\n      }\r\n\r\n      /**\r\n       * Get all DataTable tables that have been initialised - optionally you can\r\n       * select to get only currently visible tables.\r\n       *\r\n       *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\r\n       *    or visible tables only.\r\n       *  @returns {array} Array of `table` nodes (not DataTable instances) which are\r\n       *    DataTables\r\n       *  @static\r\n       *  @dtopt API-Static\r\n       *\r\n       *  @example\r\n       *    $.each( $.fn.dataTable.tables(true), function () {\r\n       *      $(table).DataTable().columns.adjust();\r\n       *    } );\r\n       */\r\n      DataTable.tables = DataTable.fnTables = function (visible) {\r\n        return jQuery.map(DataTable.settings, function (o) {\r\n          if (!visible || (visible && $(o.nTable).is(':visible'))) {\r\n            return o.nTable\r\n          }\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Convert from camel case parameters to Hungarian notation. This is made public\r\n       * for the extensions to provide the same ability as DataTables core to accept\r\n       * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\r\n       * parameters.\r\n       *\r\n       *  @param {object} src The model object which holds all parameters that can be\r\n       *    mapped.\r\n       *  @param {object} user The object to convert from camel case to Hungarian.\r\n       *  @param {boolean} force When set to `true`, properties which already have a\r\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\r\n       *    won't be.\r\n       */\r\n      DataTable.camelToHungarian = _fnCamelToHungarian\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('$()', function (selector, opts) {\r\n        var rows = this.rows(opts).nodes(), // Get all rows\r\n          jqRows = $(rows)\r\n\r\n        return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()))\r\n      })\r\n\r\n      // jQuery functions to operate on the tables\r\n      $.each(['on', 'one', 'off'], function (i, key) {\r\n        _api_register(key + '()', function (/* event, handler */) {\r\n          var args = Array.prototype.slice.call(arguments)\r\n\r\n          // Add the `dt` namespace automatically if it isn't already present\r\n          if (!args[0].match(/\\.dt\\b/)) {\r\n            args[0] += '.dt'\r\n          }\r\n\r\n          var inst = $(this.tables().nodes())\r\n          inst[key].apply(inst, args)\r\n          return this\r\n        })\r\n      })\r\n\r\n      _api_register('clear()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          _fnClearTable(settings)\r\n        })\r\n      })\r\n\r\n      _api_register('settings()', function () {\r\n        return new _Api(this.context, this.context)\r\n      })\r\n\r\n      _api_register('data()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          return _pluck(settings.aoData, '_aData')\r\n        }).flatten()\r\n      })\r\n\r\n      _api_register('destroy()', function (remove) {\r\n        remove = remove || false\r\n\r\n        return this.iterator('table', function (settings) {\r\n          var orig = settings.nTableWrapper.parentNode\r\n          var classes = settings.oClasses\r\n          var table = settings.nTable\r\n          var tbody = settings.nTBody\r\n          var thead = settings.nTHead\r\n          var tfoot = settings.nTFoot\r\n          var jqTable = $(table)\r\n          var jqTbody = $(tbody)\r\n          var jqWrapper = $(settings.nTableWrapper)\r\n          var rows = $.map(settings.aoData, function (r) {\r\n            return r.nTr\r\n          })\r\n          var i, ien\r\n\r\n          // Flag to note that the table is currently being destroyed - no action\r\n          // should be taken\r\n          settings.bDestroying = true\r\n\r\n          // Fire off the destroy callbacks for plug-ins etc\r\n          _fnCallbackFire(settings, 'aoDestroyCallback', 'destroy', [settings])\r\n\r\n          // If not being removed from the document, make all columns visible\r\n          if (!remove) {\r\n            new _Api(settings).columns().visible(true)\r\n          }\r\n\r\n          // Blitz all `DT` namespaced events (these are internal events, the\r\n          // lowercase, `dt` events are user subscribed and they are responsible\r\n          // for removing them\r\n          jqWrapper\r\n            .unbind('.DT')\r\n            .find(':not(tbody *)')\r\n            .unbind('.DT')\r\n          $(window).unbind('.DT-' + settings.sInstance)\r\n\r\n          // When scrolling we had to break the table up - restore it\r\n          if (table != thead.parentNode) {\r\n            jqTable.children('thead').detach()\r\n            jqTable.append(thead)\r\n          }\r\n\r\n          if (tfoot && table != tfoot.parentNode) {\r\n            jqTable.children('tfoot').detach()\r\n            jqTable.append(tfoot)\r\n          }\r\n\r\n          // Remove the DataTables generated nodes, events and classes\r\n          jqTable.detach()\r\n          jqWrapper.detach()\r\n\r\n          settings.aaSorting = []\r\n          settings.aaSortingFixed = []\r\n          _fnSortingClasses(settings)\r\n\r\n          $(rows).removeClass(settings.asStripeClasses.join(' '))\r\n\r\n          $('th, td', thead).removeClass(\r\n            classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone\r\n          )\r\n\r\n          if (settings.bJUI) {\r\n            $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach()\r\n            $('th, td', thead).each(function () {\r\n              var wrapper = $('div.' + classes.sSortJUIWrapper, this)\r\n              $(this).append(wrapper.contents())\r\n              wrapper.detach()\r\n            })\r\n          }\r\n\r\n          if (!remove && orig) {\r\n            // insertBefore acts like appendChild if !arg[1]\r\n            orig.insertBefore(table, settings.nTableReinsertBefore)\r\n          }\r\n\r\n          // Add the TR elements back into the table in their original order\r\n          jqTbody.children().detach()\r\n          jqTbody.append(rows)\r\n\r\n          // Restore the width of the original table - was read from the style property,\r\n          // so we can restore directly to that\r\n          jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable)\r\n\r\n          // If the were originally stripe classes - then we add them back here.\r\n          // Note this is not fool proof (for example if not all rows had stripe\r\n          // classes - but it's a good effort without getting carried away\r\n          ien = settings.asDestroyStripes.length\r\n\r\n          if (ien) {\r\n            jqTbody.children().each(function (i) {\r\n              $(this).addClass(settings.asDestroyStripes[i % ien])\r\n            })\r\n          }\r\n\r\n          /* Remove the settings object from the settings array */\r\n          var idx = $.inArray(settings, DataTable.settings)\r\n          if (idx !== -1) {\r\n            DataTable.settings.splice(idx, 1)\r\n          }\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Version string for plug-ins to check compatibility. Allowed format is\r\n       * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\r\n       * only for non-release builds. See http://semver.org/ for more information.\r\n       *  @member\r\n       *  @type string\r\n       *  @default Version number\r\n       */\r\n      DataTable.version = '1.10.2'\r\n\r\n      /**\r\n       * Private data store, containing all of the settings objects that are\r\n       * created for the tables on a given page.\r\n       *\r\n       * Note that the `DataTable.settings` object is aliased to\r\n       * `jQuery.fn.dataTableExt` through which it may be accessed and\r\n       * manipulated, or `jQuery.fn.dataTable.settings`.\r\n       *  @member\r\n       *  @type array\r\n       *  @default []\r\n       *  @private\r\n       */\r\n      DataTable.settings = []\r\n\r\n      /**\r\n       * Object models container, for the various models that DataTables has\r\n       * available to it. These models define the objects that are used to hold\r\n       * the active state and configuration of the table.\r\n       *  @namespace\r\n       */\r\n      DataTable.models = {}\r\n\r\n      /**\r\n       * Template object for the way in which DataTables holds information about\r\n       * search information for the global filter and individual column filters.\r\n       *  @namespace\r\n       */\r\n      DataTable.models.oSearch = {\r\n        /**\r\n         * Flag to indicate if the filtering should be case insensitive or not\r\n         *  @type boolean\r\n         *  @default true\r\n         */\r\n        bCaseInsensitive: true,\r\n\r\n        /**\r\n         * Applied search term\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         */\r\n        sSearch: '',\r\n\r\n        /**\r\n         * Flag to indicate if the search term should be interpreted as a\r\n         * regular expression (true) or not (false) and therefore and special\r\n         * regex characters escaped.\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bRegex: false,\r\n\r\n        /**\r\n         * Flag to indicate if DataTables is to use its smart filtering or not.\r\n         *  @type boolean\r\n         *  @default true\r\n         */\r\n        bSmart: true\r\n      }\r\n\r\n      /**\r\n       * Template object for the way in which DataTables holds information about\r\n       * each individual row. This is the object format used for the settings\r\n       * aoData array.\r\n       *  @namespace\r\n       */\r\n      DataTable.models.oRow = {\r\n        /**\r\n         * TR element for the row\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTr: null,\r\n\r\n        /**\r\n         * Array of TD elements for each row. This is null until the row has been\r\n         * created.\r\n         *  @type array nodes\r\n         *  @default []\r\n         */\r\n        anCells: null,\r\n\r\n        /**\r\n         * Data object from the original data source for the row. This is either\r\n         * an array if using the traditional form of DataTables, or an object if\r\n         * using mData options. The exact type will depend on the passed in\r\n         * data from the data source, or will be an array if using DOM a data\r\n         * source.\r\n         *  @type array|object\r\n         *  @default []\r\n         */\r\n        _aData: [],\r\n\r\n        /**\r\n         * Sorting data cache - this array is ostensibly the same length as the\r\n         * number of columns (although each index is generated only as it is\r\n         * needed), and holds the data that is used for sorting each column in the\r\n         * row. We do this cache generation at the start of the sort in order that\r\n         * the formatting of the sort data need be done only once for each cell\r\n         * per sort. This array should not be read from or written to by anything\r\n         * other than the master sorting methods.\r\n         *  @type array\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _aSortData: null,\r\n\r\n        /**\r\n         * Per cell filtering data cache. As per the sort data cache, used to\r\n         * increase the performance of the filtering in DataTables\r\n         *  @type array\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _aFilterData: null,\r\n\r\n        /**\r\n         * Filtering data cache. This is the same as the cell filtering cache, but\r\n         * in this case a string rather than an array. This is easily computed with\r\n         * a join on `_aFilterData`, but is provided as a cache so the join isn't\r\n         * needed on every search (memory traded for performance)\r\n         *  @type array\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _sFilterRow: null,\r\n\r\n        /**\r\n         * Cache of the class name that DataTables has applied to the row, so we\r\n         * can quickly look at this variable rather than needing to do a DOM check\r\n         * on className for the nTr property.\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         *  @private\r\n         */\r\n        _sRowStripe: '',\r\n\r\n        /**\r\n         * Denote if the original data source was from the DOM, or the data source\r\n         * object. This is used for invalidating data, so DataTables can\r\n         * automatically read data from the original source, unless uninstructed\r\n         * otherwise.\r\n         *  @type string\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        src: null\r\n      }\r\n\r\n      /**\r\n       * Template object for the column information object in DataTables. This object\r\n       * is held in the settings aoColumns array and contains all the information that\r\n       * DataTables needs about each individual column.\r\n       *\r\n       * Note that this object is related to {@link DataTable.defaults.column}\r\n       * but this one is the internal data store for DataTables's cache of columns.\r\n       * It should NOT be manipulated outside of DataTables. Any configuration should\r\n       * be done through the initialisation options.\r\n       *  @namespace\r\n       */\r\n      DataTable.models.oColumn = {\r\n        /**\r\n         * Column index. This could be worked out on-the-fly with $.inArray, but it\r\n         * is faster to just hold it as a variable\r\n         *  @type integer\r\n         *  @default null\r\n         */\r\n        idx: null,\r\n\r\n        /**\r\n         * A list of the columns that sorting should occur on when this column\r\n         * is sorted. That this property is an array allows multi-column sorting\r\n         * to be defined for a column (for example first name / last name columns\r\n         * would benefit from this). The values are integers pointing to the\r\n         * columns to be sorted on (typically it will be a single integer pointing\r\n         * at itself, but that doesn't need to be the case).\r\n         *  @type array\r\n         */\r\n        aDataSort: null,\r\n\r\n        /**\r\n         * Define the sorting directions that are applied to the column, in sequence\r\n         * as the column is repeatedly sorted upon - i.e. the first value is used\r\n         * as the sorting direction when the column if first sorted (clicked on).\r\n         * Sort it again (click again) and it will move on to the next index.\r\n         * Repeat until loop.\r\n         *  @type array\r\n         */\r\n        asSorting: null,\r\n\r\n        /**\r\n         * Flag to indicate if the column is searchable, and thus should be included\r\n         * in the filtering or not.\r\n         *  @type boolean\r\n         */\r\n        bSearchable: null,\r\n\r\n        /**\r\n         * Flag to indicate if the column is sortable or not.\r\n         *  @type boolean\r\n         */\r\n        bSortable: null,\r\n\r\n        /**\r\n         * Flag to indicate if the column is currently visible in the table or not\r\n         *  @type boolean\r\n         */\r\n        bVisible: null,\r\n\r\n        /**\r\n         * Store for manual type assignment using the `column.type` option. This\r\n         * is held in store so we can manipulate the column's `sType` property.\r\n         *  @type string\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _sManualType: null,\r\n\r\n        /**\r\n         * Flag to indicate if HTML5 data attributes should be used as the data\r\n         * source for filtering or sorting. True is either are.\r\n         *  @type boolean\r\n         *  @default false\r\n         *  @private\r\n         */\r\n        _bAttrSrc: false,\r\n\r\n        /**\r\n         * Developer definable function that is called whenever a cell is created (Ajax source,\r\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\r\n         * allowing you to modify the DOM element (add background colour for example) when the\r\n         * element is available.\r\n         *  @type function\r\n         *  @param {element} nTd The TD node that has been created\r\n         *  @param {*} sData The Data for the cell\r\n         *  @param {array|object} oData The data for the whole row\r\n         *  @param {int} iRow The row index for the aoData data store\r\n         *  @default null\r\n         */\r\n        fnCreatedCell: null,\r\n\r\n        /**\r\n         * Function to get data from a cell in a column. You should <b>never</b>\r\n         * access data directly through _aData internally in DataTables - always use\r\n         * the method attached to this property. It allows mData to function as\r\n         * required. This function is automatically assigned by the column\r\n         * initialisation method\r\n         *  @type function\r\n         *  @param {array|object} oData The data array/object for the array\r\n         *    (i.e. aoData[]._aData)\r\n         *  @param {string} sSpecific The specific data type you want to get -\r\n         *    'display', 'type' 'filter' 'sort'\r\n         *  @returns {*} The data for the cell from the given row's data\r\n         *  @default null\r\n         */\r\n        fnGetData: null,\r\n\r\n        /**\r\n         * Function to set data for a cell in the column. You should <b>never</b>\r\n         * set the data directly to _aData internally in DataTables - always use\r\n         * this method. It allows mData to function as required. This function\r\n         * is automatically assigned by the column initialisation method\r\n         *  @type function\r\n         *  @param {array|object} oData The data array/object for the array\r\n         *    (i.e. aoData[]._aData)\r\n         *  @param {*} sValue Value to set\r\n         *  @default null\r\n         */\r\n        fnSetData: null,\r\n\r\n        /**\r\n         * Property to read the value for the cells in the column from the data\r\n         * source array / object. If null, then the default content is used, if a\r\n         * function is given then the return from the function is used.\r\n         *  @type function|int|string|null\r\n         *  @default null\r\n         */\r\n        mData: null,\r\n\r\n        /**\r\n         * Partner property to mData which is used (only when defined) to get\r\n         * the data - i.e. it is basically the same as mData, but without the\r\n         * 'set' option, and also the data fed to it is the result from mData.\r\n         * This is the rendering method to match the data method of mData.\r\n         *  @type function|int|string|null\r\n         *  @default null\r\n         */\r\n        mRender: null,\r\n\r\n        /**\r\n         * Unique header TH/TD element for this column - this is what the sorting\r\n         * listener is attached to (if sorting is enabled.)\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTh: null,\r\n\r\n        /**\r\n         * Unique footer TH/TD element for this column (if there is one). Not used\r\n         * in DataTables as such, but can be used for plug-ins to reference the\r\n         * footer for each column.\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTf: null,\r\n\r\n        /**\r\n         * The class to apply to all TD elements in the table's TBODY for the column\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sClass: null,\r\n\r\n        /**\r\n         * When DataTables calculates the column widths to assign to each column,\r\n         * it finds the longest string in each column and then constructs a\r\n         * temporary table and reads the widths from that. The problem with this\r\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\r\n         * string - thus the calculation can go wrong (doing it properly and putting\r\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\r\n         * a \"work around\" we provide this option. It will append its value to the\r\n         * text that is found to be the longest string for the column - i.e. padding.\r\n         *  @type string\r\n         */\r\n        sContentPadding: null,\r\n\r\n        /**\r\n         * Allows a default value to be given for a column's data, and will be used\r\n         * whenever a null data source is encountered (this can be because mData\r\n         * is set to null, or because the data source itself is null).\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sDefaultContent: null,\r\n\r\n        /**\r\n         * Name for the column, allowing reference to the column by name as well as\r\n         * by index (needs a lookup to work by name).\r\n         *  @type string\r\n         */\r\n        sName: null,\r\n\r\n        /**\r\n         * Custom sorting data type - defines which of the available plug-ins in\r\n         * afnSortData the custom sorting will use - if any is defined.\r\n         *  @type string\r\n         *  @default std\r\n         */\r\n        sSortDataType: 'std',\r\n\r\n        /**\r\n         * Class to be applied to the header element when sorting on this column\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sSortingClass: null,\r\n\r\n        /**\r\n         * Class to be applied to the header element when sorting on this column -\r\n         * when jQuery UI theming is used.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sSortingClassJUI: null,\r\n\r\n        /**\r\n         * Title of the column - what is seen in the TH element (nTh).\r\n         *  @type string\r\n         */\r\n        sTitle: null,\r\n\r\n        /**\r\n         * Column sorting and filtering type\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sType: null,\r\n\r\n        /**\r\n         * Width of the column\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sWidth: null,\r\n\r\n        /**\r\n         * Width of the column when it was first \"encountered\"\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sWidthOrig: null\r\n      }\r\n\r\n      /*\r\n       * Developer note: The properties of the object below are given in Hungarian\r\n       * notation, that was used as the interface for DataTables prior to v1.10, however\r\n       * from v1.10 onwards the primary interface is camel case. In order to avoid\r\n       * breaking backwards compatibility utterly with this change, the Hungarian\r\n       * version is still, internally the primary interface, but is is not documented\r\n       * - hence the @name tags in each doc comment. This allows a Javascript function\r\n       * to create a map from Hungarian notation to camel case (going the other direction\r\n       * would require each property to be listed, which would at around 3K to the size\r\n       * of DataTables, while this method is about a 0.5K hit.\r\n       *\r\n       * Ultimately this does pave the way for Hungarian notation to be dropped\r\n       * completely, but that is a massive amount of work and will break current\r\n       * installs (therefore is on-hold until v2).\r\n       */\r\n\r\n      /**\r\n       * Initialisation options that can be given to DataTables at initialisation\r\n       * time.\r\n       *  @namespace\r\n       */\r\n      DataTable.defaults = {\r\n        /**\r\n         * An array of data to use for the table, passed in at initialisation which\r\n         * will be used in preference to any data which is already in the DOM. This is\r\n         * particularly useful for constructing tables purely in Javascript, for\r\n         * example with a custom Ajax call.\r\n         *  @type array\r\n         *  @default null\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.data\r\n         *\r\n         *  @example\r\n         *    // Using a 2D array data source\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"data\": [\r\n         *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\r\n         *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\r\n         *        ],\r\n         *        \"columns\": [\r\n         *          { \"title\": \"Engine\" },\r\n         *          { \"title\": \"Browser\" },\r\n         *          { \"title\": \"Platform\" },\r\n         *          { \"title\": \"Version\" },\r\n         *          { \"title\": \"Grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using an array of objects as a data source (`data`)\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"data\": [\r\n         *          {\r\n         *            \"engine\":   \"Trident\",\r\n         *            \"browser\":  \"Internet Explorer 4.0\",\r\n         *            \"platform\": \"Win 95+\",\r\n         *            \"version\":  4,\r\n         *            \"grade\":    \"X\"\r\n         *          },\r\n         *          {\r\n         *            \"engine\":   \"Trident\",\r\n         *            \"browser\":  \"Internet Explorer 5.0\",\r\n         *            \"platform\": \"Win 95+\",\r\n         *            \"version\":  5,\r\n         *            \"grade\":    \"C\"\r\n         *          }\r\n         *        ],\r\n         *        \"columns\": [\r\n         *          { \"title\": \"Engine\",   \"data\": \"engine\" },\r\n         *          { \"title\": \"Browser\",  \"data\": \"browser\" },\r\n         *          { \"title\": \"Platform\", \"data\": \"platform\" },\r\n         *          { \"title\": \"Version\",  \"data\": \"version\" },\r\n         *          { \"title\": \"Grade\",    \"data\": \"grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aaData: null,\r\n\r\n        /**\r\n         * If ordering is enabled, then DataTables will perform a first pass sort on\r\n         * initialisation. You can define which column(s) the sort is performed\r\n         * upon, and the sorting direction, with this variable. The `sorting` array\r\n         * should contain an array for each column to be sorted initially containing\r\n         * the column's index and a direction string ('asc' or 'desc').\r\n         *  @type array\r\n         *  @default [[0,'asc']]\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.order\r\n         *\r\n         *  @example\r\n         *    // Sort by 3rd column first, and then 4th column\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"order\": [[2,'asc'], [3,'desc']]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *    // No initial sorting\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"order\": []\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aaSorting: [[0, 'asc']],\r\n\r\n        /**\r\n         * This parameter is basically identical to the `sorting` parameter, but\r\n         * cannot be overridden by user interaction with the table. What this means\r\n         * is that you could have a column (visible or hidden) which the sorting\r\n         * will always be forced on first - any sorting after that (from the user)\r\n         * will then be performed as required. This can be useful for grouping rows\r\n         * together.\r\n         *  @type array\r\n         *  @default null\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.orderFixed\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderFixed\": [[0,'asc']]\r\n         *      } );\r\n         *    } )\r\n         */\r\n        aaSortingFixed: [],\r\n\r\n        /**\r\n         * DataTables can be instructed to load data to display in the table from a\r\n         * Ajax source. This option defines how that Ajax call is made and where to.\r\n         *\r\n         * The `ajax` property has three different modes of operation, depending on\r\n         * how it is defined. These are:\r\n         *\r\n         * * `string` - Set the URL from where the data should be loaded from.\r\n         * * `object` - Define properties for `jQuery.ajax`.\r\n         * * `function` - Custom data get function\r\n         *\r\n         * `string`\r\n         * --------\r\n         *\r\n         * As a string, the `ajax` property simply defines the URL from which\r\n         * DataTables will load data.\r\n         *\r\n         * `object`\r\n         * --------\r\n         *\r\n         * As an object, the parameters in the object are passed to\r\n         * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\r\n         * of the Ajax request. DataTables has a number of default parameters which\r\n         * you can override using this option. Please refer to the jQuery\r\n         * documentation for a full description of the options available, although\r\n         * the following parameters provide additional options in DataTables or\r\n         * require special consideration:\r\n         *\r\n         * * `data` - As with jQuery, `data` can be provided as an object, but it\r\n         *   can also be used as a function to manipulate the data DataTables sends\r\n         *   to the server. The function takes a single parameter, an object of\r\n         *   parameters with the values that DataTables has readied for sending. An\r\n         *   object may be returned which will be merged into the DataTables\r\n         *   defaults, or you can add the items to the object that was passed in and\r\n         *   not return anything from the function. This supersedes `fnServerParams`\r\n         *   from DataTables 1.9-.\r\n         *\r\n         * * `dataSrc` - By default DataTables will look for the property `data` (or\r\n         *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\r\n         *   from an Ajax source or for server-side processing - this parameter\r\n         *   allows that property to be changed. You can use Javascript dotted\r\n         *   object notation to get a data source for multiple levels of nesting, or\r\n         *   it my be used as a function. As a function it takes a single parameter,\r\n         *   the JSON returned from the server, which can be manipulated as\r\n         *   required, with the returned value being that used by DataTables as the\r\n         *   data source for the table. This supersedes `sAjaxDataProp` from\r\n         *   DataTables 1.9-.\r\n         *\r\n         * * `success` - Should not be overridden it is used internally in\r\n         *   DataTables. To manipulate / transform the data returned by the server\r\n         *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\r\n         *\r\n         * `function`\r\n         * ----------\r\n         *\r\n         * As a function, making the Ajax call is left up to yourself allowing\r\n         * complete control of the Ajax request. Indeed, if desired, a method other\r\n         * than Ajax could be used to obtain the required data, such as Web storage\r\n         * or an AIR database.\r\n         *\r\n         * The function is given four parameters and no return is required. The\r\n         * parameters are:\r\n         *\r\n         * 1. _object_ - Data to send to the server\r\n         * 2. _function_ - Callback function that must be executed when the required\r\n         *    data has been obtained. That data should be passed into the callback\r\n         *    as the only parameter\r\n         * 3. _object_ - DataTables settings object for the table\r\n         *\r\n         * Note that this supersedes `fnServerData` from DataTables 1.9-.\r\n         *\r\n         *  @type string|object|function\r\n         *  @default null\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.ajax\r\n         *  @since 1.10.0\r\n         *\r\n         * @example\r\n         *   // Get JSON data from a file via Ajax.\r\n         *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": \"data.json\"\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to change\r\n         *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"dataSrc\": \"tableData\"\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\r\n         *   // from a plain array rather than an array in an object\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"dataSrc\": \"\"\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Manipulate the data returned from the server - add a link to data\r\n         *   // (note this can, should, be done using `render` for the column - this\r\n         *   // is just a simple example of how the data can be manipulated).\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"dataSrc\": function ( json ) {\r\n         *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\r\n         *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\r\n         *         }\r\n         *         return json;\r\n         *       }\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Add data to the request\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"data\": function ( d ) {\r\n         *         return {\r\n         *           \"extra_search\": $('#extra').val()\r\n         *         };\r\n         *       }\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Send request as POST\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"type\": \"POST\"\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Get the data from localStorage (could interface with a form for\r\n         *   // adding, editing and removing rows).\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": function (data, callback, settings) {\r\n         *       callback(\r\n         *         JSON.parse( localStorage.getItem('dataTablesData') )\r\n         *       );\r\n         *     }\r\n         *   } );\r\n         */\r\n        ajax: null,\r\n\r\n        /**\r\n         * This parameter allows you to readily specify the entries in the length drop\r\n         * down menu that DataTables shows when pagination is enabled. It can be\r\n         * either a 1D array of options which will be used for both the displayed\r\n         * option and the value, or a 2D array which will use the array in the first\r\n         * position as the value, and the array in the second position as the\r\n         * displayed options (useful for language strings such as 'All').\r\n         *\r\n         * Note that the `pageLength` property will be automatically set to the\r\n         * first value given in this array, unless `pageLength` is also provided.\r\n         *  @type array\r\n         *  @default [ 10, 25, 50, 100 ]\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.lengthMenu\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aLengthMenu: [10, 25, 50, 100],\r\n\r\n        /**\r\n         * The `columns` option in the initialisation parameter allows you to define\r\n         * details about the way individual columns behave. For a full list of\r\n         * column options that can be set, please see\r\n         * {@link DataTable.defaults.column}. Note that if you use `columns` to\r\n         * define your columns, you must have an entry in the array for every single\r\n         * column that you have in your table (these can be null if you don't which\r\n         * to specify any options).\r\n         *  @member\r\n         *\r\n         *  @name DataTable.defaults.column\r\n         */\r\n        aoColumns: null,\r\n\r\n        /**\r\n         * Very similar to `columns`, `columnDefs` allows you to target a specific\r\n         * column, multiple columns, or all columns, using the `targets` property of\r\n         * each object in the array. This allows great flexibility when creating\r\n         * tables, as the `columnDefs` arrays can be of any length, targeting the\r\n         * columns you specifically want. `columnDefs` may use any of the column\r\n         * options available: {@link DataTable.defaults.column}, but it _must_\r\n         * have `targets` defined in each object in the array. Values in the `targets`\r\n         * array may be:\r\n         *   <ul>\r\n         *     <li>a string - class name will be matched on the TH for the column</li>\r\n         *     <li>0 or a positive integer - column index counting from the left</li>\r\n         *     <li>a negative integer - column index counting from the right</li>\r\n         *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\r\n         *   </ul>\r\n         *  @member\r\n         *\r\n         *  @name DataTable.defaults.columnDefs\r\n         */\r\n        aoColumnDefs: null,\r\n\r\n        /**\r\n         * Basically the same as `search`, this parameter defines the individual column\r\n         * filtering state at initialisation time. The array must be of the same size\r\n         * as the number of columns, and each element be an object with the parameters\r\n         * `search` and `escapeRegex` (the latter is optional). 'null' is also\r\n         * accepted and the default will be used.\r\n         *  @type array\r\n         *  @default []\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.searchCols\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"searchCols\": [\r\n         *          null,\r\n         *          { \"search\": \"My filter\" },\r\n         *          null,\r\n         *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\r\n         *        ]\r\n         *      } );\r\n         *    } )\r\n         */\r\n        aoSearchCols: [],\r\n\r\n        /**\r\n         * An array of CSS classes that should be applied to displayed rows. This\r\n         * array may be of any length, and DataTables will apply each class\r\n         * sequentially, looping when required.\r\n         *  @type array\r\n         *  @default null <i>Will take the values determined by the `oClasses.stripe*`\r\n         *    options</i>\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.stripeClasses\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\r\n         *      } );\r\n         *    } )\r\n         */\r\n        asStripeClasses: null,\r\n\r\n        /**\r\n         * Enable or disable automatic column width calculation. This can be disabled\r\n         * as an optimisation (it takes some time to calculate the widths) if the\r\n         * tables widths are passed in using `columns`.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.autoWidth\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"autoWidth\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bAutoWidth: true,\r\n\r\n        /**\r\n         * Deferred rendering can provide DataTables with a huge speed boost when you\r\n         * are using an Ajax or JS data source for the table. This option, when set to\r\n         * true, will cause DataTables to defer the creation of the table elements for\r\n         * each row until they are needed for a draw - saving a significant amount of\r\n         * time.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.deferRender\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajax\": \"sources/arrays.txt\",\r\n         *        \"deferRender\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bDeferRender: false,\r\n\r\n        /**\r\n         * Replace a DataTable which matches the given selector and replace it with\r\n         * one which has the properties of the new initialisation object passed. If no\r\n         * table matches the selector, then the new DataTable will be constructed as\r\n         * per normal.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.destroy\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"srollY\": \"200px\",\r\n         *        \"paginate\": false\r\n         *      } );\r\n         *\r\n         *      // Some time later....\r\n         *      $('#example').dataTable( {\r\n         *        \"filter\": false,\r\n         *        \"destroy\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bDestroy: false,\r\n\r\n        /**\r\n         * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\r\n         * that it allows the end user to input multiple words (space separated) and\r\n         * will match a row containing those words, even if not in the order that was\r\n         * specified (this allow matching across multiple columns). Note that if you\r\n         * wish to use filtering in DataTables this must remain 'true' - to remove the\r\n         * default filtering input box and retain filtering abilities, please use\r\n         * {@link DataTable.defaults.dom}.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.searching\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"searching\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bFilter: true,\r\n\r\n        /**\r\n         * Enable or disable the table information display. This shows information\r\n         * about the data that is currently visible on the page, including information\r\n         * about filtered data if that action is being performed.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.info\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"info\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bInfo: true,\r\n\r\n        /**\r\n         * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some\r\n         * slightly different and additional mark-up from what DataTables has\r\n         * traditionally used).\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.jQueryUI\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"jQueryUI\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bJQueryUI: false,\r\n\r\n        /**\r\n         * Allows the end user to select the size of a formatted page from a select\r\n         * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.lengthChange\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"lengthChange\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bLengthChange: true,\r\n\r\n        /**\r\n         * Enable or disable pagination.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.paging\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"paging\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bPaginate: true,\r\n\r\n        /**\r\n         * Enable or disable the display of a 'processing' indicator when the table is\r\n         * being processed (e.g. a sort). This is particularly useful for tables with\r\n         * large amounts of data where it can take a noticeable amount of time to sort\r\n         * the entries.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.processing\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"processing\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bProcessing: false,\r\n\r\n        /**\r\n         * Retrieve the DataTables object for the given selector. Note that if the\r\n         * table has already been initialised, this parameter will cause DataTables\r\n         * to simply return the object that has already been set up - it will not take\r\n         * account of any changes you might have made to the initialisation object\r\n         * passed to DataTables (setting this parameter to true is an acknowledgement\r\n         * that you understand this). `destroy` can be used to reinitialise a table if\r\n         * you need.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.retrieve\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      initTable();\r\n         *      tableActions();\r\n         *    } );\r\n         *\r\n         *    function initTable ()\r\n         *    {\r\n         *      return $('#example').dataTable( {\r\n         *        \"scrollY\": \"200px\",\r\n         *        \"paginate\": false,\r\n         *        \"retrieve\": true\r\n         *      } );\r\n         *    }\r\n         *\r\n         *    function tableActions ()\r\n         *    {\r\n         *      var table = initTable();\r\n         *      // perform API operations with oTable\r\n         *    }\r\n         */\r\n        bRetrieve: false,\r\n\r\n        /**\r\n         * When vertical (y) scrolling is enabled, DataTables will force the height of\r\n         * the table's viewport to the given height at all times (useful for layout).\r\n         * However, this can look odd when filtering data down to a small data set,\r\n         * and the footer is left \"floating\" further down. This parameter (when\r\n         * enabled) will cause DataTables to collapse the table's viewport down when\r\n         * the result set will fit within the given Y height.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.scrollCollapse\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollY\": \"200\",\r\n         *        \"scrollCollapse\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bScrollCollapse: false,\r\n\r\n        /**\r\n         * Configure DataTables to use server-side processing. Note that the\r\n         * `ajax` parameter must also be given in order to give DataTables a\r\n         * source to obtain the required data for each draw.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverSide\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"serverSide\": true,\r\n         *        \"ajax\": \"xhr.php\"\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bServerSide: false,\r\n\r\n        /**\r\n         * Enable or disable sorting of columns. Sorting of individual columns can be\r\n         * disabled by the `sortable` option for each column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.ordering\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"ordering\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSort: true,\r\n\r\n        /**\r\n         * Enable or display DataTables' ability to sort multiple columns at the\r\n         * same time (activated by shift-click by the user).\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.orderMulti\r\n         *\r\n         *  @example\r\n         *    // Disable multiple column sorting ability\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderMulti\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSortMulti: true,\r\n\r\n        /**\r\n         * Allows control over whether DataTables should use the top (true) unique\r\n         * cell that is found for a single column, or the bottom (false - default).\r\n         * This is useful when using complex headers.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.orderCellsTop\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderCellsTop\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSortCellsTop: false,\r\n\r\n        /**\r\n         * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\r\n         * `sorting\\_3` to the columns which are currently being sorted on. This is\r\n         * presented as a feature switch as it can increase processing time (while\r\n         * classes are removed and added) so for large data sets you might want to\r\n         * turn this off.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.orderClasses\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderClasses\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSortClasses: true,\r\n\r\n        /**\r\n         * Enable or disable state saving. When enabled HTML5 `localStorage` will be\r\n         * used to save table display information such as pagination information,\r\n         * display length, filtering and sorting. As such when the end user reloads\r\n         * the page the display display will match what thy had previously set up.\r\n         *\r\n         * Due to the use of `localStorage` the default state saving is not supported\r\n         * in IE6 or 7. If state saving is required in those browsers, use\r\n         * `stateSaveCallback` to provide a storage solution such as cookies.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.stateSave\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bStateSave: false,\r\n\r\n        /**\r\n         * This function is called when a TR element is created (and all TD child\r\n         * elements have been inserted), or registered if using a DOM source, allowing\r\n         * manipulation of the TR element (adding classes etc).\r\n         *  @type function\r\n         *  @param {node} row \"TR\" element for the current row\r\n         *  @param {array} data Raw data array for this row\r\n         *  @param {int} dataIndex The index of this row in the internal aoData array\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.createdRow\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"createdRow\": function( row, data, dataIndex ) {\r\n         *          // Bold the grade for all 'A' grade browsers\r\n         *          if ( data[4] == \"A\" )\r\n         *          {\r\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\r\n         *          }\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnCreatedRow: null,\r\n\r\n        /**\r\n         * This function is called on every 'draw' event, and allows you to\r\n         * dynamically modify any aspect you want about the created DOM.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.drawCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"drawCallback\": function( settings ) {\r\n         *          alert( 'DataTables has redrawn the table' );\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnDrawCallback: null,\r\n\r\n        /**\r\n         * Identical to fnHeaderCallback() but for the table footer this function\r\n         * allows you to modify the table footer on every 'draw' event.\r\n         *  @type function\r\n         *  @param {node} foot \"TR\" element for the footer\r\n         *  @param {array} data Full table data (as derived from the original HTML)\r\n         *  @param {int} start Index for the current display starting point in the\r\n         *    display array\r\n         *  @param {int} end Index for the current display ending point in the\r\n         *    display array\r\n         *  @param {array int} display Index array to translate the visual position\r\n         *    to the full data array\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.footerCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"footerCallback\": function( tfoot, data, start, end, display ) {\r\n         *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\r\n         *        }\r\n         *      } );\r\n         *    } )\r\n         */\r\n        fnFooterCallback: null,\r\n\r\n        /**\r\n         * When rendering large numbers in the information element for the table\r\n         * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\r\n         * to have a comma separator for the 'thousands' units (e.g. 1 million is\r\n         * rendered as \"1,000,000\") to help readability for the end user. This\r\n         * function will override the default method DataTables uses.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {int} toFormat number to be formatted\r\n         *  @returns {string} formatted string for DataTables to show the number\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.formatNumber\r\n         *\r\n         *  @example\r\n         *    // Format a number using a single quote for the separator (note that\r\n         *    // this can also be done with the language.thousands option)\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"formatNumber\": function ( toFormat ) {\r\n         *          return toFormat.toString().replace(\r\n         *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\r\n         *          );\r\n         *        };\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnFormatNumber: function (toFormat) {\r\n          return toFormat.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.oLanguage.sThousands)\r\n        },\r\n\r\n        /**\r\n         * This function is called on every 'draw' event, and allows you to\r\n         * dynamically modify the header row. This can be used to calculate and\r\n         * display useful information about the table.\r\n         *  @type function\r\n         *  @param {node} head \"TR\" element for the header\r\n         *  @param {array} data Full table data (as derived from the original HTML)\r\n         *  @param {int} start Index for the current display starting point in the\r\n         *    display array\r\n         *  @param {int} end Index for the current display ending point in the\r\n         *    display array\r\n         *  @param {array int} display Index array to translate the visual position\r\n         *    to the full data array\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.headerCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"fheaderCallback\": function( head, data, start, end, display ) {\r\n         *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\r\n         *        }\r\n         *      } );\r\n         *    } )\r\n         */\r\n        fnHeaderCallback: null,\r\n\r\n        /**\r\n         * The information element can be used to convey information about the current\r\n         * state of the table. Although the internationalisation options presented by\r\n         * DataTables are quite capable of dealing with most customisations, there may\r\n         * be times where you wish to customise the string further. This callback\r\n         * allows you to do exactly that.\r\n         *  @type function\r\n         *  @param {object} oSettings DataTables settings object\r\n         *  @param {int} start Starting position in data for the draw\r\n         *  @param {int} end End position in data for the draw\r\n         *  @param {int} max Total number of rows in the table (regardless of\r\n         *    filtering)\r\n         *  @param {int} total Total number of rows in the data set, after filtering\r\n         *  @param {string} pre The string that DataTables has formatted using it's\r\n         *    own rules\r\n         *  @returns {string} The string to be displayed in the information element.\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.infoCallback\r\n         *\r\n         *  @example\r\n         *    $('#example').dataTable( {\r\n         *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\r\n         *        return start +\" to \"+ end;\r\n         *      }\r\n         *    } );\r\n         */\r\n        fnInfoCallback: null,\r\n\r\n        /**\r\n         * Called when the table has been initialised. Normally DataTables will\r\n         * initialise sequentially and there will be no need for this function,\r\n         * however, this does not hold true when using external language information\r\n         * since that is obtained using an async XHR call.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} json The JSON object request from the server - only\r\n         *    present if client-side Ajax sourced data is used\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.initComplete\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"initComplete\": function(settings, json) {\r\n         *          alert( 'DataTables has finished its initialisation.' );\r\n         *        }\r\n         *      } );\r\n         *    } )\r\n         */\r\n        fnInitComplete: null,\r\n\r\n        /**\r\n         * Called at the very start of each table draw and can be used to cancel the\r\n         * draw by returning false, any other return (including undefined) results in\r\n         * the full draw occurring).\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @returns {boolean} False will cancel the draw, anything else (including no\r\n         *    return) will allow it to complete.\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.preDrawCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"preDrawCallback\": function( settings ) {\r\n         *          if ( $('#test').val() == 1 ) {\r\n         *            return false;\r\n         *          }\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnPreDrawCallback: null,\r\n\r\n        /**\r\n         * This function allows you to 'post process' each row after it have been\r\n         * generated for each table draw, but before it is rendered on screen. This\r\n         * function might be used for setting the row class name etc.\r\n         *  @type function\r\n         *  @param {node} row \"TR\" element for the current row\r\n         *  @param {array} data Raw data array for this row\r\n         *  @param {int} displayIndex The display index for the current table draw\r\n         *  @param {int} displayIndexFull The index of the data in the full list of\r\n         *    rows (after filtering)\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.rowCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\r\n         *          // Bold the grade for all 'A' grade browsers\r\n         *          if ( data[4] == \"A\" ) {\r\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\r\n         *          }\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnRowCallback: null,\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * This parameter allows you to override the default function which obtains\r\n         * the data from the server so something more suitable for your application.\r\n         * For example you could use POST data, or pull information from a Gears or\r\n         * AIR database.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {string} source HTTP source to obtain the data from (`ajax`)\r\n         *  @param {array} data A key/value pair object containing the data to send\r\n         *    to the server\r\n         *  @param {function} callback to be called on completion of the data get\r\n         *    process that will draw the data on the page.\r\n         *  @param {object} settings DataTables settings object\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverData\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        fnServerData: null,\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         *  It is often useful to send extra data to the server when making an Ajax\r\n         * request - for example custom filtering information, and this callback\r\n         * function makes it trivial to send extra information to the server. The\r\n         * passed in parameter is the data set that has been constructed by\r\n         * DataTables, and you can add to this or modify it as you require.\r\n         *  @type function\r\n         *  @param {array} data Data array (array of objects which are name/value\r\n         *    pairs) that has been constructed by DataTables and will be sent to the\r\n         *    server. In the case of Ajax sourced data with server-side processing\r\n         *    this will be an empty array, for server-side processing there will be a\r\n         *    significant number of parameters!\r\n         *  @returns {undefined} Ensure that you modify the data array passed in,\r\n         *    as this is passed by reference.\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverParams\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        fnServerParams: null,\r\n\r\n        /**\r\n         * Load the table state. With this function you can define from where, and how, the\r\n         * state of a table is loaded. By default DataTables will load from `localStorage`\r\n         * but you might wish to use a server-side database or cookies.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {object} settings DataTables settings object\r\n         *  @return {object} The DataTables state object to be loaded\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateLoadCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoadCallback\": function (settings) {\r\n         *          var o;\r\n         *\r\n         *          // Send an Ajax request to the server to get the data. Note that\r\n         *          // this is a synchronous request.\r\n         *          $.ajax( {\r\n         *            \"url\": \"/state_load\",\r\n         *            \"async\": false,\r\n         *            \"dataType\": \"json\",\r\n         *            \"success\": function (json) {\r\n         *              o = json;\r\n         *            }\r\n         *          } );\r\n         *\r\n         *          return o;\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateLoadCallback: function (settings) {\r\n          try {\r\n            return JSON.parse(\r\n              (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\r\n                'DataTables_' + settings.sInstance + '_' + location.pathname\r\n              )\r\n            )\r\n          } catch (e) {}\r\n        },\r\n\r\n        /**\r\n         * Callback which allows modification of the saved state prior to loading that state.\r\n         * This callback is called when the table is loading state from the stored data, but\r\n         * prior to the settings object being modified by the saved state. Note that for\r\n         * plug-in authors, you should use the `stateLoadParams` event to load parameters for\r\n         * a plug-in.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object that is to be loaded\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateLoadParams\r\n         *\r\n         *  @example\r\n         *    // Remove a saved filter, so filtering is never loaded\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoadParams\": function (settings, data) {\r\n         *          data.oSearch.sSearch = \"\";\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Disallow state loading by returning false\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoadParams\": function (settings, data) {\r\n         *          return false;\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateLoadParams: null,\r\n\r\n        /**\r\n         * Callback that is called when the state has been loaded from the state saving method\r\n         * and the DataTables settings object has been modified as a result of the loaded state.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object that was loaded\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateLoaded\r\n         *\r\n         *  @example\r\n         *    // Show an alert with the filtering value that was saved\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoaded\": function (settings, data) {\r\n         *          alert( 'Saved filter was: '+data.oSearch.sSearch );\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateLoaded: null,\r\n\r\n        /**\r\n         * Save the table state. This function allows you to define where and how the state\r\n         * information for the table is stored By default DataTables will use `localStorage`\r\n         * but you might wish to use a server-side database or cookies.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object to be saved\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateSaveCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateSaveCallback\": function (settings, data) {\r\n         *          // Send an Ajax request to the server with the state object\r\n         *          $.ajax( {\r\n         *            \"url\": \"/state_save\",\r\n         *            \"data\": data,\r\n         *            \"dataType\": \"json\",\r\n         *            \"method\": \"POST\"\r\n         *            \"success\": function () {}\r\n         *          } );\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateSaveCallback: function (settings, data) {\r\n          try {\r\n            ;(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\r\n              'DataTables_' + settings.sInstance + '_' + location.pathname,\r\n              JSON.stringify(data)\r\n            )\r\n          } catch (e) {}\r\n        },\r\n\r\n        /**\r\n         * Callback which allows modification of the state to be saved. Called when the table\r\n         * has changed state a new state save is required. This method allows modification of\r\n         * the state saving object prior to actually doing the save, including addition or\r\n         * other state properties or modification. Note that for plug-in authors, you should\r\n         * use the `stateSaveParams` event to save parameters for a plug-in.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object to be saved\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateSaveParams\r\n         *\r\n         *  @example\r\n         *    // Remove a saved filter, so filtering is never saved\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateSaveParams\": function (settings, data) {\r\n         *          data.oSearch.sSearch = \"\";\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateSaveParams: null,\r\n\r\n        /**\r\n         * Duration for which the saved state information is considered valid. After this period\r\n         * has elapsed the state will be returned to the default.\r\n         * Value is given in seconds.\r\n         *  @type int\r\n         *  @default 7200 <i>(2 hours)</i>\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.stateDuration\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateDuration\": 60*60*24; // 1 day\r\n         *      } );\r\n         *    } )\r\n         */\r\n        iStateDuration: 7200,\r\n\r\n        /**\r\n         * When enabled DataTables will not make a request to the server for the first\r\n         * page draw - rather it will use the data already on the page (no sorting etc\r\n         * will be applied to it), thus saving on an XHR at load time. `deferLoading`\r\n         * is used to indicate that deferred loading is required, but it is also used\r\n         * to tell DataTables how many records there are in the full table (allowing\r\n         * the information element and pagination to be displayed correctly). In the case\r\n         * where a filtering is applied to the table on initial load, this can be\r\n         * indicated by giving the parameter as an array, where the first element is\r\n         * the number of records available after filtering and the second element is the\r\n         * number of records without filtering (allowing the table information element\r\n         * to be shown correctly).\r\n         *  @type int | array\r\n         *  @default null\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.deferLoading\r\n         *\r\n         *  @example\r\n         *    // 57 records available in the table, no filtering applied\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"serverSide\": true,\r\n         *        \"ajax\": \"scripts/server_processing.php\",\r\n         *        \"deferLoading\": 57\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // 57 records after filtering, 100 without filtering (an initial filter applied)\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"serverSide\": true,\r\n         *        \"ajax\": \"scripts/server_processing.php\",\r\n         *        \"deferLoading\": [ 57, 100 ],\r\n         *        \"search\": {\r\n         *          \"search\": \"my_filter\"\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        iDeferLoading: null,\r\n\r\n        /**\r\n         * Number of rows to display on a single page when using pagination. If\r\n         * feature enabled (`lengthChange`) then the end user will be able to override\r\n         * this to a custom setting using a pop-up menu.\r\n         *  @type int\r\n         *  @default 10\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.pageLength\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"pageLength\": 50\r\n         *      } );\r\n         *    } )\r\n         */\r\n        iDisplayLength: 10,\r\n\r\n        /**\r\n         * Define the starting point for data display when using DataTables with\r\n         * pagination. Note that this parameter is the number of records, rather than\r\n         * the page number, so if you have 10 records per page and want to start on\r\n         * the third page, it should be \"20\".\r\n         *  @type int\r\n         *  @default 0\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.displayStart\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"displayStart\": 20\r\n         *      } );\r\n         *    } )\r\n         */\r\n        iDisplayStart: 0,\r\n\r\n        /**\r\n         * By default DataTables allows keyboard navigation of the table (sorting, paging,\r\n         * and filtering) by adding a `tabindex` attribute to the required elements. This\r\n         * allows you to tab through the controls and press the enter key to activate them.\r\n         * The tabindex is default 0, meaning that the tab follows the flow of the document.\r\n         * You can overrule this using this parameter if you wish. Use a value of -1 to\r\n         * disable built-in keyboard navigation.\r\n         *  @type int\r\n         *  @default 0\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.tabIndex\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"tabIndex\": 1\r\n         *      } );\r\n         *    } );\r\n         */\r\n        iTabIndex: 0,\r\n\r\n        /**\r\n         * Classes that DataTables assigns to the various components and features\r\n         * that it adds to the HTML table. This allows classes to be configured\r\n         * during initialisation in addition to through the static\r\n         * {@link DataTable.ext.oStdClasses} object).\r\n         *  @namespace\r\n         *  @name DataTable.defaults.classes\r\n         */\r\n        oClasses: {},\r\n\r\n        /**\r\n         * All strings that DataTables uses in the user interface that it creates\r\n         * are defined in this object, allowing you to modified them individually or\r\n         * completely replace them all as required.\r\n         *  @namespace\r\n         *  @name DataTable.defaults.language\r\n         */\r\n        oLanguage: {\r\n          /**\r\n           * Strings that are used for WAI-ARIA labels and controls only (these are not\r\n           * actually visible on the page, but will be read by screenreaders, and thus\r\n           * must be internationalised as well).\r\n           *  @namespace\r\n           *  @name DataTable.defaults.language.aria\r\n           */\r\n          oAria: {\r\n            /**\r\n             * ARIA label that is added to the table headers when the column may be\r\n             * sorted ascending by activing the column (click or return when focused).\r\n             * Note that the column header is prefixed to this string.\r\n             *  @type string\r\n             *  @default : activate to sort column ascending\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.aria.sortAscending\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"aria\": {\r\n             *            \"sortAscending\": \" - click/return to sort ascending\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sSortAscending: ': activate to sort column ascending',\r\n\r\n            /**\r\n             * ARIA label that is added to the table headers when the column may be\r\n             * sorted descending by activing the column (click or return when focused).\r\n             * Note that the column header is prefixed to this string.\r\n             *  @type string\r\n             *  @default : activate to sort column ascending\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.aria.sortDescending\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"aria\": {\r\n             *            \"sortDescending\": \" - click/return to sort descending\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sSortDescending: ': activate to sort column descending'\r\n          },\r\n\r\n          /**\r\n           * Pagination string used by DataTables for the built-in pagination\r\n           * control types.\r\n           *  @namespace\r\n           *  @name DataTable.defaults.language.paginate\r\n           */\r\n          oPaginate: {\r\n            /**\r\n             * Text to use when using the 'full_numbers' type of pagination for the\r\n             * button to take the user to the first page.\r\n             *  @type string\r\n             *  @default First\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.first\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"first\": \"First page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sFirst: 'First',\r\n\r\n            /**\r\n             * Text to use when using the 'full_numbers' type of pagination for the\r\n             * button to take the user to the last page.\r\n             *  @type string\r\n             *  @default Last\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.last\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"last\": \"Last page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sLast: 'Last',\r\n\r\n            /**\r\n             * Text to use for the 'next' pagination button (to take the user to the\r\n             * next page).\r\n             *  @type string\r\n             *  @default Next\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.next\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"next\": \"Next page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sNext: 'Next',\r\n\r\n            /**\r\n             * Text to use for the 'previous' pagination button (to take the user to\r\n             * the previous page).\r\n             *  @type string\r\n             *  @default Previous\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.previous\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"previous\": \"Previous page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sPrevious: 'Previous'\r\n          },\r\n\r\n          /**\r\n           * This string is shown in preference to `zeroRecords` when the table is\r\n           * empty of data (regardless of filtering). Note that this is an optional\r\n           * parameter - if it is not given, the value of `zeroRecords` will be used\r\n           * instead (either the default or given value).\r\n           *  @type string\r\n           *  @default No data available in table\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.emptyTable\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"emptyTable\": \"No data available in table\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sEmptyTable: 'No data available in table',\r\n\r\n          /**\r\n           * This string gives information to the end user about the information\r\n           * that is current on display on the page. The following tokens can be\r\n           * used in the string and will be dynamically replaced as the table\r\n           * display updates. This tokens can be placed anywhere in the string, or\r\n           * removed as needed by the language requires:\r\n           *\r\n           * * `\\_START\\_` - Display index of the first record on the current page\r\n           * * `\\_END\\_` - Display index of the last record on the current page\r\n           * * `\\_TOTAL\\_` - Number of records in the table after filtering\r\n           * * `\\_MAX\\_` - Number of records in the table without filtering\r\n           * * `\\_PAGE\\_` - Current page number\r\n           * * `\\_PAGES\\_` - Total number of pages of data in the table\r\n           *\r\n           *  @type string\r\n           *  @default Showing _START_ to _END_ of _TOTAL_ entries\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.info\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfo: 'Showing _START_ to _END_ of _TOTAL_ entries',\r\n\r\n          /**\r\n           * Display information string for when the table is empty. Typically the\r\n           * format of this string should match `info`.\r\n           *  @type string\r\n           *  @default Showing 0 to 0 of 0 entries\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.infoEmpty\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"infoEmpty\": \"No entries to show\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfoEmpty: 'Showing 0 to 0 of 0 entries',\r\n\r\n          /**\r\n           * When a user filters the information in a table, this string is appended\r\n           * to the information (`info`) to give an idea of how strong the filtering\r\n           * is. The variable _MAX_ is dynamically updated.\r\n           *  @type string\r\n           *  @default (filtered from _MAX_ total entries)\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.infoFiltered\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"infoFiltered\": \" - filtering from _MAX_ records\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfoFiltered: '(filtered from _MAX_ total entries)',\r\n\r\n          /**\r\n           * If can be useful to append extra information to the info string at times,\r\n           * and this variable does exactly that. This information will be appended to\r\n           * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\r\n           * being used) at all times.\r\n           *  @type string\r\n           *  @default <i>Empty string</i>\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.infoPostFix\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"infoPostFix\": \"All records shown are derived from real information.\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfoPostFix: '',\r\n\r\n          /**\r\n           * This decimal place operator is a little different from the other\r\n           * language options since DataTables doesn't output floating point\r\n           * numbers, so it won't ever use this for display of a number. Rather,\r\n           * what this parameter does is modify the sort methods of the table so\r\n           * that numbers which are in a format which has a character other than\r\n           * a period (`.`) as a decimal place will be sorted numerically.\r\n           *\r\n           * Note that numbers with different decimal places cannot be shown in\r\n           * the same table and still be sortable, the table must be consistent.\r\n           * However, multiple different tables on the page can use different\r\n           * decimal place characters.\r\n           *  @type string\r\n           *  @default\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.decimal\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"decimal\": \",\"\r\n           *          \"thousands\": \".\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sDecimal: '',\r\n\r\n          /**\r\n           * DataTables has a build in number formatter (`formatNumber`) which is\r\n           * used to format large numbers that are used in the table information.\r\n           * By default a comma is used, but this can be trivially changed to any\r\n           * character you wish with this parameter.\r\n           *  @type string\r\n           *  @default ,\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.thousands\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"thousands\": \"'\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sThousands: ',',\r\n\r\n          /**\r\n           * Detail the action that will be taken when the drop down menu for the\r\n           * pagination length option is changed. The '_MENU_' variable is replaced\r\n           * with a default select list of 10, 25, 50 and 100, and can be replaced\r\n           * with a custom select box if required.\r\n           *  @type string\r\n           *  @default Show _MENU_ entries\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.lengthMenu\r\n           *\r\n           *  @example\r\n           *    // Language change only\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"lengthMenu\": \"Display _MENU_ records\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           *\r\n           *  @example\r\n           *    // Language and options change\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"lengthMenu\": 'Display <select>'+\r\n           *            '<option value=\"10\">10</option>'+\r\n           *            '<option value=\"20\">20</option>'+\r\n           *            '<option value=\"30\">30</option>'+\r\n           *            '<option value=\"40\">40</option>'+\r\n           *            '<option value=\"50\">50</option>'+\r\n           *            '<option value=\"-1\">All</option>'+\r\n           *            '</select> records'\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sLengthMenu: 'Show _MENU_ entries',\r\n\r\n          /**\r\n           * When using Ajax sourced data and during the first draw when DataTables is\r\n           * gathering the data, this message is shown in an empty row in the table to\r\n           * indicate to the end user the the data is being loaded. Note that this\r\n           * parameter is not used when loading data by server-side processing, just\r\n           * Ajax sourced data with client-side processing.\r\n           *  @type string\r\n           *  @default Loading...\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.loadingRecords\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"loadingRecords\": \"Please wait - loading...\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sLoadingRecords: 'Loading...',\r\n\r\n          /**\r\n           * Text which is displayed when the table is processing a user action\r\n           * (usually a sort command or similar).\r\n           *  @type string\r\n           *  @default Processing...\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.processing\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"processing\": \"DataTables is currently busy\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sProcessing: 'Processing...',\r\n\r\n          /**\r\n           * Details the actions that will be taken when the user types into the\r\n           * filtering input text box. The variable \"_INPUT_\", if used in the string,\r\n           * is replaced with the HTML text box for the filtering input allowing\r\n           * control over where it appears in the string. If \"_INPUT_\" is not given\r\n           * then the input box is appended to the string automatically.\r\n           *  @type string\r\n           *  @default Search:\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.search\r\n           *\r\n           *  @example\r\n           *    // Input text box will be appended at the end automatically\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"search\": \"Filter records:\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           *\r\n           *  @example\r\n           *    // Specify where the filter should appear\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"search\": \"Apply filter _INPUT_ to table\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sSearch: 'Search:',\r\n\r\n          /**\r\n           * Assign a `placeholder` attribute to the search `input` element\r\n           *  @type string\r\n           *  @default\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.searchPlaceholder\r\n           */\r\n          sSearchPlaceholder: '',\r\n\r\n          /**\r\n           * All of the language information can be stored in a file on the\r\n           * server-side, which DataTables will look up if this parameter is passed.\r\n           * It must store the URL of the language file, which is in a JSON format,\r\n           * and the object has the same properties as the oLanguage object in the\r\n           * initialiser object (i.e. the above parameters). Please refer to one of\r\n           * the example language files to see how this works in action.\r\n           *  @type string\r\n           *  @default <i>Empty string - i.e. disabled</i>\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.url\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sUrl: '',\r\n\r\n          /**\r\n           * Text shown inside the table records when the is no information to be\r\n           * displayed after filtering. `emptyTable` is shown when there is simply no\r\n           * information in the table at all (regardless of filtering).\r\n           *  @type string\r\n           *  @default No matching records found\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.zeroRecords\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"zeroRecords\": \"No records to display\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sZeroRecords: 'No matching records found'\r\n        },\r\n\r\n        /**\r\n         * This parameter allows you to have define the global filtering state at\r\n         * initialisation time. As an object the `search` parameter must be\r\n         * defined, but all other parameters are optional. When `regex` is true,\r\n         * the search string will be treated as a regular expression, when false\r\n         * (default) it will be treated as a straight string. When `smart`\r\n         * DataTables will use it's smart filtering methods (to word match at\r\n         * any point in the data), when false this will not be done.\r\n         *  @namespace\r\n         *  @extends DataTable.models.oSearch\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.search\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"search\": {\"search\": \"Initial search\"}\r\n         *      } );\r\n         *    } )\r\n         */\r\n        oSearch: $.extend({}, DataTable.models.oSearch),\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * By default DataTables will look for the property `data` (or `aaData` for\r\n         * compatibility with DataTables 1.9-) when obtaining data from an Ajax\r\n         * source or for server-side processing - this parameter allows that\r\n         * property to be changed. You can use Javascript dotted object notation to\r\n         * get a data source for multiple levels of nesting.\r\n         *  @type string\r\n         *  @default data\r\n         *\r\n         *  @dtopt Options\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.ajaxDataProp\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        sAjaxDataProp: 'data',\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * You can instruct DataTables to load data from an external\r\n         * source using this parameter (use aData if you want to pass data in you\r\n         * already have). Simply provide a url a JSON object can be obtained from.\r\n         *  @type string\r\n         *  @default null\r\n         *\r\n         *  @dtopt Options\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.ajaxSource\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        sAjaxSource: null,\r\n\r\n        /**\r\n         * This initialisation variable allows you to specify exactly where in the\r\n         * DOM you want DataTables to inject the various controls it adds to the page\r\n         * (for example you might want the pagination controls at the top of the\r\n         * table). DIV elements (with or without a custom class) can also be added to\r\n         * aid styling. The follow syntax is used:\r\n         *   <ul>\r\n         *     <li>The following options are allowed:\r\n         *       <ul>\r\n         *         <li>'l' - Length changing</li>\r\n         *         <li>'f' - Filtering input</li>\r\n         *         <li>'t' - The table!</li>\r\n         *         <li>'i' - Information</li>\r\n         *         <li>'p' - Pagination</li>\r\n         *         <li>'r' - pRocessing</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *     <li>The following constants are allowed:\r\n         *       <ul>\r\n         *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\r\n         *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *     <li>The following syntax is expected:\r\n         *       <ul>\r\n         *         <li>'&lt;' and '&gt;' - div elements</li>\r\n         *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\r\n         *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *     <li>Examples:\r\n         *       <ul>\r\n         *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\r\n         *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *   </ul>\r\n         *  @type string\r\n         *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\r\n         *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.dom\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sDom: 'lfrtip',\r\n\r\n        /**\r\n         * DataTables features four different built-in options for the buttons to\r\n         * display for pagination control:\r\n         *\r\n         * * `simple` - 'Previous' and 'Next' buttons only\r\n         * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\r\n         * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\r\n         * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus\r\n         *   page numbers\r\n         *\r\n         * Further methods can be added using {@link DataTable.ext.oPagination}.\r\n         *  @type string\r\n         *  @default simple_numbers\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.pagingType\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"pagingType\": \"full_numbers\"\r\n         *      } );\r\n         *    } )\r\n         */\r\n        sPaginationType: 'simple_numbers',\r\n\r\n        /**\r\n         * Enable horizontal scrolling. When a table is too wide to fit into a\r\n         * certain layout, or you have a large number of columns in the table, you\r\n         * can enable x-scrolling to show the table in a viewport, which can be\r\n         * scrolled. This property can be `true` which will allow the table to\r\n         * scroll horizontally when needed, or any CSS unit, or a number (in which\r\n         * case it will be treated as a pixel measurement). Setting as simply `true`\r\n         * is recommended.\r\n         *  @type boolean|string\r\n         *  @default <i>blank string - i.e. disabled</i>\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.scrollX\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollX\": true,\r\n         *        \"scrollCollapse\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sScrollX: '',\r\n\r\n        /**\r\n         * This property can be used to force a DataTable to use more width than it\r\n         * might otherwise do when x-scrolling is enabled. For example if you have a\r\n         * table which requires to be well spaced, this parameter is useful for\r\n         * \"over-sizing\" the table, and thus forcing scrolling. This property can by\r\n         * any CSS unit, or a number (in which case it will be treated as a pixel\r\n         * measurement).\r\n         *  @type string\r\n         *  @default <i>blank string - i.e. disabled</i>\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.scrollXInner\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollX\": \"100%\",\r\n         *        \"scrollXInner\": \"110%\"\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sScrollXInner: '',\r\n\r\n        /**\r\n         * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\r\n         * to the given height, and enable scrolling for any data which overflows the\r\n         * current viewport. This can be used as an alternative to paging to display\r\n         * a lot of data in a small area (although paging and scrolling can both be\r\n         * enabled at the same time). This property can be any CSS unit, or a number\r\n         * (in which case it will be treated as a pixel measurement).\r\n         *  @type string\r\n         *  @default <i>blank string - i.e. disabled</i>\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.scrollY\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollY\": \"200px\",\r\n         *        \"paginate\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sScrollY: '',\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * Set the HTTP method that is used to make the Ajax call for server-side\r\n         * processing or Ajax sourced data.\r\n         *  @type string\r\n         *  @default GET\r\n         *\r\n         *  @dtopt Options\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverMethod\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        sServerMethod: 'GET',\r\n\r\n        /**\r\n         * DataTables makes use of renderers when displaying HTML elements for\r\n         * a table. These renderers can be added or modified by plug-ins to\r\n         * generate suitable mark-up for a site. For example the Bootstrap\r\n         * integration plug-in for DataTables uses a paging button renderer to\r\n         * display pagination buttons in the mark-up required by Bootstrap.\r\n         *\r\n         * For further information about the renderers available see\r\n         * DataTable.ext.renderer\r\n         *  @type string|object\r\n         *  @default null\r\n         *\r\n         *  @name DataTable.defaults.renderer\r\n         *\r\n         */\r\n        renderer: null\r\n      }\r\n\r\n      _fnHungarianMap(DataTable.defaults)\r\n\r\n      /*\r\n       * Developer note - See note in model.defaults.js about the use of Hungarian\r\n       * notation and camel case.\r\n       */\r\n\r\n      /**\r\n       * Column options that can be given to DataTables at initialisation time.\r\n       *  @namespace\r\n       */\r\n      DataTable.defaults.column = {\r\n        /**\r\n         * Define which column(s) an order will occur on for this column. This\r\n         * allows a column's ordering to take multiple columns into account when\r\n         * doing a sort or use the data from a different column. For example first\r\n         * name / last name columns make sense to do a multi-column sort over the\r\n         * two columns.\r\n         *  @type array|int\r\n         *  @default null <i>Takes the value of the column index automatically</i>\r\n         *\r\n         *  @name DataTable.defaults.column.orderData\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\r\n         *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\r\n         *          { \"orderData\": 2, \"targets\": [ 2 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"orderData\": [ 0, 1 ] },\r\n         *          { \"orderData\": [ 1, 0 ] },\r\n         *          { \"orderData\": 2 },\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aDataSort: null,\r\n        iDataSort: -1,\r\n\r\n        /**\r\n         * You can control the default ordering direction, and even alter the\r\n         * behaviour of the sort handler (i.e. only allow ascending ordering etc)\r\n         * using this parameter.\r\n         *  @type array\r\n         *  @default [ 'asc', 'desc' ]\r\n         *\r\n         *  @name DataTable.defaults.column.orderSequence\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\r\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\r\n         *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          { \"orderSequence\": [ \"asc\" ] },\r\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\r\n         *          { \"orderSequence\": [ \"desc\" ] },\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        asSorting: ['asc', 'desc'],\r\n\r\n        /**\r\n         * Enable or disable filtering on the data in this column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @name DataTable.defaults.column.searchable\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"searchable\": false, \"targets\": [ 0 ] }\r\n         *        ] } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"searchable\": false },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ] } );\r\n         *    } );\r\n         */\r\n        bSearchable: true,\r\n\r\n        /**\r\n         * Enable or disable ordering on this column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @name DataTable.defaults.column.orderable\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderable\": false, \"targets\": [ 0 ] }\r\n         *        ] } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"orderable\": false },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ] } );\r\n         *    } );\r\n         */\r\n        bSortable: true,\r\n\r\n        /**\r\n         * Enable or disable the display of this column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @name DataTable.defaults.column.visible\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"visible\": false, \"targets\": [ 0 ] }\r\n         *        ] } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"visible\": false },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ] } );\r\n         *    } );\r\n         */\r\n        bVisible: true,\r\n\r\n        /**\r\n         * Developer definable function that is called whenever a cell is created (Ajax source,\r\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\r\n         * allowing you to modify the DOM element (add background colour for example) when the\r\n         * element is available.\r\n         *  @type function\r\n         *  @param {element} td The TD node that has been created\r\n         *  @param {*} cellData The Data for the cell\r\n         *  @param {array|object} rowData The data for the whole row\r\n         *  @param {int} row The row index for the aoData data store\r\n         *  @param {int} col The column index for aoColumns\r\n         *\r\n         *  @name DataTable.defaults.column.createdCell\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [3],\r\n         *          \"createdCell\": function (td, cellData, rowData, row, col) {\r\n         *            if ( cellData == \"1.7\" ) {\r\n         *              $(td).css('color', 'blue')\r\n         *            }\r\n         *          }\r\n         *        } ]\r\n         *      });\r\n         *    } );\r\n         */\r\n        fnCreatedCell: null,\r\n\r\n        /**\r\n         * This parameter has been replaced by `data` in DataTables to ensure naming\r\n         * consistency. `dataProp` can still be used, as there is backwards\r\n         * compatibility in DataTables for this option, but it is strongly\r\n         * recommended that you use `data` in preference to `dataProp`.\r\n         *  @name DataTable.defaults.column.dataProp\r\n         */\r\n\r\n        /**\r\n         * This property can be used to read data from any data source property,\r\n         * including deeply nested objects / properties. `data` can be given in a\r\n         * number of different ways which effect its behaviour:\r\n         *\r\n         * * `integer` - treated as an array index for the data source. This is the\r\n         *   default that DataTables uses (incrementally increased for each column).\r\n         * * `string` - read an object property from the data source. There are\r\n         *   three 'special' options that can be used in the string to alter how\r\n         *   DataTables reads the data from the source object:\r\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\r\n         *      Javascript to read from nested objects, so to can the options\r\n         *      specified in `data`. For example: `browser.version` or\r\n         *      `browser.name`. If your object parameter name contains a period, use\r\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\r\n         *    * `[]` - Array notation. DataTables can automatically combine data\r\n         *      from and array source, joining the data with the characters provided\r\n         *      between the two brackets. For example: `name[, ]` would provide a\r\n         *      comma-space separated list from the source array. If no characters\r\n         *      are provided between the brackets, the original array source is\r\n         *      returned.\r\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\r\n         *      execute a function of the name given. For example: `browser()` for a\r\n         *      simple function on the data source, `browser.version()` for a\r\n         *      function in a nested property or even `browser().version` to get an\r\n         *      object property if the function called returns an object. Note that\r\n         *      function notation is recommended for use in `render` rather than\r\n         *      `data` as it is much simpler to use as a renderer.\r\n         * * `null` - use the original data source for the row rather than plucking\r\n         *   data directly from it. This action has effects on two other\r\n         *   initialisation options:\r\n         *    * `defaultContent` - When null is given as the `data` option and\r\n         *      `defaultContent` is specified for the column, the value defined by\r\n         *      `defaultContent` will be used for the cell.\r\n         *    * `render` - When null is used for the `data` option and the `render`\r\n         *      option is specified for the column, the whole data source for the\r\n         *      row is used for the renderer.\r\n         * * `function` - the function given will be executed whenever DataTables\r\n         *   needs to set or get the data for a cell in the column. The function\r\n         *   takes three parameters:\r\n         *    * Parameters:\r\n         *      * `{array|object}` The data source for the row\r\n         *      * `{string}` The type call data requested - this will be 'set' when\r\n         *        setting data or 'filter', 'display', 'type', 'sort' or undefined\r\n         *        when gathering data. Note that when `undefined` is given for the\r\n         *        type DataTables expects to get the raw data for the object back<\r\n         *      * `{*}` Data to set when the second parameter is 'set'.\r\n         *    * Return:\r\n         *      * The return value from the function is not required when 'set' is\r\n         *        the type of call, but otherwise the return is what will be used\r\n         *        for the data requested.\r\n         *\r\n         * Note that `data` is a getter and setter option. If you just require\r\n         * formatting of data for output, you will likely want to use `render` which\r\n         * is simply a getter and thus simpler to use.\r\n         *\r\n         * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\r\n         * name change reflects the flexibility of this property and is consistent\r\n         * with the naming of mRender. If 'mDataProp' is given, then it will still\r\n         * be used by DataTables, as it automatically maps the old name to the new\r\n         * if required.\r\n         *\r\n         *  @type string|int|function|null\r\n         *  @default null <i>Use automatically calculated column index</i>\r\n         *\r\n         *  @name DataTable.defaults.column.data\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Read table data from objects\r\n         *    // JSON structure for each row:\r\n         *    //   {\r\n         *    //      \"engine\": {value},\r\n         *    //      \"browser\": {value},\r\n         *    //      \"platform\": {value},\r\n         *    //      \"version\": {value},\r\n         *    //      \"grade\": {value}\r\n         *    //   }\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajaxSource\": \"sources/objects.txt\",\r\n         *        \"columns\": [\r\n         *          { \"data\": \"engine\" },\r\n         *          { \"data\": \"browser\" },\r\n         *          { \"data\": \"platform\" },\r\n         *          { \"data\": \"version\" },\r\n         *          { \"data\": \"grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Read information from deeply nested objects\r\n         *    // JSON structure for each row:\r\n         *    //   {\r\n         *    //      \"engine\": {value},\r\n         *    //      \"browser\": {value},\r\n         *    //      \"platform\": {\r\n         *    //         \"inner\": {value}\r\n         *    //      },\r\n         *    //      \"details\": [\r\n         *    //         {value}, {value}\r\n         *    //      ]\r\n         *    //   }\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajaxSource\": \"sources/deep.txt\",\r\n         *        \"columns\": [\r\n         *          { \"data\": \"engine\" },\r\n         *          { \"data\": \"browser\" },\r\n         *          { \"data\": \"platform.inner\" },\r\n         *          { \"data\": \"platform.details.0\" },\r\n         *          { \"data\": \"platform.details.1\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `data` as a function to provide different information for\r\n         *    // sorting, filtering and display. In this case, currency (price)\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": function ( source, type, val ) {\r\n         *            if (type === 'set') {\r\n         *              source.price = val;\r\n         *              // Store the computed dislay and filter values for efficiency\r\n         *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\r\n         *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\r\n         *              return;\r\n         *            }\r\n         *            else if (type === 'display') {\r\n         *              return source.price_display;\r\n         *            }\r\n         *            else if (type === 'filter') {\r\n         *              return source.price_filter;\r\n         *            }\r\n         *            // 'sort', 'type' and undefined all just use the integer\r\n         *            return source.price;\r\n         *          }\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using default content\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": null,\r\n         *          \"defaultContent\": \"Click to edit\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using array notation - outputting a list from an array\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": \"name[, ]\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         */\r\n        mData: null,\r\n\r\n        /**\r\n         * This property is the rendering partner to `data` and it is suggested that\r\n         * when you want to manipulate data for display (including filtering,\r\n         * sorting etc) without altering the underlying data for the table, use this\r\n         * property. `render` can be considered to be the the read only companion to\r\n         * `data` which is read / write (then as such more complex). Like `data`\r\n         * this option can be given in a number of different ways to effect its\r\n         * behaviour:\r\n         *\r\n         * * `integer` - treated as an array index for the data source. This is the\r\n         *   default that DataTables uses (incrementally increased for each column).\r\n         * * `string` - read an object property from the data source. There are\r\n         *   three 'special' options that can be used in the string to alter how\r\n         *   DataTables reads the data from the source object:\r\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\r\n         *      Javascript to read from nested objects, so to can the options\r\n         *      specified in `data`. For example: `browser.version` or\r\n         *      `browser.name`. If your object parameter name contains a period, use\r\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\r\n         *    * `[]` - Array notation. DataTables can automatically combine data\r\n         *      from and array source, joining the data with the characters provided\r\n         *      between the two brackets. For example: `name[, ]` would provide a\r\n         *      comma-space separated list from the source array. If no characters\r\n         *      are provided between the brackets, the original array source is\r\n         *      returned.\r\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\r\n         *      execute a function of the name given. For example: `browser()` for a\r\n         *      simple function on the data source, `browser.version()` for a\r\n         *      function in a nested property or even `browser().version` to get an\r\n         *      object property if the function called returns an object.\r\n         * * `object` - use different data for the different data types requested by\r\n         *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\r\n         *   of the object is the data type the property refers to and the value can\r\n         *   defined using an integer, string or function using the same rules as\r\n         *   `render` normally does. Note that an `_` option _must_ be specified.\r\n         *   This is the default value to use if you haven't specified a value for\r\n         *   the data type requested by DataTables.\r\n         * * `function` - the function given will be executed whenever DataTables\r\n         *   needs to set or get the data for a cell in the column. The function\r\n         *   takes three parameters:\r\n         *    * Parameters:\r\n         *      * {array|object} The data source for the row (based on `data`)\r\n         *      * {string} The type call data requested - this will be 'filter',\r\n         *        'display', 'type' or 'sort'.\r\n         *      * {array|object} The full data source for the row (not based on\r\n         *        `data`)\r\n         *    * Return:\r\n         *      * The return value from the function is what will be used for the\r\n         *        data requested.\r\n         *\r\n         *  @type string|int|function|object|null\r\n         *  @default null Use the data source value.\r\n         *\r\n         *  @name DataTable.defaults.column.render\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Create a comma separated list from an array of objects\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajaxSource\": \"sources/deep.txt\",\r\n         *        \"columns\": [\r\n         *          { \"data\": \"engine\" },\r\n         *          { \"data\": \"browser\" },\r\n         *          {\r\n         *            \"data\": \"platform\",\r\n         *            \"render\": \"[, ].name\"\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Execute a function to obtain data\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": null, // Use the full data source object for the renderer's source\r\n         *          \"render\": \"browserName()\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // As an object, extracting different data for the different types\r\n         *    // This would be used with a data source such as:\r\n         *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\r\n         *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\r\n         *    // (which has both forms) is used for filtering for if a user inputs either format, while\r\n         *    // the formatted phone number is the one that is shown in the table.\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": null, // Use the full data source object for the renderer's source\r\n         *          \"render\": {\r\n         *            \"_\": \"phone\",\r\n         *            \"filter\": \"phone_filter\",\r\n         *            \"display\": \"phone_display\"\r\n         *          }\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Use as a function to create a link from the data source\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": \"download_link\",\r\n         *          \"render\": function ( data, type, full ) {\r\n         *            return '<a href=\"'+data+'\">Download</a>';\r\n         *          }\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        mRender: null,\r\n\r\n        /**\r\n         * Change the cell type created for the column - either TD cells or TH cells. This\r\n         * can be useful as TH cells have semantic meaning in the table body, allowing them\r\n         * to act as a header for a row (you may wish to add scope='row' to the TH elements).\r\n         *  @type string\r\n         *  @default td\r\n         *\r\n         *  @name DataTable.defaults.column.cellType\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Make the first column use TH cells\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"cellType\": \"th\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sCellType: 'td',\r\n\r\n        /**\r\n         * Class to give to each cell in this column.\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         *\r\n         *  @name DataTable.defaults.column.class\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"class\": \"my_class\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sClass: '',\r\n\r\n        /**\r\n         * When DataTables calculates the column widths to assign to each column,\r\n         * it finds the longest string in each column and then constructs a\r\n         * temporary table and reads the widths from that. The problem with this\r\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\r\n         * string - thus the calculation can go wrong (doing it properly and putting\r\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\r\n         * a \"work around\" we provide this option. It will append its value to the\r\n         * text that is found to be the longest string for the column - i.e. padding.\r\n         * Generally you shouldn't need this!\r\n         *  @type string\r\n         *  @default <i>Empty string<i>\r\n         *\r\n         *  @name DataTable.defaults.column.contentPadding\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          {\r\n         *            \"contentPadding\": \"mmm\"\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sContentPadding: '',\r\n\r\n        /**\r\n         * Allows a default value to be given for a column's data, and will be used\r\n         * whenever a null data source is encountered (this can be because `data`\r\n         * is set to null, or because the data source itself is null).\r\n         *  @type string\r\n         *  @default null\r\n         *\r\n         *  @name DataTable.defaults.column.defaultContent\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          {\r\n         *            \"data\": null,\r\n         *            \"defaultContent\": \"Edit\",\r\n         *            \"targets\": [ -1 ]\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          {\r\n         *            \"data\": null,\r\n         *            \"defaultContent\": \"Edit\"\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sDefaultContent: null,\r\n\r\n        /**\r\n         * This parameter is only used in DataTables' server-side processing. It can\r\n         * be exceptionally useful to know what columns are being displayed on the\r\n         * client side, and to map these to database fields. When defined, the names\r\n         * also allow DataTables to reorder information from the server if it comes\r\n         * back in an unexpected order (i.e. if you switch your columns around on the\r\n         * client-side, your server-side code does not also need updating).\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         *\r\n         *  @name DataTable.defaults.column.name\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"name\": \"engine\", \"targets\": [ 0 ] },\r\n         *          { \"name\": \"browser\", \"targets\": [ 1 ] },\r\n         *          { \"name\": \"platform\", \"targets\": [ 2 ] },\r\n         *          { \"name\": \"version\", \"targets\": [ 3 ] },\r\n         *          { \"name\": \"grade\", \"targets\": [ 4 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"name\": \"engine\" },\r\n         *          { \"name\": \"browser\" },\r\n         *          { \"name\": \"platform\" },\r\n         *          { \"name\": \"version\" },\r\n         *          { \"name\": \"grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sName: '',\r\n\r\n        /**\r\n         * Defines a data source type for the ordering which can be used to read\r\n         * real-time information from the table (updating the internally cached\r\n         * version) prior to ordering. This allows ordering to occur on user\r\n         * editable elements such as form inputs.\r\n         *  @type string\r\n         *  @default std\r\n         *\r\n         *  @name DataTable.defaults.column.orderDataType\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\r\n         *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\r\n         *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\r\n         *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          null,\r\n         *          { \"orderDataType\": \"dom-text\" },\r\n         *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\r\n         *          { \"orderDataType\": \"dom-select\" },\r\n         *          { \"orderDataType\": \"dom-checkbox\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sSortDataType: 'std',\r\n\r\n        /**\r\n         * The title of this column.\r\n         *  @type string\r\n         *  @default null <i>Derived from the 'TH' value for this column in the\r\n         *    original HTML table.</i>\r\n         *\r\n         *  @name DataTable.defaults.column.title\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"title\": \"My column title\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sTitle: null,\r\n\r\n        /**\r\n         * The type allows you to specify how the data for this column will be\r\n         * ordered. Four types (string, numeric, date and html (which will strip\r\n         * HTML tags before ordering)) are currently available. Note that only date\r\n         * formats understood by Javascript's Date() object will be accepted as type\r\n         * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\r\n         * 'numeric', 'date' or 'html' (by default). Further types can be adding\r\n         * through plug-ins.\r\n         *  @type string\r\n         *  @default null <i>Auto-detected from raw data</i>\r\n         *\r\n         *  @name DataTable.defaults.column.type\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"type\": \"html\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"type\": \"html\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sType: null,\r\n\r\n        /**\r\n         * Defining the width of the column, this parameter may take any CSS value\r\n         * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\r\n         * been given a specific width through this interface ensuring that the table\r\n         * remains readable.\r\n         *  @type string\r\n         *  @default null <i>Automatic</i>\r\n         *\r\n         *  @name DataTable.defaults.column.width\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"width\": \"20%\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"width\": \"20%\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sWidth: null\r\n      }\r\n\r\n      _fnHungarianMap(DataTable.defaults.column)\r\n\r\n      /**\r\n       * DataTables settings object - this holds all the information needed for a\r\n       * given table, including configuration, data and current application of the\r\n       * table options. DataTables does not have a single instance for each DataTable\r\n       * with the settings attached to that instance, but rather instances of the\r\n       * DataTable \"class\" are created on-the-fly as needed (typically by a\r\n       * $().dataTable() call) and the settings object is then applied to that\r\n       * instance.\r\n       *\r\n       * Note that this object is related to {@link DataTable.defaults} but this\r\n       * one is the internal data store for DataTables's cache of columns. It should\r\n       * NOT be manipulated outside of DataTables. Any configuration should be done\r\n       * through the initialisation options.\r\n       *  @namespace\r\n       *  @todo Really should attach the settings object to individual instances so we\r\n       *    don't need to create new instances on each $().dataTable() call (if the\r\n       *    table already exists). It would also save passing oSettings around and\r\n       *    into every single function. However, this is a very significant\r\n       *    architecture change for DataTables and will almost certainly break\r\n       *    backwards compatibility with older installations. This is something that\r\n       *    will be done in 2.0.\r\n       */\r\n      DataTable.models.oSettings = {\r\n        /**\r\n         * Primary features of DataTables and their enablement state.\r\n         *  @namespace\r\n         */\r\n        oFeatures: {\r\n          /**\r\n           * Flag to say if DataTables should automatically try to calculate the\r\n           * optimum table and columns widths (true) or not (false).\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bAutoWidth: null,\r\n\r\n          /**\r\n           * Delay the creation of TR and TD elements until they are actually\r\n           * needed by a driven page draw. This can give a significant speed\r\n           * increase for Ajax source and Javascript source data, but makes no\r\n           * difference at all fro DOM and server-side processing tables.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bDeferRender: null,\r\n\r\n          /**\r\n           * Enable filtering on the table or not. Note that if this is disabled\r\n           * then there is no filtering at all on the table, including fnFilter.\r\n           * To just remove the filtering input use sDom and remove the 'f' option.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bFilter: null,\r\n\r\n          /**\r\n           * Table information element (the 'Showing x of y records' div) enable\r\n           * flag.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bInfo: null,\r\n\r\n          /**\r\n           * Present a user control allowing the end user to change the page size\r\n           * when pagination is enabled.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bLengthChange: null,\r\n\r\n          /**\r\n           * Pagination enabled or not. Note that if this is disabled then length\r\n           * changing must also be disabled.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bPaginate: null,\r\n\r\n          /**\r\n           * Processing indicator enable flag whenever DataTables is enacting a\r\n           * user request - typically an Ajax request for server-side processing.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bProcessing: null,\r\n\r\n          /**\r\n           * Server-side processing enabled flag - when enabled DataTables will\r\n           * get all data from the server for every draw - there is no filtering,\r\n           * sorting or paging done on the client-side.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bServerSide: null,\r\n\r\n          /**\r\n           * Sorting enablement flag.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bSort: null,\r\n\r\n          /**\r\n           * Multi-column sorting\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bSortMulti: null,\r\n\r\n          /**\r\n           * Apply a class to the columns which are being sorted to provide a\r\n           * visual highlight or not. This can slow things down when enabled since\r\n           * there is a lot of DOM interaction.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bSortClasses: null,\r\n\r\n          /**\r\n           * State saving enablement flag.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bStateSave: null\r\n        },\r\n\r\n        /**\r\n         * Scrolling settings for a table.\r\n         *  @namespace\r\n         */\r\n        oScroll: {\r\n          /**\r\n           * When the table is shorter in height than sScrollY, collapse the\r\n           * table container down to the height of the table (when true).\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bCollapse: null,\r\n\r\n          /**\r\n           * Width of the scrollbar for the web-browser's platform. Calculated\r\n           * during table initialisation.\r\n           *  @type int\r\n           *  @default 0\r\n           */\r\n          iBarWidth: 0,\r\n\r\n          /**\r\n           * Viewport width for horizontal scrolling. Horizontal scrolling is\r\n           * disabled if an empty string.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type string\r\n           */\r\n          sX: null,\r\n\r\n          /**\r\n           * Width to expand the table to when using x-scrolling. Typically you\r\n           * should not need to use this.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type string\r\n           *  @deprecated\r\n           */\r\n          sXInner: null,\r\n\r\n          /**\r\n           * Viewport height for vertical scrolling. Vertical scrolling is disabled\r\n           * if an empty string.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type string\r\n           */\r\n          sY: null\r\n        },\r\n\r\n        /**\r\n         * Language information for the table.\r\n         *  @namespace\r\n         *  @extends DataTable.defaults.oLanguage\r\n         */\r\n        oLanguage: {\r\n          /**\r\n           * Information callback function. See\r\n           * {@link DataTable.defaults.fnInfoCallback}\r\n           *  @type function\r\n           *  @default null\r\n           */\r\n          fnInfoCallback: null\r\n        },\r\n\r\n        /**\r\n         * Browser support parameters\r\n         *  @namespace\r\n         */\r\n        oBrowser: {\r\n          /**\r\n           * Indicate if the browser incorrectly calculates width:100% inside a\r\n           * scrolling element (IE6/7)\r\n           *  @type boolean\r\n           *  @default false\r\n           */\r\n          bScrollOversize: false,\r\n\r\n          /**\r\n           * Determine if the vertical scrollbar is on the right or left of the\r\n           * scrolling container - needed for rtl language layout, although not\r\n           * all browsers move the scrollbar (Safari).\r\n           *  @type boolean\r\n           *  @default false\r\n           */\r\n          bScrollbarLeft: false\r\n        },\r\n\r\n        ajax: null,\r\n\r\n        /**\r\n         * Array referencing the nodes which are used for the features. The\r\n         * parameters of this object match what is allowed by sDom - i.e.\r\n         *   <ul>\r\n         *     <li>'l' - Length changing</li>\r\n         *     <li>'f' - Filtering input</li>\r\n         *     <li>'t' - The table!</li>\r\n         *     <li>'i' - Information</li>\r\n         *     <li>'p' - Pagination</li>\r\n         *     <li>'r' - pRocessing</li>\r\n         *   </ul>\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aanFeatures: [],\r\n\r\n        /**\r\n         * Store data information - see {@link DataTable.models.oRow} for detailed\r\n         * information.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoData: [],\r\n\r\n        /**\r\n         * Array of indexes which are in the current display (after filtering etc)\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aiDisplay: [],\r\n\r\n        /**\r\n         * Array of indexes for display - no filtering\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aiDisplayMaster: [],\r\n\r\n        /**\r\n         * Store information about each column that is in use\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoColumns: [],\r\n\r\n        /**\r\n         * Store information about the table's header\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoHeader: [],\r\n\r\n        /**\r\n         * Store information about the table's footer\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoFooter: [],\r\n\r\n        /**\r\n         * Store the applied global search information in case we want to force a\r\n         * research or compare the old search to a new one.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @namespace\r\n         *  @extends DataTable.models.oSearch\r\n         */\r\n        oPreviousSearch: {},\r\n\r\n        /**\r\n         * Store the applied search for each column - see\r\n         * {@link DataTable.models.oSearch} for the format that is used for the\r\n         * filtering information for each column.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoPreSearchCols: [],\r\n\r\n        /**\r\n         * Sorting that is applied to the table. Note that the inner arrays are\r\n         * used in the following manner:\r\n         * <ul>\r\n         *   <li>Index 0 - column number</li>\r\n         *   <li>Index 1 - current sorting direction</li>\r\n         * </ul>\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @todo These inner arrays should really be objects\r\n         */\r\n        aaSorting: null,\r\n\r\n        /**\r\n         * Sorting that is always applied to the table (i.e. prefixed in front of\r\n         * aaSorting).\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aaSortingFixed: [],\r\n\r\n        /**\r\n         * Classes to use for the striping of a table.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        asStripeClasses: null,\r\n\r\n        /**\r\n         * If restoring a table - we should restore its striping classes as well\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        asDestroyStripes: [],\r\n\r\n        /**\r\n         * If restoring a table - we should restore its width\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        sDestroyWidth: 0,\r\n\r\n        /**\r\n         * Callback functions array for every time a row is inserted (i.e. on a draw).\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoRowCallback: [],\r\n\r\n        /**\r\n         * Callback functions for the header on each draw.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoHeaderCallback: [],\r\n\r\n        /**\r\n         * Callback function for the footer on each draw.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoFooterCallback: [],\r\n\r\n        /**\r\n         * Array of callback functions for draw callback functions\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoDrawCallback: [],\r\n\r\n        /**\r\n         * Array of callback functions for row created function\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoRowCreatedCallback: [],\r\n\r\n        /**\r\n         * Callback functions for just before the table is redrawn. A return of\r\n         * false will be used to cancel the draw.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoPreDrawCallback: [],\r\n\r\n        /**\r\n         * Callback functions for when the table has been initialised.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoInitComplete: [],\r\n\r\n        /**\r\n         * Callbacks for modifying the settings to be stored for state saving, prior to\r\n         * saving state.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateSaveParams: [],\r\n\r\n        /**\r\n         * Callbacks for modifying the settings that have been stored for state saving\r\n         * prior to using the stored values to restore the state.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateLoadParams: [],\r\n\r\n        /**\r\n         * Callbacks for operating on the settings object once the saved state has been\r\n         * loaded\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateLoaded: [],\r\n\r\n        /**\r\n         * Cache the table ID for quick access\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         */\r\n        sTableId: '',\r\n\r\n        /**\r\n         * The TABLE node for the main table\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTable: null,\r\n\r\n        /**\r\n         * Permanent ref to the thead element\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTHead: null,\r\n\r\n        /**\r\n         * Permanent ref to the tfoot element - if it exists\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTFoot: null,\r\n\r\n        /**\r\n         * Permanent ref to the tbody element\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTBody: null,\r\n\r\n        /**\r\n         * Cache the wrapper node (contains all DataTables controlled elements)\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTableWrapper: null,\r\n\r\n        /**\r\n         * Indicate if when using server-side processing the loading of data\r\n         * should be deferred until the second draw.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bDeferLoading: false,\r\n\r\n        /**\r\n         * Indicate if all required information has been read in\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bInitialised: false,\r\n\r\n        /**\r\n         * Information about open rows. Each object in the array has the parameters\r\n         * 'nTr' and 'nParent'\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoOpenRows: [],\r\n\r\n        /**\r\n         * Dictate the positioning of DataTables' control elements - see\r\n         * {@link DataTable.model.oInit.sDom}.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sDom: null,\r\n\r\n        /**\r\n         * Which type of pagination should be used.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         *  @default two_button\r\n         */\r\n        sPaginationType: 'two_button',\r\n\r\n        /**\r\n         * The state duration (for `stateSave`) in seconds.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        iStateDuration: 0,\r\n\r\n        /**\r\n         * Array of callback functions for state saving. Each array element is an\r\n         * object with the following parameters:\r\n         *   <ul>\r\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\r\n         *       and the JSON string to save that has been thus far created. Returns\r\n         *       a JSON string to be inserted into a json object\r\n         *       (i.e. '\"param\": [ 0, 1, 2]')</li>\r\n         *     <li>string:sName - name of callback</li>\r\n         *   </ul>\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateSave: [],\r\n\r\n        /**\r\n         * Array of callback functions for state loading. Each array element is an\r\n         * object with the following parameters:\r\n         *   <ul>\r\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\r\n         *       and the object stored. May return false to cancel state loading</li>\r\n         *     <li>string:sName - name of callback</li>\r\n         *   </ul>\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateLoad: [],\r\n\r\n        /**\r\n         * State that was saved. Useful for back reference\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oSavedState: null,\r\n\r\n        /**\r\n         * State that was loaded. Useful for back reference\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oLoadedState: null,\r\n\r\n        /**\r\n         * Source url for AJAX data for the table.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sAjaxSource: null,\r\n\r\n        /**\r\n         * Property from a given object from which to read the table data from. This\r\n         * can be an empty string (when not server-side processing), in which case\r\n         * it is  assumed an an array is given directly.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         */\r\n        sAjaxDataProp: null,\r\n\r\n        /**\r\n         * Note if draw should be blocked while getting data\r\n         *  @type boolean\r\n         *  @default true\r\n         */\r\n        bAjaxDataGet: true,\r\n\r\n        /**\r\n         * The last jQuery XHR object that was used for server-side data gathering.\r\n         * This can be used for working with the XHR information in one of the\r\n         * callbacks\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        jqXHR: null,\r\n\r\n        /**\r\n         * JSON returned from the server in the last Ajax request\r\n         *  @type object\r\n         *  @default undefined\r\n         */\r\n        json: undefined,\r\n\r\n        /**\r\n         * Data submitted as part of the last Ajax request\r\n         *  @type object\r\n         *  @default undefined\r\n         */\r\n        oAjaxData: undefined,\r\n\r\n        /**\r\n         * Function to get the server-side data.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type function\r\n         */\r\n        fnServerData: null,\r\n\r\n        /**\r\n         * Functions which are called prior to sending an Ajax request so extra\r\n         * parameters can easily be sent to the server\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoServerParams: [],\r\n\r\n        /**\r\n         * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\r\n         * required).\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         */\r\n        sServerMethod: null,\r\n\r\n        /**\r\n         * Format numbers for display.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type function\r\n         */\r\n        fnFormatNumber: null,\r\n\r\n        /**\r\n         * List of options that can be used for the user selectable length menu.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aLengthMenu: null,\r\n\r\n        /**\r\n         * Counter for the draws that the table does. Also used as a tracker for\r\n         * server-side processing\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        iDraw: 0,\r\n\r\n        /**\r\n         * Indicate if a redraw is being done - useful for Ajax\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bDrawing: false,\r\n\r\n        /**\r\n         * Draw index (iDraw) of the last error when parsing the returned data\r\n         *  @type int\r\n         *  @default -1\r\n         */\r\n        iDrawError: -1,\r\n\r\n        /**\r\n         * Paging display length\r\n         *  @type int\r\n         *  @default 10\r\n         */\r\n        _iDisplayLength: 10,\r\n\r\n        /**\r\n         * Paging start point - aiDisplay index\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        _iDisplayStart: 0,\r\n\r\n        /**\r\n         * Server-side processing - number of records in the result set\r\n         * (i.e. before filtering), Use fnRecordsTotal rather than\r\n         * this property to get the value of the number of records, regardless of\r\n         * the server-side processing setting.\r\n         *  @type int\r\n         *  @default 0\r\n         *  @private\r\n         */\r\n        _iRecordsTotal: 0,\r\n\r\n        /**\r\n         * Server-side processing - number of records in the current display set\r\n         * (i.e. after filtering). Use fnRecordsDisplay rather than\r\n         * this property to get the value of the number of records, regardless of\r\n         * the server-side processing setting.\r\n         *  @type boolean\r\n         *  @default 0\r\n         *  @private\r\n         */\r\n        _iRecordsDisplay: 0,\r\n\r\n        /**\r\n         * Flag to indicate if jQuery UI marking and classes should be used.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type boolean\r\n         */\r\n        bJUI: null,\r\n\r\n        /**\r\n         * The classes to use for the table\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        oClasses: {},\r\n\r\n        /**\r\n         * Flag attached to the settings object so you can check in the draw\r\n         * callback if filtering has been done in the draw. Deprecated in favour of\r\n         * events.\r\n         *  @type boolean\r\n         *  @default false\r\n         *  @deprecated\r\n         */\r\n        bFiltered: false,\r\n\r\n        /**\r\n         * Flag attached to the settings object so you can check in the draw\r\n         * callback if sorting has been done in the draw. Deprecated in favour of\r\n         * events.\r\n         *  @type boolean\r\n         *  @default false\r\n         *  @deprecated\r\n         */\r\n        bSorted: false,\r\n\r\n        /**\r\n         * Indicate that if multiple rows are in the header and there is more than\r\n         * one unique cell per column, if the top one (true) or bottom one (false)\r\n         * should be used for sorting / title by DataTables.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type boolean\r\n         */\r\n        bSortCellsTop: null,\r\n\r\n        /**\r\n         * Initialisation object that is used for the table\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oInit: null,\r\n\r\n        /**\r\n         * Destroy callback functions - for plug-ins to attach themselves to the\r\n         * destroy so they can clean up markup and events.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoDestroyCallback: [],\r\n\r\n        /**\r\n         * Get the number of records in the current record set, before filtering\r\n         *  @type function\r\n         */\r\n        fnRecordsTotal: function () {\r\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length\r\n        },\r\n\r\n        /**\r\n         * Get the number of records in the current record set, after filtering\r\n         *  @type function\r\n         */\r\n        fnRecordsDisplay: function () {\r\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length\r\n        },\r\n\r\n        /**\r\n         * Get the display end point - aiDisplay index\r\n         *  @type function\r\n         */\r\n        fnDisplayEnd: function () {\r\n          var len = this._iDisplayLength,\r\n            start = this._iDisplayStart,\r\n            calc = start + len,\r\n            records = this.aiDisplay.length,\r\n            features = this.oFeatures,\r\n            paginate = features.bPaginate\r\n\r\n          if (features.bServerSide) {\r\n            return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay)\r\n          } else {\r\n            return !paginate || calc > records || len === -1 ? records : calc\r\n          }\r\n        },\r\n\r\n        /**\r\n         * The DataTables object for this table\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oInstance: null,\r\n\r\n        /**\r\n         * Unique identifier for each instance of the DataTables object. If there\r\n         * is an ID on the table node, then it takes that value, otherwise an\r\n         * incrementing internal counter is used.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sInstance: null,\r\n\r\n        /**\r\n         * tabindex attribute value that is added to DataTables control elements, allowing\r\n         * keyboard navigation of the table and its controls.\r\n         */\r\n        iTabIndex: 0,\r\n\r\n        /**\r\n         * DIV container for the footer scrolling table if scrolling\r\n         */\r\n        nScrollHead: null,\r\n\r\n        /**\r\n         * DIV container for the footer scrolling table if scrolling\r\n         */\r\n        nScrollFoot: null,\r\n\r\n        /**\r\n         * Last applied sort\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aLastSort: [],\r\n\r\n        /**\r\n         * Stored plug-in instances\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        oPlugins: {}\r\n      }\r\n\r\n      /**\r\n       * Extension object for DataTables that is used to provide all extension\r\n       * options.\r\n       *\r\n       * Note that the `DataTable.ext` object is available through\r\n       * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\r\n       * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\r\n       *  @namespace\r\n       *  @extends DataTable.models.ext\r\n       */\r\n\r\n      /**\r\n       * DataTables extensions\r\n       *\r\n       * This namespace acts as a collection area for plug-ins that can be used to\r\n       * extend DataTables capabilities. Indeed many of the build in methods\r\n       * use this method to provide their own capabilities (sorting methods for\r\n       * example).\r\n       *\r\n       * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\r\n       * reasons\r\n       *\r\n       *  @namespace\r\n       */\r\n      DataTable.ext = _ext = {\r\n        /**\r\n         * Element class names\r\n         *\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        classes: {},\r\n\r\n        /**\r\n         * Error reporting.\r\n         *\r\n         * How should DataTables report an error. Can take the value 'alert' or\r\n         * 'throw'\r\n         *\r\n         *  @type string\r\n         *  @default alert\r\n         */\r\n        errMode: 'alert',\r\n\r\n        /**\r\n         * Feature plug-ins.\r\n         *\r\n         * This is an array of objects which describe the feature plug-ins that are\r\n         * available to DataTables. These feature plug-ins are then available for\r\n         * use through the `dom` initialisation option.\r\n         *\r\n         * Each feature plug-in is described by an object which must have the\r\n         * following properties:\r\n         *\r\n         * * `fnInit` - function that is used to initialise the plug-in,\r\n         * * `cFeature` - a character so the feature can be enabled by the `dom`\r\n         *   instillation option. This is case sensitive.\r\n         *\r\n         * The `fnInit` function has the following input parameters:\r\n         *\r\n         * 1. `{object}` DataTables settings object: see\r\n         *    {@link DataTable.models.oSettings}\r\n         *\r\n         * And the following return is expected:\r\n         *\r\n         * * {node|null} The element which contains your feature. Note that the\r\n         *   return may also be void if your plug-in does not require to inject any\r\n         *   DOM elements into DataTables control (`dom`) - for example this might\r\n         *   be useful when developing a plug-in which allows table control via\r\n         *   keyboard entry\r\n         *\r\n         *  @type array\r\n         *\r\n         *  @example\r\n         *    $.fn.dataTable.ext.features.push( {\r\n         *      \"fnInit\": function( oSettings ) {\r\n         *        return new TableTools( { \"oDTSettings\": oSettings } );\r\n         *      },\r\n         *      \"cFeature\": \"T\"\r\n         *    } );\r\n         */\r\n        feature: [],\r\n\r\n        /**\r\n         * Row searching.\r\n         *\r\n         * This method of searching is complimentary to the default type based\r\n         * searching, and a lot more comprehensive as it allows you complete control\r\n         * over the searching logic. Each element in this array is a function\r\n         * (parameters described below) that is called for every row in the table,\r\n         * and your logic decides if it should be included in the searching data set\r\n         * or not.\r\n         *\r\n         * Searching functions have the following input parameters:\r\n         *\r\n         * 1. `{object}` DataTables settings object: see\r\n         *    {@link DataTable.models.oSettings}\r\n         * 2. `{array|object}` Data for the row to be processed (same as the\r\n         *    original format that was passed in as the data source, or an array\r\n         *    from a DOM data source\r\n         * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\r\n         *    can be useful to retrieve the `TR` element if you need DOM interaction.\r\n         *\r\n         * And the following return is expected:\r\n         *\r\n         * * {boolean} Include the row in the searched result set (true) or not\r\n         *   (false)\r\n         *\r\n         * Note that as with the main search ability in DataTables, technically this\r\n         * is \"filtering\", since it is subtractive. However, for consistency in\r\n         * naming we call it searching here.\r\n         *\r\n         *  @type array\r\n         *  @default []\r\n         *\r\n         *  @example\r\n         *    // The following example shows custom search being applied to the\r\n         *    // fourth column (i.e. the data[3] index) based on two input values\r\n         *    // from the end-user, matching the data in a certain range.\r\n         *    $.fn.dataTable.ext.search.push(\r\n         *      function( settings, data, dataIndex ) {\r\n         *        var min = document.getElementById('min').value * 1;\r\n         *        var max = document.getElementById('max').value * 1;\r\n         *        var version = data[3] == \"-\" ? 0 : data[3]*1;\r\n         *\r\n         *        if ( min == \"\" && max == \"\" ) {\r\n         *          return true;\r\n         *        }\r\n         *        else if ( min == \"\" && version < max ) {\r\n         *          return true;\r\n         *        }\r\n         *        else if ( min < version && \"\" == max ) {\r\n         *          return true;\r\n         *        }\r\n         *        else if ( min < version && version < max ) {\r\n         *          return true;\r\n         *        }\r\n         *        return false;\r\n         *      }\r\n         *    );\r\n         */\r\n        search: [],\r\n\r\n        /**\r\n         * Internal functions, exposed for used in plug-ins.\r\n         *\r\n         * Please note that you should not need to use the internal methods for\r\n         * anything other than a plug-in (and even then, try to avoid if possible).\r\n         * The internal function may change between releases.\r\n         *\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        internal: {},\r\n\r\n        /**\r\n         * Legacy configuration options. Enable and disable legacy options that\r\n         * are available in DataTables.\r\n         *\r\n         *  @type object\r\n         */\r\n        legacy: {\r\n          /**\r\n           * Enable / disable DataTables 1.9 compatible server-side processing\r\n           * requests\r\n           *\r\n           *  @type boolean\r\n           *  @default null\r\n           */\r\n          ajax: null\r\n        },\r\n\r\n        /**\r\n         * Pagination plug-in methods.\r\n         *\r\n         * Each entry in this object is a function and defines which buttons should\r\n         * be shown by the pagination rendering method that is used for the table:\r\n         * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\r\n         * buttons are displayed in the document, while the functions here tell it\r\n         * what buttons to display. This is done by returning an array of button\r\n         * descriptions (what each button will do).\r\n         *\r\n         * Pagination types (the four built in options and any additional plug-in\r\n         * options defined here) can be used through the `paginationType`\r\n         * initialisation parameter.\r\n         *\r\n         * The functions defined take two parameters:\r\n         *\r\n         * 1. `{int} page` The current page index\r\n         * 2. `{int} pages` The number of pages in the table\r\n         *\r\n         * Each function is expected to return an array where each element of the\r\n         * array can be one of:\r\n         *\r\n         * * `first` - Jump to first page when activated\r\n         * * `last` - Jump to last page when activated\r\n         * * `previous` - Show previous page when activated\r\n         * * `next` - Show next page when activated\r\n         * * `{int}` - Show page of the index given\r\n         * * `{array}` - A nested array containing the above elements to add a\r\n         *   containing 'DIV' element (might be useful for styling).\r\n         *\r\n         * Note that DataTables v1.9- used this object slightly differently whereby\r\n         * an object with two functions would be defined for each plug-in. That\r\n         * ability is still supported by DataTables 1.10+ to provide backwards\r\n         * compatibility, but this option of use is now decremented and no longer\r\n         * documented in DataTables 1.10+.\r\n         *\r\n         *  @type object\r\n         *  @default {}\r\n         *\r\n         *  @example\r\n         *    // Show previous, next and current page buttons only\r\n         *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\r\n         *      return [ 'previous', page, 'next' ];\r\n         *    };\r\n         */\r\n        pager: {},\r\n\r\n        renderer: {\r\n          pageButton: {},\r\n          header: {}\r\n        },\r\n\r\n        /**\r\n         * Ordering plug-ins - custom data source\r\n         *\r\n         * The extension options for ordering of data available here is complimentary\r\n         * to the default type based ordering that DataTables typically uses. It\r\n         * allows much greater control over the the data that is being used to\r\n         * order a column, but is necessarily therefore more complex.\r\n         *\r\n         * This type of ordering is useful if you want to do ordering based on data\r\n         * live from the DOM (for example the contents of an 'input' element) rather\r\n         * than just the static string that DataTables knows of.\r\n         *\r\n         * The way these plug-ins work is that you create an array of the values you\r\n         * wish to be ordering for the column in question and then return that\r\n         * array. The data in the array much be in the index order of the rows in\r\n         * the table (not the currently ordering order!). Which order data gathering\r\n         * function is run here depends on the `dt-init columns.orderDataType`\r\n         * parameter that is used for the column (if any).\r\n         *\r\n         * The functions defined take two parameters:\r\n         *\r\n         * 1. `{object}` DataTables settings object: see\r\n         *    {@link DataTable.models.oSettings}\r\n         * 2. `{int}` Target column index\r\n         *\r\n         * Each function is expected to return an array:\r\n         *\r\n         * * `{array}` Data for the column to be ordering upon\r\n         *\r\n         *  @type array\r\n         *\r\n         *  @example\r\n         *    // Ordering using `input` node values\r\n         *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\r\n         *    {\r\n         *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\r\n         *        return $('input', td).val();\r\n         *      } );\r\n         *    }\r\n         */\r\n        order: {},\r\n\r\n        /**\r\n         * Type based plug-ins.\r\n         *\r\n         * Each column in DataTables has a type assigned to it, either by automatic\r\n         * detection or by direct assignment using the `type` option for the column.\r\n         * The type of a column will effect how it is ordering and search (plug-ins\r\n         * can also make use of the column type if required).\r\n         *\r\n         * @namespace\r\n         */\r\n        type: {\r\n          /**\r\n           * Type detection functions.\r\n           *\r\n           * The functions defined in this object are used to automatically detect\r\n           * a column's type, making initialisation of DataTables super easy, even\r\n           * when complex data is in the table.\r\n           *\r\n           * The functions defined take two parameters:\r\n           *\r\n           *  1. `{*}` Data from the column cell to be analysed\r\n           *  2. `{settings}` DataTables settings object. This can be used to\r\n           *     perform context specific type detection - for example detection\r\n           *     based on language settings such as using a comma for a decimal\r\n           *     place. Generally speaking the options from the settings will not\r\n           *     be required\r\n           *\r\n           * Each function is expected to return:\r\n           *\r\n           * * `{string|null}` Data type detected, or null if unknown (and thus\r\n           *   pass it on to the other type detection functions.\r\n           *\r\n           *  @type array\r\n           *\r\n           *  @example\r\n           *    // Currency type detection plug-in:\r\n           *    $.fn.dataTable.ext.type.detect.push(\r\n           *      function ( data, settings ) {\r\n           *        // Check the numeric part\r\n           *        if ( ! $.isNumeric( data.substring(1) ) ) {\r\n           *          return null;\r\n           *        }\r\n           *\r\n           *        // Check prefixed by currency\r\n           *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\r\n           *          return 'currency';\r\n           *        }\r\n           *        return null;\r\n           *      }\r\n           *    );\r\n           */\r\n          detect: [],\r\n\r\n          /**\r\n           * Type based search formatting.\r\n           *\r\n           * The type based searching functions can be used to pre-format the\r\n           * data to be search on. For example, it can be used to strip HTML\r\n           * tags or to de-format telephone numbers for numeric only searching.\r\n           *\r\n           * Note that is a search is not defined for a column of a given type,\r\n           * no search formatting will be performed.\r\n           *\r\n           * Pre-processing of searching data plug-ins - When you assign the sType\r\n           * for a column (or have it automatically detected for you by DataTables\r\n           * or a type detection plug-in), you will typically be using this for\r\n           * custom sorting, but it can also be used to provide custom searching\r\n           * by allowing you to pre-processing the data and returning the data in\r\n           * the format that should be searched upon. This is done by adding\r\n           * functions this object with a parameter name which matches the sType\r\n           * for that target column. This is the corollary of <i>afnSortData</i>\r\n           * for searching data.\r\n           *\r\n           * The functions defined take a single parameter:\r\n           *\r\n           *  1. `{*}` Data from the column cell to be prepared for searching\r\n           *\r\n           * Each function is expected to return:\r\n           *\r\n           * * `{string|null}` Formatted string that will be used for the searching.\r\n           *\r\n           *  @type object\r\n           *  @default {}\r\n           *\r\n           *  @example\r\n           *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\r\n           *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\r\n           *    }\r\n           */\r\n          search: {},\r\n\r\n          /**\r\n           * Type based ordering.\r\n           *\r\n           * The column type tells DataTables what ordering to apply to the table\r\n           * when a column is sorted upon. The order for each type that is defined,\r\n           * is defined by the functions available in this object.\r\n           *\r\n           * Each ordering option can be described by three properties added to\r\n           * this object:\r\n           *\r\n           * * `{type}-pre` - Pre-formatting function\r\n           * * `{type}-asc` - Ascending order function\r\n           * * `{type}-desc` - Descending order function\r\n           *\r\n           * All three can be used together, only `{type}-pre` or only\r\n           * `{type}-asc` and `{type}-desc` together. It is generally recommended\r\n           * that only `{type}-pre` is used, as this provides the optimal\r\n           * implementation in terms of speed, although the others are provided\r\n           * for compatibility with existing Javascript sort functions.\r\n           *\r\n           * `{type}-pre`: Functions defined take a single parameter:\r\n           *\r\n           *  1. `{*}` Data from the column cell to be prepared for ordering\r\n           *\r\n           * And return:\r\n           *\r\n           * * `{*}` Data to be sorted upon\r\n           *\r\n           * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\r\n           * functions, taking two parameters:\r\n           *\r\n           *  1. `{*}` Data to compare to the second parameter\r\n           *  2. `{*}` Data to compare to the first parameter\r\n           *\r\n           * And returning:\r\n           *\r\n           * * `{*}` Ordering match: <0 if first parameter should be sorted lower\r\n           *   than the second parameter, ===0 if the two parameters are equal and\r\n           *   >0 if the first parameter should be sorted height than the second\r\n           *   parameter.\r\n           *\r\n           *  @type object\r\n           *  @default {}\r\n           *\r\n           *  @example\r\n           *    // Numeric ordering of formatted numbers with a pre-formatter\r\n           *    $.extend( $.fn.dataTable.ext.type.order, {\r\n           *      \"string-pre\": function(x) {\r\n           *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\r\n           *        return parseFloat( a );\r\n           *      }\r\n           *    } );\r\n           *\r\n           *  @example\r\n           *    // Case-sensitive string ordering, with no pre-formatting method\r\n           *    $.extend( $.fn.dataTable.ext.order, {\r\n           *      \"string-case-asc\": function(x,y) {\r\n           *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\r\n           *      },\r\n           *      \"string-case-desc\": function(x,y) {\r\n           *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\r\n           *      }\r\n           *    } );\r\n           */\r\n          order: {}\r\n        },\r\n\r\n        /**\r\n         * Unique DataTables instance counter\r\n         *\r\n         * @type int\r\n         * @private\r\n         */\r\n        _unique: 0,\r\n\r\n        //\r\n        // Depreciated\r\n        // The following properties are retained for backwards compatiblity only.\r\n        // The should not be used in new projects and will be removed in a future\r\n        // version\r\n        //\r\n\r\n        /**\r\n         * Version check function.\r\n         *  @type function\r\n         *  @depreciated Since 1.10\r\n         */\r\n        fnVersionCheck: DataTable.fnVersionCheck,\r\n\r\n        /**\r\n         * Index for what 'this' index API functions should use\r\n         *  @type int\r\n         *  @deprecated Since v1.10\r\n         */\r\n        iApiIndex: 0,\r\n\r\n        /**\r\n         * jQuery UI class container\r\n         *  @type object\r\n         *  @deprecated Since v1.10\r\n         */\r\n        oJUIClasses: {},\r\n\r\n        /**\r\n         * Software version\r\n         *  @type string\r\n         *  @deprecated Since v1.10\r\n         */\r\n        sVersion: DataTable.version\r\n      }\r\n\r\n      //\r\n      // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\r\n      //\r\n      $.extend(_ext, {\r\n        afnFiltering: _ext.search,\r\n        aTypes: _ext.type.detect,\r\n        ofnSearch: _ext.type.search,\r\n        oSort: _ext.type.order,\r\n        afnSortData: _ext.order,\r\n        aoFeatures: _ext.feature,\r\n        oApi: _ext.internal,\r\n        oStdClasses: _ext.classes,\r\n        oPagination: _ext.pager\r\n      })\r\n\r\n      $.extend(DataTable.ext.classes, {\r\n        sTable: 'dataTable',\r\n        sNoFooter: 'no-footer',\r\n\r\n        /* Paging buttons */\r\n        sPageButton: 'paginate_button',\r\n        sPageButtonActive: 'current',\r\n        sPageButtonDisabled: 'disabled',\r\n\r\n        /* Striping classes */\r\n        sStripeOdd: 'odd',\r\n        sStripeEven: 'even',\r\n\r\n        /* Empty row */\r\n        sRowEmpty: 'dataTables_empty',\r\n\r\n        /* Features */\r\n        sWrapper: 'dataTables_wrapper',\r\n        sFilter: 'dataTables_filter',\r\n        sInfo: 'dataTables_info',\r\n        sPaging: 'dataTables_paginate paging_' /* Note that the type is postfixed */,\r\n        sLength: 'dataTables_length',\r\n        sProcessing: 'dataTables_processing',\r\n\r\n        /* Sorting */\r\n        sSortAsc: 'sorting_asc',\r\n        sSortDesc: 'sorting_desc',\r\n        sSortable: 'sorting' /* Sortable in both directions */,\r\n        sSortableAsc: 'sorting_asc_disabled',\r\n        sSortableDesc: 'sorting_desc_disabled',\r\n        sSortableNone: 'sorting_disabled',\r\n        sSortColumn: 'sorting_' /* Note that an int is postfixed for the sorting order */,\r\n\r\n        /* Filtering */\r\n        sFilterInput: '',\r\n\r\n        /* Page length */\r\n        sLengthSelect: '',\r\n\r\n        /* Scrolling */\r\n        sScrollWrapper: 'dataTables_scroll',\r\n        sScrollHead: 'dataTables_scrollHead',\r\n        sScrollHeadInner: 'dataTables_scrollHeadInner',\r\n        sScrollBody: 'dataTables_scrollBody',\r\n        sScrollFoot: 'dataTables_scrollFoot',\r\n        sScrollFootInner: 'dataTables_scrollFootInner',\r\n\r\n        /* Misc */\r\n        sHeaderTH: '',\r\n        sFooterTH: '',\r\n\r\n        // Deprecated\r\n        sSortJUIAsc: '',\r\n        sSortJUIDesc: '',\r\n        sSortJUI: '',\r\n        sSortJUIAscAllowed: '',\r\n        sSortJUIDescAllowed: '',\r\n        sSortJUIWrapper: '',\r\n        sSortIcon: '',\r\n        sJUIHeader: '',\r\n        sJUIFooter: ''\r\n      })\r\n      ;(function () {\r\n        // Reused strings for better compression. Closure compiler appears to have a\r\n        // weird edge case where it is trying to expand strings rather than use the\r\n        // variable version. This results in about 200 bytes being added, for very\r\n        // little preference benefit since it this run on script load only.\r\n        var _empty = ''\r\n        _empty = ''\r\n\r\n        var _stateDefault = _empty + 'ui-state-default'\r\n        var _sortIcon = _empty + 'css_right ui-icon ui-icon-'\r\n        var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix'\r\n\r\n        $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {\r\n          /* Full numbers paging buttons */\r\n          sPageButton: 'fg-button ui-button ' + _stateDefault,\r\n          sPageButtonActive: 'ui-state-disabled',\r\n          sPageButtonDisabled: 'ui-state-disabled',\r\n\r\n          /* Features */\r\n          sPaging:\r\n            'dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ' +\r\n            'ui-buttonset-multi paging_' /* Note that the type is postfixed */,\r\n\r\n          /* Sorting */\r\n          sSortAsc: _stateDefault + ' sorting_asc',\r\n          sSortDesc: _stateDefault + ' sorting_desc',\r\n          sSortable: _stateDefault + ' sorting',\r\n          sSortableAsc: _stateDefault + ' sorting_asc_disabled',\r\n          sSortableDesc: _stateDefault + ' sorting_desc_disabled',\r\n          sSortableNone: _stateDefault + ' sorting_disabled',\r\n          sSortJUIAsc: _sortIcon + 'triangle-1-n',\r\n          sSortJUIDesc: _sortIcon + 'triangle-1-s',\r\n          sSortJUI: _sortIcon + 'carat-2-n-s',\r\n          sSortJUIAscAllowed: _sortIcon + 'carat-1-n',\r\n          sSortJUIDescAllowed: _sortIcon + 'carat-1-s',\r\n          sSortJUIWrapper: 'DataTables_sort_wrapper',\r\n          sSortIcon: 'DataTables_sort_icon',\r\n\r\n          /* Scrolling */\r\n          sScrollHead: 'dataTables_scrollHead ' + _stateDefault,\r\n          sScrollFoot: 'dataTables_scrollFoot ' + _stateDefault,\r\n\r\n          /* Misc */\r\n          sHeaderTH: _stateDefault,\r\n          sFooterTH: _stateDefault,\r\n          sJUIHeader: _headerFooter + ' ui-corner-tl ui-corner-tr',\r\n          sJUIFooter: _headerFooter + ' ui-corner-bl ui-corner-br'\r\n        })\r\n      })()\r\n\r\n      var extPagination = DataTable.ext.pager\r\n\r\n      function _numbers (page, pages) {\r\n        var numbers = [],\r\n          buttons = extPagination.numbers_length,\r\n          half = Math.floor(buttons / 2),\r\n          i = 1\r\n\r\n        if (pages <= buttons) {\r\n          numbers = _range(0, pages)\r\n        } else if (page <= half) {\r\n          numbers = _range(0, buttons - 2)\r\n          numbers.push('ellipsis')\r\n          numbers.push(pages - 1)\r\n        } else if (page >= pages - 1 - half) {\r\n          numbers = _range(pages - (buttons - 2), pages)\r\n          numbers.splice(0, 0, 'ellipsis') // no unshift in ie6\r\n          numbers.splice(0, 0, 0)\r\n        } else {\r\n          numbers = _range(page - 1, page + 2)\r\n          numbers.push('ellipsis')\r\n          numbers.push(pages - 1)\r\n          numbers.splice(0, 0, 'ellipsis')\r\n          numbers.splice(0, 0, 0)\r\n        }\r\n\r\n        numbers.DT_el = 'span'\r\n        return numbers\r\n      }\r\n\r\n      $.extend(extPagination, {\r\n        simple: function (page, pages) {\r\n          return ['previous', 'next']\r\n        },\r\n\r\n        full: function (page, pages) {\r\n          return ['first', 'previous', 'next', 'last']\r\n        },\r\n\r\n        simple_numbers: function (page, pages) {\r\n          return ['previous', _numbers(page, pages), 'next']\r\n        },\r\n\r\n        full_numbers: function (page, pages) {\r\n          return ['first', 'previous', _numbers(page, pages), 'next', 'last']\r\n        },\r\n\r\n        // For testing and plug-ins to use\r\n        _numbers: _numbers,\r\n        numbers_length: 7\r\n      })\r\n\r\n      $.extend(true, DataTable.ext.renderer, {\r\n        pageButton: {\r\n          _: function (settings, host, idx, buttons, page, pages) {\r\n            var classes = settings.oClasses\r\n            var lang = settings.oLanguage.oPaginate\r\n            var btnDisplay,\r\n              btnClass,\r\n              counter = 0\r\n\r\n            var attach = function (container, buttons) {\r\n              var i, ien, node, button\r\n              var clickHandler = function (e) {\r\n                _fnPageChange(settings, e.data.action, true)\r\n              }\r\n\r\n              for (i = 0, ien = buttons.length; i < ien; i++) {\r\n                button = buttons[i]\r\n\r\n                if ($.isArray(button)) {\r\n                  var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container)\r\n                  attach(inner, button)\r\n                } else {\r\n                  btnDisplay = ''\r\n                  btnClass = ''\r\n\r\n                  switch (button) {\r\n                    case 'ellipsis':\r\n                      container.append('<span>&hellip;</span>')\r\n                      break\r\n\r\n                    case 'first':\r\n                      btnDisplay = lang.sFirst\r\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    case 'previous':\r\n                      btnDisplay = lang.sPrevious\r\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    case 'next':\r\n                      btnDisplay = lang.sNext\r\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    case 'last':\r\n                      btnDisplay = lang.sLast\r\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    default:\r\n                      btnDisplay = button + 1\r\n                      btnClass = page === button ? classes.sPageButtonActive : ''\r\n                      break\r\n                  }\r\n\r\n                  if (btnDisplay) {\r\n                    node = $('<a>', {\r\n                      class: classes.sPageButton + ' ' + btnClass,\r\n                      'aria-controls': settings.sTableId,\r\n                      'data-dt-idx': counter,\r\n                      tabindex: settings.iTabIndex,\r\n                      id: idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null\r\n                    })\r\n                      .html(btnDisplay)\r\n                      .appendTo(container)\r\n\r\n                    _fnBindAction(node, { action: button }, clickHandler)\r\n\r\n                    counter++\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // IE9 throws an 'unknown error' if document.activeElement is used\r\n            // inside an iframe or frame. Try / catch the error. Not good for\r\n            // accessibility, but neither are frames.\r\n            try {\r\n              // Because this approach is destroying and recreating the paging\r\n              // elements, focus is lost on the select button which is bad for\r\n              // accessibility. So we want to restore focus once the draw has\r\n              // completed\r\n              var activeEl = $(document.activeElement).data('dt-idx')\r\n\r\n              attach($(host).empty(), buttons)\r\n\r\n              if (activeEl !== null) {\r\n                $(host)\r\n                  .find('[data-dt-idx=' + activeEl + ']')\r\n                  .focus()\r\n              }\r\n            } catch (e) {}\r\n          }\r\n        }\r\n      })\r\n\r\n      var __numericReplace = function (d, decimalPlace, re1, re2) {\r\n        if (!d || d === '-') {\r\n          return -Infinity\r\n        }\r\n\r\n        // If a decimal place other than `.` is used, it needs to be given to the\r\n        // function so we can detect it and replace with a `.` which is the only\r\n        // decimal place Javascript recognises - it is not locale aware.\r\n        if (decimalPlace) {\r\n          d = _numToDecimal(d, decimalPlace)\r\n        }\r\n\r\n        if (d.replace) {\r\n          if (re1) {\r\n            d = d.replace(re1, '')\r\n          }\r\n\r\n          if (re2) {\r\n            d = d.replace(re2, '')\r\n          }\r\n        }\r\n\r\n        return d * 1\r\n      }\r\n\r\n      // Add the numeric 'deformatting' functions for sorting. This is done in a\r\n      // function to provide an easy ability for the language options to add\r\n      // additional methods if a non-period decimal place is used.\r\n      function _addNumericSort (decimalPlace) {\r\n        $.each(\r\n          {\r\n            // Plain numbers\r\n            num: function (d) {\r\n              return __numericReplace(d, decimalPlace)\r\n            },\r\n\r\n            // Formatted numbers\r\n            'num-fmt': function (d) {\r\n              return __numericReplace(d, decimalPlace, _re_formatted_numeric)\r\n            },\r\n\r\n            // HTML numeric\r\n            'html-num': function (d) {\r\n              return __numericReplace(d, decimalPlace, _re_html)\r\n            },\r\n\r\n            // HTML numeric, formatted\r\n            'html-num-fmt': function (d) {\r\n              return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric)\r\n            }\r\n          },\r\n          function (key, fn) {\r\n            _ext.type.order[key + decimalPlace + '-pre'] = fn\r\n          }\r\n        )\r\n      }\r\n\r\n      // Default sort methods\r\n      $.extend(_ext.type.order, {\r\n        // Dates\r\n        'date-pre': function (d) {\r\n          return Date.parse(d) || 0\r\n        },\r\n\r\n        // html\r\n        'html-pre': function (a) {\r\n          return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, '').toLowerCase() : a + ''\r\n        },\r\n\r\n        // string\r\n        'string-pre': function (a) {\r\n          // This is a little complex, but faster than always calling toString,\r\n          // http://jsperf.com/tostring-v-check\r\n          return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString()\r\n        },\r\n\r\n        // string-asc and -desc are retained only for compatibility with the old\r\n        // sort methods\r\n        'string-asc': function (x, y) {\r\n          return x < y ? -1 : x > y ? 1 : 0\r\n        },\r\n\r\n        'string-desc': function (x, y) {\r\n          return x < y ? 1 : x > y ? -1 : 0\r\n        }\r\n      })\r\n\r\n      // Numeric sorting types - order doesn't matter here\r\n      _addNumericSort('')\r\n\r\n      // Built in type detection. See model.ext.aTypes for information about\r\n      // what is required from this methods.\r\n      $.extend(DataTable.ext.type.detect, [\r\n        // Plain numbers - first since V8 detects some plain numbers as dates\r\n        // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _isNumber(d, decimal) ? 'num' + decimal : null\r\n        },\r\n\r\n        // Dates (only those recognised by the browser's Date.parse)\r\n        function (d, settings) {\r\n          // V8 will remove any unknown characters at the start and end of the\r\n          // expression, leading to false matches such as `$245.12` or `10%` being\r\n          // a valid date. See forum thread 18941 for detail.\r\n          if (d && (!_re_date_start.test(d) || !_re_date_end.test(d))) {\r\n            return null\r\n          }\r\n          var parsed = Date.parse(d)\r\n          return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null\r\n        },\r\n\r\n        // Formatted numbers\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null\r\n        },\r\n\r\n        // HTML numeric\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null\r\n        },\r\n\r\n        // HTML numeric, formatted\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null\r\n        },\r\n\r\n        // HTML (this is strict checking - there must be html)\r\n        function (d, settings) {\r\n          return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ? 'html' : null\r\n        }\r\n      ])\r\n\r\n      // Filter formatting functions. See model.ext.ofnSearch for information about\r\n      // what is required from these methods.\r\n\r\n      $.extend(DataTable.ext.type.search, {\r\n        html: function (data) {\r\n          return _empty(data)\r\n            ? data\r\n            : typeof data === 'string'\r\n            ? data.replace(_re_new_lines, ' ').replace(_re_html, '')\r\n            : ''\r\n        },\r\n\r\n        string: function (data) {\r\n          return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, ' ') : data\r\n        }\r\n      })\r\n\r\n      $.extend(true, DataTable.ext.renderer, {\r\n        header: {\r\n          _: function (settings, cell, column, classes) {\r\n            // No additional mark-up required\r\n            // Attach a sort listener to update on sort - note that using the\r\n            // `DT` namespace will allow the event to be removed automatically\r\n            // on destroy, while the `dt` namespaced event is the one we are\r\n            // listening for\r\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\r\n              if (settings !== ctx) {\r\n                // need to check this this is the host\r\n                return // table, not a nested one\r\n              }\r\n\r\n              var colIdx = column.idx\r\n\r\n              cell\r\n                .removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc)\r\n                .addClass(\r\n                  columns[colIdx] == 'asc'\r\n                    ? classes.sSortAsc\r\n                    : columns[colIdx] == 'desc'\r\n                    ? classes.sSortDesc\r\n                    : column.sSortingClass\r\n                )\r\n            })\r\n          },\r\n\r\n          jqueryui: function (settings, cell, column, classes) {\r\n            var colIdx = column.idx\r\n\r\n            $('<div/>')\r\n              .addClass(classes.sSortJUIWrapper)\r\n              .append(cell.contents())\r\n              .append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI))\r\n              .appendTo(cell)\r\n\r\n            // Attach a sort listener to update on sort\r\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\r\n              if (settings !== ctx) {\r\n                return\r\n              }\r\n\r\n              cell\r\n                .removeClass(classes.sSortAsc + ' ' + classes.sSortDesc)\r\n                .addClass(\r\n                  columns[colIdx] == 'asc'\r\n                    ? classes.sSortAsc\r\n                    : columns[colIdx] == 'desc'\r\n                    ? classes.sSortDesc\r\n                    : column.sSortingClass\r\n                )\r\n\r\n              cell\r\n                .find('span.' + classes.sSortIcon)\r\n                .removeClass(\r\n                  classes.sSortJUIAsc +\r\n                    ' ' +\r\n                    classes.sSortJUIDesc +\r\n                    ' ' +\r\n                    classes.sSortJUI +\r\n                    ' ' +\r\n                    classes.sSortJUIAscAllowed +\r\n                    ' ' +\r\n                    classes.sSortJUIDescAllowed\r\n                )\r\n                .addClass(\r\n                  columns[colIdx] == 'asc'\r\n                    ? classes.sSortJUIAsc\r\n                    : columns[colIdx] == 'desc'\r\n                    ? classes.sSortJUIDesc\r\n                    : column.sSortingClassJUI\r\n                )\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      /*\r\n       * Public helper functions. These aren't used internally by DataTables, or\r\n       * called by any of the options passed into DataTables, but they can be used\r\n       * externally by developers working with DataTables. They are helper functions\r\n       * to make working with DataTables a little bit easier.\r\n       */\r\n\r\n      /**\r\n       * Helpers for `columns.render`.\r\n       *\r\n       * The options defined here can be used with the `columns.render` initialisation\r\n       * option to provide a display renderer. The following functions are defined:\r\n       *\r\n       * * `number` - Will format numeric data (defined by `columns.data`) for\r\n       *   display, retaining the original unformatted data for sorting and filtering.\r\n       *   It takes 4 parameters:\r\n       *   * `string` - Thousands grouping separator\r\n       *   * `string` - Decimal point indicator\r\n       *   * `integer` - Number of decimal points to show\r\n       *   * `string` (optional) - Prefix.\r\n       *\r\n       * @example\r\n       *   // Column definition using the number renderer\r\n       *   {\r\n       *     data: \"salary\",\r\n       *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\r\n       *   }\r\n       *\r\n       * @namespace\r\n       */\r\n      DataTable.render = {\r\n        number: function (thousands, decimal, precision, prefix) {\r\n          return {\r\n            display: function (d) {\r\n              var negative = d < 0 ? '-' : ''\r\n              d = Math.abs(parseFloat(d))\r\n\r\n              var intPart = parseInt(d, 10)\r\n              var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : ''\r\n\r\n              return (\r\n                negative + (prefix || '') + intPart.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands) + floatPart\r\n              )\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /*\r\n       * This is really a good bit rubbish this method of exposing the internal methods\r\n       * publicly... - To be fixed in 2.0 using methods on the prototype\r\n       */\r\n\r\n      /**\r\n       * Create a wrapper function for exporting an internal functions to an external API.\r\n       *  @param {string} fn API function name\r\n       *  @returns {function} wrapped function\r\n       *  @memberof DataTable#internal\r\n       */\r\n      function _fnExternApiFunc (fn) {\r\n        return function () {\r\n          var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments))\r\n          return DataTable.ext.internal[fn].apply(this, args)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Reference to internal functions for use by plug-in developers. Note that\r\n       * these methods are references to internal functions and are considered to be\r\n       * private. If you use these methods, be aware that they are liable to change\r\n       * between versions.\r\n       *  @namespace\r\n       */\r\n      $.extend(DataTable.ext.internal, {\r\n        _fnExternApiFunc: _fnExternApiFunc,\r\n        _fnBuildAjax: _fnBuildAjax,\r\n        _fnAjaxUpdate: _fnAjaxUpdate,\r\n        _fnAjaxParameters: _fnAjaxParameters,\r\n        _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\r\n        _fnAjaxDataSrc: _fnAjaxDataSrc,\r\n        _fnAddColumn: _fnAddColumn,\r\n        _fnColumnOptions: _fnColumnOptions,\r\n        _fnAdjustColumnSizing: _fnAdjustColumnSizing,\r\n        _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\r\n        _fnColumnIndexToVisible: _fnColumnIndexToVisible,\r\n        _fnVisbleColumns: _fnVisbleColumns,\r\n        _fnGetColumns: _fnGetColumns,\r\n        _fnColumnTypes: _fnColumnTypes,\r\n        _fnApplyColumnDefs: _fnApplyColumnDefs,\r\n        _fnHungarianMap: _fnHungarianMap,\r\n        _fnCamelToHungarian: _fnCamelToHungarian,\r\n        _fnLanguageCompat: _fnLanguageCompat,\r\n        _fnBrowserDetect: _fnBrowserDetect,\r\n        _fnAddData: _fnAddData,\r\n        _fnAddTr: _fnAddTr,\r\n        _fnNodeToDataIndex: _fnNodeToDataIndex,\r\n        _fnNodeToColumnIndex: _fnNodeToColumnIndex,\r\n        _fnGetCellData: _fnGetCellData,\r\n        _fnSetCellData: _fnSetCellData,\r\n        _fnSplitObjNotation: _fnSplitObjNotation,\r\n        _fnGetObjectDataFn: _fnGetObjectDataFn,\r\n        _fnSetObjectDataFn: _fnSetObjectDataFn,\r\n        _fnGetDataMaster: _fnGetDataMaster,\r\n        _fnClearTable: _fnClearTable,\r\n        _fnDeleteIndex: _fnDeleteIndex,\r\n        _fnInvalidateRow: _fnInvalidateRow,\r\n        _fnGetRowElements: _fnGetRowElements,\r\n        _fnCreateTr: _fnCreateTr,\r\n        _fnBuildHead: _fnBuildHead,\r\n        _fnDrawHead: _fnDrawHead,\r\n        _fnDraw: _fnDraw,\r\n        _fnReDraw: _fnReDraw,\r\n        _fnAddOptionsHtml: _fnAddOptionsHtml,\r\n        _fnDetectHeader: _fnDetectHeader,\r\n        _fnGetUniqueThs: _fnGetUniqueThs,\r\n        _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\r\n        _fnFilterComplete: _fnFilterComplete,\r\n        _fnFilterCustom: _fnFilterCustom,\r\n        _fnFilterColumn: _fnFilterColumn,\r\n        _fnFilter: _fnFilter,\r\n        _fnFilterCreateSearch: _fnFilterCreateSearch,\r\n        _fnEscapeRegex: _fnEscapeRegex,\r\n        _fnFilterData: _fnFilterData,\r\n        _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\r\n        _fnUpdateInfo: _fnUpdateInfo,\r\n        _fnInfoMacros: _fnInfoMacros,\r\n        _fnInitialise: _fnInitialise,\r\n        _fnInitComplete: _fnInitComplete,\r\n        _fnLengthChange: _fnLengthChange,\r\n        _fnFeatureHtmlLength: _fnFeatureHtmlLength,\r\n        _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\r\n        _fnPageChange: _fnPageChange,\r\n        _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\r\n        _fnProcessingDisplay: _fnProcessingDisplay,\r\n        _fnFeatureHtmlTable: _fnFeatureHtmlTable,\r\n        _fnScrollDraw: _fnScrollDraw,\r\n        _fnApplyToChildren: _fnApplyToChildren,\r\n        _fnCalculateColumnWidths: _fnCalculateColumnWidths,\r\n        _fnThrottle: _fnThrottle,\r\n        _fnConvertToWidth: _fnConvertToWidth,\r\n        _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,\r\n        _fnGetWidestNode: _fnGetWidestNode,\r\n        _fnGetMaxLenString: _fnGetMaxLenString,\r\n        _fnStringToCss: _fnStringToCss,\r\n        _fnScrollBarWidth: _fnScrollBarWidth,\r\n        _fnSortFlatten: _fnSortFlatten,\r\n        _fnSort: _fnSort,\r\n        _fnSortAria: _fnSortAria,\r\n        _fnSortListener: _fnSortListener,\r\n        _fnSortAttachListener: _fnSortAttachListener,\r\n        _fnSortingClasses: _fnSortingClasses,\r\n        _fnSortData: _fnSortData,\r\n        _fnSaveState: _fnSaveState,\r\n        _fnLoadState: _fnLoadState,\r\n        _fnSettingsFromNode: _fnSettingsFromNode,\r\n        _fnLog: _fnLog,\r\n        _fnMap: _fnMap,\r\n        _fnBindAction: _fnBindAction,\r\n        _fnCallbackReg: _fnCallbackReg,\r\n        _fnCallbackFire: _fnCallbackFire,\r\n        _fnLengthOverflow: _fnLengthOverflow,\r\n        _fnRenderer: _fnRenderer,\r\n        _fnDataSource: _fnDataSource,\r\n        _fnRowAttributes: _fnRowAttributes,\r\n        _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant\r\n        // in 1.10, so this dead-end function is\r\n        // added to prevent errors\r\n      })\r\n\r\n      // jQuery access\r\n      $.fn.dataTable = DataTable\r\n\r\n      // Legacy aliases\r\n      $.fn.dataTableSettings = DataTable.settings\r\n      $.fn.dataTableExt = DataTable.ext\r\n\r\n      // With a capital `D` we return a DataTables API instance rather than a\r\n      // jQuery object\r\n      $.fn.DataTable = function (opts) {\r\n        return $(this)\r\n          .dataTable(opts)\r\n          .api()\r\n      }\r\n\r\n      // All properties that are available to $.fn.dataTable should also be\r\n      // available on $.fn.DataTable\r\n      $.each(DataTable, function (prop, val) {\r\n        $.fn.DataTable[prop] = val\r\n      })\r\n\r\n      // Information about events fired by DataTables - for documentation.\r\n      /**\r\n       * Draw event, fired whenever the table is redrawn on the page, at the same\r\n       * point as fnDrawCallback. This may be useful for binding events or\r\n       * performing calculations when the table is altered at all.\r\n       *  @name DataTable#draw.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Search event, fired when the searching applied to the table (using the\r\n       * built-in global search, or column filters) is altered.\r\n       *  @name DataTable#search.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Page change event, fired when the paging of the table is altered.\r\n       *  @name DataTable#page.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Order event, fired when the ordering applied to the table is altered.\r\n       *  @name DataTable#order.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * DataTables initialisation complete event, fired when the table is fully\r\n       * drawn, including Ajax data loaded, if Ajax data is required.\r\n       *  @name DataTable#init.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The JSON object request from the server - only\r\n       *    present if client-side Ajax sourced data is used</li></ol>\r\n       */\r\n\r\n      /**\r\n       * State save event, fired when the table has changed state a new state save\r\n       * is required. This event allows modification of the state saving object\r\n       * prior to actually doing the save, including addition or other state\r\n       * properties (for plug-ins) or modification of a DataTables core property.\r\n       *  @name DataTable#stateSaveParams.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The state information to be saved\r\n       */\r\n\r\n      /**\r\n       * State load event, fired when the table is loading state from the stored\r\n       * data, but prior to the settings object being modified by the saved state\r\n       * - allowing modification of the saved state is required or loading of\r\n       * state for a plug-in.\r\n       *  @name DataTable#stateLoadParams.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The saved state information\r\n       */\r\n\r\n      /**\r\n       * State loaded event, fired when state has been loaded from stored data and\r\n       * the settings object has been modified by the loaded data.\r\n       *  @name DataTable#stateLoaded.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The saved state information\r\n       */\r\n\r\n      /**\r\n       * Processing event, fired when DataTables is doing some kind of processing\r\n       * (be it, order, searcg or anything else). It can be used to indicate to\r\n       * the end user that there is something happening, or that something has\r\n       * finished.\r\n       *  @name DataTable#processing.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {boolean} bShow Flag for if DataTables is doing processing or not\r\n       */\r\n\r\n      /**\r\n       * Ajax (XHR) event, fired whenever an Ajax request is completed from a\r\n       * request to made to the server for new data. This event is called before\r\n       * DataTables processed the returned data, so it can also be used to pre-\r\n       * process the data returned from the server, if needed.\r\n       *\r\n       * Note that this trigger is called in `fnServerData`, if you override\r\n       * `fnServerData` and which to use this event, you need to trigger it in you\r\n       * success function.\r\n       *  @name DataTable#xhr.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       *  @param {object} json JSON returned from the server\r\n       *\r\n       *  @example\r\n       *     // Use a custom property returned from the server in another DOM element\r\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\r\n       *       $('#status').html( json.status );\r\n       *     } );\r\n       *\r\n       *  @example\r\n       *     // Pre-process the data returned from the server\r\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\r\n       *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {\r\n       *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;\r\n       *       }\r\n       *       // Note no return - manipulate the data directly in the JSON object.\r\n       *     } );\r\n       */\r\n\r\n      /**\r\n       * Destroy event, fired when the DataTable is destroyed by calling fnDestroy\r\n       * or passing the bDestroy:true parameter in the initialisation object. This\r\n       * can be used to remove bound events, added DOM nodes, etc.\r\n       *  @name DataTable#destroy.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Page length change event, fired when number of records to show on each\r\n       * page (the length) is changed.\r\n       *  @name DataTable#length.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       *  @param {integer} len New length\r\n       */\r\n\r\n      /**\r\n       * Column sizing has changed.\r\n       *  @name DataTable#column-sizing.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Column visibility has changed.\r\n       *  @name DataTable#column-visibility.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       *  @param {int} column Column index\r\n       *  @param {bool} vis `false` if column now hidden, or `true` if visible\r\n       */\r\n\r\n      return $.fn.dataTable\r\n    }\r\n  )\r\n})(window, document)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/jquery.dataTables.js?");

/***/ }),

/***/ 232:
/*!*********************************************************************!*\
  !*** ./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/* provided dependency */ var $ = __webpack_require__(/*! jquery */ 0);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(function (t, e) {\r\n   true\r\n    ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! d3 */ 165)], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n    : 0\r\n})(this, function (E) {\r\n  'use strict'\r\n  var c =\r\n    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\r\n      ? function (t) {\r\n          return typeof t\r\n        }\r\n      : function (t) {\r\n          return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype\r\n            ? 'symbol'\r\n            : typeof t\r\n        }\r\n  function k () {\r\n    return 'undefined' != typeof jQuery || 'undefined' != typeof $\r\n  }\r\n  function i (t, e) {\r\n    return (\r\n      t[e.x_accessor] >= e.processed.min_x &&\r\n      t[e.x_accessor] <= e.processed.max_x &&\r\n      t[e.y_accessor] >= e.processed.min_y &&\r\n      t[e.y_accessor] <= e.processed.max_y\r\n    )\r\n  }\r\n  function u (t) {\r\n    return '[object Array]' === Object.prototype.toString.call(t)\r\n  }\r\n  function a (t) {\r\n    var e = t.map(function (t) {\r\n      return !0 === u(t) && 0 < t.length\r\n    })\r\n    return E.sum(e) === t.length\r\n  }\r\n  function n (t) {\r\n    var e = t.map(function (t) {\r\n      return !0 == ((e = t), '[object Object]' === Object.prototype.toString.call(e))\r\n      var e\r\n    })\r\n    return E.sum(e) === t.length\r\n  }\r\n  function e (t) {\r\n    return (u((e = t)) && 0 === e.length) || n(t)\r\n    var e\r\n  }\r\n  function w (t) {\r\n    return t.height - t.bottom\r\n  }\r\n  function v (t) {\r\n    return w(t) - t.buffer\r\n  }\r\n  function M (t) {\r\n    return t.top\r\n  }\r\n  function b (t) {\r\n    return M(t) + t.buffer\r\n  }\r\n  function G (t) {\r\n    return t.left\r\n  }\r\n  function Y (t) {\r\n    return G(t) + t.buffer\r\n  }\r\n  function A (t) {\r\n    return t.width - t.right\r\n  }\r\n  function P (t) {\r\n    return A(t) - t.buffer\r\n  }\r\n  function _ (t) {\r\n    t.exit().remove()\r\n  }\r\n  function D (t, e) {\r\n    t.selectAll(e).remove()\r\n  }\r\n  function S (t, e) {\r\n    return t.append('g').classed(e, !0)\r\n  }\r\n  function r (t, e) {\r\n    var r = O(t.target),\r\n      a = h(t.data),\r\n      n = r.selectAll('line.' + e).data(a)\r\n    return (\r\n      n\r\n        .enter()\r\n        .append('line')\r\n        .attr('class', e)\r\n        .attr('opacity', 0.3),\r\n      _(n),\r\n      _(n),\r\n      n\r\n    )\r\n  }\r\n  function m (t, e, r) {\r\n    e.color_accessor\r\n      ? (t.attr('stroke', e.scalefns.colorf), t.classed(r, !1))\r\n      : (t.attr('stroke', null), t.classed(r, !0))\r\n  }\r\n  function l (t, e) {\r\n    e &&\r\n      t.attr({\r\n        dy: 0,\r\n        transform: function () {\r\n          var t = E.select(this)\r\n          return 'rotate(' + e + ' ' + t.attr('x') + ',' + t.attr('y') + ')'\r\n        }\r\n      })\r\n  }\r\n  function g (t) {\r\n    if (!(t = t.node())) return !1\r\n    for (var e = 0; e < t.length; e++) if (o(t[e], t)) return !0\r\n    return !1\r\n  }\r\n  function o (t, e) {\r\n    for (var r = t.getBoundingClientRect(), a = 0; a < e.length; a++)\r\n      if (e[a] != t) {\r\n        var n = e[a].getBoundingClientRect()\r\n        if (r.top === n.top && !(n.left > r.right || n.right < r.left)) return !0\r\n      }\r\n    return !1\r\n  }\r\n  function s (t, e) {\r\n    var r = h(t.data)\r\n    return 'string' == typeof (r = r[0][t[e + '_accessor']]) ? 'categorical' : 'numerical'\r\n  }\r\n  function O (t) {\r\n    return E.select(t).select('svg')\r\n  }\r\n  function h (t) {\r\n    var e = []\r\n    return e.concat.apply(e, t)\r\n  }\r\n  function z (t) {\r\n    if ('string' == typeof t) return F(t)\r\n    if (t instanceof window.HTMLElement) {\r\n      var e = t.getAttribute('data-mg-uid')\r\n      return (\r\n        e ||\r\n          (void 0 === MG._next_elem_id && (MG._next_elem_id = 0),\r\n          (e = 'mg-' + MG._next_elem_id++),\r\n          t.setAttribute('data-mg-uid', e)),\r\n        e\r\n      )\r\n    }\r\n    return console.warn('The specified target should be a string or an HTMLElement.', t), F(t)\r\n  }\r\n  function F (t) {\r\n    return t.replace(/[^a-zA-Z0-9 _-]+/g, '').replace(/ +?/g, '')\r\n  }\r\n  function d (t, e) {\r\n    return Number(\r\n      E.select(t)\r\n        .style(e)\r\n        .replace(/px/g, '')\r\n    )\r\n  }\r\n  function f (t) {\r\n    return d(t, 'width')\r\n  }\r\n  ;(('undefined' == typeof window ? __webpack_require__.g : window).MG = { version: '2.11' }),\r\n    (MG.convert = {}),\r\n    (MG.convert.date = function (t, e, r) {\r\n      r = void 0 === r ? '%Y-%m-%d' : r\r\n      var a = E.timeParse(r)\r\n      return (t = t.map(function (t) {\r\n        return (t[e] = a(t[e].trim())), t\r\n      }))\r\n    }),\r\n    (MG.convert.number = function (t, e) {\r\n      return (t = t.map(function (t) {\r\n        return (t[e] = Number(t[e])), t\r\n      }))\r\n    }),\r\n    (MG.time_format = function (t, e) {\r\n      return t ? E.utcFormat(e) : E.timeFormat(e)\r\n    })\r\n  var t = function (t, e, r) {\r\n    var a = {}\r\n    if (null === t) return t\r\n    if (Array.prototype.forEach && t.forEach === Array.prototype.forEach) t.forEach(e, r)\r\n    else if (t.length === +t.length) {\r\n      for (var n = 0, o = t.length; n < o; n++) if (e.call(r, t[n], n, t) === a) return\r\n    } else for (var i in t) if (e.call(r, t[i], i, t) === a) return\r\n    return t\r\n  }\r\n  function p (r) {\r\n    return (\r\n      t(Array.prototype.slice.call(arguments, 1), function (t) {\r\n        if (t) for (var e in t) void 0 === r[e] && (r[e] = t[e])\r\n      }),\r\n      r\r\n    )\r\n  }\r\n  function x (t) {\r\n    return '[object Date]' === Object.prototype.toString.call(t)\r\n  }\r\n  function y (t) {\r\n    return Array.isArray ? Array.isArray(t) : '[object Array]' === Object.prototype.toString.call(t)\r\n  }\r\n  function C (t) {\r\n    return '[object Function]' === Object.prototype.toString.call(t)\r\n  }\r\n  function T (t, e) {\r\n    var r,\r\n      a = [],\r\n      n = []\r\n    for (r = 0; r < e.length; r++) a[e[r]] = !0\r\n    for (r = 0; r < t.length; r++) a[t[r]] || n.push(t[r])\r\n    return n\r\n  }\r\n  function R (t, e) {\r\n    console.warn('Deprecation: ' + t + (e ? '. This feature will be removed in ' + e + '.' : ' the near future.')),\r\n      console.trace()\r\n  }\r\n  function L (t, e, r) {\r\n    var a,\r\n      n = 0\r\n    for (\r\n      t.textContent = e, a = t.getBBox();\r\n      a.width > r && ((t.textContent = e.slice(0, --n) + '...'), (a = t.getBBox()), '...' !== t.textContent);\r\n\r\n    );\r\n  }\r\n  function j (t) {\r\n    var e = O(t.target)\r\n    if ((e.select('.mg-header').remove(), t.target && t.title)) {\r\n      var r = e\r\n        .insert('text')\r\n        .attr('class', 'mg-header')\r\n        .attr('x', t.center_title_full_width ? t.width / 2 : (t.width + t.left - t.right) / 2)\r\n        .attr('y', t.title_y_position)\r\n        .attr('text-anchor', 'middle')\r\n        .attr('dy', '0.55em')\r\n      if (\r\n        (r\r\n          .append('tspan')\r\n          .attr('class', 'mg-chart-title')\r\n          .text(t.title),\r\n        t.show_tooltips && t.description && k())\r\n      ) {\r\n        r.append('tspan')\r\n          .attr('class', 'mg-chart-description')\r\n          .attr('dx', '0.3em')\r\n          .text('')\r\n        var a = $(r.node())\r\n        a.popover({\r\n          html: !0,\r\n          animation: !1,\r\n          placement: 'top',\r\n          content: t.description,\r\n          container: t.target,\r\n          trigger: 'manual',\r\n          template:\r\n            '<div class=\"popover mg-popover\"><div class=\"arrow\"></div><div class=\"popover-inner\"><h3 class=\"popover-title\"></h3><div class=\"popover-content\"><p></p></div></div></div>'\r\n        })\r\n          .on('mouseenter', function () {\r\n            E.selectAll(t.target)\r\n              .selectAll('.mg-popover')\r\n              .remove(),\r\n              $(this).popover('show'),\r\n              $(\r\n                E.select(t.target)\r\n                  .select('.popover')\r\n                  .node()\r\n              ).on('mouseleave', function () {\r\n                a.popover('hide')\r\n              })\r\n          })\r\n          .on('mouseleave', function () {\r\n            setTimeout(function () {\r\n              $('.popover:hover').length || a.popover('hide')\r\n            }, 120)\r\n          })\r\n      } else\r\n        t.show_tooltips &&\r\n          t.description &&\r\n          'undefined' == typeof $ &&\r\n          (t.error = 'In order to enable tooltips, please make sure you include jQuery.')\r\n    }\r\n    t.error && Xe(t)\r\n  }\r\n  function X (e, t, r, a, n) {\r\n    e.scalefns[t] = function (t) {\r\n      return void 0 === n ? e.scales[r](t[a]) : e.scales[r](t[a]) + n\r\n    }\r\n  }\r\n  function U (t, e) {\r\n    return 'bottom' === t || 'top' === t ? [Y(e), P(e)] : 'left' === t || 'right' === t ? [v(e), e.top] : void 0\r\n  }\r\n  function N (t, e) {\r\n    return E.set(\r\n      t.map(function (t) {\r\n        return t[e]\r\n      })\r\n    ).values()\r\n  }\r\n  function B (e) {\r\n    var t\r\n    return (\r\n      null === e.color_domain\r\n        ? 'number' === e.color_type\r\n          ? (t = E.extent(e.data[0], function (t) {\r\n              return t[e.color_accessor]\r\n            }))\r\n          : 'category' === e.color_type && (t = N(e.data[0], e.color_accessor))\r\n        : (t = e.color_domain),\r\n      t\r\n    )\r\n  }\r\n  function I (t) {\r\n    return null === t.color_range ? ('number' === t.color_type ? ['blue', 'red'] : null) : t.color_range\r\n  }\r\n  function H (t, e, r) {\r\n    var a = xt(t),\r\n      n = a.secondary(t.processed.min_x, t.processed.max_x)\r\n    0 === n.length && (n = [t.scales.X.ticks(t.xax_count)[0]])\r\n    var o,\r\n      i,\r\n      s,\r\n      c = S(r, 'mg-year-marker')\r\n    'default' === a.timeframe &&\r\n      t.show_year_markers &&\r\n      ((o = t),\r\n      (i = c),\r\n      (s = n),\r\n      a.yformat,\r\n      i\r\n        .selectAll('.mg-year-marker')\r\n        .data(s)\r\n        .enter()\r\n        .append('line')\r\n        .attr('x1', function (t) {\r\n          return o.scales.X(t).toFixed(2)\r\n        })\r\n        .attr('x2', function (t) {\r\n          return o.scales.X(t).toFixed(2)\r\n        })\r\n        .attr('y1', M(o))\r\n        .attr('y2', w(o))),\r\n      'years' != a.tick_diff_timeframe &&\r\n        (function (t, e, r, a, n) {\r\n          var o,\r\n            i,\r\n            s,\r\n            c,\r\n            l,\r\n            u = e.position,\r\n            d = e.namespace,\r\n            f = t.scales[d.toUpperCase()],\r\n            p = E.select(t.target)\r\n              .select('.mg-x-axis text')\r\n              .node()\r\n              .getBoundingClientRect()\r\n          'top' === u &&\r\n            ((o = function (t, e) {\r\n              return f(t).toFixed(2)\r\n            }),\r\n            (i = M(t) - (7 * t.xax_tick_length) / 3 - p.height),\r\n            (s = '.50em'),\r\n            (c = 'middle'),\r\n            (l = function (t) {\r\n              return n(new Date(t))\r\n            }))\r\n          'bottom' === u &&\r\n            ((o = function (t, e) {\r\n              return f(t).toFixed(2)\r\n            }),\r\n            (i = w(t) + (7 * t.xax_tick_length) / 3 + 0.8 * p.height),\r\n            (s = '.50em'),\r\n            (c = 'middle'),\r\n            (l = function (t) {\r\n              return n(new Date(t))\r\n            }))\r\n          r.selectAll('.mg-year-marker')\r\n            .data(a)\r\n            .enter()\r\n            .append('text')\r\n            .attr('x', o)\r\n            .attr('y', i)\r\n            .attr('dy', s)\r\n            .attr('text-anchor', c)\r\n            .text(l)\r\n        })(t, e, c, n, a.yformat)\r\n  }\r\n  function q (t, a, e) {\r\n    var r,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c,\r\n      l,\r\n      u = e.namespace,\r\n      d = ((r = a),\r\n      (o = (n = e).position),\r\n      (i = n.namespace),\r\n      (s = r[i + 'ax_tick_length']),\r\n      (c = r.scales[i.toUpperCase()]),\r\n      (l = {}),\r\n      'left' === o &&\r\n        ((l.x = G(r) - (3 * s) / 2),\r\n        (l.y = function (t) {\r\n          return c(t).toFixed(2)\r\n        }),\r\n        (l.dx = -3),\r\n        (l.dy = '.35em'),\r\n        (l.textAnchor = 'end'),\r\n        (l.text = function (t) {\r\n          return J(r)(t)\r\n        })),\r\n      'right' === o &&\r\n        ((l.x = A(r) + (3 * s) / 2),\r\n        (l.y = function (t) {\r\n          return c(t).toFixed(2)\r\n        }),\r\n        (l.dx = 3),\r\n        (l.dy = '.35em'),\r\n        (l.textAnchor = 'start'),\r\n        (l.text = function (t) {\r\n          return J(r)(t)\r\n        })),\r\n      'top' === o &&\r\n        ((l.x = function (t) {\r\n          return c(t).toFixed(2)\r\n        }),\r\n        (l.y = (M(r) - (7 * s) / 3).toFixed(2)),\r\n        (l.dx = 0),\r\n        (l.dy = '0em'),\r\n        (l.textAnchor = 'middle'),\r\n        (l.text = function (t) {\r\n          return ht(r)(t)\r\n        })),\r\n      'bottom' === o &&\r\n        ((l.x = function (t) {\r\n          return c(t).toFixed(2)\r\n        }),\r\n        (l.y = (w(r) + (7 * s) / 3).toFixed(2)),\r\n        (l.dx = 0),\r\n        (l.dy = '.50em'),\r\n        (l.textAnchor = 'middle'),\r\n        (l.text = function (t) {\r\n          return ht(r)(t)\r\n        })),\r\n      l),\r\n      f = a.processed[u + '_ticks'],\r\n      p = t\r\n        .selectAll('.mg-yax-labels')\r\n        .data(f)\r\n        .enter()\r\n        .append('text')\r\n        .attr('x', d.x)\r\n        .attr('dx', d.dx)\r\n        .attr('y', d.y)\r\n        .attr('dy', d.dy)\r\n        .attr('text-anchor', d.textAnchor)\r\n        .text(d.text)\r\n    ;('x' == u &&\r\n      (a.time_series && a.european_clock\r\n        ? (p\r\n            .append('tspan')\r\n            .classed('mg-european-hours', !0)\r\n            .text(function (t, e) {\r\n              var r = new Date(t)\r\n              return 0 === e ? E.timeFormat('%H')(r) : ''\r\n            }),\r\n          p\r\n            .append('tspan')\r\n            .classed('mg-european-minutes-seconds', !0)\r\n            .text(function (t, e) {\r\n              var r = new Date(t)\r\n              return ':' + a.processed.xax_format(r)\r\n            }))\r\n        : p.text(function (t) {\r\n            return a.xax_units + a.processed.xax_format(t)\r\n          }),\r\n      a.time_series && (a.show_years || a.show_secondary_x_label) && H(a, e, t)),\r\n    g(p)) &&\r\n      (p\r\n        .filter(function (t, e) {\r\n          return (e + 1) % 2 == 0\r\n        })\r\n        .remove(),\r\n      O(a.target)\r\n        .selectAll('.mg-' + u + 'ax-ticks')\r\n        .filter(function (t, e) {\r\n          return (e + 1) % 2 == 0\r\n        })\r\n        .remove())\r\n  }\r\n  function V (t, e, r) {\r\n    var a,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c,\r\n      l,\r\n      u,\r\n      d = r.namespace,\r\n      f = e.processed[d + '_ticks'].length,\r\n      p = ((a = e),\r\n      (o = (n = r).namespace),\r\n      (i = n.position),\r\n      (s = a.processed[o + '_ticks'].length),\r\n      (c = a.processed[o + '_ticks']),\r\n      (l = a.scales[o.toUpperCase()]),\r\n      (u = {}),\r\n      'left' === i && ((u.x1 = G(a)), (u.x2 = G(a)), (u.y1 = l(c[0]).toFixed(2)), (u.y2 = l(c[s - 1]).toFixed(2))),\r\n      'right' === i && ((u.x1 = A(a)), (u.x2 = A(a)), (u.y1 = l(c[0]).toFixed(2)), (u.y2 = l(c[s - 1]).toFixed(2))),\r\n      'top' === i && ((u.x1 = G(a)), (u.x2 = A(a)), (u.y1 = M(a)), (u.y2 = M(a))),\r\n      'bottom' === i && ((u.x1 = G(a)), (u.x2 = A(a)), (u.y1 = w(a)), (u.y2 = w(a))),\r\n      ('left' !== i && 'right' !== i) ||\r\n        (a.axes_not_compact\r\n          ? ((u.y1 = w(a)), (u.y2 = M(a)))\r\n          : s && ((u.y1 = l(c[0]).toFixed(2)), (u.y2 = l(c[s - 1]).toFixed(2)))),\r\n      u)\r\n    e[d + '_extended_ticks'] ||\r\n      e[d + '_extended_ticks'] ||\r\n      !f ||\r\n      t\r\n        .append('line')\r\n        .attr('x1', p.x1)\r\n        .attr('x2', p.x2)\r\n        .attr('y1', p.y1)\r\n        .attr('y2', p.y2)\r\n  }\r\n  function W (t, e) {\r\n    t.rug_buffer_size = 'point' === t.chart_type ? t.buffer / 2 : (2 * t.buffer) / 3\r\n    var r,\r\n      a,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c,\r\n      l,\r\n      u,\r\n      d,\r\n      f = ((r = t),\r\n      (a = 'mg-' + e.namespace + '-rug'),\r\n      (n = O(r.target)),\r\n      (o = h(r.data)),\r\n      (i = n.selectAll('line.' + a).data(o))\r\n        .enter()\r\n        .append('svg:line')\r\n        .attr('class', a)\r\n        .attr('opacity', 0.3),\r\n      _(i),\r\n      _(i),\r\n      i),\r\n      p = ((s = t),\r\n      (l = (c = e).position),\r\n      (u = c.namespace),\r\n      (d = {}),\r\n      'left' === l &&\r\n        ((d.x1 = G(s) + 1),\r\n        (d.x2 = G(s) + s.rug_buffer_size),\r\n        (d.y1 = s.scalefns[u + 'f']),\r\n        (d.y2 = s.scalefns[u + 'f'])),\r\n      'right' === l &&\r\n        ((d.x1 = A(s) - 1),\r\n        (d.x2 = A(s) - s.rug_buffer_size),\r\n        (d.y1 = s.scalefns[u + 'f']),\r\n        (d.y2 = s.scalefns[u + 'f'])),\r\n      'top' === l &&\r\n        ((d.x1 = s.scalefns[u + 'f']),\r\n        (d.x2 = s.scalefns[u + 'f']),\r\n        (d.y1 = M(s) + 1),\r\n        (d.y2 = M(s) + s.rug_buffer_size)),\r\n      'bottom' === l &&\r\n        ((d.x1 = s.scalefns[u + 'f']),\r\n        (d.x2 = s.scalefns[u + 'f']),\r\n        (d.y1 = w(s) - 1),\r\n        (d.y2 = w(s) - s.rug_buffer_size)),\r\n      d)\r\n    f\r\n      .attr('x1', p.x1)\r\n      .attr('x2', p.x2)\r\n      .attr('y1', p.y1)\r\n      .attr('y2', p.y2),\r\n      m(f, t, 'mg-' + e.namespace + '-rug-mono')\r\n  }\r\n  function Q (p, _) {\r\n    var m = _.namespace,\r\n      t = 'mg-' + m + '-axis',\r\n      g = p.scales[m.toUpperCase()],\r\n      e = p.scales[(m + 'group').toUpperCase()],\r\n      h = m + 'group_accessor',\r\n      r = O(p.target)\r\n    D(r, '.' + t)\r\n    var x,\r\n      y = S(r, t)\r\n    ;(e.domain && e.domain() ? e.domain() : ['1']).forEach(function (t) {\r\n      var e,\r\n        r,\r\n        a,\r\n        n,\r\n        o,\r\n        i,\r\n        s,\r\n        c,\r\n        l,\r\n        u,\r\n        d = ((e = p),\r\n        (a = t),\r\n        (n = (r = _).namespace),\r\n        (o = r.position),\r\n        (i = e.scales[n.toUpperCase()]),\r\n        (s = e.scales[(n + 'group').toUpperCase()]),\r\n        (c = { cat: {}, group: {} }),\r\n        'left' === o &&\r\n          ((c.cat.x = Y(e) - e.buffer),\r\n          (c.cat.y = function (t) {\r\n            return s(a) + i(t) + i.bandwidth() / 2\r\n          }),\r\n          (c.cat.dy = '.35em'),\r\n          (c.cat.textAnchor = 'end'),\r\n          (c.group.x = Y(e) - e.buffer),\r\n          (c.group.y = s(a) + (s.bandwidth ? s.bandwidth() / 2 : 0)),\r\n          (c.group.dy = '.35em'),\r\n          (c.group.textAnchor = (e['rotate_' + n + '_labels'], 'end'))),\r\n        'right' === o &&\r\n          ((c.cat.x = P(e) - e.buffer),\r\n          (c.cat.y = function (t) {\r\n            return s(a) + i(t) + i.bandwidth() / 2\r\n          }),\r\n          (c.cat.dy = '.35em'),\r\n          (c.cat.textAnchor = 'start'),\r\n          (c.group.x = P(e) - e.buffer),\r\n          (c.group.y = s(a) + (s.bandwidth ? s.bandwidth() / 2 : 0)),\r\n          (c.group.dy = '.35em'),\r\n          (c.group.textAnchor = 'start')),\r\n        'top' === o &&\r\n          ((c.cat.x = function (t) {\r\n            return s(a) + i(t) + i.bandwidth() / 2\r\n          }),\r\n          (c.cat.y = b(e) + e.buffer),\r\n          (c.cat.dy = '.35em'),\r\n          (c.cat.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle'),\r\n          (c.group.x = s(a) + (s.bandwidth ? s.bandwidth() / 2 : 0)),\r\n          (c.group.y = b(e) + e.buffer),\r\n          (c.group.dy = '.35em'),\r\n          (c.group.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle')),\r\n        'bottom' === o &&\r\n          ((c.cat.x = function (t) {\r\n            return s(a) + i(t) + i.bandwidth() / 2\r\n          }),\r\n          (c.cat.y = v(e) + e.buffer),\r\n          (c.cat.dy = '.35em'),\r\n          (c.cat.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle'),\r\n          (c.group.x = s(a) + (s.bandwidth ? s.bandwidth() / 2 - i.bandwidth() / 2 : 0)),\r\n          (c.group.y = v(e) + e.buffer),\r\n          (c.group.dy = '.35em'),\r\n          (c.group.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle')),\r\n        c)\r\n      if (((x = S(y, 'mg-group-' + F(t))), null !== p[h]))\r\n        var f = x\r\n          .append('text')\r\n          .classed('mg-barplot-group-label', !0)\r\n          .attr('x', d.group.x)\r\n          .attr('y', d.group.y)\r\n          .attr('dy', d.group.dy)\r\n          .attr('text-anchor', d.group.textAnchor)\r\n          .text(t)\r\n      else\r\n        f = x\r\n          .selectAll('text')\r\n          .data(g.domain())\r\n          .enter()\r\n          .append('text')\r\n          .attr('x', d.cat.x)\r\n          .attr('y', d.cat.y)\r\n          .attr('dy', d.cat.dy)\r\n          .attr('text-anchor', d.cat.textAnchor)\r\n          .text(String)\r\n      p['rotate_' + m + '_labels'] &&\r\n        ((l = f),\r\n        (u = p['rotate_' + m + '_labels']) &&\r\n          l.attr('transform', function () {\r\n            var t = E.select(this)\r\n            return 'rotate(' + u + ' ' + t.attr('x') + ',' + t.attr('y') + ')'\r\n          }))\r\n    })\r\n  }\r\n  ;(MG.merge_with_defaults = p),\r\n    (MG.clone = function (t) {\r\n      var e, r\r\n      if (null === t || 'object' !== (void 0 === t ? 'undefined' : c(t))) return t\r\n      if (x(t)) return (e = new Date()).setTime(t.getTime()), e\r\n      if (y(t)) {\r\n        e = []\r\n        for (var a = 0, n = t.length; a < n; a++) e[a] = MG.clone(t[a])\r\n        return e\r\n      }\r\n      if (((r = t), '[object Object]' === Object.prototype.toString.call(r))) {\r\n        for (var o in ((e = {}), t)) t.hasOwnProperty(o) && (e[o] = MG.clone(t[o]))\r\n        return e\r\n      }\r\n      throw new Error(\"Unable to copy obj! Its type isn't supported.\")\r\n    }),\r\n    (MG.arr_diff = T),\r\n    (MG.warn_deprecation = R),\r\n    (MG.truncate_text = L),\r\n    (MG.wrap_text = function (t, i, s, c) {\r\n      t.each(function () {\r\n        for (\r\n          var t,\r\n            e = E.select(this),\r\n            r = e\r\n              .text()\r\n              .split(s || /\\s+/)\r\n              .reverse(),\r\n            a = [],\r\n            n = 0,\r\n            o = (e.attr('y'),\r\n            e\r\n              .text(null)\r\n              .append('tspan')\r\n              .attr('x', 0)\r\n              .attr('y', '0em')\r\n              .attr(c || {}));\r\n          (t = r.pop());\r\n\r\n        )\r\n          a.push(t),\r\n            o.text(a.join(' ')),\r\n            (null === i || o.node().getComputedTextLength() > i) &&\r\n              (a.pop(),\r\n              o.text(a.join(' ')),\r\n              (a = [t]),\r\n              (o = e\r\n                .append('tspan')\r\n                .attr('x', 0)\r\n                .attr('y', 1.1 * ++n + 0 + 'em')\r\n                .attr(c || {})\r\n                .text(t)))\r\n      })\r\n    }),\r\n    (MG.register = function (t, e, r) {\r\n      MG.charts[t] = { descriptor: e, defaults: r || {} }\r\n    }),\r\n    (MG._hooks = {}),\r\n    (MG.add_hook = function (t, e, r) {\r\n      var a\r\n      if (\r\n        (MG._hooks[t] || (MG._hooks[t] = []),\r\n        0 <\r\n          (a = MG._hooks[t]).filter(function (t) {\r\n            return t.func === e\r\n          }).length)\r\n      )\r\n        throw 'That function is already registered.'\r\n      a.push({ func: e, context: r })\r\n    }),\r\n    (MG.call_hook = function (t) {\r\n      var r,\r\n        e = MG._hooks[t],\r\n        a = [].slice.apply(arguments, [1])\r\n      return (\r\n        e &&\r\n          e.forEach(function (t) {\r\n            if (t.func) {\r\n              var e = r || a\r\n              e && e.constructor !== Array && (e = [e]), (e = [].concat.apply([], e)), (r = t.func.apply(t.context, e))\r\n            }\r\n          }),\r\n        r || a\r\n      )\r\n    }),\r\n    (MG.globals = {}),\r\n    (MG.deprecations = {\r\n      rollover_callback: { replacement: 'mouseover', version: '2.0' },\r\n      rollout_callback: { replacement: 'mouseout', version: '2.0' },\r\n      x_rollover_format: { replacement: 'x_mouseover', version: '2.10' },\r\n      y_rollover_format: { replacement: 'y_mouseover', version: '2.10' },\r\n      show_years: { replacement: 'show_secondary_x_label', version: '2.1' },\r\n      xax_start_at_min: { replacement: 'axes_not_compact', version: '2.7' },\r\n      interpolate_tension: { replacement: 'interpolate', version: '2.10' }\r\n    }),\r\n    (MG.globals.link = !1),\r\n    (MG.globals.version = '1.1'),\r\n    (MG.charts = {}),\r\n    (MG.data_graphic = function (t) {\r\n      var e = {\r\n        missing_is_zero: !1,\r\n        missing_is_hidden: !1,\r\n        missing_is_hidden_accessor: null,\r\n        legend: '',\r\n        legend_target: '',\r\n        error: '',\r\n        animate_on_load: !1,\r\n        top: 65,\r\n        title_y_position: 10,\r\n        center_title_full_width: !1,\r\n        bottom: 45,\r\n        right: 10,\r\n        left: 50,\r\n        buffer: 8,\r\n        width: 350,\r\n        height: 220,\r\n        full_width: !1,\r\n        full_height: !1,\r\n        small_height_threshold: 120,\r\n        small_width_threshold: 160,\r\n        xax_count: 6,\r\n        xax_tick_length: 5,\r\n        axes_not_compact: !0,\r\n        yax_count: 3,\r\n        yax_tick_length: 5,\r\n        x_extended_ticks: !1,\r\n        y_extended_ticks: !1,\r\n        y_scale_type: 'linear',\r\n        max_x: null,\r\n        max_y: null,\r\n        min_x: null,\r\n        min_y: null,\r\n        min_y_from_data: !1,\r\n        point_size: 2.5,\r\n        active_point_on_lines: !1,\r\n        active_point_accessor: 'active',\r\n        active_point_size: 2,\r\n        points_always_visible: !1,\r\n        x_accessor: 'date',\r\n        xax_units: '',\r\n        x_label: '',\r\n        x_sort: !0,\r\n        x_axis: !0,\r\n        y_axis: !0,\r\n        x_axis_position: 'bottom',\r\n        y_axis_position: 'left',\r\n        x_axis_type: null,\r\n        y_axis_type: null,\r\n        ygroup_accessor: null,\r\n        xgroup_accessor: null,\r\n        y_padding_percentage: 0.05,\r\n        y_outer_padding_percentage: 0.1,\r\n        ygroup_padding_percentage: 0.25,\r\n        ygroup_outer_padding_percentage: 0,\r\n        x_padding_percentage: 0.05,\r\n        x_outer_padding_percentage: 0.1,\r\n        xgroup_padding_percentage: 0.25,\r\n        xgroup_outer_padding_percentage: 0,\r\n        y_categorical_show_guides: !1,\r\n        x_categorical_show_guide: !1,\r\n        rotate_x_labels: 0,\r\n        rotate_y_labels: 0,\r\n        y_accessor: 'value',\r\n        y_label: '',\r\n        yax_units: '',\r\n        yax_units_append: !1,\r\n        x_rug: !1,\r\n        y_rug: !1,\r\n        mouseover_align: 'right',\r\n        x_mouseover: null,\r\n        y_mouseover: null,\r\n        transition_on_update: !0,\r\n        mouseover: null,\r\n        click: null,\r\n        show_rollover_text: !0,\r\n        show_confidence_band: null,\r\n        xax_format: null,\r\n        area: !0,\r\n        flip_area_under_y_value: null,\r\n        chart_type: 'line',\r\n        data: [],\r\n        decimals: 2,\r\n        format: 'count',\r\n        inflator: 10 / 9,\r\n        linked: !1,\r\n        linked_format: '%Y-%m-%d',\r\n        list: !1,\r\n        baselines: null,\r\n        markers: null,\r\n        scalefns: {},\r\n        scales: {},\r\n        utc_time: !1,\r\n        european_clock: !1,\r\n        show_year_markers: !1,\r\n        show_secondary_x_label: !0,\r\n        target: '#viz',\r\n        interpolate: E.curveCatmullRom.alpha(0),\r\n        custom_line_color_map: [],\r\n        colors: null,\r\n        max_data_size: null,\r\n        aggregate_rollover: !1,\r\n        show_tooltips: !0,\r\n        showActivePoint: !0,\r\n        brush: null,\r\n        zoom_target: null,\r\n        brushing_selection_changed: null\r\n      }\r\n      MG.call_hook('global.defaults', e), t || (t = {})\r\n      var r = MG.charts[t.chart_type || e.chart_type]\r\n      for (var a in (p(t, r.defaults, e), t.list && ((t.x_accessor = 0), (t.y_accessor = 1)), MG.deprecations))\r\n        if (t.hasOwnProperty(a)) {\r\n          var n = MG.deprecations[a],\r\n            o = 'Use of `args.' + a + '` has been deprecated',\r\n            i = n.replacement\r\n          if (\r\n            (i &&\r\n              (t[i]\r\n                ? (o +=\r\n                    '. The replacement - `args.' +\r\n                    i +\r\n                    '` - has already been defined. This definition will be discarded.')\r\n                : (t[i] = t[a])),\r\n            n.warned)\r\n          )\r\n            continue\r\n          ;(n.warned = !0), i && (o += ' in favor of `args.' + i + '`'), R(o, n.version)\r\n        }\r\n      return MG.call_hook('global.before_init', t), new r.descriptor(t), t.data\r\n    }),\r\n    k() &&\r\n      ((function (m) {\r\n        var g = function (t, e) {\r\n          ;(this.type = null),\r\n            (this.options = null),\r\n            (this.enabled = null),\r\n            (this.timeout = null),\r\n            (this.hoverState = null),\r\n            (this.$element = null),\r\n            (this.inState = null),\r\n            this.init('tooltip', t, e)\r\n        }\r\n        ;(g.VERSION = '3.3.5'),\r\n          (g.TRANSITION_DURATION = 150),\r\n          (g.DEFAULTS = {\r\n            animation: !0,\r\n            placement: 'top',\r\n            selector: !1,\r\n            template:\r\n              '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\r\n            trigger: 'hover focus',\r\n            title: '',\r\n            delay: 0,\r\n            html: !1,\r\n            container: !1,\r\n            viewport: { selector: 'body', padding: 0 }\r\n          }),\r\n          (g.prototype.init = function (t, e, r) {\r\n            if (\r\n              ((this.enabled = !0),\r\n              (this.type = t),\r\n              (this.$element = m(e)),\r\n              (this.options = this.getOptions(r)),\r\n              (this.$viewport =\r\n                this.options.viewport &&\r\n                m(\r\n                  m.isFunction(this.options.viewport)\r\n                    ? this.options.viewport.call(this, this.$element)\r\n                    : this.options.viewport.selector || this.options.viewport\r\n                )),\r\n              (this.inState = { click: !1, hover: !1, focus: !1 }),\r\n              this.$element[0] instanceof document.constructor && !this.options.selector)\r\n            )\r\n              throw new Error(\r\n                '`selector` option must be specified when initializing ' + this.type + ' on the window.document object!'\r\n              )\r\n            for (var a = this.options.trigger.split(' '), n = a.length; n--; ) {\r\n              var o = a[n]\r\n              if ('click' == o)\r\n                this.$element.on('click.' + this.type, this.options.selector, m.proxy(this.toggle, this))\r\n              else if ('manual' != o) {\r\n                var i = 'hover' == o ? 'mouseenter' : 'focusin',\r\n                  s = 'hover' == o ? 'mouseleave' : 'focusout'\r\n                this.$element.on(i + '.' + this.type, this.options.selector, m.proxy(this.enter, this)),\r\n                  this.$element.on(s + '.' + this.type, this.options.selector, m.proxy(this.leave, this))\r\n              }\r\n            }\r\n            this.options.selector\r\n              ? (this._options = m.extend({}, this.options, { trigger: 'manual', selector: '' }))\r\n              : this.fixTitle()\r\n          }),\r\n          (g.prototype.getDefaults = function () {\r\n            return g.DEFAULTS\r\n          }),\r\n          (g.prototype.getOptions = function (t) {\r\n            return (\r\n              (t = m.extend({}, this.getDefaults(), this.$element.data(), t)).delay &&\r\n                'number' == typeof t.delay &&\r\n                (t.delay = { show: t.delay, hide: t.delay }),\r\n              t\r\n            )\r\n          }),\r\n          (g.prototype.getDelegateOptions = function () {\r\n            var r = {},\r\n              a = this.getDefaults()\r\n            return (\r\n              this._options &&\r\n                m.each(this._options, function (t, e) {\r\n                  a[t] != e && (r[t] = e)\r\n                }),\r\n              r\r\n            )\r\n          }),\r\n          (g.prototype.enter = function (t) {\r\n            var e = t instanceof this.constructor ? t : m(t.currentTarget).data('bs.' + this.type)\r\n            if (\r\n              (e ||\r\n                ((e = new this.constructor(t.currentTarget, this.getDelegateOptions())),\r\n                m(t.currentTarget).data('bs.' + this.type, e)),\r\n              t instanceof m.Event && (e.inState['focusin' == t.type ? 'focus' : 'hover'] = !0),\r\n              e.tip().hasClass('in') || 'in' == e.hoverState)\r\n            )\r\n              e.hoverState = 'in'\r\n            else {\r\n              if ((clearTimeout(e.timeout), (e.hoverState = 'in'), !e.options.delay || !e.options.delay.show))\r\n                return e.show()\r\n              e.timeout = setTimeout(function () {\r\n                'in' == e.hoverState && e.show()\r\n              }, e.options.delay.show)\r\n            }\r\n          }),\r\n          (g.prototype.isInStateTrue = function () {\r\n            for (var t in this.inState) if (this.inState[t]) return !0\r\n            return !1\r\n          }),\r\n          (g.prototype.leave = function (t) {\r\n            var e = t instanceof this.constructor ? t : m(t.currentTarget).data('bs.' + this.type)\r\n            if (\r\n              (e ||\r\n                ((e = new this.constructor(t.currentTarget, this.getDelegateOptions())),\r\n                m(t.currentTarget).data('bs.' + this.type, e)),\r\n              t instanceof m.Event && (e.inState['focusout' == t.type ? 'focus' : 'hover'] = !1),\r\n              !e.isInStateTrue())\r\n            ) {\r\n              if ((clearTimeout(e.timeout), (e.hoverState = 'out'), !e.options.delay || !e.options.delay.hide))\r\n                return e.hide()\r\n              e.timeout = setTimeout(function () {\r\n                'out' == e.hoverState && e.hide()\r\n              }, e.options.delay.hide)\r\n            }\r\n          }),\r\n          (g.prototype.show = function () {\r\n            var t = m.Event('show.bs.' + this.type)\r\n            if (this.hasContent() && this.enabled) {\r\n              this.$element.trigger(t)\r\n              var e = m.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\r\n              if (t.isDefaultPrevented() || !e) return\r\n              var r = this,\r\n                a = this.tip(),\r\n                n = this.getUID(this.type)\r\n              this.setContent(),\r\n                a.attr('id', n),\r\n                this.$element.attr('aria-describedby', n),\r\n                this.options.animation && a.addClass('fade')\r\n              var o =\r\n                  'function' == typeof this.options.placement\r\n                    ? this.options.placement.call(this, a[0], this.$element[0])\r\n                    : this.options.placement,\r\n                i = /\\s?auto?\\s?/i,\r\n                s = i.test(o)\r\n              s && (o = o.replace(i, '') || 'top'),\r\n                a\r\n                  .detach()\r\n                  .css({ top: 0, left: 0, display: 'block' })\r\n                  .addClass(o)\r\n                  .data('bs.' + this.type, this),\r\n                this.options.container ? a.appendTo(this.options.container) : a.insertAfter(this.$element),\r\n                this.$element.trigger('inserted.bs.' + this.type)\r\n              var c = this.getPosition(),\r\n                l = a[0].offsetWidth,\r\n                u = a[0].offsetHeight\r\n              if (s) {\r\n                var d = o,\r\n                  f = this.getPosition(this.$viewport)\r\n                ;(o =\r\n                  'bottom' == o && c.bottom + u > f.bottom\r\n                    ? 'top'\r\n                    : 'top' == o && c.top - u < f.top\r\n                    ? 'bottom'\r\n                    : 'right' == o && c.right + l > f.width\r\n                    ? 'left'\r\n                    : 'left' == o && c.left - l < f.left\r\n                    ? 'right'\r\n                    : o),\r\n                  a.removeClass(d).addClass(o)\r\n              }\r\n              var p = this.getCalculatedOffset(o, c, l, u)\r\n              this.applyPlacement(p, o)\r\n              var _ = function () {\r\n                var t = r.hoverState\r\n                r.$element.trigger('shown.bs.' + r.type), (r.hoverState = null), 'out' == t && r.leave(r)\r\n              }\r\n              m.support.transition && this.$tip.hasClass('fade')\r\n                ? a.one('bsTransitionEnd', _).emulateTransitionEnd(g.TRANSITION_DURATION)\r\n                : _()\r\n            }\r\n          }),\r\n          (g.prototype.applyPlacement = function (t, e) {\r\n            var r = this.tip(),\r\n              a = r[0].offsetWidth,\r\n              n = r[0].offsetHeight,\r\n              o = parseInt(r.css('margin-top'), 10),\r\n              i = parseInt(r.css('margin-left'), 10)\r\n            isNaN(o) && (o = 0),\r\n              isNaN(i) && (i = 0),\r\n              (t.top += o),\r\n              (t.left += i),\r\n              m.offset.setOffset(\r\n                r[0],\r\n                m.extend(\r\n                  {\r\n                    using: function (t) {\r\n                      r.css({ top: Math.round(t.top), left: Math.round(t.left) })\r\n                    }\r\n                  },\r\n                  t\r\n                ),\r\n                0\r\n              ),\r\n              r.addClass('in')\r\n            var s = r[0].offsetWidth,\r\n              c = r[0].offsetHeight\r\n            'top' == e && c != n && (t.top = t.top + n - c)\r\n            var l = this.getViewportAdjustedDelta(e, t, s, c)\r\n            l.left ? (t.left += l.left) : (t.top += l.top)\r\n            var u = /top|bottom/.test(e),\r\n              d = u ? 2 * l.left - a + s : 2 * l.top - n + c,\r\n              f = u ? 'offsetWidth' : 'offsetHeight'\r\n            r.offset(t), this.replaceArrow(d, r[0][f], u)\r\n          }),\r\n          (g.prototype.replaceArrow = function (t, e, r) {\r\n            this.arrow()\r\n              .css(r ? 'left' : 'top', 50 * (1 - t / e) + '%')\r\n              .css(r ? 'top' : 'left', '')\r\n          }),\r\n          (g.prototype.setContent = function () {\r\n            var t = this.tip(),\r\n              e = this.getTitle()\r\n            t.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](e),\r\n              t.removeClass('fade in top bottom left right')\r\n          }),\r\n          (g.prototype.hide = function (t) {\r\n            var e = this,\r\n              r = m(this.$tip),\r\n              a = m.Event('hide.bs.' + this.type)\r\n            function n () {\r\n              'in' != e.hoverState && r.detach(),\r\n                e.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + e.type),\r\n                t && t()\r\n            }\r\n            if ((this.$element.trigger(a), !a.isDefaultPrevented()))\r\n              return (\r\n                r.removeClass('in'),\r\n                m.support.transition && r.hasClass('fade')\r\n                  ? r.one('bsTransitionEnd', n).emulateTransitionEnd(g.TRANSITION_DURATION)\r\n                  : n(),\r\n                (this.hoverState = null),\r\n                this\r\n              )\r\n          }),\r\n          (g.prototype.fixTitle = function () {\r\n            var t = this.$element\r\n            ;(t.attr('title') || 'string' != typeof t.attr('data-original-title')) &&\r\n              t.attr('data-original-title', t.attr('title') || '').attr('title', '')\r\n          }),\r\n          (g.prototype.hasContent = function () {\r\n            return this.getTitle()\r\n          }),\r\n          (g.prototype.getPosition = function (t) {\r\n            var e = (t = t || this.$element)[0],\r\n              r = 'BODY' == e.tagName,\r\n              a = e.getBoundingClientRect()\r\n            null == a.width && (a = m.extend({}, a, { width: a.right - a.left, height: a.bottom - a.top }))\r\n            var n = r ? { top: 0, left: 0 } : t.offset(),\r\n              o = { scroll: r ? document.documentElement.scrollTop || document.body.scrollTop : t.scrollTop() },\r\n              i = r ? { width: m(window).width(), height: m(window).height() } : null\r\n            return m.extend({}, a, o, i, n)\r\n          }),\r\n          (g.prototype.getCalculatedOffset = function (t, e, r, a) {\r\n            return 'bottom' == t\r\n              ? { top: e.top + e.height, left: e.left + e.width / 2 - r / 2 }\r\n              : 'top' == t\r\n              ? { top: e.top - a, left: e.left + e.width / 2 - r / 2 }\r\n              : 'left' == t\r\n              ? { top: e.top + e.height / 2 - a / 2, left: e.left - r }\r\n              : { top: e.top + e.height / 2 - a / 2, left: e.left + e.width }\r\n          }),\r\n          (g.prototype.getViewportAdjustedDelta = function (t, e, r, a) {\r\n            var n = { top: 0, left: 0 }\r\n            if (!this.$viewport) return n\r\n            var o = (this.options.viewport && this.options.viewport.padding) || 0,\r\n              i = this.getPosition(this.$viewport)\r\n            if (/right|left/.test(t)) {\r\n              var s = e.top - o - i.scroll,\r\n                c = e.top + o - i.scroll + a\r\n              s < i.top ? (n.top = i.top - s) : c > i.top + i.height && (n.top = i.top + i.height - c)\r\n            } else {\r\n              var l = e.left - o,\r\n                u = e.left + o + r\r\n              l < i.left ? (n.left = i.left - l) : u > i.right && (n.left = i.left + i.width - u)\r\n            }\r\n            return n\r\n          }),\r\n          (g.prototype.getTitle = function () {\r\n            var t = this.$element,\r\n              e = this.options\r\n            return t.attr('data-original-title') || ('function' == typeof e.title ? e.title.call(t[0]) : e.title)\r\n          }),\r\n          (g.prototype.getUID = function (t) {\r\n            for (; (t += ~~(1e6 * Math.random())), document.getElementById(t); );\r\n            return t\r\n          }),\r\n          (g.prototype.tip = function () {\r\n            if (!this.$tip && ((this.$tip = m(this.options.template)), 1 != this.$tip.length))\r\n              throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\r\n            return this.$tip\r\n          }),\r\n          (g.prototype.arrow = function () {\r\n            return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\r\n          }),\r\n          (g.prototype.enable = function () {\r\n            this.enabled = !0\r\n          }),\r\n          (g.prototype.disable = function () {\r\n            this.enabled = !1\r\n          }),\r\n          (g.prototype.toggleEnabled = function () {\r\n            this.enabled = !this.enabled\r\n          }),\r\n          (g.prototype.toggle = function (t) {\r\n            var e = this\r\n            t &&\r\n              ((e = m(t.currentTarget).data('bs.' + this.type)) ||\r\n                ((e = new this.constructor(t.currentTarget, this.getDelegateOptions())),\r\n                m(t.currentTarget).data('bs.' + this.type, e))),\r\n              t\r\n                ? ((e.inState.click = !e.inState.click), e.isInStateTrue() ? e.enter(e) : e.leave(e))\r\n                : e.tip().hasClass('in')\r\n                ? e.leave(e)\r\n                : e.enter(e)\r\n          }),\r\n          (g.prototype.destroy = function () {\r\n            var t = this\r\n            clearTimeout(this.timeout),\r\n              this.hide(function () {\r\n                t.$element.off('.' + t.type).removeData('bs.' + t.type),\r\n                  t.$tip && t.$tip.detach(),\r\n                  (t.$tip = null),\r\n                  (t.$arrow = null),\r\n                  (t.$viewport = null)\r\n              })\r\n          })\r\n        var t = m.fn.tooltip\r\n        ;(m.fn.tooltip = function (a) {\r\n          return this.each(function () {\r\n            var t = m(this),\r\n              e = t.data('bs.tooltip'),\r\n              r = 'object' == (void 0 === a ? 'undefined' : c(a)) && a\r\n            ;(!e && /destroy|hide/.test(a)) ||\r\n              (e || t.data('bs.tooltip', (e = new g(this, r))), 'string' == typeof a && e[a]())\r\n          })\r\n        }),\r\n          (m.fn.tooltip.Constructor = g),\r\n          (m.fn.tooltip.noConflict = function () {\r\n            return (m.fn.tooltip = t), this\r\n          })\r\n      })(jQuery),\r\n      (function (n) {\r\n        var o = function (t, e) {\r\n          this.init('popover', t, e)\r\n        }\r\n        if (!n.fn.tooltip) throw new Error('Popover requires tooltip.js')\r\n        ;(o.VERSION = '3.3.5'),\r\n          (o.DEFAULTS = n.extend({}, n.fn.tooltip.Constructor.DEFAULTS, {\r\n            placement: 'right',\r\n            trigger: 'click',\r\n            content: '',\r\n            template:\r\n              '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\r\n          })),\r\n          (((o.prototype = n.extend(\r\n            {},\r\n            n.fn.tooltip.Constructor.prototype\r\n          )).constructor = o).prototype.getDefaults = function () {\r\n            return o.DEFAULTS\r\n          }),\r\n          (o.prototype.setContent = function () {\r\n            var t = this.tip(),\r\n              e = this.getTitle(),\r\n              r = this.getContent()\r\n            t.find('.popover-title')[this.options.html ? 'html' : 'text'](e),\r\n              t\r\n                .find('.popover-content')\r\n                .children()\r\n                .detach()\r\n                .end()\r\n                [this.options.html ? ('string' == typeof r ? 'html' : 'append') : 'text'](r),\r\n              t.removeClass('fade top bottom left right in'),\r\n              t.find('.popover-title').html() || t.find('.popover-title').hide()\r\n          }),\r\n          (o.prototype.hasContent = function () {\r\n            return this.getTitle() || this.getContent()\r\n          }),\r\n          (o.prototype.getContent = function () {\r\n            var t = this.$element,\r\n              e = this.options\r\n            return t.attr('data-content') || ('function' == typeof e.content ? e.content.call(t[0]) : e.content)\r\n          }),\r\n          (o.prototype.arrow = function () {\r\n            return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\r\n          })\r\n        var t = n.fn.popover\r\n        ;(n.fn.popover = function (a) {\r\n          return this.each(function () {\r\n            var t = n(this),\r\n              e = t.data('bs.popover'),\r\n              r = 'object' == (void 0 === a ? 'undefined' : c(a)) && a\r\n            ;(!e && /destroy|hide/.test(a)) ||\r\n              (e || t.data('bs.popover', (e = new o(this, r))), 'string' == typeof a && e[a]())\r\n          })\r\n        }),\r\n          (n.fn.popover.Constructor = o),\r\n          (n.fn.popover.noConflict = function () {\r\n            return (n.fn.popover = t), this\r\n          })\r\n      })(jQuery)),\r\n    (MG.chart_title = j),\r\n    (MG.scale_factory = function (o) {\r\n      var i = { use_inflator: !1, zero_bottom: !1, scaleType: 'numerical' }\r\n      return (\r\n        (this.namespace = function (t) {\r\n          return (\r\n            (i.namespace = t),\r\n            (i.namespace_accessor_name = i.namespace + '_accessor'),\r\n            (i.scale_name = i.namespace.toUpperCase()),\r\n            (i.scalefn_name = i.namespace + 'f'),\r\n            this\r\n          )\r\n        }),\r\n        (this.scaleName = function (t) {\r\n          return (i.scale_name = t.toUpperCase()), (i.scalefn_name = t + 'f'), this\r\n        }),\r\n        (this.inflateDomain = function (t) {\r\n          return (i.use_inflator = t), this\r\n        }),\r\n        (this.zeroBottom = function (t) {\r\n          return (i.zero_bottom = t), this\r\n        }),\r\n        (this.numericalDomainFromData = function () {\r\n          var t,\r\n            e = []\r\n          0 < arguments.length && (e = arguments)\r\n          for (var r = 0; r < o.data.length; r++) 0 < o.data[r].length && (t = o.data[r])\r\n          ;(i.is_time_series = !!x(t[0][o[i.namespace_accessor_name]])),\r\n            X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]),\r\n            (function (t, e, r) {\r\n              var a = e.namespace,\r\n                n = e.namespace_accessor_name,\r\n                o = e.use_inflator,\r\n                i = e.zero_bottom,\r\n                s = t[n],\r\n                c = h(t.data)\r\n                  .map(function (t) {\r\n                    return t[s]\r\n                  })\r\n                  .concat(h(r))\r\n              'log' === t[a + '_scale_type'] &&\r\n                (c = c.filter(function (t) {\r\n                  return 0 < t\r\n                }))\r\n              var l = E.extent(c),\r\n                u = l[0],\r\n                d = l[1]\r\n              i &&\r\n                !t['min_' + a + '_from_data'] &&\r\n                0 < u &&\r\n                !e.is_time_series &&\r\n                (u = 'log' === t[a + '_scale_type'] ? 1 : 0),\r\n                'log' !== t[a + '_scale_type'] && u < 0 && !e.is_time_series && (u -= (u - u * t.inflator) * o),\r\n                e.is_time_series || (d = d < 0 ? d + (d - d * t.inflator) * o : d * (o ? t.inflator : 1)),\r\n                (u = null != t['min_' + a] ? t['min_' + a] : u),\r\n                (d = null != t['max_' + a] ? t['max_' + a] : d),\r\n                u === d &&\r\n                  null == t['min_' + a] &&\r\n                  null == t['max_' + a] &&\r\n                  (x(u)\r\n                    ? (d = new Date(MG.clone(u).setDate(u.getDate() + 1)))\r\n                    : 'number' == typeof u && ((d = u + 1), (t.xax_count = 2))),\r\n                (t.processed['min_' + a] = u),\r\n                (t.processed['max_' + a] = d),\r\n                t.processed['zoom_' + a] &&\r\n                  ((t.processed['min_' + a] = t.processed['zoom_' + a][0]),\r\n                  (t.processed['max_' + a] = t.processed['zoom_' + a][1])),\r\n                MG.call_hook('x_axis.process_min_max', t, t.processed.min_x, t.processed.max_x),\r\n                MG.call_hook('y_axis.process_min_max', t, t.processed.min_y, t.processed.max_y)\r\n            })(o, i, e, i.use_inflator)\r\n          var a = o.utc_time ? E.scaleUtc() : E.scaleTime()\r\n          return (\r\n            (o.scales[i.scale_name] = i.is_time_series\r\n              ? a\r\n              : C(o[i.namespace + '_scale_type'])\r\n              ? o.y_scale_type()\r\n              : 'log' === o[i.namespace + '_scale_type']\r\n              ? E.scaleLog()\r\n              : E.scaleLinear()),\r\n            o.scales[i.scale_name].domain([o.processed['min_' + i.namespace], o.processed['max_' + i.namespace]]),\r\n            (i.scaleType = 'numerical'),\r\n            this\r\n          )\r\n        }),\r\n        (this.categoricalDomain = function (t) {\r\n          return (\r\n            (o.scales[i.scale_name] = E.scaleOrdinal().domain(t)),\r\n            X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]),\r\n            this\r\n          )\r\n        }),\r\n        (this.categoricalDomainFromData = function () {\r\n          var t = h(o.data)\r\n          return (\r\n            (i.categoricalVariables = E.set(\r\n              t.map(function (t) {\r\n                return t[o[i.namespace_accessor_name]]\r\n              })\r\n            ).values()),\r\n            (o.scales[i.scale_name] = E.scaleBand().domain(i.categoricalVariables)),\r\n            (i.scaleType = 'categorical'),\r\n            this\r\n          )\r\n        }),\r\n        (this.numericalRange = function (t) {\r\n          return 'string' == typeof t ? o.scales[i.scale_name].range(U(t, o)) : o.scales[i.scale_name].range(t), this\r\n        }),\r\n        (this.categoricalRangeBands = function (t, e) {\r\n          void 0 === e && (e = !1)\r\n          var r = i.namespace,\r\n            a = o[r + '_padding_percentage'],\r\n            n = o[r + '_outer_padding_percentage']\r\n          return (\r\n            'string' == typeof t\r\n              ? o.scales[i.scale_name]\r\n                  .range(U(t, o))\r\n                  .paddingInner(a)\r\n                  .paddingOuter(n)\r\n              : o.scales[i.scale_name]\r\n                  .range(t)\r\n                  .paddingInner(a)\r\n                  .paddingOuter(n),\r\n            X(\r\n              o,\r\n              i.scalefn_name,\r\n              i.scale_name,\r\n              o[i.namespace_accessor_name],\r\n              e ? o.scales[i.scale_name].bandwidth() / 2 : 0\r\n            ),\r\n            this\r\n          )\r\n        }),\r\n        (this.categoricalRange = function (t) {\r\n          return o.scales[i.scale_name].range(t), X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]), this\r\n        }),\r\n        (this.categoricalColorRange = function () {\r\n          return (\r\n            (o.scales[i.scale_name] =\r\n              10 < o.scales[i.scale_name].domain().length\r\n                ? E.scaleOrdinal(E.schemeCategory20)\r\n                : E.scaleOrdinal(E.schemeCategory10)),\r\n            o.scales[i.scale_name].domain(i.categoricalVariables),\r\n            X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]),\r\n            this\r\n          )\r\n        }),\r\n        (this.clamp = function (t) {\r\n          return o.scales[i.scale_name].clamp(t), this\r\n        }),\r\n        this\r\n      )\r\n    })\r\n  var Z = {}\r\n  function K (t) {\r\n    if (t.y_rug) {\r\n      t.rug_buffer_size = 'point' === t.chart_type ? t.buffer / 2 : (2 * t.buffer) / 3\r\n      var e = r(t, 'mg-y-rug')\r\n      e\r\n        .attr('x1', t.left + 1)\r\n        .attr('x2', t.left + t.rug_buffer_size)\r\n        .attr('y1', t.scalefns.yf)\r\n        .attr('y2', t.scalefns.yf),\r\n        m(e, t, 'mg-y-rug-mono')\r\n    }\r\n  }\r\n  function J (r) {\r\n    var t = r.yax_format\r\n    if (!t) {\r\n      var a = r.decimals\r\n      'count' === r.format\r\n        ? (1 < r.processed.y_ticks.length &&\r\n            (a = Math.max(\r\n              0,\r\n              -Math.floor(Math.log(Math.abs(r.processed.y_ticks[1] - r.processed.y_ticks[0])) / Math.LN10)\r\n            )),\r\n          (t = function (t) {\r\n            var e\r\n            return (\r\n              (e = 0 !== a ? E.format(',.' + a + 'f') : t < 1e3 ? E.format(',.0f') : E.format(',.2s')),\r\n              r.yax_units_append ? e(t) + r.yax_units : r.yax_units + e(t)\r\n            )\r\n          }))\r\n        : (t = function (t) {\r\n            return E.format('.0%')(t)\r\n          })\r\n    }\r\n    return t\r\n  }\r\n  function tt (t) {\r\n    var e = O(t.target),\r\n      r = t.scales.X.domain()\r\n    if (r[0] <= 0 && 0 <= r[1]) {\r\n      var a = t.scales.Y.range(),\r\n        n = t.categorical_groups.length\r\n          ? t.scales.YGROUP(t.categorical_groups[t.categorical_groups.length - 1])\r\n          : t.scales.YGROUP()\r\n      e.append('svg:line')\r\n        .attr('x1', t.scales.X(0))\r\n        .attr('x2', t.scales.X(0))\r\n        .attr('y1', a[0] + b(t))\r\n        .attr('y2', a[a.length - 1] + n)\r\n        .attr('stroke', 'black')\r\n        .attr('opacity', 0.2)\r\n    }\r\n  }\r\n  function et (t, e) {\r\n    e.y_label &&\r\n      t\r\n        .append('text')\r\n        .attr('class', 'label')\r\n        .attr('x', function () {\r\n          return -1 * (b(e) + (v(e) - b(e)) / 2)\r\n        })\r\n        .attr('y', function () {\r\n          return e.left / 2\r\n        })\r\n        .attr('dy', '-1.2em')\r\n        .attr('text-anchor', 'middle')\r\n        .text(function (t) {\r\n          return e.y_label\r\n        })\r\n        .attr('transform', function (t) {\r\n          return 'rotate(-90)'\r\n        })\r\n  }\r\n  function rt (t) {\r\n    t.processed || (t.processed = {})\r\n    var e = O(t.target)\r\n    if (\r\n      (MG.call_hook('y_axis.process_min_max', t, t.processed.min_y, t.processed.max_y), D(e, '.mg-y-axis'), !t.y_axis)\r\n    )\r\n      return this\r\n    var r,\r\n      a,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c,\r\n      l,\r\n      u,\r\n      d = S(e, 'mg-y-axis')\r\n    return (\r\n      et(d, t),\r\n      ke(t, 'y'),\r\n      (r = d),\r\n      (i = (a = t).processed.y_ticks.length),\r\n      a.x_extended_ticks ||\r\n        a.y_extended_ticks ||\r\n        !i ||\r\n        (a.axes_not_compact && 'bar' !== a.chart_type\r\n          ? ((n = a.height - a.bottom), (o = a.top))\r\n          : i\r\n          ? ((n = a.scales.Y(a.processed.y_ticks[0]).toFixed(2)),\r\n            (o = a.scales.Y(a.processed.y_ticks[i - 1]).toFixed(2)))\r\n          : (o = n = 0),\r\n        r\r\n          .append('line')\r\n          .attr('x1', a.left)\r\n          .attr('x2', a.left)\r\n          .attr('y1', n)\r\n          .attr('y2', o)),\r\n      (s = t),\r\n      d\r\n        .selectAll('.mg-yax-ticks')\r\n        .data(s.processed.y_ticks)\r\n        .enter()\r\n        .append('line')\r\n        .classed('mg-extended-yax-ticks', s.y_extended_ticks)\r\n        .attr('x1', s.left)\r\n        .attr('x2', function () {\r\n          return s.y_extended_ticks ? s.width - s.right : s.left - s.yax_tick_length\r\n        })\r\n        .attr('y1', function (t) {\r\n          return s.scales.Y(t).toFixed(2)\r\n        })\r\n        .attr('y2', function (t) {\r\n          return s.scales.Y(t).toFixed(2)\r\n        }),\r\n      (c = d),\r\n      (u = J((l = t))),\r\n      c\r\n        .selectAll('.mg-yax-labels')\r\n        .data(l.processed.y_ticks)\r\n        .enter()\r\n        .append('text')\r\n        .attr('x', l.left - (3 * l.yax_tick_length) / 2)\r\n        .attr('dx', -3)\r\n        .attr('y', function (t) {\r\n          return l.scales.Y(t).toFixed(2)\r\n        })\r\n        .attr('dy', '.35em')\r\n        .attr('text-anchor', 'end')\r\n        .text(function (t) {\r\n          return u(t)\r\n        }),\r\n      t.y_rug && K(t),\r\n      this\r\n    )\r\n  }\r\n  function at (o) {\r\n    var t = O(o.target)\r\n    D(t, '.mg-y-axis')\r\n    var i,\r\n      s = S(t, 'mg-y-axis')\r\n    ;(o.categorical_groups.length ? o.categorical_groups : ['1']).forEach(function (t) {\r\n      var e, r, a, n\r\n      ;((i = S(s, 'mg-group-' + F(t))), null !== o.ygroup_accessor)\r\n        ? ((a = t),\r\n          (n = o),\r\n          i\r\n            .append('svg:text')\r\n            .classed('mg-barplot-group-label', !0)\r\n            .attr('x', n.left - n.buffer)\r\n            .attr('y', n.scales.YGROUP(a) + n.scales.YGROUP.bandwidth() / 2)\r\n            .attr('dy', '.35em')\r\n            .attr('text-anchor', 'end')\r\n            .text(a))\r\n        : l(\r\n            ((e = t),\r\n            (r = o),\r\n            i\r\n              .selectAll('text')\r\n              .data(r.scales.Y.domain())\r\n              .enter()\r\n              .append('svg:text')\r\n              .attr('x', r.left - r.buffer)\r\n              .attr('y', function (t) {\r\n                return r.scales.YGROUP(e) + r.scales.Y(t) + r.scales.Y.bandwidth() / 2\r\n              })\r\n              .attr('dy', '.35em')\r\n              .attr('text-anchor', 'end')\r\n              .text(String)),\r\n            o.rotate_y_labels\r\n          )\r\n    })\r\n  }\r\n  function nt (t) {\r\n    if (t.x_rug) {\r\n      t.rug_buffer_size = 'point' === t.chart_type ? t.buffer / 2 : t.buffer\r\n      var e = r(t, 'mg-x-rug')\r\n      e\r\n        .attr('x1', t.scalefns.xf)\r\n        .attr('x2', t.scalefns.xf)\r\n        .attr('y1', t.height - t.bottom - t.rug_buffer_size)\r\n        .attr('y2', t.height - t.bottom),\r\n        m(e, t, 'mg-x-rug-mono')\r\n    }\r\n  }\r\n  function ot (t) {\r\n    var e,\r\n      r,\r\n      a,\r\n      n = O(t.target)\r\n    if (\r\n      ((e = t).processed || (e.processed = {}),\r\n      (a = (r = t).chart_type),\r\n      r.processed.xax_format ||\r\n        (r.xax_format\r\n          ? (r.processed.xax_format = r.xax_format)\r\n          : 'line' === a || 'point' === a || 'histogram' === a\r\n          ? (r.processed.xax_format = ht(r))\r\n          : 'bar' === a && (r.processed.xax_format = ct(r))),\r\n      D(n, '.mg-x-axis'),\r\n      !t.x_axis)\r\n    )\r\n      return this\r\n    var o,\r\n      i,\r\n      s,\r\n      c,\r\n      l,\r\n      u,\r\n      d,\r\n      f,\r\n      p,\r\n      _,\r\n      m = S(n, 'mg-x-axis')\r\n    return (\r\n      (o = m),\r\n      ke((i = t), 'x'),\r\n      (l = o),\r\n      (u = (c = i).scales.X.ticks(c.xax_count).length - 1),\r\n      c.x_extended_ticks ||\r\n        l\r\n          .append('line')\r\n          .attr('x1', function () {\r\n            return 0 === c.xax_count\r\n              ? Y(c)\r\n              : c.axes_not_compact && 'bar' !== c.chart_type\r\n              ? c.left\r\n              : c.scales.X(c.scales.X.ticks(c.xax_count)[0]).toFixed(2)\r\n          })\r\n          .attr('x2', function () {\r\n            return 0 === c.xax_count || (c.axes_not_compact && 'bar' !== c.chart_type)\r\n              ? A(c)\r\n              : c.scales.X(c.scales.X.ticks(c.xax_count)[u]).toFixed(2)\r\n          })\r\n          .attr('y1', c.height - c.bottom)\r\n          .attr('y2', c.height - c.bottom),\r\n      (s = i),\r\n      o\r\n        .selectAll('.mg-xax-ticks')\r\n        .data(s.processed.x_ticks)\r\n        .enter()\r\n        .append('line')\r\n        .attr('x1', function (t) {\r\n          return s.scales.X(t).toFixed(2)\r\n        })\r\n        .attr('x2', function (t) {\r\n          return s.scales.X(t).toFixed(2)\r\n        })\r\n        .attr('y1', s.height - s.bottom)\r\n        .attr('y2', function () {\r\n          return s.x_extended_ticks ? s.top : s.height - s.bottom + s.xax_tick_length\r\n        })\r\n        .attr('class', function () {\r\n          if (s.x_extended_ticks) return 'mg-extended-xax-ticks'\r\n        })\r\n        .classed('mg-xax-ticks', !0),\r\n      (function (a, t) {\r\n        var e = t\r\n          .selectAll('.mg-xax-labels')\r\n          .data(a.processed.x_ticks)\r\n          .enter()\r\n          .append('text')\r\n          .attr('x', function (t) {\r\n            return a.scales.X(t).toFixed(2)\r\n          })\r\n          .attr('y', (a.height - a.bottom + (7 * a.xax_tick_length) / 3).toFixed(2))\r\n          .attr('dy', '.50em')\r\n          .attr('text-anchor', 'middle')\r\n        if (\r\n          (a.time_series && a.european_clock\r\n            ? (e\r\n                .append('tspan')\r\n                .classed('mg-european-hours', !0)\r\n                .text(function (t, e) {\r\n                  var r = new Date(t)\r\n                  return 0 === e ? E.timeFormat('%H')(r) : ''\r\n                }),\r\n              e\r\n                .append('tspan')\r\n                .classed('mg-european-minutes-seconds', !0)\r\n                .text(function (t, e) {\r\n                  var r = new Date(t)\r\n                  return ':' + a.processed.xax_format(r)\r\n                }))\r\n            : e.text(function (t) {\r\n                return a.xax_units + a.processed.xax_format(t)\r\n              }),\r\n          g(e))\r\n        ) {\r\n          e.filter(function (t, e) {\r\n            return (e + 1) % 2 == 0\r\n          }).remove()\r\n          var r = O(a.target)\r\n          r.selectAll('.mg-xax-ticks')\r\n            .filter(function (t, e) {\r\n              return (e + 1) % 2 == 0\r\n            })\r\n            .remove()\r\n        }\r\n      })((f = t), (d = m)),\r\n      (_ = d),\r\n      (p = f).time_series &&\r\n        (p.show_years || p.show_secondary_x_label) &&\r\n        (function (t, e) {\r\n          var r = xt(t),\r\n            a = r.secondary(t.processed.min_x, t.processed.max_x)\r\n          if (0 === a.length) {\r\n            var n = t.scales.X.ticks(t.xax_count)[0]\r\n            a = [n]\r\n          }\r\n          var o,\r\n            i,\r\n            s,\r\n            c,\r\n            l,\r\n            u,\r\n            d,\r\n            f = S(e, 'mg-year-marker')\r\n          'default' === r.timeframe &&\r\n            t.show_year_markers &&\r\n            ((o = t),\r\n            (i = f),\r\n            (s = a),\r\n            r.yformat,\r\n            i\r\n              .selectAll('.mg-year-marker')\r\n              .data(s)\r\n              .enter()\r\n              .append('line')\r\n              .attr('x1', function (t) {\r\n                return o.scales.X(t).toFixed(2)\r\n              })\r\n              .attr('x2', function (t) {\r\n                return o.scales.X(t).toFixed(2)\r\n              })\r\n              .attr('y1', M(o))\r\n              .attr('y2', w(o))),\r\n            'years' != r.tick_diff_time_frame &&\r\n              ((c = t),\r\n              (l = f),\r\n              (u = a),\r\n              (d = r.yformat),\r\n              l\r\n                .selectAll('.mg-year-marker')\r\n                .data(u)\r\n                .enter()\r\n                .append('text')\r\n                .attr('x', function (t, e) {\r\n                  return c.scales.X(t).toFixed(2)\r\n                })\r\n                .attr('y', function () {\r\n                  var t = E.select(c.target)\r\n                    .select('.mg-x-axis text')\r\n                    .node()\r\n                    .getBoundingClientRect()\r\n                  return w(c) + (7 * c.xax_tick_length) / 3 + 0.8 * t.height\r\n                })\r\n                .attr('dy', '.50em')\r\n                .attr('text-anchor', 'middle')\r\n                .text(function (t) {\r\n                  return d(new Date(t))\r\n                }))\r\n        })(p, _),\r\n      t.x_label && st(m, t),\r\n      t.x_rug && nt(t),\r\n      this\r\n    )\r\n  }\r\n  function B (e) {\r\n    var t\r\n    return (\r\n      null === e.color_domain\r\n        ? 'number' === e.color_type\r\n          ? (t = E.extent(e.data[0], function (t) {\r\n              return t[e.color_accessor]\r\n            }))\r\n          : 'category' === e.color_type &&\r\n            (t = E.set(\r\n              e.data[0].map(function (t) {\r\n                return t[e.color_accessor]\r\n              })\r\n            ).values()).sort()\r\n        : (t = e.color_domain),\r\n      t\r\n    )\r\n  }\r\n  function I (t) {\r\n    return null === t.color_range ? ('number' === t.color_type ? ['blue', 'red'] : null) : t.color_range\r\n  }\r\n  function it (t) {\r\n    return null === t.size_range ? [1, 5] : t.size_range\r\n  }\r\n  function st (t, e) {\r\n    e.x_label &&\r\n      t\r\n        .append('text')\r\n        .attr('class', 'label')\r\n        .attr('x', function () {\r\n          return Y(e) + (P(e) - Y(e)) / 2\r\n        })\r\n        .attr('dx', null != e.x_label_nudge_x ? e.x_label_nudge_x : 0)\r\n        .attr('y', function () {\r\n          var t = E.select(e.target)\r\n            .select('.mg-x-axis text')\r\n            .node()\r\n            .getBoundingClientRect()\r\n          return w(e) + e.xax_tick_length * (7 / 3) + 0.8 * t.height + 10\r\n        })\r\n        .attr('dy', '.5em')\r\n        .attr('text-anchor', 'middle')\r\n        .text(function (t) {\r\n          return e.x_label\r\n        })\r\n  }\r\n  function ct (r) {\r\n    return function (t) {\r\n      if (t < 1 && -1 < t && 0 !== t) return r.xax_units + t.toFixed(r.decimals)\r\n      var e = E.format(',.0f')\r\n      return r.xax_units + e(t)\r\n    }\r\n  }\r\n  function lt (t) {\r\n    var e\r\n    return (\r\n      ut(t)\r\n        ? (e = 'millis')\r\n        : dt(t)\r\n        ? (e = 'seconds')\r\n        : ft(t)\r\n        ? (e = 'less-than-a-day')\r\n        : pt(t)\r\n        ? (e = 'four-days')\r\n        : _t(t)\r\n        ? (e = 'many-days')\r\n        : mt(t)\r\n        ? (e = 'many-months')\r\n        : (e = 365 <= t / 86400 ? 'years' : 'default'),\r\n      e\r\n    )\r\n  }\r\n  function ut (t) {\r\n    return t < 1\r\n  }\r\n  function dt (t) {\r\n    return t < 60\r\n  }\r\n  function ft (t) {\r\n    return t / 3600 < 24\r\n  }\r\n  function pt (t) {\r\n    return t / 3600 < 96\r\n  }\r\n  function _t (t) {\r\n    return t / 86400 < 60\r\n  }\r\n  function mt (t) {\r\n    return t / 86400 < 365\r\n  }\r\n  function gt (t) {\r\n    if (t.time_series) {\r\n      var e = (t.processed.max_x - t.processed.min_x) / 1e3,\r\n        r = (t.processed.x_ticks[1] - t.processed.x_ticks[0]) / 1e3\r\n      ;(t.processed.x_time_frame = lt(e)),\r\n        (t.processed.x_tick_diff_time_frame = lt(r)),\r\n        (t.processed.main_x_time_format = ((a = t.utc_time),\r\n        ut((n = r))\r\n          ? MG.time_format(a, '%M:%S.%L')\r\n          : dt(n)\r\n          ? MG.time_format(a, '%M:%S')\r\n          : ft(n)\r\n          ? MG.time_format(a, '%H:%M')\r\n          : pt(n) || _t(n)\r\n          ? MG.time_format(a, '%b %d')\r\n          : mt(n)\r\n          ? MG.time_format(a, '%b')\r\n          : MG.time_format(a, '%Y')))\r\n    }\r\n    var a, n\r\n  }\r\n  function ht (r) {\r\n    if (r.xax_format) return r.xax_format\r\n    var t = h(r.processed.original_data || r.data)[0],\r\n      a = t[r.processed.original_x_accessor || r.x_accessor]\r\n    return (\r\n      void 0 === a && (a = t),\r\n      function (t) {\r\n        return (\r\n          gt(r),\r\n          x(a)\r\n            ? r.processed.main_x_time_format(new Date(t))\r\n            : 'number' == typeof a\r\n            ? ((e = t % 1 != 0 ? E.format(',.' + r.decimals + 'f') : t < 1e3 ? E.format(',.0f') : E.format(',.2s')),\r\n              r.xax_units + e(t))\r\n            : r.xax_units + t\r\n        )\r\n        var e\r\n      }\r\n    )\r\n  }\r\n  function xt (t) {\r\n    var e = { timeframe: t.processed.x_time_frame, tick_diff_timeframe: t.processed.x_tick_diff_time_frame }\r\n    switch (e.timeframe) {\r\n      case 'millis':\r\n      case 'seconds':\r\n        ;(e.secondary = E.timeDays),\r\n          t.european_clock\r\n            ? (e.yformat = MG.time_format(t.utc_time, '%b %d'))\r\n            : (e.yformat = MG.time_format(t.utc_time, '%I %p'))\r\n        break\r\n      case 'less-than-a-day':\r\n      case 'four-days':\r\n        ;(e.secondary = E.timeDays), (e.yformat = MG.time_format(t.utc_time, '%b %d'))\r\n        break\r\n      case 'many-days':\r\n      case 'many-months':\r\n        ;(e.secondary = E.timeYears), (e.yformat = MG.time_format(t.utc_time, '%Y'))\r\n        break\r\n      default:\r\n        ;(e.secondary = E.timeYears), (e.yformat = MG.time_format(t.utc_time, '%Y'))\r\n    }\r\n    return e\r\n  }\r\n  function yt (t) {\r\n    var e = parseInt(t.width)\r\n    t.full_width && (e = f(t.target)), 'categorical' === t.x_axis_type && null === e && (e = Dt(t, 'x')), (t.width = e)\r\n  }\r\n  function vt (t) {\r\n    var e = parseInt(t.height)\r\n    t.full_height && (e = d(t.target, 'height')),\r\n      'categorical' === t.y_axis_type && null === e && (e = Dt(t, 'y')),\r\n      (t.height = e)\r\n  }\r\n  function bt (t, e) {\r\n    ;((!t.selectAll('.mg-main-line').empty() && 'line' !== e.chart_type) ||\r\n      (!t.selectAll('.mg-points').empty() && 'point' !== e.chart_type) ||\r\n      (!t.selectAll('.mg-histogram').empty() && 'histogram' !== e.chart_type) ||\r\n      (!t.selectAll('.mg-barplot').empty() && 'bar' !== e.chart_type)) &&\r\n      t.remove()\r\n  }\r\n  function wt (t, e) {\r\n    return (\r\n      O(e.target).empty() &&\r\n        (t = E.select(e.target)\r\n          .append('svg')\r\n          .classed('linked', e.linked)\r\n          .attr('width', e.width)\r\n          .attr('height', e.height)),\r\n      t\r\n    )\r\n  }\r\n  function kt (t, e) {\r\n    e.width !== Number(t.attr('width')) && t.attr('width', e.width),\r\n      e.height !== Number(t.attr('height')) && t.attr('height', e.height)\r\n  }\r\n  function Mt (t, e) {\r\n    t.attr('viewBox', '0 0 ' + e.width + ' ' + e.height),\r\n      (e.full_width || e.full_height) && t.attr('preserveAspectRatio', 'xMinYMin meet')\r\n  }\r\n  function Gt (t, e) {\r\n    t.empty() &&\r\n      console.warn(\r\n        'The specified target element \"' +\r\n          e.target +\r\n          '\" could not be found in the page. The chart will not be rendered.'\r\n      )\r\n  }\r\n  function At (t, e) {\r\n    var r,\r\n      a,\r\n      n,\r\n      o = 'x' === e ? t.width : t.height\r\n    !(function (t, e) {\r\n      var r = t[e + 'group_accessor']\r\n      if (((t.categorical_groups = []), r)) {\r\n        var a = t.data[0]\r\n        t.categorical_groups = E.set(\r\n          a.map(function (t) {\r\n            return t[r]\r\n          })\r\n        ).values()\r\n      }\r\n    })(t, e),\r\n      (function (t, e) {\r\n        var r = t[e + 'group_accessor']\r\n        if (((t.total_bars = t.data[0].length), r)) {\r\n          var a = ((n = t.data[0]),\r\n          (o = r),\r\n          n\r\n            .map(function (t) {\r\n              return t[o]\r\n            })\r\n            .reduce(function (t, e) {\r\n              return (t[e] = t[e] + 1 || 1), t\r\n            }, {}))\r\n          ;(a = E.max(\r\n            Object.keys(a).map(function (t) {\r\n              return a[t]\r\n            })\r\n          )),\r\n            (t.bars_per_group = a)\r\n        } else t.bars_per_group = t.data[0].length\r\n        var n, o\r\n      })(t, e),\r\n      (function (t, e, r) {\r\n        var a = e + 'group_height'\r\n        if (r) {\r\n          var n =\r\n            'y' === e\r\n              ? (t.height - t.top - t.bottom - 2 * t.buffer) / (t.categorical_groups.length || 1)\r\n              : (t.width - t.left - t.right - 2 * t.buffer) / (t.categorical_groups.length || 1)\r\n          t[a] = n\r\n        } else {\r\n          var o = (1 + t[e + '_padding_percentage']) * t.bar_thickness\r\n          t[a] = t.bars_per_group * o + 2 * t[e + '_outer_padding_percentage'] * o\r\n        }\r\n      })(t, e, o),\r\n      o &&\r\n        ((n = (r = t)[(a = e) + 'group_height'] / (r.bars_per_group + r[a + '_outer_padding_percentage'])),\r\n        (r.bar_thickness = n - n * r[a + '_padding_percentage']))\r\n  }\r\n  function Dt (t, e) {\r\n    return (\r\n      t[e + 'group_height'] * (t.categorical_groups.length || 1) +\r\n      ('y' === e ? t.top + t.bottom + 2 * t.buffer : t.left + t.right + 2 * t.buffer) +\r\n      t.categorical_groups.length *\r\n        t[e + 'group_height'] *\r\n        (t[e + 'group_padding_percentage'] + t[e + 'group_outer_padding_percentage'])\r\n    )\r\n  }\r\n  function Ot (t) {\r\n    var e\r\n    ;(e = t = t) || (e = {}),\r\n      e.processed || (e.processed = {}),\r\n      (t = e = p(e, { target: null, title: null, description: null }))\r\n    var r = E.select(t.target)\r\n    Gt(r, t)\r\n    var a,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c,\r\n      l,\r\n      u = r.selectAll('svg')\r\n    return (\r\n      'categorical' === t.y_axis_type && At(t, 'y'),\r\n      'categorical' === t.x_axis_type && At(t, 'x'),\r\n      (n = (a = t).chart_type),\r\n      a.processed.xax_format ||\r\n        (a.xax_format\r\n          ? (a.processed.xax_format = a.xax_format)\r\n          : 'line' === n || 'point' === n || 'histogram' === n\r\n          ? (a.processed.xax_format = ht(a))\r\n          : 'bar' === n && (a.processed.xax_format = ct(a))),\r\n      (i = h((o = t).processed.original_data || o.data)[0]),\r\n      (o.time_series = x(i[o.processed.original_x_accessor || o.x_accessor])),\r\n      yt(t),\r\n      vt(t),\r\n      bt(u, t),\r\n      (u = wt(u, t)),\r\n      (c = t),\r\n      (s = u).selectAll('.mg-clip-path').remove(),\r\n      s\r\n        .append('defs')\r\n        .attr('class', 'mg-clip-path')\r\n        .append('clipPath')\r\n        .attr('id', 'mg-plot-window-' + z(c.target))\r\n        .append('svg:rect')\r\n        .attr('x', G(c))\r\n        .attr('y', M(c))\r\n        .attr('width', c.width - c.left - c.right - c.buffer)\r\n        .attr('height', c.height - c.top - c.bottom - c.buffer + 1),\r\n      kt(u, t),\r\n      Mt(u, t),\r\n      (l = u).classed('mg-missing', !1),\r\n      l.selectAll('.mg-missing-text').remove(),\r\n      l.selectAll('.mg-missing-pane').remove(),\r\n      j(t),\r\n      (function (t, e) {\r\n        var r = 0\r\n        if (t.selectAll('.mg-main-line').nodes().length >= e.data.length)\r\n          if (0 < e.custom_line_color_map.length) {\r\n            var a = T(\r\n              (function (t) {\r\n                for (var e = new Array(t), r = 0; r < e.length; r++) e[r] = r + 1\r\n                return e\r\n              })(e.max_data_size),\r\n              e.custom_line_color_map\r\n            )\r\n            for (r = 0; r < a.length; r++) t.selectAll('.mg-main-line.mg-line' + a[r] + '-color').remove()\r\n          } else {\r\n            var n = e.data.length\r\n            for (r = t.selectAll('.mg-main-line').nodes() ? t.selectAll('.mg-main-line').nodes().length : 0; n < r; r--)\r\n              t.selectAll('.mg-main-line.mg-line' + r + '-color').remove()\r\n          }\r\n      })(u, t),\r\n      this\r\n    )\r\n  }\r\n  function zt (t) {\r\n    return t.label\r\n  }\r\n  function Ft (e) {\r\n    return function (t) {\r\n      return e.scales.X(t[e.x_accessor]) >= Y(e) && e.scales.X(t[e.x_accessor]) <= P(e)\r\n    }\r\n  }\r\n  function Ct (e) {\r\n    return function (t) {\r\n      return e.scales.X(t[e.x_accessor])\r\n    }\r\n  }\r\n  function Tt (t) {\r\n    var e = t.scales.Y\r\n    return function (t) {\r\n      return e(t.value).toFixed(2)\r\n    }\r\n  }\r\n  function Rt (t, e, r, a, n, o) {\r\n    var i\r\n    t && (n((i = a.append('g').attr('class', e)), r), o(i, r))\r\n  }\r\n  function Et (t, e) {\r\n    var r,\r\n      a = ((r = Ct(e)),\r\n      function (t) {\r\n        return r(t).toFixed(2)\r\n      })\r\n    t.selectAll('.mg-markers')\r\n      .data(e.markers.filter(Ft(e)))\r\n      .enter()\r\n      .append('line')\r\n      .attr('x1', a)\r\n      .attr('x2', a)\r\n      .attr('y1', e.top)\r\n      .attr('y2', v(e))\r\n      .attr('class', function (t) {\r\n        return t.lineclass\r\n      })\r\n      .attr('stroke-dasharray', '3,1')\r\n  }\r\n  function Yt (t, e) {\r\n    t\r\n      .selectAll('.mg-markers')\r\n      .data(e.markers.filter(Ft(e)))\r\n      .enter()\r\n      .append('text')\r\n      .attr('class', function (t) {\r\n        return t.textclass || ''\r\n      })\r\n      .classed('mg-marker-text', !0)\r\n      .attr('x', Ct(e))\r\n      .attr('y', 'bottom' === e.x_axis_position ? 0.95 * M(e) : w(e) + e.buffer)\r\n      .attr('text-anchor', 'middle')\r\n      .text(zt)\r\n      .each(function (t) {\r\n        t.click &&\r\n          E.select(this)\r\n            .style('cursor', 'pointer')\r\n            .on('click', t.click),\r\n          t.mouseover &&\r\n            E.select(this)\r\n              .style('cursor', 'pointer')\r\n              .on('mouseover', t.mouseover),\r\n          t.mouseout &&\r\n            E.select(this)\r\n              .style('cursor', 'pointer')\r\n              .on('mouseout', t.mouseout)\r\n      }),\r\n      (function (t, e) {\r\n        if (t && 1 != t.length)\r\n          for (var r = 0; r < t.length; r++)\r\n            if (o(t[r], t)) {\r\n              var a = E.select(t[r]),\r\n                n = +a.attr('y')\r\n              n + 8 >= e.top && (n = e.top - 16), a.attr('y', n)\r\n            }\r\n      })(t.selectAll('.mg-marker-text').nodes(), e)\r\n  }\r\n  function $t (t, e) {\r\n    var r = Tt(e)\r\n    t.selectAll('.mg-baselines')\r\n      .data(e.baselines)\r\n      .enter()\r\n      .append('line')\r\n      .attr('x1', Y(e))\r\n      .attr('x2', P(e))\r\n      .attr('y1', r)\r\n      .attr('y2', r)\r\n  }\r\n  function Pt (t, e) {\r\n    var r = Tt(e)\r\n    t.selectAll('.mg-baselines')\r\n      .data(e.baselines)\r\n      .enter()\r\n      .append('text')\r\n      .attr('x', P(e))\r\n      .attr('y', r)\r\n      .attr('dy', -3)\r\n      .attr('text-anchor', 'end')\r\n      .text(zt)\r\n  }\r\n  function St (t) {\r\n    var e,\r\n      r,\r\n      a,\r\n      n,\r\n      o,\r\n      i = O(t.target)\r\n    return (\r\n      (e = i).selectAll('.mg-markers').remove(),\r\n      e.selectAll('.mg-baselines').remove(),\r\n      (a = i),\r\n      Rt((r = t).markers, 'mg-markers', r, a, Et, Yt),\r\n      (o = i),\r\n      Rt((n = t).baselines, 'mg-baselines', n, o, $t, Pt),\r\n      this\r\n    )\r\n  }\r\n  function Lt (t) {\r\n    t.selectAll('.mg-active-datapoint-container')\r\n      .selectAll('*')\r\n      .remove()\r\n  }\r\n  function jt (t, e) {\r\n    t.select('.mg-active-datapoint').remove()\r\n    var r,\r\n      a = 'right' === e.mouseover_align ? 'end' : 'left' === e.mouseover_align ? 'start' : 'middle',\r\n      n =\r\n        'right' === e.mouseover_align\r\n          ? P(e)\r\n          : 'left' === e.mouseover_align\r\n          ? Y(e)\r\n          : (e.width - e.left - e.right) / 2 + e.left,\r\n      o = t\r\n        .select('.mg-active-datapoint-container')\r\n        .append('text')\r\n        .attr('class', 'mg-active-datapoint')\r\n        .attr('xml:space', 'preserve')\r\n        .attr('text-anchor', a),\r\n      i = 0.75,\r\n      s = 'bottom' === e.x_axis_position ? M(e) * i : w(e) + 3 * e.buffer\r\n    e.markers &&\r\n      t.selectAll('.mg-marker-text').each(function () {\r\n        r ? r !== E.select(this).attr('y') && (i = 0.56) : (r = E.select(this).attr('y'))\r\n      })\r\n    o.attr('transform', 'translate(' + n + ',' + s + ')')\r\n  }\r\n  function Xt (t, e) {\r\n    jt(e.svg, t)\r\n    var r,\r\n      a,\r\n      o = {\r\n        row_number: 0,\r\n        rargs: e,\r\n        mouseover_row: function (t) {\r\n          return (\r\n            (o.row_number += 1),\r\n            (e = o.row_number),\r\n            (r = o.text_container),\r\n            (a = t),\r\n            (n = r\r\n              .append('tspan')\r\n              .attr('x', 0)\r\n              .attr('y', 1.1 * e + 'em')),\r\n            {\r\n              rargs: a,\r\n              text: function (t) {\r\n                return (\r\n                  (e = t),\r\n                  {\r\n                    bold: function () {\r\n                      return r.attr('font-weight', 'bold')\r\n                    },\r\n                    font_size: function (t) {\r\n                      return r.attr('font-size', t)\r\n                    },\r\n                    x: function (t) {\r\n                      return r.attr('x', t)\r\n                    },\r\n                    y: function (t) {\r\n                      return r.attr('y', t)\r\n                    },\r\n                    elem: (r = n.append('tspan').text(e))\r\n                  }\r\n                )\r\n                var e, r\r\n              }\r\n            }\r\n          )\r\n          var e, r, a, n\r\n        },\r\n        text_container: ((r = e.svg), (a = r.select('.mg-active-datapoint')), a.selectAll('*').remove(), a)\r\n      }\r\n    return o\r\n  }\r\n  ;(Z.categorical = function (t, e) {\r\n    e.namespace\r\n    Q(t, e),\r\n      (function (d, t) {\r\n        var f,\r\n          p,\r\n          _,\r\n          m,\r\n          e = t.namespace,\r\n          g = (d.scalefns[e + 'f'], d.scalefns[e + 'groupf'], d.scales[(e + 'group').toUpperCase()]),\r\n          h = d.scales[e.toUpperCase()],\r\n          x = t.position,\r\n          r = O(d.target),\r\n          a = g.domain && g.domain() ? g.domain() : [null]\r\n        D(r, '.mg-category-guides')\r\n        var y = S(r, 'mg-category-guides')\r\n        a.forEach(function (e) {\r\n          h.domain().forEach(function (t) {\r\n            ;('left' !== x && 'right' !== x) ||\r\n              ((f = Y(d)), (p = P(d)), (_ = h(t) + g(e) + h.bandwidth() / 2), (m = h(t) + g(e) + h.bandwidth() / 2)),\r\n              ('top' !== x && 'bottom' !== x) ||\r\n                ((f = h(t) + g(e) + (h.bandwidth() / 2) * (null === e)),\r\n                (p = h(t) + g(e) + (h.bandwidth() / 2) * (null === e)),\r\n                (_ = v(d)),\r\n                (m = b(d))),\r\n              y\r\n                .append('line')\r\n                .attr('x1', f)\r\n                .attr('x2', p)\r\n                .attr('y1', _)\r\n                .attr('y2', m)\r\n                .attr('stroke-dasharray', '2,1')\r\n          })\r\n          var t,\r\n            r,\r\n            a,\r\n            n,\r\n            o,\r\n            i,\r\n            s,\r\n            c,\r\n            l = g(e) + h(h.domain()[0]) + (h.bandwidth() / 2) * (null === e || ('top' !== x && 'bottom' != x)),\r\n            u =\r\n              g(e) +\r\n              h(h.domain()[h.domain().length - 1]) +\r\n              (h.bandwidth() / 2) * (null === e || ('top' !== x && 'bottom' != x))\r\n          ;('left' !== x && 'right' !== x) ||\r\n            ((t = Y(d)), (r = Y(d)), (a = l), (n = u), (o = P(d)), (i = P(d)), (s = l), (c = u)),\r\n            ('bottom' !== x && 'top' !== x) ||\r\n              ((t = l), (r = u), (a = v(d)), (n = v(d)), (o = l), (i = u), (s = b(d)), (c = b(d))),\r\n            y\r\n              .append('line')\r\n              .attr('x1', t)\r\n              .attr('x2', r)\r\n              .attr('y1', a)\r\n              .attr('y2', n)\r\n              .attr('stroke-dasharray', '2,1'),\r\n            y\r\n              .append('line')\r\n              .attr('x1', o)\r\n              .attr('x2', i)\r\n              .attr('y1', s)\r\n              .attr('y2', c)\r\n              .attr('stroke-dasharray', '2,1')\r\n        })\r\n      })(t, e)\r\n  }),\r\n    (Z.numerical = function (t, e) {\r\n      var r = e.namespace,\r\n        a = r + '_axis',\r\n        n = 'mg-' + r + '-axis',\r\n        o = O(t.target)\r\n      if ((D(o, '.' + n), !t[a])) return this\r\n      var i,\r\n        s,\r\n        c,\r\n        l,\r\n        u,\r\n        d,\r\n        f,\r\n        p,\r\n        _,\r\n        m,\r\n        g,\r\n        h,\r\n        x,\r\n        y,\r\n        v,\r\n        b = S(o, n)\r\n      return (\r\n        (function (t, e) {\r\n          var r = t[e + '_accessor'],\r\n            a = t.scales[e.toUpperCase()].ticks(t[e + 'ax_count']),\r\n            n = t.processed['max_' + e]\r\n          function o (t) {\r\n            return 1e3 === t ? 3 : 1e6 === t ? 7 : Math.log(t) / Math.LN10\r\n          }\r\n          'log' === t[e + '_scale_type'] &&\r\n            (a = a.filter(function (t) {\r\n              return Math.abs(o(t)) % 1 < 1e-6 || Math.abs(o(t)) % 1 > 1 - 1e-6\r\n            }))\r\n          var i = a.length,\r\n            s = !0\r\n          t.data.forEach(function (t, e) {\r\n            t.forEach(function (t, e) {\r\n              if (t[r] % 1 != 0) return (s = !1)\r\n            })\r\n          }),\r\n            s &&\r\n              n < i &&\r\n              'count' === t.format &&\r\n              (a = a.filter(function (t) {\r\n                return t % 1 == 0\r\n              })),\r\n            (t.processed[e + '_ticks'] = a)\r\n        })(t, r),\r\n        V(b, t, e),\r\n        (i = b),\r\n        (s = t),\r\n        (p = (c = e).namespace),\r\n        (_ = c.position),\r\n        (m = s.scales[p.toUpperCase()]),\r\n        (g = s.processed[p + '_ticks']),\r\n        (h = 'mg-' + p + 'ax-ticks'),\r\n        (x = 'mg-extended-' + p + 'ax-ticks'),\r\n        (y = s[p + '_extended_ticks']),\r\n        (v = s[p + 'ax_tick_length']),\r\n        'left' === _ &&\r\n          ((l = G(s)),\r\n          (u = y ? A(s) : G(s) - v),\r\n          (d = function (t) {\r\n            return m(t).toFixed(2)\r\n          }),\r\n          (f = function (t) {\r\n            return m(t).toFixed(2)\r\n          })),\r\n        'right' === _ &&\r\n          ((l = A(s)),\r\n          (u = y ? G(s) : A(s) + v),\r\n          (d = function (t) {\r\n            return m(t).toFixed(2)\r\n          }),\r\n          (f = function (t) {\r\n            return m(t).toFixed(2)\r\n          })),\r\n        'top' === _ &&\r\n          ((l = function (t) {\r\n            return m(t).toFixed(2)\r\n          }),\r\n          (u = function (t) {\r\n            return m(t).toFixed(2)\r\n          }),\r\n          (d = M(s)),\r\n          (f = y ? w(s) : M(s) - v)),\r\n        'bottom' === _ &&\r\n          ((l = function (t) {\r\n            return m(t).toFixed(2)\r\n          }),\r\n          (u = function (t) {\r\n            return m(t).toFixed(2)\r\n          }),\r\n          (d = w(s)),\r\n          (f = y ? M(s) : w(s) + v)),\r\n        i\r\n          .selectAll('.' + h)\r\n          .data(g)\r\n          .enter()\r\n          .append('line')\r\n          .classed(x, y)\r\n          .attr('x1', l)\r\n          .attr('x2', u)\r\n          .attr('y1', d)\r\n          .attr('y2', f),\r\n        q(b, t, e),\r\n        t[r + '_label'] && e.label(o.select('.mg-' + r + '-axis'), t),\r\n        t[r + '_rug'] && W(t, e),\r\n        t.show_bar_zero && tt(t),\r\n        this\r\n      )\r\n    }),\r\n    (MG.axis_factory = function (t) {\r\n      var e = { type: 'numerical' }\r\n      return (\r\n        (this.namespace = function (t) {\r\n          return (e.namespace = t), this\r\n        }),\r\n        (this.rug = function (t) {\r\n          return (e.rug = t), this\r\n        }),\r\n        (this.label = function (t) {\r\n          return (e.label = t), this\r\n        }),\r\n        (this.type = function (t) {\r\n          return (e.type = t), this\r\n        }),\r\n        (this.position = function (t) {\r\n          return (e.position = t), this\r\n        }),\r\n        (this.zeroLine = function (t) {\r\n          return (e.zeroLine = t), this\r\n        }),\r\n        (this.draw = function () {\r\n          return Z[e.type](t, e), this\r\n        }),\r\n        this\r\n      )\r\n    }),\r\n    (MG.y_rug = K),\r\n    (MG.y_axis = rt),\r\n    (MG.y_axis_categorical = function (t) {\r\n      return (\r\n        t.y_axis &&\r\n          (at(t),\r\n          t.show_bar_zero && tt(t),\r\n          t.ygroup_accessor &&\r\n            ((r = O((e = t).target)),\r\n            (a = e.scales.YGROUP.domain())[0],\r\n            a[a.length - 1],\r\n            r\r\n              .select('.mg-category-guides')\r\n              .selectAll('mg-group-lines')\r\n              .data(a)\r\n              .enter()\r\n              .append('line')\r\n              .attr('x1', Y(e))\r\n              .attr('x2', Y(e))\r\n              .attr('y1', function (t) {\r\n                return e.scales.YGROUP(t)\r\n              })\r\n              .attr('y2', function (t) {\r\n                return e.scales.YGROUP(t) + e.ygroup_height\r\n              })\r\n              .attr('stroke-width', 1)),\r\n          t.y_categorical_show_guides &&\r\n            ((o = O((n = t).target)),\r\n            (i = []),\r\n            n.data[0].forEach(function (t) {\r\n              ;-1 === i.indexOf(t[n.y_accessor]) &&\r\n                o\r\n                  .select('.mg-category-guides')\r\n                  .append('line')\r\n                  .attr('x1', Y(n))\r\n                  .attr('x2', P(n))\r\n                  .attr('y1', n.scalefns.yf(t) + n.scalefns.ygroupf(t))\r\n                  .attr('y2', n.scalefns.yf(t) + n.scalefns.ygroupf(t))\r\n                  .attr('stroke-dasharray', '2,1')\r\n            }))),\r\n        this\r\n      )\r\n      var e, r, a, n, o, i\r\n    }),\r\n    (MG.x_rug = nt),\r\n    (MG.x_axis = ot),\r\n    (MG.x_axis_categorical = function (t) {\r\n      var e = O(t.target),\r\n        r = 0\r\n      'bar' === t.chart_type && (r = t.buffer + 5),\r\n        mg_add_categorical_scale(t, 'X', t.categorical_variables.reverse(), t.left, P(t) - r),\r\n        X(t, 'xf', 'X', 'value'),\r\n        D(e, '.mg-x-axis')\r\n      var a = S(e, 'mg-x-axis')\r\n      return (\r\n        t.x_axis &&\r\n          ((n = a),\r\n          (o = t),\r\n          (i = r),\r\n          (s = n\r\n            .selectAll('text')\r\n            .data(o.categorical_variables)\r\n            .enter()\r\n            .append('text')),\r\n          s\r\n            .attr('x', function (t) {\r\n              return o.scales.X(t) + o.scales.X.bandwidth() / 2 + o.buffer * o.bar_outer_padding_percentage + i / 2\r\n            })\r\n            .attr('y', v(o))\r\n            .attr('dy', '.35em')\r\n            .attr('text-anchor', 'middle')\r\n            .text(String),\r\n          o.truncate_x_labels &&\r\n            s.each(function (t, e) {\r\n              var r = o.scales.X.bandwidth()\r\n              L(this, t, r)\r\n            }),\r\n          l(s, o.rotate_x_labels)),\r\n        this\r\n      )\r\n      var n, o, i, s\r\n    }),\r\n    (MG.init = Ot),\r\n    (MG.markers = St)\r\n  var Ut = function (n, o) {\r\n      return function (a) {\r\n        return ['x', 'y'].every(function (t) {\r\n          return (\r\n            !(t in o) || ((e = a[n[t + '_accessor']]), (r = o[t]), e > Math.min(r[0], r[1]) && e < Math.max(r[0], r[1]))\r\n          )\r\n          var e, r\r\n        })\r\n      }\r\n    },\r\n    Nt = function (e, r) {\r\n      var t = e.processed.raw_data || e.data\r\n      'raw_data' in e.processed ||\r\n        ((e.processed.raw_domain = { x: e.scales.X.domain(), y: e.scales.Y.domain() }), (e.processed.raw_data = t)),\r\n        'point' === e.chart_type &&\r\n          (a(t)\r\n            ? (e.data = t.map(function (t) {\r\n                return t.filter(Ut(e, r))\r\n              }))\r\n            : (e.data = t.filter(Ut(e, r)))),\r\n        ['x', 'y'].forEach(function (t) {\r\n          t in r ? (e.processed['zoom_' + t] = r[t]) : delete e.processed['zoom_' + t]\r\n        }),\r\n        e.processed.subplot &&\r\n          (r !== e.processed.raw_domain\r\n            ? MG.create_brushing_pattern(e.processed.subplot, It(e.processed.subplot, r))\r\n            : MG.remove_brushing_pattern(e.processed.subplot)),\r\n        new MG.charts[e.chart_type || defaults.chart_type].descriptor(e)\r\n    },\r\n    Bt = function (r, a) {\r\n      return ['x', 'y'].reduce(function (t, e) {\r\n        return (\r\n          e in a &&\r\n            ((t[e] = a[e].map(function (t) {\r\n              return +r.scales[e.toUpperCase()].invert(t)\r\n            })),\r\n            'y' === e && t[e].reverse()),\r\n          t\r\n        )\r\n      }, {})\r\n    },\r\n    It = function (r, a) {\r\n      return ['x', 'y'].reduce(function (t, e) {\r\n        return (\r\n          e in a &&\r\n            ((t[e] = a[e].map(function (t) {\r\n              return +r.scales[e.toUpperCase()](t)\r\n            })),\r\n            'y' === e && t[e].reverse()),\r\n          t\r\n        )\r\n      }, {})\r\n    }\r\n  ;(MG.convert_range_to_domain = Bt),\r\n    (MG.zoom_to_data_domain = Nt),\r\n    (MG.zoom_to_data_range = function (t, e) {\r\n      var r = Bt(t, e)\r\n      Nt(t, r)\r\n    }),\r\n    (MG.zoom_to_raw_range = function (t) {\r\n      'raw_domain' in t.processed &&\r\n        (Nt(t, t.processed.raw_domain), delete t.processed.raw_domain, delete t.processed.raw_data)\r\n    })\r\n  var Ht = function (t) {\r\n      return E.select(t.target)\r\n        .select('.mg-extent')\r\n        .size()\r\n        ? E.select(t.target).select('.mg-extent')\r\n        : E.select(t.target)\r\n            .select('.mg-rollover-rect, .mg-voronoi')\r\n            .insert('g', '*')\r\n            .classed('mg-brush', !0)\r\n            .append('rect')\r\n            .classed('mg-extent', !0)\r\n    },\r\n    qt = function (t, e) {\r\n      var r = e.x[0],\r\n        a = e.x[1] - e.x[0],\r\n        n = e.y[0],\r\n        o = e.y[1] - e.y[0]\r\n      Ht(t)\r\n        .attr('x', r)\r\n        .attr('width', a)\r\n        .attr('y', n)\r\n        .attr('height', o)\r\n        .attr('opacity', 1)\r\n    },\r\n    Vt = function (t) {\r\n      Ht(t)\r\n        .attr('width', 0)\r\n        .attr('height', 0)\r\n        .attr('opacity', 0)\r\n    }\r\n  ;(MG.add_brush_function = function (t) {\r\n    if ('categorical' === t.x_axis_type || 'categorical' === t.y_axis_type)\r\n      return console.warn('The option \"brush\" does not support axis type \"categorical\" currently.')\r\n    t.zoom_target || (t.zoom_target = t), t.zoom_target !== t && (t.zoom_target.processed.subplot = t)\r\n    var i,\r\n      r,\r\n      s,\r\n      a,\r\n      e,\r\n      c,\r\n      n,\r\n      o,\r\n      l,\r\n      u,\r\n      d = void 0\r\n    switch (t.brush) {\r\n      case 'x':\r\n        d = { x: !0, y: !1 }\r\n        break\r\n      case 'y':\r\n        d = { x: !1, y: !0 }\r\n        break\r\n      case 'xy':\r\n        d = { x: !0, y: !0 }\r\n        break\r\n      default:\r\n        d = { x: !0, y: !0 }\r\n    }\r\n    ;(r = (i = t).zoom_target),\r\n      (s = d),\r\n      (a = E.select(i.target).select('svg')),\r\n      (e = a.select('.mg-rollover-rect, .mg-voronoi')),\r\n      (c = e.node()),\r\n      (o = n = !1),\r\n      (l = []),\r\n      (u = function () {\r\n        var t = i.left,\r\n          e = i.width - i.right - i.buffer,\r\n          r = i.top,\r\n          a = i.height - i.bottom - i.buffer,\r\n          n = E.mouse(c),\r\n          o = {}\r\n        return (\r\n          (o.x = s.x ? [Math.max(t, Math.min(l[0], n[0])), Math.min(e, Math.max(l[0], n[0]))] : [t, e]),\r\n          (o.y = s.y ? [Math.max(r, Math.min(l[1], n[1])), Math.min(a, Math.max(l[1], n[1]))] : [r, a]),\r\n          o\r\n        )\r\n      }),\r\n      e.classed('mg-brush-container', !0),\r\n      e.on('mousedown.' + i.target, function () {\r\n        ;(n = !(o = !0)), (l = E.mouse(c)), a.classed('mg-brushed', !1), a.classed('mg-brushing-in-progress', !0), Vt(i)\r\n      }),\r\n      E.select(document).on('mousemove.' + i.target, function () {\r\n        o && ((n = !0), e.classed('mg-brushing', !0), qt(i, u()))\r\n      }),\r\n      E.select(document).on('mouseup.' + i.target, function () {\r\n        if (o) {\r\n          ;(o = !1), a.classed('mg-brushing-in-progress', !1)\r\n          var t = u()\r\n          if (n)\r\n            if (((n = !1), r === i))\r\n              MG.zoom_to_data_range(r, t), a.select('.mg-rollover-rect, .mg-voronoi').classed('mg-brushed', !0)\r\n            else {\r\n              var e = MG.convert_range_to_domain(i, t)\r\n              MG.zoom_to_data_domain(r, e)\r\n            }\r\n          else MG.zoom_to_raw_range(r)\r\n          C(i.brushing_selection_changed) && i.brushing_selection_changed(i, t)\r\n        }\r\n      })\r\n  }),\r\n    (MG.create_brushing_pattern = qt),\r\n    (MG.remove_brushing_pattern = Vt)\r\n  var Wt = new function () {\r\n    var t,\r\n      i = []\r\n    function s () {\r\n      i.forEach(function (t) {\r\n        var e = E.select(t).select('svg')\r\n        if (!e.empty() && (0 < e.node().parentNode.offsetWidth || 0 < e.node().parentNode.offsetHeight)) {\r\n          var r = 0 !== e.attr('width') ? e.attr('height') / e.attr('width') : 0,\r\n            a = f(t)\r\n          e.attr('width', a), e.attr('height', r * a)\r\n        }\r\n      })\r\n    }\r\n    return (\r\n      'undefined' != typeof MutationObserver\r\n        ? (t = MutationObserver)\r\n        : 'undefined' != typeof WebKitMutationObserver && (t = WebKitMutationObserver),\r\n      {\r\n        add_target: function (n) {\r\n          if ((0 === i.length && window.addEventListener('resize', s, !0), -1 === i.indexOf(n) && (i.push(n), t))) {\r\n            var o = new t(function (t) {\r\n              var e,\r\n                r,\r\n                a = E.select(n).node()\r\n              ;(a &&\r\n                !t.some(function (t) {\r\n                  for (var e = 0; e < t.removedNodes.length; e++) if (t.removedNodes[e] === a) return !0\r\n                })) ||\r\n                (o.disconnect(),\r\n                (e = n),\r\n                -1 !== (r = i.indexOf(e)) && i.splice(r, 1),\r\n                0 === i.length && window.removeEventListener('resize', s, !0))\r\n            })\r\n            o.observe(E.select(n).node().parentNode, { childList: !0 })\r\n          }\r\n        }\r\n      }\r\n    )\r\n  }()\r\n  function Qt (t) {\r\n    var e\r\n    ;((e = t).full_width || e.full_height) && Wt.add_target(e.target)\r\n  }\r\n  k() &&\r\n    (function (s) {\r\n      if ('function' == typeof s().dropdown) return\r\n      var c = '[data-toggle=\"dropdown\"]',\r\n        a = function (t) {\r\n          s(t).on('click.bs.dropdown', this.toggle)\r\n        }\r\n      function o (a) {\r\n        ;(a && 3 === a.which) ||\r\n          (s('.dropdown-backdrop').remove(),\r\n          s(c).each(function () {\r\n            var t = s(this),\r\n              e = l(t),\r\n              r = { relatedTarget: this }\r\n            e.hasClass('open') &&\r\n              (e.trigger((a = s.Event('hide.bs.dropdown', r))),\r\n              a.isDefaultPrevented() ||\r\n                (t.attr('aria-expanded', 'false'), e.removeClass('open').trigger('hidden.bs.dropdown', r)))\r\n          }))\r\n      }\r\n      function l (t) {\r\n        var e = t.attr('data-target')\r\n        e || (e = (e = t.attr('href')) && /#[A-Za-z]/.test(e) && e.replace(/.*(?=#[^\\s]*$)/, ''))\r\n        var r = e && s(e)\r\n        return r && r.length ? r : t.parent()\r\n      }\r\n      ;(a.VERSION = '3.3.1'),\r\n        (a.prototype.toggle = function (t) {\r\n          var e = s(this)\r\n          if (!e.is('.disabled, :disabled')) {\r\n            var r = l(e),\r\n              a = r.hasClass('open')\r\n            if ((o(), !a)) {\r\n              'ontouchstart' in document.documentElement &&\r\n                !r.closest('.navbar-nav').length &&\r\n                s('<div class=\"dropdown-backdrop\"/>')\r\n                  .insertAfter(s(this))\r\n                  .on('click', o)\r\n              var n = { relatedTarget: this }\r\n              if ((r.trigger((t = s.Event('show.bs.dropdown', n))), t.isDefaultPrevented())) return\r\n              e.trigger('focus').attr('aria-expanded', 'true'), r.toggleClass('open').trigger('shown.bs.dropdown', n)\r\n            }\r\n            return !1\r\n          }\r\n        }),\r\n        (a.prototype.keydown = function (t) {\r\n          if (/(38|40|27|32)/.test(t.which) && !/input|textarea/i.test(t.target.tagName)) {\r\n            var e = s(this)\r\n            if ((t.preventDefault(), t.stopPropagation(), !e.is('.disabled, :disabled'))) {\r\n              var r = l(e),\r\n                a = r.hasClass('open')\r\n              if ((!a && 27 != t.which) || (a && 27 == t.which))\r\n                return 27 == t.which && r.find(c).trigger('focus'), e.trigger('click')\r\n              var n = ' li:not(.divider):visible a',\r\n                o = r.find('[role=\"menu\"]' + n + ', [role=\"listbox\"]' + n)\r\n              if (o.length) {\r\n                var i = o.index(t.target)\r\n                38 == t.which && 0 < i && i--,\r\n                  40 == t.which && i < o.length - 1 && i++,\r\n                  ~i || (i = 0),\r\n                  o.eq(i).trigger('focus')\r\n              }\r\n            }\r\n          }\r\n        })\r\n      var t = s.fn.dropdown\r\n      ;(s.fn.dropdown = function (r) {\r\n        return this.each(function () {\r\n          var t = s(this),\r\n            e = t.data('bs.dropdown')\r\n          e || t.data('bs.dropdown', (e = new a(this))), 'string' == typeof r && e[r].call(t)\r\n        })\r\n      }),\r\n        (s.fn.dropdown.Constructor = a),\r\n        (s.fn.dropdown.noConflict = function () {\r\n          return (s.fn.dropdown = t), this\r\n        }),\r\n        s(document)\r\n          .on('click.bs.dropdown.data-api', o)\r\n          .on('click.bs.dropdown.data-api', '.dropdown form', function (t) {\r\n            t.stopPropagation()\r\n          })\r\n          .on('click.bs.dropdown.data-api', c, a.prototype.toggle)\r\n          .on('keydown.bs.dropdown.data-api', c, a.prototype.keydown)\r\n          .on('keydown.bs.dropdown.data-api', '[role=\"menu\"]', a.prototype.keydown)\r\n          .on('keydown.bs.dropdown.data-api', '[role=\"listbox\"]', a.prototype.keydown)\r\n    })(jQuery),\r\n    (MG.button_layout = function (t) {\r\n      return (\r\n        (this.target = t),\r\n        (this.feature_set = {}),\r\n        (this.public_name = {}),\r\n        (this.sorters = {}),\r\n        (this.manual = []),\r\n        (this.manual_map = {}),\r\n        (this.manual_callback = {}),\r\n        (this._strip_punctuation = function (t) {\r\n          return t.replace(/[^a-zA-Z0-9 _]+/g, '').replace(/ +?/g, '')\r\n        }),\r\n        (this.data = function (t) {\r\n          return (this._data = t), this\r\n        }),\r\n        (this.manual_button = function (t, e, r) {\r\n          return (\r\n            (this.feature_set[t] = e),\r\n            (this.manual_map[this._strip_punctuation(t)] = t),\r\n            (this.manual_callback[t] = r),\r\n            this\r\n          )\r\n        }),\r\n        (this.button = function (t) {\r\n          return (\r\n            1 < arguments.length && (this.public_name[t] = arguments[1]),\r\n            2 < arguments.length && (this.sorters[t] = arguments[2]),\r\n            (this.feature_set[t] = []),\r\n            this\r\n          )\r\n        }),\r\n        (this.callback = function (t) {\r\n          return (this._callback = t), this\r\n        }),\r\n        (this.display = function () {\r\n          var e,\r\n            t,\r\n            r,\r\n            a,\r\n            n = this._callback,\r\n            o = this.manual_callback,\r\n            i = this.manual_map\r\n          r = Object.keys(this.feature_set)\r\n          var s,\r\n            c = function (t) {\r\n              return e[t]\r\n            }\r\n          for (s = 0; s < this._data.length; s++) {\r\n            ;(e = this._data[s]), (t = r.map(c))\r\n            for (var l = 0; l < r.length; l++)\r\n              (a = r[l]), -1 === this.feature_set[a].indexOf(t[l]) && this.feature_set[a].push(t[l])\r\n          }\r\n          for (a in this.feature_set) this.sorters.hasOwnProperty(a) && this.feature_set[a].sort(this.sorters[a])\r\n          $(this.target).empty(), $(this.target).append(\"<div class='col-lg-12 segments text-center'></div>\")\r\n          var u = function () {\r\n            var t,\r\n              e = $(this).data('key'),\r\n              r = $(this).data('feature')\r\n            return (\r\n              $('.' + r + '-btns button.btn span.title').html(e),\r\n              i.hasOwnProperty(r) ? ((t = i[r]), o[t](e)) : n(r, e),\r\n              !1\r\n            )\r\n          }\r\n          for (var d in this.feature_set) {\r\n            for (\r\n              r = this.feature_set[d],\r\n                $(this.target + ' div.segments').append(\r\n                  '<div class=\"btn-group ' +\r\n                    this._strip_punctuation(d) +\r\n                    '-btns text-left\"><button type=\"button\" class=\"btn btn-default btn-lg dropdown-toggle\" data-toggle=\"dropdown\"><span class=\\'which-button\\'>' +\r\n                    (this.public_name.hasOwnProperty(d) ? this.public_name[d] : d) +\r\n                    \"</span><span class='title'>\" +\r\n                    (this.manual_callback.hasOwnProperty(d) ? this.feature_set[d][0] : 'all') +\r\n                    '</span><span class=\"caret\"></span></button><ul class=\"dropdown-menu\" role=\"menu\">' +\r\n                    (this.manual_callback.hasOwnProperty(d)\r\n                      ? ''\r\n                      : '<li><a href=\"#\" data-feature=\"' + d + '\" data-key=\"all\">All</a></li>') +\r\n                    (this.manual_callback.hasOwnProperty(d) ? '' : '<li class=\"divider\"></li>') +\r\n                    '</ul></div>'\r\n                ),\r\n                s = 0;\r\n              s < r.length;\r\n              s++\r\n            )\r\n              'all' !== r[s] &&\r\n                void 0 !== r[s] &&\r\n                $(this.target + ' div.' + this._strip_punctuation(d) + '-btns ul.dropdown-menu').append(\r\n                  '<li><a href=\"#\" data-feature=\"' +\r\n                    this._strip_punctuation(d) +\r\n                    '\" data-key=\"' +\r\n                    r[s] +\r\n                    '\">' +\r\n                    r[s] +\r\n                    '</a></li>'\r\n                )\r\n            $('.' + this._strip_punctuation(d) + '-btns .dropdown-menu li a').on('click', u)\r\n          }\r\n          return this\r\n        }),\r\n        this\r\n      )\r\n    })\r\n  var Zt = function (t, e, r) {\r\n      var a = e.line_id,\r\n        n = r.color,\r\n        o = r.colors\r\n      t.classed('mg-hover-line-color', null === n)\r\n        .classed('mg-hover-line' + a + '-color', null === o)\r\n        .attr('fill', null === o ? '' : o[a - 1])\r\n    },\r\n    Kt = function (r, t, e) {\r\n      ;(t.existing_band = e.selectAll('.mg-confidence-band').nodes()),\r\n        r.show_confidence_band &&\r\n          (t.confidence_area = E.area()\r\n            .defined(t.line.defined())\r\n            .x(r.scalefns.xf)\r\n            .y0(function (t) {\r\n              var e = r.show_confidence_band[0]\r\n              return null != t[e] ? r.scales.Y(t[e]) : r.scales.Y(t[r.y_accessor])\r\n            })\r\n            .y1(function (t) {\r\n              var e = r.show_confidence_band[1]\r\n              return null != t[e] ? r.scales.Y(t[e]) : r.scales.Y(t[r.y_accessor])\r\n            })\r\n            .curve(r.interpolate))\r\n    },\r\n    Jt = function (t, e) {\r\n      var r = t.scalefns,\r\n        a = t.scales,\r\n        n = t.interpolate,\r\n        o = t.flip_area_under_y_value,\r\n        i = Number.isFinite(o) ? a.Y(o) : a.Y.range()[0]\r\n      e.area = E.area()\r\n        .defined(e.line.defined())\r\n        .x(r.xf)\r\n        .y0(function () {\r\n          return i\r\n        })\r\n        .y1(r.yf)\r\n        .curve(n)\r\n    },\r\n    te = function (t, e) {\r\n      var r = t.y_accessor,\r\n        a = t.scalefns,\r\n        n = t.scales,\r\n        o = t.interpolate\r\n      e.flat_line = E.line()\r\n        .defined(function (t) {\r\n          return (void 0 === t._missing || !0 !== t._missing) && null !== t[r]\r\n        })\r\n        .x(a.xf)\r\n        .y(function () {\r\n          return n.Y(e.data_median)\r\n        })\r\n        .curve(o)\r\n    },\r\n    ee = function (t, e) {\r\n      var r = t.scalefns,\r\n        a = t.interpolate,\r\n        n = t.missing_is_zero,\r\n        o = t.y_accessor\r\n      ;(e.line = E.line()\r\n        .x(r.xf)\r\n        .y(r.yf)\r\n        .curve(a)),\r\n        n ||\r\n          (e.line = e.line.defined(function (t) {\r\n            return (void 0 === t._missing || !0 !== t._missing) && null !== t[o]\r\n          }))\r\n    },\r\n    re = function (t, e, r, a) {\r\n      var n = t.show_confidence_band,\r\n        o = t.transition_on_update,\r\n        i = t.data,\r\n        s = t.target\r\n      if (n) {\r\n        r.select('.mg-confidence-band-' + a).empty() &&\r\n          r.append('path').attr('class', 'mg-confidence-band mg-confidence-band-' + a),\r\n          r\r\n            .select('.mg-confidence-band-' + a)\r\n            .transition()\r\n            .duration(function () {\r\n              return o ? 1e3 : 0\r\n            })\r\n            .attr('d', e.confidence_area(i[a - 1]))\r\n            .attr('clip-path', 'url(#mg-plot-window-' + z(s) + ')')\r\n      }\r\n    },\r\n    ae = function (t, e, r, a, n) {\r\n      var o = t.data,\r\n        i = t.target,\r\n        s = t.colors,\r\n        c = r.selectAll('.mg-main-area.mg-area' + n)\r\n      e.display_area\r\n        ? c.empty()\r\n          ? r\r\n              .append('path')\r\n              .classed('mg-main-area', !0)\r\n              .classed('mg-area' + n, !0)\r\n              .classed('mg-area-color', null === s)\r\n              .classed('mg-area' + n + '-color', null === s)\r\n              .attr('d', e.area(o[a]))\r\n              .attr('fill', null === s ? '' : s[n - 1])\r\n              .attr('clip-path', 'url(#mg-plot-window-' + z(i) + ')')\r\n          : (r.node().appendChild(c.node()),\r\n            c\r\n              .transition()\r\n              .duration(e.update_transition_duration)\r\n              .attr('d', e.area(o[a]))\r\n              .attr('clip-path', 'url(#mg-plot-window-' + z(i) + ')'))\r\n        : c.empty() || c.remove()\r\n    },\r\n    ne = function (t, e) {\r\n      t.classed('mg-line-color', !0).classed('mg-line' + e + '-color', !0)\r\n    },\r\n    oe = function (t, e, r, a, n, o) {\r\n      if (a.empty()) {\r\n        var i = r.append('path').attr('class', 'mg-main-line mg-line' + o)\r\n        ;(g = i),\r\n          (h = n),\r\n          (x = o),\r\n          (y = t.colors) && y.constructor === Array ? (g.attr('stroke', y[h]), y.length < h + 1 && ne(g, x)) : ne(g, x),\r\n          (l = e),\r\n          (u = i),\r\n          (d = n),\r\n          (f = (c = t).animate_on_load),\r\n          (p = c.data),\r\n          (_ = c.y_accessor),\r\n          (m = c.target),\r\n          f\r\n            ? ((l.data_median = E.median(p[d], function (t) {\r\n                return t[_]\r\n              })),\r\n              u\r\n                .attr('d', l.flat_line(p[d]))\r\n                .transition()\r\n                .duration(1e3)\r\n                .attr('d', l.line(p[d]))\r\n                .attr('clip-path', 'url(#mg-plot-window-' + z(m) + ')'))\r\n            : u.attr('d', l.line(p[d])).attr('clip-path', 'url(#mg-plot-window-' + z(m) + ')')\r\n      } else {\r\n        r.node().appendChild(a.node())\r\n        var s = a.transition().duration(e.update_transition_duration)\r\n        e.display_area || !t.transition_on_update || t.missing_is_hidden\r\n          ? s.attr('d', e.line(t.data[n]))\r\n          : s.attrTween('d', je(e.line(t.data[n]), 4))\r\n      }\r\n      var c, l, u, d, f, p, _, m, g, h, x, y\r\n    },\r\n    ie = function (t, e, r, a) {\r\n      var n,\r\n        o = void 0\r\n      if (t.legend)\r\n        if (\r\n          (u(t.legend)\r\n            ? (o = t.legend[r])\r\n            : ((n = t.legend), '[object Function]' === Object.prototype.toString.call(n) && (o = t.legend(t.data[r]))),\r\n          t.legend_target)\r\n        )\r\n          t.colors && t.colors.constructor === Array\r\n            ? (e.legend_text =\r\n                \"<span style='color:\" + t.colors[r] + \"'>&mdash; \" + o + '&nbsp; </span>' + e.legend_text)\r\n            : (e.legend_text =\r\n                \"<span class='mg-line\" + a + \"-legend-color'>&mdash; \" + o + '&nbsp; </span>' + e.legend_text)\r\n        else {\r\n          var i = void 0,\r\n            s = void 0,\r\n            c = void 0\r\n          'left' === t.y_axis_position\r\n            ? ((i = t.data[r][t.data[r].length - 1]), (s = 'start'), (c = t.buffer))\r\n            : ((i = t.data[r][0]), (s = 'end'), (c = -t.buffer))\r\n          var l = e.legend_group\r\n            .append('svg:text')\r\n            .attr('x', t.scalefns.xf(i))\r\n            .attr('dx', c)\r\n            .attr('y', t.scalefns.yf(i))\r\n            .attr('dy', '.35em')\r\n            .attr('font-size', 10)\r\n            .attr('text-anchor', s)\r\n            .attr('font-weight', '300')\r\n            .text(o)\r\n          t.colors && t.colors.constructor === Array\r\n            ? t.colors.length < r + 1\r\n              ? l.classed('mg-line' + a + '-legend-color', !0)\r\n              : l.attr('fill', t.colors[r])\r\n            : l.classed('mg-line-legend-color', !0).classed('mg-line' + a + '-legend-color', !0),\r\n            (function (t, e) {\r\n              if (t && 1 != t.length) {\r\n                var r, a, n\r\n                t.sort(function (t, e) {\r\n                  return E.select(e).attr('y') - E.select(t).attr('y')\r\n                }),\r\n                  t.reverse()\r\n                for (var o = 0; o < t.length; o++) {\r\n                  a = E.select(t[o]).text()\r\n                  for (var i = 0; i < t.length; i++)\r\n                    if (\r\n                      ((n = E.select(t[i]).text()),\r\n                      !1 !==\r\n                        ((l = t[o]),\r\n                        (u = t[i]),\r\n                        void 0,\r\n                        (d = l.getBoundingClientRect()),\r\n                        (f = u.getBoundingClientRect()),\r\n                        (r = d.top <= f.bottom && d.top >= f.top && f.bottom - d.top)) && a !== n)\r\n                    ) {\r\n                      var s = E.select(t[o]),\r\n                        c = +s.attr('y')\r\n                      ;(c += r), s.attr('y', c)\r\n                    }\r\n                }\r\n              }\r\n              var l, u, d, f\r\n            })(e.legend_group.selectAll('.mg-line-legend text').nodes())\r\n        }\r\n    },\r\n    se = function (e, t, r, a, n, o) {\r\n      var i,\r\n        s,\r\n        c,\r\n        l = E.voronoi()\r\n          .x(function (t) {\r\n            return e.scales.X(t[e.x_accessor]).toFixed(2)\r\n          })\r\n          .y(function (t) {\r\n            return e.scales.Y(t[e.y_accessor]).toFixed(2)\r\n          })\r\n          .extent([\r\n            [e.buffer, e.buffer + (e.title ? e.title_y_position : 0)],\r\n            [e.width - e.buffer, e.height - e.buffer]\r\n          ])\r\n      S(t, 'mg-voronoi')\r\n        .selectAll('path')\r\n        .data(l.polygons(((s = e), (c = s.data), E.merge(c))))\r\n        .enter()\r\n        .append('path')\r\n        .filter(function (t) {\r\n          return void 0 !== t && 0 < t.length\r\n        })\r\n        .attr('d', function (t) {\r\n          return null == t ? null : 'M' + t.join('L') + 'Z'\r\n        })\r\n        .datum(function (t) {\r\n          return null == t ? null : t.data\r\n        })\r\n        .attr(\r\n          'class',\r\n          ((i = e),\r\n          function (t) {\r\n            var e = void 0\r\n            if (i.linked) {\r\n              var r = t[i.x_accessor],\r\n                a = MG.time_format(i.utc_time, i.linked_format)\r\n              return (\r\n                (e = 'roll_' + ('number' == typeof r ? t.line_id - 1 : a(r)) + ' mg-line' + t.line_id),\r\n                null === i.color && (e += ' mg-line' + t.line_id + '-color'),\r\n                e\r\n              )\r\n            }\r\n            return (e = 'mg-line' + t.line_id), null === i.color && (e += ' mg-line' + t.line_id + '-color'), e\r\n          })\r\n        )\r\n        .on('click', o)\r\n        .on('mouseover', r)\r\n        .on('mouseout', a)\r\n        .on('mousemove', n),\r\n        le(e, t)\r\n    },\r\n    ce = function (a, t, e, r, n, o) {\r\n      var i,\r\n        s,\r\n        c,\r\n        l,\r\n        u,\r\n        d = ((s = (i = a).x_accessor),\r\n        (c = i.data),\r\n        (l = i.x_sort),\r\n        (u = E.nest()\r\n          .key(function (t) {\r\n            return t[s]\r\n          })\r\n          .entries(E.merge(c))).forEach(function (t) {\r\n          var e = t.values[0]\r\n          t.key = e[s]\r\n        }),\r\n        l\r\n          ? u.sort(function (t, e) {\r\n              return new Date(t.key) - new Date(e.key)\r\n            })\r\n          : u),\r\n        f = d.map(function (t) {\r\n          var e = t.key\r\n          return a.scales.X(e)\r\n        })\r\n      t\r\n        .append('g')\r\n        .attr('class', 'mg-rollover-rect')\r\n        .selectAll('.mg-rollover-rects')\r\n        .data(d)\r\n        .enter()\r\n        .append('rect')\r\n        .attr('x', function (t, e) {\r\n          return 1 === f.length ? Y(a) : 0 === e ? f[e].toFixed(2) : ((f[e - 1] + f[e]) / 2).toFixed(2)\r\n        })\r\n        .attr('y', a.top)\r\n        .attr('width', function (t, e) {\r\n          return 1 === f.length\r\n            ? P(a)\r\n            : 0 === e\r\n            ? ((f[e + 1] - f[e]) / 2).toFixed(2)\r\n            : e === f.length - 1\r\n            ? ((f[e] - f[e - 1]) / 2).toFixed(2)\r\n            : ((f[e + 1] - f[e - 1]) / 2).toFixed(2)\r\n        })\r\n        .attr('class', function (t) {\r\n          var e = t.values,\r\n            r = e\r\n              .map(function (t) {\r\n                var e = t.line_id,\r\n                  r = ue(e)\r\n                return null === a.colors && (r += ' ' + de(e)), r\r\n              })\r\n              .join(' ')\r\n          return a.linked && 0 < e.length && (r += ' ' + fe(pe(e[0], a))), r\r\n        })\r\n        .attr('height', a.height - a.bottom - a.top - a.buffer)\r\n        .attr('opacity', 0)\r\n        .on('click', o)\r\n        .on('mouseover', e)\r\n        .on('mouseout', r)\r\n        .on('mousemove', n),\r\n        _e(a, t)\r\n    },\r\n    le = function (t, e) {\r\n      for (var r = t.data, a = t.custom_line_color_map, n = 0; n < r.length; n++) {\r\n        var o = n + 1\r\n        0 < a.length && void 0 !== a[n] && (o = a[n]),\r\n          1 !== r[n].length ||\r\n            e.selectAll('.mg-voronoi .mg-line' + o).empty() ||\r\n            (e.selectAll('.mg-voronoi .mg-line' + o).on('mouseover')(r[n][0], 0),\r\n            e.selectAll('.mg-voronoi .mg-line' + o).on('mouseout')(r[n][0], 0))\r\n      }\r\n    },\r\n    ue = function (t) {\r\n      return 'mg-line' + t\r\n    },\r\n    de = function (t) {\r\n      return 'mg-line' + t + '-color'\r\n    },\r\n    fe = function (t) {\r\n      return 'roll_' + t\r\n    },\r\n    pe = function (t, e) {\r\n      var r = e.x_accessor,\r\n        a = e.utc_time,\r\n        n = e.linked_format,\r\n        o = t[r],\r\n        i = MG.time_format(a, n)\r\n      return 'number' == typeof o ? o.toString().replace('.', '_') : i(o)\r\n    },\r\n    _e = function (t, e) {\r\n      var r = t.data,\r\n        a = e.selectAll('.mg-rollover-rect rect'),\r\n        n = a.nodes()[0][0] || a.nodes()[0]\r\n      0 <\r\n        r.filter(function (t) {\r\n          return 1 === t.length\r\n        }).length && a.on('mouseover')(n.__data__, 0)\r\n    },\r\n    me = function (t) {\r\n      var e = t.data\r\n      return 1 === e.length && 1 === e[0].length\r\n    },\r\n    ge = function (t, e) {\r\n      var r = t.existing_band\r\n      r[0] && r[0].length > e.selectAll('.mg-main-line').node().length && e.selectAll('.mg-confidence-band').remove()\r\n    },\r\n    he = function (t) {\r\n      var e,\r\n        r,\r\n        a,\r\n        n,\r\n        o,\r\n        i,\r\n        s,\r\n        c = {},\r\n        l = O(t.target)\r\n      D(l, '.mg-line-legend'),\r\n        (e = c),\r\n        (r = l),\r\n        t.legend && (e.legend_group = S(r, 'mg-line-legend')),\r\n        (c.data_median = 0),\r\n        (c.update_transition_duration = t.transition_on_update ? 1e3 : 0),\r\n        (c.display_area =\r\n          (t.area && !t.use_data_y_min && t.data.length <= 1 && !1 === t.aggregate_rollover) ||\r\n          (Array.isArray(t.area) && 0 < t.area.length)),\r\n        (c.legend_text = ''),\r\n        (o = l),\r\n        ee((a = t), (n = c)),\r\n        Jt(a, n),\r\n        te(a, n),\r\n        Kt(a, n, o),\r\n        (c.existing_band = l.selectAll('.mg-confidence-band').nodes()),\r\n        !1 !== MG.call_hook('line.before_all_series', [t]) &&\r\n          (function (e, t, r) {\r\n            ge(t, r), e.active_point_on_lines && r.selectAll('circle.mg-shown-active-point').remove()\r\n            for (var a = e.data.length - 1; 0 <= a; a--) {\r\n              var n = e.data[a]\r\n              MG.call_hook('line.before_each_series', [n, e])\r\n              var o = a + 1\r\n              if (\r\n                (0 < e.custom_line_color_map.length && (o = e.custom_line_color_map[a]),\r\n                (e.data[a].line_id = o),\r\n                e.active_point_on_lines &&\r\n                  r\r\n                    .selectAll('circle-' + o)\r\n                    .data(e.data[a])\r\n                    .enter()\r\n                    .filter(function (t) {\r\n                      return t[e.active_point_accessor]\r\n                    })\r\n                    .append('circle')\r\n                    .attr('class', 'mg-area' + o + '-color mg-shown-active-point')\r\n                    .attr('cx', e.scalefns.xf)\r\n                    .attr('cy', e.scalefns.yf)\r\n                    .attr('r', function () {\r\n                      return e.active_point_size\r\n                    }),\r\n                0 !== n.length)\r\n              ) {\r\n                var i = r.select('path.mg-main-line.mg-line' + o)\r\n                re(e, t, r, o),\r\n                  Array.isArray(e.area) ? e.area[o - 1] && ae(e, t, r, a, o) : ae(e, t, r, a, o),\r\n                  oe(e, t, r, i, a, o),\r\n                  ie(e, t, a, o),\r\n                  MG.call_hook('line.after_each_series', [n, i, e])\r\n              }\r\n            }\r\n          })(t, c, l),\r\n        (i = t.legend_target),\r\n        (s = c.legend_text),\r\n        i && E.select(i).html(s)\r\n    },\r\n    xe = function (t, e) {\r\n      var r,\r\n        a,\r\n        n,\r\n        o,\r\n        i,\r\n        s,\r\n        c,\r\n        l,\r\n        u,\r\n        d,\r\n        f,\r\n        p,\r\n        _ = O(t.target)\r\n      t.showActivePoint &&\r\n        0 === _.selectAll('.mg-active-datapoint-container').nodes().length &&\r\n        S(_, 'mg-active-datapoint-container'),\r\n        D((r = _), '.mg-rollover-rect'),\r\n        D(r, '.mg-voronoi'),\r\n        D(r, '.mg-active-datapoint'),\r\n        D(r, '.mg-line-rollover-circle'),\r\n        (n = _),\r\n        (o = (a = t).data),\r\n        (i = a.colors),\r\n        (s = n\r\n          .selectAll('.mg-line-rollover-circle')\r\n          .data(o)\r\n          .enter()\r\n          .append('circle')\r\n          .attr('cx', 0)\r\n          .attr('cy', 0)\r\n          .attr('r', 0)),\r\n        i && i.constructor === Array\r\n          ? s\r\n              .attr('class', function (t) {\r\n                return 'mg-line' + t.line_id\r\n              })\r\n              .attr('fill', function (t, e) {\r\n                return i[e]\r\n              })\r\n              .attr('stroke', function (t, e) {\r\n                return i[e]\r\n              })\r\n          : s.attr('class', function (t, e) {\r\n              var r = t.line_id\r\n              return ['mg-line' + r, 'mg-line' + r + '-color', 'mg-area' + r + '-color'].join(' ')\r\n            }),\r\n        s.classed('mg-line-rollover-circle', !0),\r\n        (function (t) {\r\n          for (var e = t.data, r = t.custom_line_color_map, a = 0; a < e.length; a++)\r\n            for (var n = 0; n < e[a].length; n++)\r\n              (e[a][n].index = a + 1), 0 < r.length ? (e[a][n].line_id = r[a]) : (e[a][n].line_id = a + 1)\r\n        })(t),\r\n        (f = (d = t).data),\r\n        (p = d.aggregate_rollover),\r\n        1 < f.length && !p\r\n          ? se(t, _, e.rolloverOn(t), e.rolloverOff(t), e.rolloverMove(t), e.rolloverClick(t))\r\n          : ((l = (c = t).data),\r\n            (u = c.aggregate_rollover),\r\n            1 < l.length && u\r\n              ? ce(t, _, e.rolloverOn(t), e.rolloverOff(t), e.rolloverMove(t), e.rolloverClick(t))\r\n              : (function (a, t, e, r, n, o) {\r\n                  var i = 1\r\n                  0 < a.custom_line_color_map.length && (i = a.custom_line_color_map[0])\r\n                  var s,\r\n                    c,\r\n                    l = t.append('g').attr('class', 'mg-rollover-rect'),\r\n                    u = a.data[0].map(a.scalefns.xf)\r\n                  l\r\n                    .selectAll('.mg-rollover-rects')\r\n                    .data(a.data[0])\r\n                    .enter()\r\n                    .append('rect')\r\n                    .attr('class', function (t, e) {\r\n                      var r = de(i) + ' ' + ue(t.line_id)\r\n                      return a.linked && (r += r + ' ' + fe(pe(t, a))), r\r\n                    })\r\n                    .attr('x', function (t, e) {\r\n                      return 1 === u.length ? Y(a) : 0 === e ? u[e].toFixed(2) : ((u[e - 1] + u[e]) / 2).toFixed(2)\r\n                    })\r\n                    .attr('y', function (t, e) {\r\n                      return 1 < a.data.length ? a.scalefns.yf(t) - 6 : a.top\r\n                    })\r\n                    .attr('width', function (t, e) {\r\n                      return 1 === u.length\r\n                        ? P(a)\r\n                        : 0 === e\r\n                        ? ((u[e + 1] - u[e]) / 2).toFixed(2)\r\n                        : e === u.length - 1\r\n                        ? ((u[e] - u[e - 1]) / 2).toFixed(2)\r\n                        : ((u[e + 1] - u[e - 1]) / 2).toFixed(2)\r\n                    })\r\n                    .attr('height', function (t, e) {\r\n                      return 1 < a.data.length ? 12 : a.height - a.bottom - a.top - a.buffer\r\n                    })\r\n                    .attr('opacity', 0)\r\n                    .on('click', o)\r\n                    .on('mouseover', e)\r\n                    .on('mouseout', r)\r\n                    .on('mousemove', n),\r\n                    me(a) && ((s = t), (c = a.data), s.select('.mg-rollover-rect rect').on('mouseover')(c[0][0], 0))\r\n                })(t, _, e.rolloverOn(t), e.rolloverOff(t), e.rolloverMove(t), e.rolloverClick(t)))\r\n    },\r\n    ye = function (t, e, r) {\r\n      var a = t.scales,\r\n        n = t.x_accessor,\r\n        o = t.y_accessor,\r\n        i = t.point_size\r\n      e.select('circle.mg-line-rollover-circle.mg-line' + r.line_id)\r\n        .attr('cx', a.X(r[n]).toFixed(2))\r\n        .attr('cy', a.Y(r[o]).toFixed(2))\r\n        .attr('r', i)\r\n        .style('opacity', 1)\r\n    },\r\n    ve = function (t, e, r) {\r\n      var a = t.scales,\r\n        n = t.x_accessor,\r\n        o = t.y_accessor,\r\n        i = t.point_size\r\n      e.selectAll('circle.mg-line-rollover-circle.mg-line' + r.line_id)\r\n        .classed('mg-line-rollover-circle', !0)\r\n        .attr('cx', function () {\r\n          return a.X(r[n]).toFixed(2)\r\n        })\r\n        .attr('cy', function () {\r\n          return a.Y(r[o]).toFixed(2)\r\n        })\r\n        .attr('r', i)\r\n        .style('opacity', 1)\r\n    }\r\n  MG.register('line', function (t) {\r\n    ;(this.init = function (e) {\r\n      if (!(this.args = e).data || 0 === e.data.length)\r\n        return (\r\n          (e.internal_error = 'No data was supplied'),\r\n          (t = e),\r\n          console.error('INTERNAL ERROR : ', t.target, ' : ', t.internal_error),\r\n          this\r\n        )\r\n      var t\r\n      ;(e.internal_error = void 0),\r\n        Me(e),\r\n        Ae(e),\r\n        MG.call_hook('line.before_destroy', this),\r\n        Ot(e),\r\n        new MG.scale_factory(e)\r\n          .namespace('x')\r\n          .numericalDomainFromData()\r\n          .numericalRange('bottom')\r\n      var r = (e.baselines || []).map(function (t) {\r\n        return t[e.y_accessor]\r\n      })\r\n      return (\r\n        new MG.scale_factory(e)\r\n          .namespace('y')\r\n          .zeroBottom(!0)\r\n          .inflateDomain(!0)\r\n          .numericalDomainFromData(r)\r\n          .numericalRange('left'),\r\n        e.x_axis &&\r\n          new MG.axis_factory(e)\r\n            .namespace('x')\r\n            .type('numerical')\r\n            .position(e.x_axis_position)\r\n            .rug(nt(e))\r\n            .label(st)\r\n            .draw(),\r\n        e.y_axis &&\r\n          new MG.axis_factory(e)\r\n            .namespace('y')\r\n            .type('numerical')\r\n            .position(e.y_axis_position)\r\n            .rug(K(e))\r\n            .label(et)\r\n            .draw(),\r\n        this.markers(),\r\n        this.mainPlot(),\r\n        this.rollover(),\r\n        this.windowListeners(),\r\n        e.brush && MG.add_brush_function(e),\r\n        MG.call_hook('line.after_init', this),\r\n        this\r\n      )\r\n    }),\r\n      (this.mainPlot = function () {\r\n        return he(t), this\r\n      }),\r\n      (this.markers = function () {\r\n        return St(t), this\r\n      }),\r\n      (this.rollover = function () {\r\n        return xe(t, this), MG.call_hook('line.after_rollover', t), this\r\n      }),\r\n      (this.rolloverClick = function (r) {\r\n        return function (t, e) {\r\n          r.click && r.click(t, e)\r\n        }\r\n      }),\r\n      (this.rolloverOn = function (n) {\r\n        var o = O(n.target)\r\n        return function (r, t) {\r\n          if (\r\n            ((function (a, n, t) {\r\n              if (a.aggregate_rollover && 1 < a.data.length)\r\n                n.selectAll('circle.mg-line-rollover-circle').style('opacity', 0),\r\n                  t.values.forEach(function (t, e, r) {\r\n                    ;(a.missing_is_hidden && r[e]._missing) || (i(t, a) && ye(a, n, t))\r\n                  })\r\n              else {\r\n                if ((a.missing_is_hidden && t._missing) || null === t[a.y_accessor]) return\r\n                i(t, a) && ve(a, n, t)\r\n              }\r\n            })(n, o, r),\r\n            (function (t, e, r) {\r\n              if (\r\n                t.linked &&\r\n                !MG.globals.link &&\r\n                ((MG.globals.link = !0),\r\n                !t.aggregate_rollover || void 0 !== e[t.y_accessor] || (e.values && 0 < e.values.length))\r\n              ) {\r\n                var a = e.values ? e.values[0] : e,\r\n                  n = pe(a, t)\r\n                E.selectAll('.' + ue(a.line_id) + '.' + fe(n)).each(function (t) {\r\n                  E.select(this).on('mouseover')(t, r)\r\n                })\r\n              }\r\n            })(n, r, t),\r\n            o\r\n              .selectAll('text')\r\n              .filter(function (t, e) {\r\n                return r === t\r\n              })\r\n              .attr('opacity', 0.3),\r\n            n.show_rollover_text && !((n.missing_is_hidden && r._missing) || null === r[n.y_accessor]))\r\n          ) {\r\n            var e = Xt(n, { svg: o }),\r\n              a = e.mouseover_row()\r\n            n.aggregate_rollover &&\r\n              a.text(\r\n                (n.aggregate_rollover && 1 < n.data.length\r\n                  ? function (t, e) {\r\n                      return Pe(t, e, t.x_mouseover, 'key', t.time_series)\r\n                    }\r\n                  : Se)(n, r)\r\n              ),\r\n              (n.aggregate_rollover && 1 < n.data.length ? r.values : [r]).forEach(function (t) {\r\n                n.aggregate_rollover && (a = e.mouseover_row()),\r\n                  n.legend && Zt(a.text(n.legend[t.index - 1] + '  ').bold(), t, n),\r\n                  Zt(a.text('  ').elem, t, n),\r\n                  n.aggregate_rollover || a.text(Se(n, t)),\r\n                  a.text(Le(n, t, n.time_series))\r\n              })\r\n          }\r\n          n.mouseover && n.mouseover(r, t)\r\n        }\r\n      }),\r\n      (this.rolloverOff = function (c) {\r\n        var l = O(c.target)\r\n        return function (t, e) {\r\n          var r, a, n, o, i, s\r\n          !(function (t, e, a) {\r\n            var r = t.linked,\r\n              n = t.utc_time,\r\n              o = t.linked_format,\r\n              i = t.x_accessor\r\n            if (r && MG.globals.link) {\r\n              MG.globals.link = !1\r\n              var s = MG.time_format(n, o)\r\n              ;(e.values ? e.values : [e]).forEach(function (t) {\r\n                var e = t[i],\r\n                  r = 'number' == typeof e ? a : s(e)\r\n                E.selectAll('.roll_' + r).each(function (t) {\r\n                  E.select(this).on('mouseout')(t)\r\n                })\r\n              })\r\n            }\r\n          })(c, t, e),\r\n            c.aggregate_rollover\r\n              ? l\r\n                  .selectAll('circle.mg-line-rollover-circle')\r\n                  .filter(function (t) {\r\n                    return 1 < t.length\r\n                  })\r\n                  .style('opacity', 0)\r\n              : ((a = l),\r\n                (n = t),\r\n                (o = (r = c).custom_line_color_map),\r\n                (i = r.data),\r\n                (s = n.line_id),\r\n                a.selectAll('circle.mg-line-rollover-circle.mg-line' + s).style('opacity', function () {\r\n                  var t = s - 1\r\n                  return 0 < o.length && void 0 !== o.indexOf(s) && (t = o.indexOf(s)), 1 === i[t].length ? 1 : 0\r\n                })),\r\n            1 < c.data[0].length && Lt(l),\r\n            c.mouseout && c.mouseout(t, e)\r\n        }\r\n      }),\r\n      (this.rolloverMove = function (r) {\r\n        return function (t, e) {\r\n          r.mousemove && r.mousemove(t, e)\r\n        }\r\n      }),\r\n      (this.windowListeners = function () {\r\n        return Qt(this.args), this\r\n      }),\r\n      this.init(t)\r\n  })\r\n  function be (t, e, r) {\r\n    var a,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c = Xt(t, { svg: e }).mouseover_row()\r\n    if (null !== t.color_accessor && 'category' === t.color_type) {\r\n      var l = r[t.color_accessor]\r\n      c.text(l + '  ')\r\n        .bold()\r\n        .attr('fill', t.scalefns.colorf(r))\r\n    }\r\n    ;(a = t),\r\n      (n = c.text('   ').elem),\r\n      (o = r),\r\n      (i = a.color_accessor),\r\n      (s = a.scalefns),\r\n      null !== i ? (n.attr('fill', s.colorf(o)), n.attr('stroke', s.colorf(o))) : n.classed('mg-points-mono', !0),\r\n      c.text(Se(t, r)),\r\n      c.text(Le(t, r, t.time_series))\r\n  }\r\n  MG.register(\r\n    'histogram',\r\n    function (r) {\r\n      var a = this\r\n      ;(this.init = function (e) {\r\n        Me((a.args = e)),\r\n          De(e),\r\n          Ot(e),\r\n          new MG.scale_factory(e)\r\n            .namespace('x')\r\n            .numericalDomainFromData()\r\n            .numericalRange('bottom')\r\n        var t = (e.baselines || []).map(function (t) {\r\n          return t[e.y_accessor]\r\n        })\r\n        return (\r\n          new MG.scale_factory(e)\r\n            .namespace('y')\r\n            .zeroBottom(!0)\r\n            .inflateDomain(!0)\r\n            .numericalDomainFromData(t)\r\n            .numericalRange('left'),\r\n          ot(e),\r\n          rt(e),\r\n          a.mainPlot(),\r\n          a.markers(),\r\n          a.rollover(),\r\n          a.windowListeners(),\r\n          a\r\n        )\r\n      }),\r\n        (this.mainPlot = function () {\r\n          var t = O(r.target)\r\n          return (\r\n            t.selectAll('.mg-histogram').remove(),\r\n            t\r\n              .append('g')\r\n              .attr('class', 'mg-histogram')\r\n              .selectAll('.mg-bar')\r\n              .data(r.data[0])\r\n              .enter()\r\n              .append('g')\r\n              .attr('class', 'mg-bar')\r\n              .attr('transform', function (t) {\r\n                return (\r\n                  'translate(' +\r\n                  r.scales.X(t[r.x_accessor]).toFixed(2) +\r\n                  ',' +\r\n                  r.scales.Y(t[r.y_accessor]).toFixed(2) +\r\n                  ')'\r\n                )\r\n              })\r\n              .append('rect')\r\n              .attr('x', 1)\r\n              .attr('width', function (t, e) {\r\n                return 1 === r.data[0].length\r\n                  ? (r.scalefns.xf(r.data[0][0]) - r.bar_margin).toFixed(0)\r\n                  : e !== r.data[0].length - 1\r\n                  ? (r.scalefns.xf(r.data[0][e + 1]) - r.scalefns.xf(t)).toFixed(0)\r\n                  : (r.scalefns.xf(r.data[0][1]) - r.scalefns.xf(r.data[0][0])).toFixed(0)\r\n              })\r\n              .attr('height', function (t) {\r\n                return 0 === t[r.y_accessor]\r\n                  ? 0\r\n                  : (r.height - r.bottom - r.buffer - r.scales.Y(t[r.y_accessor])).toFixed(2)\r\n              }),\r\n            a\r\n          )\r\n        }),\r\n        (this.markers = function () {\r\n          return St(r), a\r\n        }),\r\n        (this.rollover = function () {\r\n          var t = O(r.target)\r\n          return (\r\n            0 === t.selectAll('.mg-active-datapoint-container').nodes().length && S(t, 'mg-active-datapoint-container'),\r\n            t.selectAll('.mg-rollover-rect').remove(),\r\n            t.selectAll('.mg-active-datapoint').remove(),\r\n            t\r\n              .append('g')\r\n              .attr('class', 'mg-rollover-rect')\r\n              .selectAll('.mg-bar')\r\n              .data(r.data[0])\r\n              .enter()\r\n              .append('g')\r\n              .attr('class', function (t, e) {\r\n                return r.linked ? 'mg-rollover-rects roll_' + e : 'mg-rollover-rects'\r\n              })\r\n              .attr('transform', function (t) {\r\n                return 'translate(' + r.scales.X(t[r.x_accessor]) + ',0)'\r\n              })\r\n              .append('rect')\r\n              .attr('x', 1)\r\n              .attr('y', r.buffer + (r.title ? r.title_y_position : 0))\r\n              .attr('width', function (t, e) {\r\n                return 1 === r.data[0].length\r\n                  ? (r.scalefns.xf(r.data[0][0]) - r.bar_margin).toFixed(0)\r\n                  : e !== r.data[0].length - 1\r\n                  ? (r.scalefns.xf(r.data[0][e + 1]) - r.scalefns.xf(t)).toFixed(0)\r\n                  : (r.scalefns.xf(r.data[0][1]) - r.scalefns.xf(r.data[0][0])).toFixed(0)\r\n              })\r\n              .attr('height', function (t) {\r\n                return r.height\r\n              })\r\n              .attr('opacity', 0)\r\n              .on('mouseover', a.rolloverOn(r))\r\n              .on('mouseout', a.rolloverOff(r))\r\n              .on('mousemove', a.rolloverMove(r)),\r\n            a\r\n          )\r\n        }),\r\n        (this.rolloverOn = function (e) {\r\n          var n = O(e.target)\r\n          return function (r, a) {\r\n            if (\r\n              (n\r\n                .selectAll('text')\r\n                .filter(function (t, e) {\r\n                  return r === t\r\n                })\r\n                .attr('opacity', 0.3),\r\n              e.processed.xax_format || MG.time_format(e.utc_time, '%b %e, %Y'),\r\n              Ee(e),\r\n              n\r\n                .selectAll('.mg-bar rect')\r\n                .filter(function (t, e) {\r\n                  return e === a\r\n                })\r\n                .classed('active', !0),\r\n              e.linked &&\r\n                !MG.globals.link &&\r\n                ((MG.globals.link = !0),\r\n                E.selectAll('.mg-rollover-rects.roll_' + a + ' rect').each(function (t) {\r\n                  E.select(this).on('mouseover')(t, a)\r\n                })),\r\n              e.show_rollover_text)\r\n            ) {\r\n              var t = Xt(e, { svg: n }).mouseover_row()\r\n              t.text('  ').elem.classed('hist-symbol', !0), t.text(Se(e, r)), t.text(Le(e, r, e.time_series))\r\n            }\r\n            e.mouseover && (jt(n, e), e.mouseover(r, a))\r\n          }\r\n        }),\r\n        (this.rolloverOff = function (r) {\r\n          var a = O(r.target)\r\n          return function (t, e) {\r\n            r.linked &&\r\n              MG.globals.link &&\r\n              ((MG.globals.link = !1),\r\n              E.selectAll('.mg-rollover-rects.roll_' + e + ' rect').each(function (t) {\r\n                E.select(this).on('mouseout')(t, e)\r\n              })),\r\n              a.selectAll('.mg-bar rect').classed('active', !1),\r\n              Lt(a),\r\n              r.mouseout && r.mouseout(t, e)\r\n          }\r\n        }),\r\n        (this.rolloverMove = function (r) {\r\n          return function (t, e) {\r\n            r.mousemove && r.mousemove(t, e)\r\n          }\r\n        }),\r\n        (this.windowListeners = function () {\r\n          return Qt(a.args), a\r\n        }),\r\n        this.init(r)\r\n    },\r\n    {\r\n      binned: !1,\r\n      bins: null,\r\n      processed_x_accessor: 'x',\r\n      processed_y_accessor: 'y',\r\n      processed_dx_accessor: 'dx',\r\n      bar_margin: 1\r\n    }\r\n  )\r\n  var we = function (t, e) {\r\n    var r = e.x_accessor,\r\n      a = e.y_accessor\r\n    return t.filter(function (t) {\r\n      return (\r\n        (null === e.min_x || t[r] >= e.min_x) &&\r\n        (null === e.max_x || t[r] <= e.max_x) &&\r\n        (null === e.min_y || t[a] >= e.min_y) &&\r\n        (null === e.max_y || t[a] <= e.max_y)\r\n      )\r\n    })\r\n  }\r\n  MG.register(\r\n    'point',\r\n    function (a) {\r\n      var o = this\r\n      ;(this.init = function (e) {\r\n        if (\r\n          (((this.args = e).x_axis_type = s(e, 'x')),\r\n          (e.y_axis_type = s(e, 'y')),\r\n          Me(e),\r\n          Oe(e),\r\n          Ot(e),\r\n          'categorical' === e.x_axis_type\r\n            ? (MG.scale_factory(e)\r\n                .namespace('x')\r\n                .categoricalDomainFromData()\r\n                .categoricalRangeBands([0, e.xgroup_height], null === e.xgroup_accessor),\r\n              e.xgroup_accessor\r\n                ? new MG.scale_factory(e)\r\n                    .namespace('xgroup')\r\n                    .categoricalDomainFromData()\r\n                    .categoricalRangeBands('bottom')\r\n                : ((e.scales.XGROUP = function () {\r\n                    return Y(e)\r\n                  }),\r\n                  (e.scalefns.xgroupf = function () {\r\n                    return Y(e)\r\n                  })),\r\n              (e.scalefns.xoutf = function (t) {\r\n                return e.scalefns.xf(t) + e.scalefns.xgroupf(t)\r\n              }))\r\n            : (MG.scale_factory(e)\r\n                .namespace('x')\r\n                .inflateDomain(!0)\r\n                .zeroBottom('categorical' === e.y_axis_type)\r\n                .numericalDomainFromData(\r\n                  (e.baselines || []).map(function (t) {\r\n                    return t[e.x_accessor]\r\n                  })\r\n                )\r\n                .numericalRange('bottom'),\r\n              (e.scalefns.xoutf = e.scalefns.xf)),\r\n          'categorical' === e.y_axis_type)\r\n        )\r\n          MG.scale_factory(e)\r\n            .namespace('y')\r\n            .zeroBottom(!0)\r\n            .categoricalDomainFromData()\r\n            .categoricalRangeBands([0, e.ygroup_height], !0),\r\n            e.ygroup_accessor\r\n              ? new MG.scale_factory(e)\r\n                  .namespace('ygroup')\r\n                  .categoricalDomainFromData()\r\n                  .categoricalRangeBands('left')\r\n              : ((e.scales.YGROUP = function () {\r\n                  return b(e)\r\n                }),\r\n                (e.scalefns.ygroupf = function () {\r\n                  return b(e)\r\n                })),\r\n            (e.scalefns.youtf = function (t) {\r\n              return e.scalefns.yf(t) + e.scalefns.ygroupf(t)\r\n            })\r\n        else {\r\n          var t = (e.baselines || []).map(function (t) {\r\n            return t[e.y_accessor]\r\n          })\r\n          MG.scale_factory(e)\r\n            .namespace('y')\r\n            .inflateDomain(!0)\r\n            .zeroBottom('categorical' === e.x_axis_type)\r\n            .numericalDomainFromData(t)\r\n            .numericalRange('left'),\r\n            (e.scalefns.youtf = function (t) {\r\n              return e.scalefns.yf(t)\r\n            })\r\n        }\r\n        if (null !== e.color_accessor) {\r\n          var r = MG.scale_factory(e).namespace('color')\r\n          'number' === e.color_type\r\n            ? r\r\n                .numericalDomainFromData(B(e))\r\n                .numericalRange(I(e))\r\n                .clamp(!0)\r\n            : e.color_domain\r\n            ? r.categoricalDomain(e.color_domain).categoricalRange(e.color_range)\r\n            : r.categoricalDomainFromData().categoricalColorRange()\r\n        }\r\n        return (\r\n          e.size_accessor &&\r\n            new MG.scale_factory(e)\r\n              .namespace('size')\r\n              .numericalDomainFromData()\r\n              .numericalRange(it(e))\r\n              .clamp(!0),\r\n          new MG.axis_factory(e)\r\n            .namespace('x')\r\n            .type(e.x_axis_type)\r\n            .zeroLine('categorical' === e.y_axis_type)\r\n            .position(e.x_axis_position)\r\n            .rug(nt(e))\r\n            .label(st)\r\n            .draw(),\r\n          new MG.axis_factory(e)\r\n            .namespace('y')\r\n            .type(e.y_axis_type)\r\n            .zeroLine('categorical' === e.x_axis_type)\r\n            .position(e.y_axis_position)\r\n            .rug(K(e))\r\n            .label(et)\r\n            .draw(),\r\n          this.mainPlot(),\r\n          this.markers(),\r\n          this.rollover(),\r\n          this.windowListeners(),\r\n          e.brush && MG.add_brush_function(e),\r\n          this\r\n        )\r\n      }),\r\n        (this.markers = function () {\r\n          return St(a), a.least_squares && ze(a), this\r\n        }),\r\n        (this.mainPlot = function () {\r\n          var t = O(a.target),\r\n            e = we(a.data[0], a)\r\n          t.selectAll('.mg-points').remove()\r\n          var r = t\r\n            .append('g')\r\n            .classed('mg-points', !0)\r\n            .selectAll('circle')\r\n            .data(e)\r\n            .enter()\r\n            .append('circle')\r\n            .attr('class', function (t, e) {\r\n              return 'path-' + e\r\n            })\r\n            .attr('cx', a.scalefns.xoutf)\r\n            .attr('cy', function (t) {\r\n              return a.scalefns.youtf(t)\r\n            })\r\n          return (\r\n            null !== a.color_accessor\r\n              ? (r.attr('fill', a.scalefns.colorf), r.attr('stroke', a.scalefns.colorf))\r\n              : r.classed('mg-points-mono', !0),\r\n            null !== a.size_accessor ? r.attr('r', a.scalefns.sizef) : r.attr('r', a.point_size),\r\n            this\r\n          )\r\n        }),\r\n        (this.rollover = function () {\r\n          var t = O(a.target)\r\n          0 === t.selectAll('.mg-active-datapoint-container').nodes().length && S(t, 'mg-active-datapoint-container'),\r\n            t.selectAll('.mg-voronoi').remove()\r\n          var e = E.voronoi()\r\n            .x(a.scalefns.xoutf)\r\n            .y(a.scalefns.youtf)\r\n            .extent([\r\n              [a.buffer, a.buffer + (a.title ? a.title_y_position : 0)],\r\n              [a.width - a.buffer, a.height - a.buffer]\r\n            ])\r\n          return (\r\n            t\r\n              .append('g')\r\n              .attr('class', 'mg-voronoi')\r\n              .selectAll('path')\r\n              .data(e.polygons(we(a.data[0], a)))\r\n              .enter()\r\n              .append('path')\r\n              .attr('d', function (t) {\r\n                return null == t ? null : 'M' + t.join(',') + 'Z'\r\n              })\r\n              .attr('class', function (t, e) {\r\n                return 'path-' + e\r\n              })\r\n              .style('fill-opacity', 0)\r\n              .on('mouseover', this.rolloverOn(a))\r\n              .on('mouseout', this.rolloverOff(a))\r\n              .on('mousemove', this.rolloverMove(a)),\r\n            1 === a.data[0].length && be(a, t, a.data[0][0]),\r\n            this\r\n          )\r\n        }),\r\n        (this.rolloverOn = function (a) {\r\n          var n = O(a.target)\r\n          return function (t, e) {\r\n            n.selectAll('.mg-points circle').classed('selected', !1)\r\n            var r = n.selectAll('.mg-points circle.path-' + e).classed('selected', !0)\r\n            a.size_accessor\r\n              ? r.attr('r', function (t) {\r\n                  return a.scalefns.sizef(t) + a.active_point_size_increase\r\n                })\r\n              : r.attr('r', a.point_size + a.active_point_size_increase),\r\n              a.linked &&\r\n                !MG.globals.link &&\r\n                ((MG.globals.link = !0),\r\n                E.selectAll('.mg-voronoi .path-' + e).each(function () {\r\n                  E.select(o).on('mouseover')(t, e)\r\n                })),\r\n              a.show_rollover_text && be(a, n, t.data),\r\n              a.mouseover && a.mouseover(t, e)\r\n          }\r\n        }),\r\n        (this.rolloverOff = function (a) {\r\n          var n = O(a.target)\r\n          return function (t, e) {\r\n            a.linked &&\r\n              MG.globals.link &&\r\n              ((MG.globals.link = !1),\r\n              E.selectAll('.mg-voronoi .path-' + e).each(function () {\r\n                E.select(o).on('mouseout')(t, e)\r\n              }))\r\n            var r = n\r\n              .selectAll('.mg-points circle')\r\n              .classed('unselected', !1)\r\n              .classed('selected', !1)\r\n            a.size_accessor ? r.attr('r', a.scalefns.sizef) : r.attr('r', a.point_size),\r\n              1 < a.data[0].length && Lt(n),\r\n              a.mouseout && a.mouseout(t, e)\r\n          }\r\n        }),\r\n        (this.rolloverMove = function (r) {\r\n          return function (t, e) {\r\n            r.mousemove && r.mousemove(t, e)\r\n          }\r\n        }),\r\n        (this.update = function (t) {\r\n          return this\r\n        }),\r\n        (this.windowListeners = function () {\r\n          return Qt(this.args), this\r\n        }),\r\n        this.init(a)\r\n    },\r\n    {\r\n      y_padding_percentage: 0.05,\r\n      y_outer_padding_percentage: 0.2,\r\n      ygroup_padding_percentage: 0,\r\n      ygroup_outer_padding_percentage: 0,\r\n      x_padding_percentage: 0.05,\r\n      x_outer_padding_percentage: 0.2,\r\n      xgroup_padding_percentage: 0,\r\n      xgroup_outer_padding_percentage: 0,\r\n      y_categorical_show_guides: !0,\r\n      x_categorical_show_guides: !0,\r\n      buffer: 16,\r\n      ls: !1,\r\n      lowess: !1,\r\n      point_size: 2.5,\r\n      label_accessor: null,\r\n      size_accessor: null,\r\n      color_accessor: null,\r\n      size_range: null,\r\n      color_range: null,\r\n      size_domain: null,\r\n      color_domain: null,\r\n      active_point_size_increase: 1,\r\n      color_type: 'number'\r\n    }\r\n  )\r\n  MG.register(\r\n    'bar',\r\n    function (M) {\r\n      var G = this\r\n      ;(this.args = M),\r\n        (this.init = function (e) {\r\n          if (\r\n            (((G.args = e).x_axis_type = s(e, 'x')),\r\n            (e.y_axis_type = s(e, 'y')),\r\n            'categorical' == e.x_axis_type\r\n              ? (e.orientation = 'vertical')\r\n              : 'categorical' == e.y_axis_type\r\n              ? (e.orientation = 'horizontal')\r\n              : 'categorical' != e.x_axis_type && 'categorical' != e.y_axis_type && (e.orientation = 'vertical'),\r\n            Me(e),\r\n            Oe(e),\r\n            Ot(e),\r\n            'categorical' === e.x_axis_type\r\n              ? (MG.scale_factory(e)\r\n                  .namespace('x')\r\n                  .categoricalDomainFromData()\r\n                  .categoricalRangeBands([0, e.xgroup_height], null === e.xgroup_accessor),\r\n                e.xgroup_accessor\r\n                  ? new MG.scale_factory(e)\r\n                      .namespace('xgroup')\r\n                      .categoricalDomainFromData()\r\n                      .categoricalRangeBands('bottom')\r\n                  : ((e.scales.XGROUP = function (t) {\r\n                      return Y(e)\r\n                    }),\r\n                    (e.scalefns.xgroupf = function (t) {\r\n                      return Y(e)\r\n                    })),\r\n                (e.scalefns.xoutf = function (t) {\r\n                  return e.scalefns.xf(t) + e.scalefns.xgroupf(t)\r\n                }))\r\n              : (MG.scale_factory(e)\r\n                  .namespace('x')\r\n                  .inflateDomain(!0)\r\n                  .zeroBottom('categorical' === e.y_axis_type)\r\n                  .numericalDomainFromData(\r\n                    (e.baselines || []).map(function (t) {\r\n                      return t[e.x_accessor]\r\n                    })\r\n                  )\r\n                  .numericalRange('bottom'),\r\n                (e.scalefns.xoutf = e.scalefns.xf)),\r\n            'categorical' === e.y_axis_type)\r\n          )\r\n            MG.scale_factory(e)\r\n              .namespace('y')\r\n              .zeroBottom(!0)\r\n              .categoricalDomainFromData()\r\n              .categoricalRangeBands([0, e.ygroup_height], !0),\r\n              e.ygroup_accessor\r\n                ? new MG.scale_factory(e)\r\n                    .namespace('ygroup')\r\n                    .categoricalDomainFromData()\r\n                    .categoricalRangeBands('left')\r\n                : ((e.scales.YGROUP = function () {\r\n                    return b(e)\r\n                  }),\r\n                  (e.scalefns.ygroupf = function (t) {\r\n                    return b(e)\r\n                  })),\r\n              (e.scalefns.youtf = function (t) {\r\n                return e.scalefns.yf(t) + e.scalefns.ygroupf(t)\r\n              })\r\n          else {\r\n            var t = (e.baselines || []).map(function (t) {\r\n              return t[e.y_accessor]\r\n            })\r\n            MG.scale_factory(e)\r\n              .namespace('y')\r\n              .inflateDomain(!0)\r\n              .zeroBottom('categorical' === e.x_axis_type)\r\n              .numericalDomainFromData(t)\r\n              .numericalRange('left'),\r\n              (e.scalefns.youtf = function (t) {\r\n                return e.scalefns.yf(t)\r\n              })\r\n          }\r\n          return (\r\n            null !== e.ygroup_accessor &&\r\n              ((e.ycolor_accessor = e.y_accessor),\r\n              MG.scale_factory(e)\r\n                .namespace('ycolor')\r\n                .scaleName('color')\r\n                .categoricalDomainFromData()\r\n                .categoricalColorRange()),\r\n            null !== e.xgroup_accessor &&\r\n              ((e.xcolor_accessor = e.x_accessor),\r\n              MG.scale_factory(e)\r\n                .namespace('xcolor')\r\n                .scaleName('color')\r\n                .categoricalDomainFromData()\r\n                .categoricalColorRange()),\r\n            new MG.axis_factory(e)\r\n              .namespace('x')\r\n              .type(e.x_axis_type)\r\n              .zeroLine('categorical' === e.y_axis_type)\r\n              .position(e.x_axis_position)\r\n              .draw(),\r\n            new MG.axis_factory(e)\r\n              .namespace('y')\r\n              .type(e.y_axis_type)\r\n              .zeroLine('categorical' === e.x_axis_type)\r\n              .position(e.y_axis_position)\r\n              .draw(),\r\n            G.mainPlot(),\r\n            G.markers(),\r\n            G.rollover(),\r\n            G.windowListeners(),\r\n            G\r\n          )\r\n        }),\r\n        (this.mainPlot = function () {\r\n          var t = O(M.target),\r\n            e = M.data[0],\r\n            r = t.select('g.mg-barplot'),\r\n            a = r.empty(),\r\n            n = void 0\r\n          ;(a && M.animate_on_load) || M.transition_on_update,\r\n            M.transition_duration,\r\n            a && (r = t.append('g').classed('mg-barplot', !0)),\r\n            (n = r\r\n              .selectAll('.mg-bar')\r\n              .data(e)\r\n              .enter()\r\n              .append('rect')\r\n              .classed('mg-bar', !0)\r\n              .classed('default-bar', !M.scales.hasOwnProperty('COLOR')))\r\n          var o = void 0,\r\n            i = void 0,\r\n            s = void 0,\r\n            c = void 0,\r\n            l = void 0,\r\n            u = void 0,\r\n            d = void 0,\r\n            f = void 0,\r\n            p = void 0,\r\n            _ = void 0,\r\n            m = void 0,\r\n            g = void 0,\r\n            h = void 0,\r\n            x = void 0,\r\n            y = void 0,\r\n            v = void 0\r\n          if (\r\n            ('vertical' == M.orientation &&\r\n              ((o = 'height'),\r\n              (i = 'width'),\r\n              (s = M.y_axis_type),\r\n              (c = M.x_axis_type),\r\n              (l = 'y'),\r\n              (u = 'x'),\r\n              (d = 'categorical' == s ? M.scalefns.youtf : M.scalefns.yf),\r\n              (f = 'categorical' == c ? M.scalefns.xoutf : M.scalefns.xf),\r\n              (p = M.scales.Y),\r\n              (_ = M.scales.X),\r\n              (m = M.y_accessor),\r\n              (g = M.x_accessor),\r\n              (h = function (t) {\r\n                var e = void 0\r\n                return (e = d(t)), t[m] < 0 && (e = p(0)), e\r\n              }),\r\n              (x = function (t) {\r\n                return Math.abs(d(t) - p(0))\r\n              }),\r\n              (y = function (t) {\r\n                return Math.abs(p(t[M.reference_accessor]) - p(0))\r\n              }),\r\n              (v = function (t) {\r\n                return p(t[M.reference_accessor])\r\n              })),\r\n            'horizontal' == M.orientation &&\r\n              ((o = 'width'),\r\n              (i = 'height'),\r\n              (s = M.x_axis_type),\r\n              (c = M.y_axis_type),\r\n              (l = 'x'),\r\n              (u = 'y'),\r\n              (d = 'categorical' == s ? M.scalefns.xoutf : M.scalefns.xf),\r\n              (f = 'categorical' == c ? M.scalefns.youtf : M.scalefns.yf),\r\n              (p = M.scales.X),\r\n              (_ = M.scales.Y),\r\n              (m = M.x_accessor),\r\n              (g = M.y_accessor),\r\n              (h = function (t) {\r\n                return p(0)\r\n              }),\r\n              (x = function (t) {\r\n                return Math.abs(d(t) - p(0))\r\n              }),\r\n              (y = function (t) {\r\n                return Math.abs(p(t[M.reference_accessor]) - p(0))\r\n              }),\r\n              (v = function (t) {\r\n                return p(0)\r\n              })),\r\n            n.attr(l, h),\r\n            n.attr(u, function (t) {\r\n              var e = void 0\r\n              return 'categorical' == c ? (e = f(t)) : ((e = _(0)), t[g] < 0 && (e = f(t))), (e -= M.bar_thickness / 2)\r\n            }),\r\n            M.scales.COLOR && n.attr('fill', M.scalefns.colorf),\r\n            n.attr(o, x).attr(i, function (t) {\r\n              return M.bar_thickness\r\n            }),\r\n            null !== M.reference_accessor)\r\n          ) {\r\n            var b = e.filter(function (t) {\r\n              return t.hasOwnProperty(M.reference_accessor)\r\n            })\r\n            r.selectAll('.mg-categorical-reference')\r\n              .data(b)\r\n              .enter()\r\n              .append('rect')\r\n              .attr(l, v)\r\n              .attr(u, function (t) {\r\n                return f(t) - M.reference_thickness / 2\r\n              })\r\n              .attr(o, y)\r\n              .attr(i, M.reference_thickness)\r\n          }\r\n          if (null !== M.comparison_accessor) {\r\n            var w = null\r\n            w = null === M.comparison_thickness ? M.bar_thickness / 2 : M.comparison_thickness\r\n            var k = e.filter(function (t) {\r\n              return t.hasOwnProperty(M.comparison_accessor)\r\n            })\r\n            r.selectAll('.mg-categorical-comparison')\r\n              .data(k)\r\n              .enter()\r\n              .append('line')\r\n              .attr(l + '1', function (t) {\r\n                return p(t[M.comparison_accessor])\r\n              })\r\n              .attr(l + '2', function (t) {\r\n                return p(t[M.comparison_accessor])\r\n              })\r\n              .attr(u + '1', function (t) {\r\n                return f(t) - w / 2\r\n              })\r\n              .attr(u + '2', function (t) {\r\n                return f(t) + w / 2\r\n              })\r\n              .attr('stroke', 'black')\r\n              .attr('stroke-width', M.comparison_width)\r\n          }\r\n          return (\r\n            (M.legend || (null !== M.color_accessor && M.ygroup_accessor !== M.color_accessor)) &&\r\n              (M.legend_target\r\n                ? (function (t) {\r\n                    var e = t.legend_target,\r\n                      r = t.orientation,\r\n                      a = t.scales\r\n                    if (e) {\r\n                      var n = E.select(e)\r\n                        .append('div')\r\n                        .classed('mg-bar-target-legend', !0)\r\n                      ;('horizontal' == r ? a.Y.domain() : a.X.domain()).forEach(function (t) {\r\n                        var e = n.append('span').classed('mg-bar-target-element', !0)\r\n                        e\r\n                          .append('span')\r\n                          .classed('mg-bar-target-legend-shape', !0)\r\n                          .style('color', a.COLOR(t))\r\n                          .text(' '),\r\n                          e\r\n                            .append('span')\r\n                            .classed('mg-bar-target-legend-text', !0)\r\n                            .text(t)\r\n                      })\r\n                    }\r\n                  })(M)\r\n                : (function (t, r) {\r\n                    var e = void 0\r\n                    e = 'horizontal' == r.orientation ? r.scales.Y.domain() : r.scales.X.domain()\r\n                    var a = 0,\r\n                      n = t\r\n                        .append('g')\r\n                        .classed('mg-bar-legend', !0)\r\n                        .append('text')\r\n                    n.selectAll('*').remove(),\r\n                      n\r\n                        .attr('width', r.right)\r\n                        .attr('height', 100)\r\n                        .attr('text-anchor', 'start'),\r\n                      e.forEach(function (t) {\r\n                        var e = n\r\n                          .append('tspan')\r\n                          .attr('x', P(r))\r\n                          .attr('y', r.height / 2)\r\n                          .attr('dy', 1.1 * a + 'em')\r\n                        e\r\n                          .append('tspan')\r\n                          .text(' ')\r\n                          .attr('fill', r.scales.COLOR(t))\r\n                          .attr('font-size', 20),\r\n                          e\r\n                            .append('tspan')\r\n                            .text(t)\r\n                            .attr('font-weight', 300)\r\n                            .attr('font-size', 10),\r\n                          a++\r\n                      })\r\n                  })(t, M)),\r\n            G\r\n          )\r\n        }),\r\n        (this.markers = function () {\r\n          return St(M), G\r\n        }),\r\n        (this.rollover = function () {\r\n          var t = O(M.target)\r\n          0 === t.selectAll('.mg-active-datapoint-container').nodes().length && S(t, 'mg-active-datapoint-container'),\r\n            t.selectAll('.mg-rollover-rect').remove(),\r\n            t.selectAll('.mg-active-datapoint').remove()\r\n          var e = void 0,\r\n            r = void 0,\r\n            a = void 0,\r\n            n = void 0,\r\n            o = void 0,\r\n            i = void 0,\r\n            s = void 0,\r\n            c = void 0,\r\n            l = void 0,\r\n            u = void 0,\r\n            d = void 0,\r\n            f = void 0\r\n          'vertical' == M.orientation &&\r\n            ((e = 'height'),\r\n            (r = 'width'),\r\n            (a = M.y_axis_type),\r\n            (n = M.x_axis_type),\r\n            (o = 'y'),\r\n            (i = 'x'),\r\n            'categorical' == a ? M.scalefns.youtf : M.scalefns.yf,\r\n            (s = 'categorical' == n ? M.scalefns.xoutf : M.scalefns.xf),\r\n            (c = M.scales.Y),\r\n            (l = M.scales.X),\r\n            M.y_accessor,\r\n            (u = M.x_accessor),\r\n            (d = function (t) {\r\n              return b(M)\r\n            }),\r\n            (f = function (t) {\r\n              return M.height - M.top - M.bottom - 2 * M.buffer\r\n            })),\r\n            'horizontal' == M.orientation &&\r\n              ((e = 'width'),\r\n              (r = 'height'),\r\n              (a = M.x_axis_type),\r\n              (n = M.y_axis_type),\r\n              (o = 'x'),\r\n              (i = 'y'),\r\n              'categorical' == a ? M.scalefns.xoutf : M.scalefns.xf,\r\n              (s = 'categorical' == n ? M.scalefns.youtf : M.scalefns.yf),\r\n              (c = M.scales.X),\r\n              (l = M.scales.Y),\r\n              M.x_accessor,\r\n              (u = M.y_accessor),\r\n              (d = function (t) {\r\n                return c(0)\r\n              }),\r\n              (f = function (t) {\r\n                return M.width - M.left - M.right - 2 * M.buffer\r\n              }))\r\n          var p = void 0,\r\n            _ = void 0\r\n          'right' === M.rollover_align\r\n            ? ((p = M.width - M.right), (_ = 'end'))\r\n            : 'left' === M.rollover_align\r\n            ? ((p = M.left), (_ = 'start'))\r\n            : ((p = (M.width - M.left - M.right) / 2 + M.left), (_ = 'middle')),\r\n            t\r\n              .append('text')\r\n              .attr('class', 'mg-active-datapoint')\r\n              .attr('xml:space', 'preserve')\r\n              .attr('x', p)\r\n              .attr('y', 0.75 * M.top)\r\n              .attr('dy', '.35em')\r\n              .attr('text-anchor', _)\r\n          var m = t\r\n            .append('g')\r\n            .attr('class', 'mg-rollover-rect')\r\n            .selectAll('.mg-bar-rollover')\r\n            .data(M.data[0])\r\n            .enter()\r\n            .append('rect')\r\n            .attr('class', 'mg-bar-rollover')\r\n          return (\r\n            m\r\n              .attr('opacity', 0)\r\n              .attr(o, d)\r\n              .attr(i, function (t) {\r\n                var e = void 0\r\n                return (\r\n                  'categorical' == n ? (e = s(t)) : ((e = l(0)), t[u] < 0 && (e = s(t))), (e -= M.bar_thickness / 2)\r\n                )\r\n              }),\r\n            m.attr(e, f),\r\n            m.attr(r, function (t) {\r\n              return M.bar_thickness\r\n            }),\r\n            m\r\n              .on('mouseover', G.rolloverOn(M))\r\n              .on('mouseout', G.rolloverOff(M))\r\n              .on('mousemove', G.rolloverMove(M)),\r\n            G\r\n          )\r\n        }),\r\n        (this.rolloverOn = function (o) {\r\n          var i = O(o.target)\r\n          return (\r\n            G.is_vertical ? o.x_accessor : o.y_accessor,\r\n            G.is_vertical ? o.y_accessor : o.x_accessor,\r\n            G.is_vertical ? o.yax_units : o.xax_units,\r\n            function (t, r) {\r\n              MG.time_format(o.utc_time, '%b %e, %Y'), Ee(o)\r\n              var e = i\r\n                .selectAll('g.mg-barplot .mg-bar')\r\n                .filter(function (t, e) {\r\n                  return e === r\r\n                })\r\n                .classed('active', !0)\r\n              if (\r\n                (o.scales.hasOwnProperty('COLOR')\r\n                  ? e.attr('fill', E.rgb(o.scalefns.colorf(t)).darker())\r\n                  : e.classed('default-active', !0),\r\n                o.show_rollover_text)\r\n              ) {\r\n                var a = Xt(o, { svg: i }),\r\n                  n = a.mouseover_row()\r\n                o.ygroup_accessor && n.text(t[o.ygroup_accessor] + '   ').bold(),\r\n                  n.text(Se(o, t)),\r\n                  n.text(o.y_accessor + ': ' + t[o.y_accessor]),\r\n                  (o.predictor_accessor || o.baseline_accessor) &&\r\n                    ((n = a.mouseover_row()),\r\n                    o.predictor_accessor && n.text(Pe(o, t, null, o.predictor_accessor, !1)),\r\n                    o.baseline_accessor && n.text(Pe(o, t, null, o.baseline_accessor, !1)))\r\n              }\r\n              o.mouseover && o.mouseover(t, r)\r\n            }\r\n          )\r\n        }),\r\n        (this.rolloverOff = function (a) {\r\n          var n = O(a.target)\r\n          return function (t, e) {\r\n            var r = n.selectAll('g.mg-barplot .mg-bar.active').classed('active', !1)\r\n            a.scales.hasOwnProperty('COLOR') ? r.attr('fill', a.scalefns.colorf(t)) : r.classed('default-active', !1),\r\n              n.select('.mg-active-datapoint').text(''),\r\n              Lt(n),\r\n              a.mouseout && a.mouseout(t, e)\r\n          }\r\n        }),\r\n        (this.rolloverMove = function (r) {\r\n          return function (t, e) {\r\n            r.mousemove && r.mousemove(t, e)\r\n          }\r\n        }),\r\n        (this.windowListeners = function () {\r\n          return Qt(G.args), G\r\n        }),\r\n        this.init(M)\r\n    },\r\n    {\r\n      y_padding_percentage: 0.05,\r\n      y_outer_padding_percentage: 0.2,\r\n      ygroup_padding_percentage: 0,\r\n      ygroup_outer_padding_percentage: 0,\r\n      x_padding_percentage: 0.05,\r\n      x_outer_padding_percentage: 0.2,\r\n      xgroup_padding_percentage: 0,\r\n      xgroup_outer_padding_percentage: 0,\r\n      buffer: 16,\r\n      y_accessor: 'factor',\r\n      x_accessor: 'value',\r\n      reference_accessor: null,\r\n      comparison_accessor: null,\r\n      secondary_label_accessor: null,\r\n      color_accessor: null,\r\n      color_type: 'category',\r\n      color_domain: null,\r\n      reference_thickness: 1,\r\n      comparison_width: 3,\r\n      comparison_thickness: null,\r\n      legend: !1,\r\n      legend_target: null,\r\n      mouseover_align: 'right',\r\n      baseline_accessor: null,\r\n      predictor_accessor: null,\r\n      predictor_proportion: 5,\r\n      show_bar_zero: !0,\r\n      binned: !0,\r\n      truncate_x_labels: !0,\r\n      truncate_y_labels: !0\r\n    }\r\n  ),\r\n    (MG.data_table = function (t) {\r\n      return (\r\n        (this.args = t),\r\n        (this.args.standard_col = { width: 150, font_size: 12, font_weight: 'normal' }),\r\n        (this.args.columns = []),\r\n        (this.formatting_options = [\r\n          ['color', 'color'],\r\n          ['font-weight', 'font_weight'],\r\n          ['font-style', 'font_style'],\r\n          ['font-size', 'font_size']\r\n        ]),\r\n        (this._strip_punctuation = function (t) {\r\n          return t.replace(/[^a-zA-Z0-9 _]+/g, '').replace(/ +?/g, '')\r\n        }),\r\n        (this._format_element = function (a, n, o) {\r\n          this.formatting_options.forEach(function (t) {\r\n            var e = t[0],\r\n              r = t[1]\r\n            o[r] && a.style(e, 'string' == typeof o[r] || 'number' == typeof o[r] ? o[r] : o[r](n))\r\n          })\r\n        }),\r\n        (this._add_column = function (t, e) {\r\n          var r = this.args.standard_col,\r\n            a = p(MG.clone(t), MG.clone(r))\r\n          ;(a.type = e), this.args.columns.push(a)\r\n        }),\r\n        (this.target = function () {\r\n          var t = arguments[0]\r\n          return (this.args.target = t), this\r\n        }),\r\n        (this.title = function () {\r\n          return this._add_column(arguments[0], 'title'), this\r\n        }),\r\n        (this.text = function () {\r\n          return this._add_column(arguments[0], 'text'), this\r\n        }),\r\n        (this.bullet = function () {\r\n          return this\r\n        }),\r\n        (this.sparkline = function () {\r\n          return this\r\n        }),\r\n        (this.number = function () {\r\n          return this._add_column(arguments[0], 'number'), this\r\n        }),\r\n        (this.display = function () {\r\n          var t = this.args\r\n          j(t)\r\n          var e,\r\n            r,\r\n            a,\r\n            n,\r\n            o,\r\n            i,\r\n            s,\r\n            c,\r\n            l,\r\n            u,\r\n            d,\r\n            f,\r\n            p = t.target,\r\n            _ = E.select(p)\r\n              .append('table')\r\n              .classed('mg-data-table', !0),\r\n            m = _.append('colgroup'),\r\n            g = _.append('thead'),\r\n            h = _.append('tbody')\r\n          for (a = g.append('tr'), f = 0; f < t.columns.length; f++) {\r\n            var x = t.columns[f]\r\n            ;(i = x.type),\r\n              (c = void 0 === (c = x.label) ? '' : c),\r\n              (n = a\r\n                .append('th')\r\n                .style('width', x.width)\r\n                .style('text-align', 'title' === i ? 'left' : 'right')\r\n                .text(c)),\r\n              t.show_tooltips &&\r\n                x.description &&\r\n                k() &&\r\n                (n\r\n                  .append('i')\r\n                  .classed('fa', !0)\r\n                  .classed('fa-question-circle', !0)\r\n                  .classed('fa-inverse', !0),\r\n                $(n.node()).popover({\r\n                  html: !0,\r\n                  animation: !1,\r\n                  content: x.description,\r\n                  trigger: 'hover',\r\n                  placement: 'top',\r\n                  container: $(n.node())\r\n                }))\r\n          }\r\n          for (f = 0; f < t.columns.length; f++)\r\n            (d = m.append('col')), 'number' === t.columns[f].type && d.attr('align', 'char').attr('char', '.')\r\n          for (var y = 0; y < t.data.length; y++) {\r\n            a = h.append('tr')\r\n            for (var v = 0; v < t.columns.length; v++) {\r\n              if (((o = (e = t.columns[v]).accessor), (s = l = t.data[y][o]), 'number' === (i = e.type))) {\r\n                if (\r\n                  (e.hasOwnProperty('round') && !e.hasOwnProperty('format') && (l = E.format('0,.' + e.round + 'f')(l)),\r\n                  e.hasOwnProperty('value_formatter') && (l = e.value_formatter(l)),\r\n                  e.hasOwnProperty('format'))\r\n                ) {\r\n                  e.round && (l = Math.round(l, e.round))\r\n                  var b,\r\n                    w = e.format\r\n                  'percentage' === w && (b = E.format('.0%')),\r\n                    'count' === w && (b = E.format(',.0f')),\r\n                    'temperature' === w &&\r\n                      (b = function (t) {\r\n                        return t + ''\r\n                      }),\r\n                    (l = b(l))\r\n                }\r\n                e.hasOwnProperty('currency') && (l = e.currency + l)\r\n              }\r\n              ;(u = a\r\n                .append('td')\r\n                .classed('table-' + i, !0)\r\n                .classed('table-' + i + '-' + this._strip_punctuation(o), !0)\r\n                .attr('data-value', s)\r\n                .style('width', e.width)\r\n                .style('text-align', 'title' === i || 'text' === i ? 'left' : 'right')),\r\n                this._format_element(u, s, e),\r\n                'title' === i\r\n                  ? ((r = u.append('div').text(l)),\r\n                    this._format_element(r, l, e),\r\n                    t.columns[v].hasOwnProperty('secondary_accessor') &&\r\n                      u\r\n                        .append('div')\r\n                        .text(t.data[y][t.columns[v].secondary_accessor])\r\n                        .classed('secondary-title', !0))\r\n                  : u.text(l)\r\n            }\r\n          }\r\n          return this\r\n        }),\r\n        this\r\n      )\r\n    })\r\n  function ke (t, e) {\r\n    var r, a, n\r\n    function o (t) {\r\n      return 1e3 === t ? 3 : 1e6 === t ? 7 : Math.log(t) / Math.LN10\r\n    }\r\n    'x' === e\r\n      ? ((r = t.x_accessor), (a = t.scales.X.ticks(t.xax_count)), (n = t.processed.max_x))\r\n      : 'y' === e && ((r = t.y_accessor), (a = t.scales.Y.ticks(t.yax_count)), (n = t.processed.max_y)),\r\n      (('x' === e && 'log' === t.x_scale_type) || ('y' === e && 'log' === t.y_scale_type)) &&\r\n        (a = a.filter(function (t) {\r\n          return Math.abs(o(t)) % 1 < 1e-6 || Math.abs(o(t)) % 1 > 1 - 1e-6\r\n        }))\r\n    var i = a.length,\r\n      s = !0\r\n    t.data.forEach(function (t, e) {\r\n      t.forEach(function (t, e) {\r\n        if (t[r] % 1 != 0) return (s = !1)\r\n      })\r\n    }),\r\n      s &&\r\n        n < i &&\r\n        'count' === t.format &&\r\n        (a = a.filter(function (t) {\r\n          return t % 1 == 0\r\n        })),\r\n      'x' === e ? (t.processed.x_ticks = a) : 'y' === e && (t.processed.y_ticks = a)\r\n  }\r\n  function Me (r) {\r\n    if (\r\n      ((r.data = MG.clone(r.data)),\r\n      (r.single_object = !1),\r\n      (r.array_of_objects = !1),\r\n      (r.array_of_arrays = !1),\r\n      (r.nested_array_of_arrays = !1),\r\n      (r.nested_array_of_objects = !1),\r\n      a(r.data)\r\n        ? ((r.nested_array_of_objects = r.data.map(function (t) {\r\n            return e(t)\r\n          })),\r\n          (r.nested_array_of_arrays = r.data.map(function (t) {\r\n            return a(t)\r\n          })))\r\n        : ((r.array_of_objects = n(r.data)), (r.array_of_arrays = a(r.data))),\r\n      'line' === r.chart_type\r\n        ? (r.array_of_objects || r.array_of_arrays) && (r.data = [r.data])\r\n        : y(r.data[0]) || (r.data = [r.data]),\r\n      Ge(r, 'x_accessor'),\r\n      Ge(r, 'y_accessor'),\r\n      void 0 !== r.color && (r.colors = r.color),\r\n      null !== r.colors && 'string' == typeof r.colors && (r.colors = [r.colors]),\r\n      'line' === r.chart_type && !0 === r.x_sort)\r\n    )\r\n      for (var t = 0; t < r.data.length; t++)\r\n        r.data[t].sort(function (t, e) {\r\n          return t[r.x_accessor] - e[r.x_accessor]\r\n        })\r\n    return this\r\n  }\r\n  function Ge (e, r) {\r\n    y(e[r]) &&\r\n      ((e.data = e.data.map(function (t) {\r\n        return e[r].map(function (e) {\r\n          return t\r\n            .map(function (t) {\r\n              if (void 0 !== (t = MG.clone(t))[e]) return (t['multiline_' + r] = t[e]), t\r\n            })\r\n            .filter(function (t) {\r\n              return void 0 !== t\r\n            })\r\n        })\r\n      })[0]),\r\n      (e[r] = 'multiline_' + r))\r\n  }\r\n  function Ae (r) {\r\n    var t,\r\n      e =\r\n        0 <\r\n        E.sum(\r\n          r.data.map(function (t) {\r\n            return 0 < t.length && x(t[0][r.x_accessor])\r\n          })\r\n        )\r\n    if ((r.missing_is_zero || r.missing_is_hidden) && 'line' === r.chart_type && e)\r\n      for (var a = 0; a < r.data.length; a++)\r\n        if (!(r.data[a].length <= 1)) {\r\n          var n = r.data[a][0],\r\n            o = r.data[a][r.data[a].length - 1],\r\n            i = [],\r\n            s = MG.clone(n[r.x_accessor]).setDate(n[r.x_accessor].getDate() + 1),\r\n            c = r.min_x ? r.min_x : s,\r\n            l = r.max_x ? r.max_x : o[r.x_accessor]\r\n          if (\r\n            ((t = lt((l - c) / 1e3)),\r\n            -1 !== ['four-days', 'many-days', 'many-months', 'years', 'default'].indexOf(t) &&\r\n              null === r.missing_is_hidden_accessor)\r\n          )\r\n            for (var u = new Date(c); u <= l; u.setDate(u.getDate() + 1)) {\r\n              var d = {}\r\n              u.setHours(0, 0, 0, 0), Date.parse(u) === Date.parse(new Date(s)) && i.push(MG.clone(r.data[a][0]))\r\n              var f = null\r\n              r.data[a].forEach(function (t, e) {\r\n                if (Date.parse(t[r.x_accessor]) === Date.parse(new Date(u))) return (f = t), !1\r\n              }),\r\n                f\r\n                  ? ((f[r.missing_is_hidden_accessor] || null === f[r.y_accessor]) && (f._missing = !0), i.push(f))\r\n                  : ((d[r.x_accessor] = new Date(u)), (d[r.y_accessor] = 0), (d._missing = !0), i.push(d))\r\n            }\r\n          else\r\n            for (var p = 0; p < r.data[a].length; p += 1) {\r\n              var _ = MG.clone(r.data[a][p])\r\n              ;(_._missing = r.data[a][p][r.missing_is_hidden_accessor]), i.push(_)\r\n            }\r\n          r.data[a] = i\r\n        }\r\n    return this\r\n  }\r\n  function De (e) {\r\n    var t,\r\n      r = e.data[0]\r\n    if (!1 === e.binned) {\r\n      if ('object' === c(r[0]))\r\n        t = r.map(function (t) {\r\n          return t[e.x_accessor]\r\n        })\r\n      else {\r\n        if ('number' != typeof r[0])\r\n          return void console.log('TypeError: expected an array of numbers, found ' + c(r[0]))\r\n        t = r\r\n      }\r\n      var a = E.histogram()\r\n      e.bins && a.thresholds(e.bins)\r\n      var n = a(t)\r\n      e.processed_data = n.map(function (t) {\r\n        return { x: t.x0, y: t.length }\r\n      })\r\n    } else {\r\n      var o, i\r\n      e.processed_data = r.map(function (t) {\r\n        return { x: t[e.x_accessor], y: t[e.y_accessor] }\r\n      })\r\n      for (var s = 0; s < e.processed_data.length; s++)\r\n        (o = e.processed_data[s]),\r\n          s === e.processed_data.length - 1\r\n            ? (o.dx = e.processed_data[s - 1].dx)\r\n            : ((i = e.processed_data[s + 1]), (o.dx = i.x - o.x))\r\n    }\r\n    return (\r\n      e.processed || (e.processed = {}),\r\n      (e.processed.original_data = e.data),\r\n      (e.processed.original_x_accessor = e.x_accessor),\r\n      (e.processed.original_y_accessor = e.y_accessor),\r\n      (e.data = [e.processed_data]),\r\n      (e.x_accessor = e.processed_x_accessor),\r\n      (e.y_accessor = e.processed_y_accessor),\r\n      this\r\n    )\r\n  }\r\n  function Oe (e) {\r\n    var t = e.data[0],\r\n      r = t.map(function (t) {\r\n        return t[e.x_accessor]\r\n      }),\r\n      a = t.map(function (t) {\r\n        return t[e.y_accessor]\r\n      })\r\n    return e.least_squares && (e.ls_line = Fe(r, a)), this\r\n  }\r\n  function ze (e) {\r\n    var t = O(e.target),\r\n      r = e.data[0],\r\n      a = E.min(r, function (t) {\r\n        return t[e.x_accessor]\r\n      }),\r\n      n = E.max(r, function (t) {\r\n        return t[e.x_accessor]\r\n      })\r\n    E.select(e.target)\r\n      .selectAll('.mg-least-squares-line')\r\n      .remove(),\r\n      t\r\n        .append('svg:line')\r\n        .attr('x1', e.scales.X(a))\r\n        .attr('x2', e.scales.X(n))\r\n        .attr('y1', e.scales.Y(e.ls_line.fit(a)))\r\n        .attr('y2', e.scales.Y(e.ls_line.fit(n)))\r\n        .attr('class', 'mg-least-squares-line')\r\n  }\r\n  function Fe (t, e) {\r\n    var r, a, n\r\n    t.length\r\n    ;(r = x(t[0])\r\n      ? t.map(function (t) {\r\n          return t.getTime()\r\n        })\r\n      : t),\r\n      (a = x(e[0])\r\n        ? e.map(function (t) {\r\n            return t.getTime()\r\n          })\r\n        : e)\r\n    for (var o = E.mean(r), i = E.mean(a), s = 0, c = 0, l = 0; l < r.length; l++)\r\n      (s += ((n = r[l]) - o) * (a[l] - i)), (c += (n - o) * (n - o))\r\n    var u = s / c,\r\n      d = i - u * o\r\n    return {\r\n      x0: d,\r\n      beta: u,\r\n      fit: function (t) {\r\n        return d + t * u\r\n      }\r\n    }\r\n  }\r\n  function Ce (t, e) {\r\n    return 0 <= t && t <= 1 ? Math.pow(1 - Math.pow(t, e), e) : 0\r\n  }\r\n  function Te (t) {\r\n    var e,\r\n      r,\r\n      a,\r\n      n,\r\n      o,\r\n      i,\r\n      s,\r\n      c = ((a = t),\r\n      (n = E.sum(\r\n        a.map(function (t) {\r\n          return t.w\r\n        })\r\n      )),\r\n      {\r\n        xbar:\r\n          E.sum(\r\n            a.map(function (t) {\r\n              return t.w * t.x\r\n            })\r\n          ) / n,\r\n        ybar:\r\n          E.sum(\r\n            a.map(function (t) {\r\n              return t.w * t.y\r\n            })\r\n          ) / n\r\n      }),\r\n      l = ((o = t),\r\n      (i = r = c.xbar),\r\n      (s = e = c.ybar),\r\n      E.sum(\r\n        o.map(function (t) {\r\n          return Math.pow(t.w, 2) * (t.x - i) * (t.y - s)\r\n        })\r\n      ) /\r\n        E.sum(\r\n          o.map(function (t) {\r\n            return Math.pow(t.w, 2) * Math.pow(t.x - i, 2)\r\n          })\r\n        ))\r\n    return { beta: l, xbar: r, ybar: e, x0: e - l * r }\r\n  }\r\n  function Re (t, e, r, a, n) {\r\n    var o = Math.floor(t.length * r),\r\n      i = t.slice()\r\n    i.sort(function (t, e) {\r\n      return t < e ? -1 : e < t ? 1 : 0\r\n    })\r\n    for (\r\n      var s,\r\n        c,\r\n        l,\r\n        u,\r\n        d,\r\n        f = E.quantile(i, 0.98),\r\n        p = E.quantile(i, 0.02),\r\n        _ = E.zip(t, e, n).sort(),\r\n        m = Math.abs(f - p) / a,\r\n        g = p,\r\n        h = f,\r\n        x = E.range(g, h, m),\r\n        y = [],\r\n        v = 0;\r\n      v < x.length;\r\n      v += 1\r\n    ) {\r\n      ;(c = x[v]),\r\n        (s = _.map(function (t) {\r\n          return [Math.abs(t[0] - c), t[0], t[1], t[2]]\r\n        })\r\n          .sort()\r\n          .slice(0, o)),\r\n        (d = E.max(s)[0])\r\n      var b = Te(\r\n        (s = s.map(function (t) {\r\n          return { w: ((e = t[0] / d), Ce(e, 3) * t[3]), x: t[1], y: t[2] }\r\n          var e\r\n        }))\r\n      )\r\n      ;(u = b.x0), (l = b.beta), y.push(u + l * c)\r\n    }\r\n    return { x: x, y: y }\r\n  }\r\n  function Ee (r) {\r\n    return 'count' === r.format\r\n      ? function (t) {\r\n          var e\r\n          return (\r\n            (e = t % 1 != 0 ? E.format(',.' + r.decimals + 'f') : E.format(',.0f')),\r\n            r.yax_units_append ? e(t) + r.yax_units : r.yax_units + e(t)\r\n          )\r\n        }\r\n      : function (t) {\r\n          var e = (r.decimals ? '.' + r.decimals : '') + '%'\r\n          return E.format(e)(t)\r\n        }\r\n  }\r\n  MG.register(\r\n    'missing-data',\r\n    function (t) {\r\n      var R = this\r\n      ;(this.init = function (t) {\r\n        yt((R.args = t)), vt(t)\r\n        var e = E.select(t.target)\r\n        Gt(e, t)\r\n        var r,\r\n          a,\r\n          n,\r\n          o,\r\n          i,\r\n          s,\r\n          c,\r\n          l,\r\n          u,\r\n          d,\r\n          f,\r\n          p,\r\n          _,\r\n          m,\r\n          g,\r\n          h,\r\n          x,\r\n          y,\r\n          v,\r\n          b,\r\n          w,\r\n          k,\r\n          M,\r\n          G,\r\n          A,\r\n          D,\r\n          O,\r\n          z,\r\n          F,\r\n          C = e.selectAll('svg')\r\n        if (\r\n          (bt(C, t),\r\n          kt((C = wt(C, t)), t),\r\n          Mt(C, t),\r\n          (r = t.target),\r\n          E.select(r)\r\n            .selectAll('svg *')\r\n            .remove(),\r\n          C.classed('mg-missing', !0),\r\n          (a = t.legend_target) && E.select(a).html(''),\r\n          j(t),\r\n          t.show_missing_background)\r\n        ) {\r\n          !(function (t) {\r\n            for (var e = [], r = 1; r <= 50; r++) e.push({ x: r, y: Math.random() - 0.03 * r })\r\n            t.data = e\r\n          })(t),\r\n            ((G = t).scales.X = E.scaleLinear()\r\n              .domain([0, G.data.length])\r\n              .range([Y(G), P(G)])),\r\n            (G.scalefns.yf = function (t) {\r\n              var e = t.y\r\n              return G.scales.Y(e)\r\n            }),\r\n            ((M = t).scales.Y = E.scaleLinear()\r\n              .domain([-2, 2])\r\n              .range([M.height - M.bottom - 2 * M.buffer, M.top])),\r\n            (M.scalefns.xf = function (t) {\r\n              var e = t.x\r\n              return M.scales.X(e)\r\n            })\r\n          var T = S(C, 'mg-missing-pane')\r\n          ;(h = T),\r\n            (y = (x = t).title),\r\n            (v = x.buffer),\r\n            (b = x.title_y_position),\r\n            (w = x.width),\r\n            (k = x.height),\r\n            h\r\n              .append('svg:rect')\r\n              .classed('mg-missing-background', !0)\r\n              .attr('x', v)\r\n              .attr('y', v + 2 * (y ? b : 0))\r\n              .attr('width', w - 2 * v)\r\n              .attr('height', k - 2 * v - 2 * (y ? b : 0))\r\n              .attr('rx', 15)\r\n              .attr('ry', 15),\r\n            (d = T),\r\n            (p = (f = t).scalefns),\r\n            (_ = f.interpolate),\r\n            (m = f.data),\r\n            (g = E.line()\r\n              .x(p.xf)\r\n              .y(p.yf)\r\n              .curve(_)),\r\n            d\r\n              .append('path')\r\n              .attr('class', 'mg-main-line mg-line1-color')\r\n              .attr('d', g(m)),\r\n            (n = T),\r\n            (i = (o = t).scalefns),\r\n            (s = o.scales),\r\n            (c = o.interpolate),\r\n            (l = o.data),\r\n            (u = E.area()\r\n              .x(i.xf)\r\n              .y0(s.Y.range()[0])\r\n              .y1(i.yf)\r\n              .curve(c)),\r\n            n\r\n              .append('path')\r\n              .attr('class', 'mg-main-area mg-area1-color')\r\n              .attr('d', u(l))\r\n        }\r\n        return (\r\n          (A = C),\r\n          (O = (D = t).missing_text),\r\n          (z = D.width),\r\n          (F = D.height),\r\n          A.selectAll('.mg-missing-text')\r\n            .data([O])\r\n            .enter()\r\n            .append('text')\r\n            .attr('class', 'mg-missing-text')\r\n            .attr('x', z / 2)\r\n            .attr('y', F / 2)\r\n            .attr('dy', '.50em')\r\n            .attr('text-anchor', 'middle')\r\n            .text(O),\r\n          R.windowListeners(),\r\n          R\r\n        )\r\n      }),\r\n        (this.windowListeners = function () {\r\n          return Qt(R.args), R\r\n        }),\r\n        this.init(t)\r\n    },\r\n    {\r\n      top: 40,\r\n      bottom: 30,\r\n      right: 10,\r\n      left: 0,\r\n      buffer: 8,\r\n      legend_target: '',\r\n      width: 350,\r\n      height: 220,\r\n      missing_text: 'Data currently missing or unavailable',\r\n      scalefns: {},\r\n      scales: {},\r\n      show_tooltips: !0,\r\n      show_missing_background: !0\r\n    }\r\n  ),\r\n    (MG.raw_data_transformation = Me),\r\n    (MG.process_line = Ae),\r\n    (MG.process_histogram = De),\r\n    (MG.process_categorical_variables = function (t) {\r\n      return (\r\n        'vertical' === t.bar_orientation ? t.x_accessor : t.y_accessor,\r\n        'vertical' === t.bar_orientation ? t.y_accessor : t.x_accessor,\r\n        this\r\n      )\r\n    }),\r\n    (MG.process_point = Oe),\r\n    (MG.add_ls = ze),\r\n    (MG.add_lowess = function (e) {\r\n      var t = O(e.target),\r\n        r = e.lowess_line,\r\n        a = E.svg\r\n          .line()\r\n          .x(function (t) {\r\n            return e.scales.X(t.x)\r\n          })\r\n          .y(function (t) {\r\n            return e.scales.Y(t.y)\r\n          })\r\n          .interpolate(e.interpolate)\r\n      t.append('path')\r\n        .attr('d', a(r))\r\n        .attr('class', 'mg-lowess-line')\r\n    }),\r\n    (MG.lowess_robust = function (t, e, r, a) {\r\n      var n,\r\n        o,\r\n        i = []\r\n      for (E.mean(e), o = 0; o < t.length; o += 1) i.push(1)\r\n      var s = (n = Re(t, e, r, a, i)).x,\r\n        c = n.y\r\n      for (o = 0; o < 100; o += 1) {\r\n        i = E.zip(c, e).map(function (t) {\r\n          return Math.abs(t[1] - t[0])\r\n        })\r\n        var l = E.quantile(i.sort(), 0.5)\r\n        ;(s = (n = Re(\r\n          t,\r\n          e,\r\n          r,\r\n          a,\r\n          (i = i.map(function (t) {\r\n            return Ce(t / (6 * l), 2)\r\n          }))\r\n        )).x),\r\n          (c = n.y)\r\n      }\r\n      return E.zip(s, c).map(function (t) {\r\n        var e = {}\r\n        return (e.x = t[0]), (e.y = t[1]), e\r\n      })\r\n    }),\r\n    (MG.lowess = function (t, e, r, a) {\r\n      for (var n = [], o = 0; o < t.length; o += 1) n.push(1)\r\n      Re(t, e, r, a, n)\r\n    }),\r\n    (MG.least_squares = Fe)\r\n  var Ye = function (t, e, r, a) {\r\n      return 'string' == typeof t ? MG.time_format(a, t)(e[r]) : 'function' == typeof t ? t(e) : e[r]\r\n    },\r\n    $e = function (t, e, r) {\r\n      return 'string' == typeof t ? E.format('s')(e[r]) : 'function' == typeof t ? t(e) : e[r]\r\n    }\r\n  function Pe (t, e, r, a, n) {\r\n    var o,\r\n      i = (function (t) {\r\n        if (t.rollover_time_format) return MG.time_format(t.utc_time, t.rollover_time_format)\r\n        switch (t.processed.x_time_frame) {\r\n          case 'millis':\r\n            return MG.time_format(t.utc_time, '%b %e, %Y  %H:%M:%S.%L')\r\n          case 'seconds':\r\n            return MG.time_format(t.utc_time, '%b %e, %Y  %H:%M:%S')\r\n          case 'less-than-a-day':\r\n          case 'four-days':\r\n            return MG.time_format(t.utc_time, '%b %e, %Y  %I:%M%p')\r\n        }\r\n        return MG.time_format(t.utc_time, '%b %e, %Y')\r\n      })(t)\r\n    return (\r\n      (o =\r\n        'string' == typeof e[a]\r\n          ? function (t) {\r\n              return t\r\n            }\r\n          : Ee(t)),\r\n      null !== r\r\n        ? n\r\n          ? Ye(r, e, a, t.utc)\r\n          : $e(r, e, a)\r\n        : n\r\n        ? i(new Date(+e[a])) + '  '\r\n        : (t.time_series ? '' : a + ': ') + o(e[a]) + '   '\r\n    )\r\n  }\r\n  function Se (t, e) {\r\n    return Pe(t, e, t.x_mouseover, t.x_accessor, t.time_series)\r\n  }\r\n  function Le (t, e) {\r\n    return Pe(t, e, t.y_mouseover, t.y_accessor, !1)\r\n  }\r\n  function je (c, l) {\r\n    return function () {\r\n      for (\r\n        var a = this,\r\n          n = a.cloneNode(),\r\n          o = a.getTotalLength() || 0,\r\n          i = (n.setAttribute('d', c), n).getTotalLength() || 0,\r\n          t = [0],\r\n          e = 0,\r\n          r = l / Math.max(o, i);\r\n        (e += r) < 1;\r\n\r\n      )\r\n        t.push(e)\r\n      t.push(1)\r\n      var s = t.map(function (t) {\r\n        var e = a.getPointAtLength(t * o),\r\n          r = n.getPointAtLength(t * i)\r\n        return E.interpolate([e.x, e.y], [r.x, r.y])\r\n      })\r\n      return function (e) {\r\n        return e < 1\r\n          ? 'M' +\r\n              s\r\n                .map(function (t) {\r\n                  return t(e)\r\n                })\r\n                .join('L')\r\n          : c\r\n      }\r\n    }\r\n  }\r\n  function Xe (t) {\r\n    console.error('ERROR : ', t.target, ' : ', t.error),\r\n      E.select(t.target)\r\n        .select('.mg-chart-title')\r\n        .append('tspan')\r\n        .attr('class', 'fa fa-x fa-exclamation-circle mg-warning')\r\n        .attr('dx', '0.3em')\r\n        .text('')\r\n  }\r\n  return (\r\n    (MG.format_rollover_number = Ee),\r\n    (MG.path_tween = je),\r\n    (MG.render_markup = function (t) {\r\n      switch ('undefined' == typeof window ? 'undefined' : c(window)) {\r\n        case 'undefined':\r\n          return (function (t) {\r\n            var e,\r\n              r = MG.virtual_window,\r\n              a = E.select(r.document),\r\n              n = r.document.createElement('div'),\r\n              o = __webpack_require__.g.d3,\r\n              i = __webpack_require__.g.window,\r\n              s = __webpack_require__.g.document\r\n            ;(__webpack_require__.g.d3 = a), (__webpack_require__.g.window = r), (__webpack_require__.g.document = r.document)\r\n            try {\r\n              t(n)\r\n            } catch (t) {\r\n              e = t\r\n            }\r\n            if (((__webpack_require__.g.d3 = o), (__webpack_require__.g.window = i), (__webpack_require__.g.document = s), e)) throw e\r\n            return a\r\n              .select(function () {\r\n                return n\r\n              })\r\n              .html()\r\n          })(t)\r\n        default:\r\n          return (e = t), (r = document.createElement('div')), e(r), E.select(r).html()\r\n      }\r\n      var e, r\r\n    }),\r\n    (MG.init_virtual_window = function (t, e) {\r\n      if (!MG.virtual_window || e) {\r\n        var r = t.jsdom({ html: '', features: { QuerySelector: !0 } })\r\n        MG.virtual_window = r.defaultView\r\n      }\r\n    }),\r\n    (MG.error = Xe),\r\n    MG\r\n  )\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js?");

/***/ }),

/***/ 772:
/*!****************************************************************************!*\
  !*** ./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/*\r\n * Very simple jQuery Color Picker\r\n * https://github.com/tkrotoff/jquery-simplecolorpicker\r\n *\r\n * Copyright (C) 2012-2013 Tanguy Krotoff <tkrotoff@gmail.com>\r\n *\r\n * Licensed under the MIT license\r\n */\r\n\r\n;(function ($) {\r\n  'use strict'\r\n\r\n  /**\r\n   * Constructor.\r\n   */\r\n  var SimpleColorPicker = function (select, options) {\r\n    this.init('simplecolorpicker', select, options)\r\n  }\r\n\r\n  /**\r\n   * SimpleColorPicker class.\r\n   */\r\n  SimpleColorPicker.prototype = {\r\n    constructor: SimpleColorPicker,\r\n\r\n    init: function (type, select, options) {\r\n      var self = this\r\n\r\n      self.type = type\r\n\r\n      self.$select = $(select)\r\n      self.$select.hide()\r\n\r\n      self.options = $.extend({}, $.fn.simplecolorpicker.defaults, options)\r\n\r\n      self.$colorList = null\r\n\r\n      if (self.options.picker === true) {\r\n        var selectText = self.$select.find('> option:selected').text()\r\n        self.$icon = $(\r\n          '<span class=\"simplecolorpicker icon\"' +\r\n            ' title=\"' +\r\n            selectText +\r\n            '\"' +\r\n            ' style=\"background-color: ' +\r\n            self.$select.val() +\r\n            ';\"' +\r\n            ' role=\"button\" tabindex=\"0\">' +\r\n            '</span>'\r\n        ).insertAfter(self.$select)\r\n        self.$icon.on('click.' + self.type, $.proxy(self.showPicker, self))\r\n\r\n        self.$picker = $('<span class=\"simplecolorpicker picker ' + self.options.theme + '\"></span>').appendTo(\r\n          document.body\r\n        )\r\n        self.$colorList = self.$picker\r\n\r\n        // Hide picker when clicking outside\r\n        $(document).on('mousedown.' + self.type, $.proxy(self.hidePicker, self))\r\n        self.$picker.on('mousedown.' + self.type, $.proxy(self.mousedown, self))\r\n      } else {\r\n        self.$inline = $('<span class=\"simplecolorpicker inline ' + self.options.theme + '\"></span>').insertAfter(\r\n          self.$select\r\n        )\r\n        self.$colorList = self.$inline\r\n      }\r\n\r\n      // Build the list of colors\r\n      // <span class=\"color selected\" title=\"Green\" style=\"background-color: #7bd148;\" role=\"button\"></span>\r\n      self.$select.find('> option').each(function () {\r\n        var $option = $(this)\r\n        var color = $option.val()\r\n\r\n        var isSelected = $option.is(':selected')\r\n        var isDisabled = $option.is(':disabled')\r\n\r\n        var selected = ''\r\n        if (isSelected === true) {\r\n          selected = ' data-selected'\r\n        }\r\n\r\n        var disabled = ''\r\n        if (isDisabled === true) {\r\n          disabled = ' data-disabled'\r\n        }\r\n\r\n        var title = ''\r\n        if (isDisabled === false) {\r\n          title = ' title=\"' + $option.text() + '\"'\r\n        }\r\n\r\n        var role = ''\r\n        if (isDisabled === false) {\r\n          role = ' role=\"button\" tabindex=\"0\"'\r\n        }\r\n\r\n        var $colorSpan = $(\r\n          '<span class=\"color\"' +\r\n            title +\r\n            ' style=\"background-color: ' +\r\n            color +\r\n            ';\"' +\r\n            ' data-color=\"' +\r\n            color +\r\n            '\"' +\r\n            selected +\r\n            disabled +\r\n            role +\r\n            '>' +\r\n            '</span>'\r\n        )\r\n\r\n        self.$colorList.append($colorSpan)\r\n        $colorSpan.on('click.' + self.type, $.proxy(self.colorSpanClicked, self))\r\n\r\n        var $next = $option.next()\r\n        if ($next.is('optgroup') === true) {\r\n          // Vertical break, like hr\r\n          self.$colorList.append('<span class=\"vr\"></span>')\r\n        }\r\n      })\r\n    },\r\n\r\n    /**\r\n     * Changes the selected color.\r\n     *\r\n     * @param color the hexadecimal color to select, ex: '#fbd75b'\r\n     */\r\n    selectColor: function (color) {\r\n      var self = this\r\n\r\n      var $colorSpan = self.$colorList.find('> span.color').filter(function () {\r\n        return (\r\n          $(this)\r\n            .data('color')\r\n            .toLowerCase() === color.toLowerCase()\r\n        )\r\n      })\r\n\r\n      if ($colorSpan.length > 0) {\r\n        self.selectColorSpan($colorSpan)\r\n      } else {\r\n        console.error(\"The given color '\" + color + \"' could not be found\")\r\n      }\r\n    },\r\n\r\n    showPicker: function () {\r\n      var pos = this.$icon.offset()\r\n      this.$picker.css({\r\n        // Remove some pixels to align the picker icon with the icons inside the dropdown\r\n        left: pos.left - 6,\r\n        top: pos.top + this.$icon.outerHeight()\r\n      })\r\n\r\n      this.$picker.show(this.options.pickerDelay)\r\n    },\r\n\r\n    hidePicker: function () {\r\n      this.$picker.hide(this.options.pickerDelay)\r\n    },\r\n\r\n    /**\r\n     * Selects the given span inside $colorList.\r\n     *\r\n     * The given span becomes the selected one.\r\n     * It also changes the HTML select value, this will emit the 'change' event.\r\n     */\r\n    selectColorSpan: function ($colorSpan) {\r\n      var color = $colorSpan.data('color')\r\n      var title = $colorSpan.prop('title')\r\n\r\n      // Mark this span as the selected one\r\n      $colorSpan.siblings().removeAttr('data-selected')\r\n      $colorSpan.attr('data-selected', '')\r\n\r\n      if (this.options.picker === true) {\r\n        this.$icon.css('background-color', color)\r\n        this.$icon.prop('title', title)\r\n        this.hidePicker()\r\n      }\r\n\r\n      // Change HTML select value\r\n      this.$select.val(color)\r\n    },\r\n\r\n    /**\r\n     * The user clicked on a color inside $colorList.\r\n     */\r\n    colorSpanClicked: function (e) {\r\n      // When a color is clicked, make it the new selected one (unless disabled)\r\n      if ($(e.target).is('[data-disabled]') === false) {\r\n        this.selectColorSpan($(e.target))\r\n        this.$select.trigger('change')\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Prevents the mousedown event from \"eating\" the click event.\r\n     */\r\n    mousedown: function (e) {\r\n      e.stopPropagation()\r\n      e.preventDefault()\r\n    },\r\n\r\n    destroy: function () {\r\n      if (this.options.picker === true) {\r\n        this.$icon.off('.' + this.type)\r\n        this.$icon.remove()\r\n        $(document).off('.' + this.type)\r\n      }\r\n\r\n      this.$colorList.off('.' + this.type)\r\n      this.$colorList.remove()\r\n\r\n      this.$select.removeData(this.type)\r\n      this.$select.show()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Plugin definition.\r\n   * How to use: $('#id').simplecolorpicker()\r\n   */\r\n  $.fn.simplecolorpicker = function (option) {\r\n    var args = $.makeArray(arguments)\r\n    args.shift()\r\n\r\n    // For HTML element passed to the plugin\r\n    return this.each(function () {\r\n      var $this = $(this),\r\n        data = $this.data('simplecolorpicker'),\r\n        options = typeof option === 'object' && option\r\n      if (data === undefined) {\r\n        $this.data('simplecolorpicker', (data = new SimpleColorPicker(this, options)))\r\n      }\r\n      if (typeof option === 'string') {\r\n        data[option].apply(data, args)\r\n      }\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Default options.\r\n   */\r\n  $.fn.simplecolorpicker.defaults = {\r\n    // No theme by default\r\n    theme: '',\r\n\r\n    // Show the picker or make it inline\r\n    picker: false,\r\n\r\n    // Animation delay in milliseconds\r\n    pickerDelay: 0\r\n  }\r\n})(jQuery)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js?");

/***/ })

}]);