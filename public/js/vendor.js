(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendor"],{

/***/ "./src/public/js/plugins/jquery.custom.js":
/*!************************************************!*\
  !*** ./src/public/js/plugins/jquery.custom.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/*!\n * jQuery serializeObject - v0.2 - 1/20/2010\n * http://benalman.com/projects/jquery-misc-plugins/\n *\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\n * Dual licensed under the MIT and GPL licenses.\n * http://benalman.com/about/license/\n */\n\n// Whereas .serializeArray() serializes a form into an array, .serializeObject()\n// serializes a form into an (arguably more useful) object.\n\n;(function ($, undefined) {\n  '$:nomunge' // Used by YUI compressor.\n\n  $.fn.serializeObject = function () {\n    var obj = {}\n\n    $.each(this.serializeArray(), function (i, o) {\n      var n = o.name,\n        v = o.value\n\n      obj[n] = obj[n] === undefined ? v : $.isArray(obj[n]) ? obj[n].concat(v) : [obj[n], v]\n    })\n\n    return obj\n  }\n\n  /**\n   This is a jQuery plugin to support resizing text areas.\n\n   Originally based off text area resizer by Ryan O'Dell : http://plugins.jquery.com/misc/textarea.js\n   Modifications by Discourse https://github.com/discourse/discourse\n   @module $.fn.DivResizer\n   **/\n\n  var div,\n    endDrag,\n    grip,\n    lastMousePos,\n    min,\n    mousePosition,\n    originalDivHeight,\n    originalPos,\n    performDrag,\n    startDrag,\n    wrappedEndDrag,\n    wrappedPerformDrag\n  div = void 0\n  originalPos = void 0\n  originalDivHeight = void 0\n  lastMousePos = 0\n  min = 350\n  grip = void 0\n  wrappedEndDrag = void 0\n  wrappedPerformDrag = void 0\n\n  startDrag = function (e, opts) {\n    div = $(e.data.el)\n    div.addClass('clear-transitions')\n    div.blur()\n    lastMousePos = mousePosition(e).y\n    originalPos = lastMousePos\n    originalDivHeight = div.height()\n    wrappedPerformDrag = (function () {\n      return function (e) {\n        return performDrag(e, opts)\n      }\n    })()\n    wrappedEndDrag = (function () {\n      return function (e) {\n        return endDrag(e, opts)\n      }\n    })()\n    $(document)\n      .mousemove(wrappedPerformDrag)\n      .mouseup(wrappedEndDrag)\n    return false\n  }\n\n  performDrag = function (e, opts) {\n    $(div).trigger('div-resizing')\n\n    var size, sizePx, thisMousePos\n    thisMousePos = mousePosition(e).y\n    size = originalDivHeight + (originalPos - thisMousePos)\n    lastMousePos = thisMousePos\n\n    var maxHeight = $(window).height()\n    if (opts.maxHeight) {\n      maxHeight = opts.maxHeight(maxHeight)\n    }\n    size = Math.min(size, maxHeight)\n    size = Math.max(min, size)\n    sizePx = size + 'px'\n    if (typeof opts.onDrag === 'function') {\n      opts.onDrag(sizePx)\n    }\n    div.height(sizePx)\n    if (size < min) {\n      endDrag(e, opts)\n    }\n    return false\n  }\n\n  endDrag = function (e, opts) {\n    $(document)\n      .unbind('mousemove', wrappedPerformDrag)\n      .unbind('mouseup', wrappedEndDrag)\n    div.removeClass('clear-transitions')\n    div.focus()\n    if (typeof opts.resize === 'function') {\n      opts.resize()\n    }\n    $(div).trigger('div-resized')\n    div = null\n  }\n\n  mousePosition = function (e) {\n    return {\n      x: e.clientX + document.documentElement.scrollLeft,\n      y: e.clientY + document.documentElement.scrollTop\n    }\n  }\n\n  $.fn.DivResizer = function (opts) {\n    return this.each(function () {\n      var grippie, start, staticOffset\n      div = $(this)\n      if (div.hasClass('processed')) return\n      div.addClass('processed')\n      staticOffset = null\n      start = function () {\n        return function (e) {\n          return startDrag(e, opts)\n        }\n      }\n      grippie = div\n        .prepend(\"<div class='grippie'></div>\")\n        .find('.grippie')\n        .bind(\n          'mousedown',\n          {\n            el: this\n          },\n          start()\n        )\n    })\n  }\n})(jQuery)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/plugins/jquery.custom.js?");

/***/ }),

/***/ "./src/public/js/vendor/angular/angular-cookies.min.js":
/*!*************************************************************!*\
  !*** ./src/public/js/vendor/angular/angular-cookies.min.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n AngularJS v1.4.7\n (c) 2010-2015 Google, Inc. http://angularjs.org\n License: MIT\n */\n;(function (p, c, n) {\n  'use strict'\n  function l (b, a, g) {\n    var d = g.baseHref(),\n      k = b[0]\n    return function (b, e, f) {\n      var g, h\n      f = f || {}\n      h = f.expires\n      g = c.isDefined(f.path) ? f.path : d\n      c.isUndefined(e) && ((h = 'Thu, 01 Jan 1970 00:00:00 GMT'), (e = ''))\n      c.isString(h) && (h = new Date(h))\n      e = encodeURIComponent(b) + '=' + encodeURIComponent(e)\n      e = e + (g ? ';path=' + g : '') + (f.domain ? ';domain=' + f.domain : '')\n      e += h ? ';expires=' + h.toUTCString() : ''\n      e += f.secure ? ';secure' : ''\n      f = e.length + 1\n      4096 < f &&\n        a.warn(\"Cookie '\" + b + \"' possibly not set or overflowed because it was too large (\" + f + ' > 4096 bytes)!')\n      k.cookie = e\n    }\n  }\n  c.module('ngCookies', ['ng']).provider('$cookies', [\n    function () {\n      var b = (this.defaults = {})\n      this.$get = [\n        '$$cookieReader',\n        '$$cookieWriter',\n        function (a, g) {\n          return {\n            get: function (d) {\n              return a()[d]\n            },\n            getObject: function (d) {\n              return (d = this.get(d)) ? c.fromJson(d) : d\n            },\n            getAll: function () {\n              return a()\n            },\n            put: function (d, a, m) {\n              g(d, a, m ? c.extend({}, b, m) : b)\n            },\n            putObject: function (d, b, a) {\n              this.put(d, c.toJson(b), a)\n            },\n            remove: function (a, k) {\n              g(a, n, k ? c.extend({}, b, k) : b)\n            }\n          }\n        }\n      ]\n    }\n  ])\n  c.module('ngCookies').factory('$cookieStore', [\n    '$cookies',\n    function (b) {\n      return {\n        get: function (a) {\n          return b.getObject(a)\n        },\n        put: function (a, c) {\n          b.putObject(a, c)\n        },\n        remove: function (a) {\n          b.remove(a)\n        }\n      }\n    }\n  ])\n  l.$inject = ['$document', '$log', '$browser']\n  c.module('ngCookies').provider('$$cookieWriter', function () {\n    this.$get = l\n  })\n})(window, window.angular)\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/angular/angular-cookies.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/angular/angular-route.min.js":
/*!***********************************************************!*\
  !*** ./src/public/js/vendor/angular/angular-route.min.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n AngularJS v1.4.7\n (c) 2010-2015 Google, Inc. http://angularjs.org\n License: MIT\n */\n;(function (p, c, C) {\n  'use strict'\n  function v (r, h, g) {\n    return {\n      restrict: 'ECA',\n      terminal: !0,\n      priority: 400,\n      transclude: 'element',\n      link: function (a, f, b, d, y) {\n        function z () {\n          k && (g.cancel(k), (k = null))\n          l && (l.$destroy(), (l = null))\n          m &&\n            ((k = g.leave(m)),\n            k.then(function () {\n              k = null\n            }),\n            (m = null))\n        }\n        function x () {\n          var b = r.current && r.current.locals\n          if (c.isDefined(b && b.$template)) {\n            var b = a.$new(),\n              d = r.current\n            m = y(b, function (b) {\n              g.enter(b, null, m || f).then(function () {\n                !c.isDefined(t) || (t && !a.$eval(t)) || h()\n              })\n              z()\n            })\n            l = d.scope = b\n            l.$emit('$viewContentLoaded')\n            l.$eval(w)\n          } else z()\n        }\n        var l,\n          m,\n          k,\n          t = b.autoscroll,\n          w = b.onload || ''\n        a.$on('$routeChangeSuccess', x)\n        x()\n      }\n    }\n  }\n  function A (c, h, g) {\n    return {\n      restrict: 'ECA',\n      priority: -400,\n      link: function (a, f) {\n        var b = g.current,\n          d = b.locals\n        f.html(d.$template)\n        var y = c(f.contents())\n        b.controller &&\n          ((d.$scope = a),\n          (d = h(b.controller, d)),\n          b.controllerAs && (a[b.controllerAs] = d),\n          f.data('$ngControllerController', d),\n          f.children().data('$ngControllerController', d))\n        y(a)\n      }\n    }\n  }\n  p = c.module('ngRoute', ['ng']).provider('$route', function () {\n    function r (a, f) {\n      return c.extend(Object.create(a), f)\n    }\n    function h (a, c) {\n      var b = c.caseInsensitiveMatch,\n        d = { originalPath: a, regexp: a },\n        g = (d.keys = [])\n      a = a\n        .replace(/([().])/g, '\\\\$1')\n        .replace(/(\\/)?:(\\w+)([\\?\\*])?/g, function (a, c, b, d) {\n          a = '?' === d ? d : null\n          d = '*' === d ? d : null\n          g.push({ name: b, optional: !!a })\n          c = c || ''\n          return '' + (a ? '' : c) + '(?:' + (a ? c : '') + ((d && '(.+?)') || '([^/]+)') + (a || '') + ')' + (a || '')\n        })\n        .replace(/([\\/$\\*])/g, '\\\\$1')\n      d.regexp = new RegExp('^' + a + '$', b ? 'i' : '')\n      return d\n    }\n    var g = {}\n    this.when = function (a, f) {\n      var b = c.copy(f)\n      c.isUndefined(b.reloadOnSearch) && (b.reloadOnSearch = !0)\n      c.isUndefined(b.caseInsensitiveMatch) && (b.caseInsensitiveMatch = this.caseInsensitiveMatch)\n      g[a] = c.extend(b, a && h(a, b))\n      if (a) {\n        var d = '/' == a[a.length - 1] ? a.substr(0, a.length - 1) : a + '/'\n        g[d] = c.extend({ redirectTo: a }, h(d, b))\n      }\n      return this\n    }\n    this.caseInsensitiveMatch = !1\n    this.otherwise = function (a) {\n      'string' === typeof a && (a = { redirectTo: a })\n      this.when(null, a)\n      return this\n    }\n    this.$get = [\n      '$rootScope',\n      '$location',\n      '$routeParams',\n      '$q',\n      '$injector',\n      '$templateRequest',\n      '$sce',\n      function (a, f, b, d, h, p, x) {\n        function l (b) {\n          var e = s.current\n          ;(v =\n            (n = k()) &&\n            e &&\n            n.$$route === e.$$route &&\n            c.equals(n.pathParams, e.pathParams) &&\n            !n.reloadOnSearch &&\n            !w) ||\n            (!e && !n) ||\n            (a.$broadcast('$routeChangeStart', n, e).defaultPrevented && b && b.preventDefault())\n        }\n        function m () {\n          var u = s.current,\n            e = n\n          if (v) (u.params = e.params), c.copy(u.params, b), a.$broadcast('$routeUpdate', u)\n          else if (e || u)\n            (w = !1),\n              (s.current = e) &&\n                e.redirectTo &&\n                (c.isString(e.redirectTo)\n                  ? f\n                      .path(t(e.redirectTo, e.params))\n                      .search(e.params)\n                      .replace()\n                  : f.url(e.redirectTo(e.pathParams, f.path(), f.search())).replace()),\n              d\n                .when(e)\n                .then(function () {\n                  if (e) {\n                    var a = c.extend({}, e.resolve),\n                      b,\n                      f\n                    c.forEach(a, function (b, e) {\n                      a[e] = c.isString(b) ? h.get(b) : h.invoke(b, null, null, e)\n                    })\n                    c.isDefined((b = e.template))\n                      ? c.isFunction(b) && (b = b(e.params))\n                      : c.isDefined((f = e.templateUrl)) &&\n                        (c.isFunction(f) && (f = f(e.params)),\n                        c.isDefined(f) && ((e.loadedTemplateUrl = x.valueOf(f)), (b = p(f))))\n                    c.isDefined(b) && (a.$template = b)\n                    return d.all(a)\n                  }\n                })\n                .then(\n                  function (f) {\n                    e == s.current &&\n                      (e && ((e.locals = f), c.copy(e.params, b)), a.$broadcast('$routeChangeSuccess', e, u))\n                  },\n                  function (b) {\n                    e == s.current && a.$broadcast('$routeChangeError', e, u, b)\n                  }\n                )\n        }\n        function k () {\n          var a, b\n          c.forEach(g, function (d, g) {\n            var q\n            if ((q = !b)) {\n              var h = f.path()\n              q = d.keys\n              var l = {}\n              if (d.regexp)\n                if ((h = d.regexp.exec(h))) {\n                  for (var k = 1, m = h.length; k < m; ++k) {\n                    var n = q[k - 1],\n                      p = h[k]\n                    n && p && (l[n.name] = p)\n                  }\n                  q = l\n                } else q = null\n              else q = null\n              q = a = q\n            }\n            q && ((b = r(d, { params: c.extend({}, f.search(), a), pathParams: a })), (b.$$route = d))\n          })\n          return b || (g[null] && r(g[null], { params: {}, pathParams: {} }))\n        }\n        function t (a, b) {\n          var d = []\n          c.forEach((a || '').split(':'), function (a, c) {\n            if (0 === c) d.push(a)\n            else {\n              var f = a.match(/(\\w+)(?:[?*])?(.*)/),\n                g = f[1]\n              d.push(b[g])\n              d.push(f[2] || '')\n              delete b[g]\n            }\n          })\n          return d.join('')\n        }\n        var w = !1,\n          n,\n          v,\n          s = {\n            routes: g,\n            reload: function () {\n              w = !0\n              a.$evalAsync(function () {\n                l()\n                m()\n              })\n            },\n            updateParams: function (a) {\n              if (this.current && this.current.$$route)\n                (a = c.extend({}, this.current.params, a)), f.path(t(this.current.$$route.originalPath, a)), f.search(a)\n              else throw B('norout')\n            }\n          }\n        a.$on('$locationChangeStart', l)\n        a.$on('$locationChangeSuccess', m)\n        return s\n      }\n    ]\n  })\n  var B = c.$$minErr('ngRoute')\n  p.provider('$routeParams', function () {\n    this.$get = function () {\n      return {}\n    }\n  })\n  p.directive('ngView', v)\n  p.directive('ngView', A)\n  v.$inject = ['$route', '$anchorScroll', '$animate']\n  A.$inject = ['$compile', '$controller', '$route']\n})(window, window.angular)\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/angular/angular-route.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/angular/angular-sanitize.min.js":
/*!**************************************************************!*\
  !*** ./src/public/js/vendor/angular/angular-sanitize.min.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n AngularJS v1.4.7\n (c) 2010-2015 Google, Inc. http://angularjs.org\n License: MIT\n */\n;(function (n, h, p) {\n  'use strict'\n  function E (a) {\n    var f = []\n    r(f, h.noop).chars(a)\n    return f.join('')\n  }\n  function g (a, f) {\n    var d = {},\n      c = a.split(','),\n      b\n    for (b = 0; b < c.length; b++) d[f ? h.lowercase(c[b]) : c[b]] = !0\n    return d\n  }\n  function F (a, f) {\n    function d (a, b, d, l) {\n      b = h.lowercase(b)\n      if (s[b]) for (; e.last() && t[e.last()]; ) c('', e.last())\n      u[b] && e.last() == b && c('', b)\n      ;(l = v[b] || !!l) || e.push(b)\n      var m = {}\n      d.replace(G, function (b, a, f, c, d) {\n        m[a] = q(f || c || d || '')\n      })\n      f.start && f.start(b, m, l)\n    }\n    function c (b, a) {\n      var c = 0,\n        d\n      if ((a = h.lowercase(a))) for (c = e.length - 1; 0 <= c && e[c] != a; c--);\n      if (0 <= c) {\n        for (d = e.length - 1; d >= c; d--) f.end && f.end(e[d])\n        e.length = c\n      }\n    }\n    'string' !== typeof a && (a = null === a || 'undefined' === typeof a ? '' : '' + a)\n    var b,\n      k,\n      e = [],\n      m = a,\n      l\n    for (\n      e.last = function () {\n        return e[e.length - 1]\n      };\n      a;\n\n    ) {\n      l = ''\n      k = !0\n      if (e.last() && w[e.last()])\n        (a = a.replace(new RegExp('([\\\\W\\\\w]*)<\\\\s*\\\\/\\\\s*' + e.last() + '[^>]*>', 'i'), function (a, b) {\n          b = b.replace(H, '$1').replace(I, '$1')\n          f.chars && f.chars(q(b))\n          return ''\n        })),\n          c('', e.last())\n      else {\n        if (0 === a.indexOf('\\x3c!--'))\n          (b = a.indexOf('--', 4)),\n            0 <= b &&\n              a.lastIndexOf('--\\x3e', b) === b &&\n              (f.comment && f.comment(a.substring(4, b)), (a = a.substring(b + 3)), (k = !1))\n        else if (x.test(a)) {\n          if ((b = a.match(x))) (a = a.replace(b[0], '')), (k = !1)\n        } else if (J.test(a)) {\n          if ((b = a.match(y))) (a = a.substring(b[0].length)), b[0].replace(y, c), (k = !1)\n        } else\n          K.test(a) &&\n            ((b = a.match(z))\n              ? (b[4] && ((a = a.substring(b[0].length)), b[0].replace(z, d)), (k = !1))\n              : ((l += '<'), (a = a.substring(1))))\n        k &&\n          ((b = a.indexOf('<')),\n          (l += 0 > b ? a : a.substring(0, b)),\n          (a = 0 > b ? '' : a.substring(b)),\n          f.chars && f.chars(q(l)))\n      }\n      if (a == m) throw L('badparse', a)\n      m = a\n    }\n    c()\n  }\n  function q (a) {\n    if (!a) return ''\n    A.innerHTML = a.replace(/</g, '&lt;')\n    return A.textContent\n  }\n  function B (a) {\n    return a\n      .replace(/&/g, '&amp;')\n      .replace(M, function (a) {\n        var d = a.charCodeAt(0)\n        a = a.charCodeAt(1)\n        return '&#' + (1024 * (d - 55296) + (a - 56320) + 65536) + ';'\n      })\n      .replace(N, function (a) {\n        return '&#' + a.charCodeAt(0) + ';'\n      })\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n  }\n  function r (a, f) {\n    var d = !1,\n      c = h.bind(a, a.push)\n    return {\n      start: function (a, k, e) {\n        a = h.lowercase(a)\n        !d && w[a] && (d = a)\n        d ||\n          !0 !== C[a] ||\n          (c('<'),\n          c(a),\n          h.forEach(k, function (d, e) {\n            var k = h.lowercase(e),\n              g = ('img' === a && 'src' === k) || 'background' === k\n            !0 !== O[k] || (!0 === D[k] && !f(d, g)) || (c(' '), c(e), c('=\"'), c(B(d)), c('\"'))\n          }),\n          c(e ? '/>' : '>'))\n      },\n      end: function (a) {\n        a = h.lowercase(a)\n        d || !0 !== C[a] || (c('</'), c(a), c('>'))\n        a == d && (d = !1)\n      },\n      chars: function (a) {\n        d || c(B(a))\n      }\n    }\n  }\n  var L = h.$$minErr('$sanitize'),\n    z = /^<((?:[a-zA-Z])[\\w:-]*)((?:\\s+[\\w:-]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)\\s*(>?)/,\n    y = /^<\\/\\s*([\\w:-]+)[^>]*>/,\n    G = /([\\w:-]+)(?:\\s*=\\s*(?:(?:\"((?:[^\"])*)\")|(?:'((?:[^'])*)')|([^>\\s]+)))?/g,\n    K = /^</,\n    J = /^<\\//,\n    H = /\\x3c!--(.*?)--\\x3e/g,\n    x = /<!DOCTYPE([^>]*?)>/i,\n    I = /<!\\[CDATA\\[(.*?)]]\\x3e/g,\n    M = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n    N = /([^\\#-~| |!])/g,\n    v = g('area,br,col,hr,img,wbr')\n  n = g('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr')\n  p = g('rp,rt')\n  var u = h.extend({}, p, n),\n    s = h.extend(\n      {},\n      n,\n      g(\n        'address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul'\n      )\n    ),\n    t = h.extend(\n      {},\n      p,\n      g(\n        'a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var'\n      )\n    )\n  n = g(\n    'circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan,use'\n  )\n  var w = g('script,style'),\n    C = h.extend({}, v, s, t, u, n),\n    D = g('background,cite,href,longdesc,src,usemap,xlink:href')\n  n = g(\n    'abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width'\n  )\n  p = g(\n    'accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan',\n    !0\n  )\n  var O = h.extend({}, D, p, n),\n    A = document.createElement('pre')\n  h.module('ngSanitize', []).provider('$sanitize', function () {\n    this.$get = [\n      '$$sanitizeUri',\n      function (a) {\n        return function (f) {\n          var d = []\n          F(\n            f,\n            r(d, function (c, b) {\n              return !/^unsafe/.test(a(c, b))\n            })\n          )\n          return d.join('')\n        }\n      }\n    ]\n  })\n  h.module('ngSanitize').filter('linky', [\n    '$sanitize',\n    function (a) {\n      var f = /((ftp|https?):\\/\\/|(www\\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\\S*[^\\s.;,(){}<>\"\\u201d\\u2019]/i,\n        d = /^mailto:/i\n      return function (c, b) {\n        function k (a) {\n          a && g.push(E(a))\n        }\n        function e (a, c) {\n          g.push('<a ')\n          h.isDefined(b) && g.push('target=\"', b, '\" ')\n          g.push('href=\"', a.replace(/\"/g, '&quot;'), '\">')\n          k(c)\n          g.push('</a>')\n        }\n        if (!c) return c\n        for (var m, l = c, g = [], n, p; (m = l.match(f)); )\n          (n = m[0]),\n            m[2] || m[4] || (n = (m[3] ? 'http://' : 'mailto:') + n),\n            (p = m.index),\n            k(l.substr(0, p)),\n            e(n, m[0].replace(d, '')),\n            (l = l.substring(p + m[0].length))\n        k(l)\n        return a(g.join(''))\n      }\n    }\n  ])\n})(window, window.angular)\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/angular/angular-sanitize.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/angular/angular.min.js":
/*!*****************************************************!*\
  !*** ./src/public/js/vendor/angular/angular.min.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_jQuery) {/*\n AngularJS v1.4.7\n (c) 2010-2015 Google, Inc. http://angularjs.org\n License: MIT\n */\n;(function (Q, X, w) {\n  'use strict'\n  function I (b) {\n    return function () {\n      var a = arguments[0],\n        c\n      c = '[' + (b ? b + ':' : '') + a + '] http://errors.angularjs.org/1.4.7/' + (b ? b + '/' : '') + a\n      for (a = 1; a < arguments.length; a++) {\n        c = c + (1 == a ? '?' : '&') + 'p' + (a - 1) + '='\n        var d = encodeURIComponent,\n          e\n        e = arguments[a]\n        e =\n          'function' == typeof e\n            ? e.toString().replace(/ \\{[\\s\\S]*$/, '')\n            : 'undefined' == typeof e\n            ? 'undefined'\n            : 'string' != typeof e\n            ? JSON.stringify(e)\n            : e\n        c += d(e)\n      }\n      return Error(c)\n    }\n  }\n  function Da (b) {\n    if (null == b || Za(b)) return !1\n    var a = 'length' in Object(b) && b.length\n    return b.nodeType === pa && a ? !0 : G(b) || J(b) || 0 === a || ('number' === typeof a && 0 < a && a - 1 in b)\n  }\n  function m (b, a, c) {\n    var d, e\n    if (b)\n      if (x(b))\n        for (d in b)\n          'prototype' == d ||\n            'length' == d ||\n            'name' == d ||\n            (b.hasOwnProperty && !b.hasOwnProperty(d)) ||\n            a.call(c, b[d], d, b)\n      else if (J(b) || Da(b)) {\n        var f = 'object' !== typeof b\n        d = 0\n        for (e = b.length; d < e; d++) (f || d in b) && a.call(c, b[d], d, b)\n      } else if (b.forEach && b.forEach !== m) b.forEach(a, c, b)\n      else if (mc(b)) for (d in b) a.call(c, b[d], d, b)\n      else if ('function' === typeof b.hasOwnProperty) for (d in b) b.hasOwnProperty(d) && a.call(c, b[d], d, b)\n      else for (d in b) ta.call(b, d) && a.call(c, b[d], d, b)\n    return b\n  }\n  function nc (b, a, c) {\n    for (var d = Object.keys(b).sort(), e = 0; e < d.length; e++) a.call(c, b[d[e]], d[e])\n    return d\n  }\n  function oc (b) {\n    return function (a, c) {\n      b(c, a)\n    }\n  }\n  function Ud () {\n    return ++nb\n  }\n  function pc (b, a) {\n    a ? (b.$$hashKey = a) : delete b.$$hashKey\n  }\n  function Mb (b, a, c) {\n    for (var d = b.$$hashKey, e = 0, f = a.length; e < f; ++e) {\n      var h = a[e]\n      if (C(h) || x(h))\n        for (var g = Object.keys(h), l = 0, k = g.length; l < k; l++) {\n          var n = g[l],\n            p = h[n]\n          c && C(p)\n            ? ea(p)\n              ? (b[n] = new Date(p.valueOf()))\n              : Oa(p)\n              ? (b[n] = new RegExp(p))\n              : (C(b[n]) || (b[n] = J(p) ? [] : {}), Mb(b[n], [p], !0))\n            : (b[n] = p)\n        }\n    }\n    pc(b, d)\n    return b\n  }\n  function P (b) {\n    return Mb(b, ua.call(arguments, 1), !1)\n  }\n  function Vd (b) {\n    return Mb(b, ua.call(arguments, 1), !0)\n  }\n  function Y (b) {\n    return parseInt(b, 10)\n  }\n  function Nb (b, a) {\n    return P(Object.create(b), a)\n  }\n  function y () {}\n  function $a (b) {\n    return b\n  }\n  function qa (b) {\n    return function () {\n      return b\n    }\n  }\n  function qc (b) {\n    return x(b.toString) && b.toString !== Object.prototype.toString\n  }\n  function v (b) {\n    return 'undefined' === typeof b\n  }\n  function A (b) {\n    return 'undefined' !== typeof b\n  }\n  function C (b) {\n    return null !== b && 'object' === typeof b\n  }\n  function mc (b) {\n    return null !== b && 'object' === typeof b && !rc(b)\n  }\n  function G (b) {\n    return 'string' === typeof b\n  }\n  function V (b) {\n    return 'number' === typeof b\n  }\n  function ea (b) {\n    return '[object Date]' === va.call(b)\n  }\n  function x (b) {\n    return 'function' === typeof b\n  }\n  function Oa (b) {\n    return '[object RegExp]' === va.call(b)\n  }\n  function Za (b) {\n    return b && b.window === b\n  }\n  function ab (b) {\n    return b && b.$evalAsync && b.$watch\n  }\n  function bb (b) {\n    return 'boolean' === typeof b\n  }\n  function sc (b) {\n    return !(!b || !(b.nodeName || (b.prop && b.attr && b.find)))\n  }\n  function Wd (b) {\n    var a = {}\n    b = b.split(',')\n    var c\n    for (c = 0; c < b.length; c++) a[b[c]] = !0\n    return a\n  }\n  function wa (b) {\n    return F(b.nodeName || (b[0] && b[0].nodeName))\n  }\n  function cb (b, a) {\n    var c = b.indexOf(a)\n    0 <= c && b.splice(c, 1)\n    return c\n  }\n  function ha (b, a, c, d) {\n    if (Za(b) || ab(b)) throw Ea('cpws')\n    if (tc.test(va.call(a))) throw Ea('cpta')\n    if (a) {\n      if (b === a) throw Ea('cpi')\n      c = c || []\n      d = d || []\n      C(b) && (c.push(b), d.push(a))\n      var e\n      if (J(b)) for (e = a.length = 0; e < b.length; e++) a.push(ha(b[e], null, c, d))\n      else {\n        var f = a.$$hashKey\n        J(a)\n          ? (a.length = 0)\n          : m(a, function (b, c) {\n              delete a[c]\n            })\n        if (mc(b)) for (e in b) a[e] = ha(b[e], null, c, d)\n        else if (b && 'function' === typeof b.hasOwnProperty)\n          for (e in b) b.hasOwnProperty(e) && (a[e] = ha(b[e], null, c, d))\n        else for (e in b) ta.call(b, e) && (a[e] = ha(b[e], null, c, d))\n        pc(a, f)\n      }\n    } else if (((a = b), C(b))) {\n      if (c && -1 !== (f = c.indexOf(b))) return d[f]\n      if (J(b)) return ha(b, [], c, d)\n      if (tc.test(va.call(b))) a = new b.constructor(b)\n      else if (ea(b)) a = new Date(b.getTime())\n      else if (Oa(b)) (a = new RegExp(b.source, b.toString().match(/[^\\/]*$/)[0])), (a.lastIndex = b.lastIndex)\n      else if (x(b.cloneNode)) a = b.cloneNode(!0)\n      else return (e = Object.create(rc(b))), ha(b, e, c, d)\n      d && (c.push(b), d.push(a))\n    }\n    return a\n  }\n  function ja (b, a) {\n    if (J(b)) {\n      a = a || []\n      for (var c = 0, d = b.length; c < d; c++) a[c] = b[c]\n    } else if (C(b)) for (c in ((a = a || {}), b)) if ('$' !== c.charAt(0) || '$' !== c.charAt(1)) a[c] = b[c]\n    return a || b\n  }\n  function ka (b, a) {\n    if (b === a) return !0\n    if (null === b || null === a) return !1\n    if (b !== b && a !== a) return !0\n    var c = typeof b,\n      d\n    if (c == typeof a && 'object' == c)\n      if (J(b)) {\n        if (!J(a)) return !1\n        if ((c = b.length) == a.length) {\n          for (d = 0; d < c; d++) if (!ka(b[d], a[d])) return !1\n          return !0\n        }\n      } else {\n        if (ea(b)) return ea(a) ? ka(b.getTime(), a.getTime()) : !1\n        if (Oa(b)) return Oa(a) ? b.toString() == a.toString() : !1\n        if (ab(b) || ab(a) || Za(b) || Za(a) || J(a) || ea(a) || Oa(a)) return !1\n        c = fa()\n        for (d in b)\n          if ('$' !== d.charAt(0) && !x(b[d])) {\n            if (!ka(b[d], a[d])) return !1\n            c[d] = !0\n          }\n        for (d in a) if (!(d in c) && '$' !== d.charAt(0) && A(a[d]) && !x(a[d])) return !1\n        return !0\n      }\n    return !1\n  }\n  function db (b, a, c) {\n    return b.concat(ua.call(a, c))\n  }\n  function uc (b, a) {\n    var c = 2 < arguments.length ? ua.call(arguments, 2) : []\n    return !x(a) || a instanceof RegExp\n      ? a\n      : c.length\n      ? function () {\n          return arguments.length ? a.apply(b, db(c, arguments, 0)) : a.apply(b, c)\n        }\n      : function () {\n          return arguments.length ? a.apply(b, arguments) : a.call(b)\n        }\n  }\n  function Xd (b, a) {\n    var c = a\n    'string' === typeof b && '$' === b.charAt(0) && '$' === b.charAt(1)\n      ? (c = w)\n      : Za(a)\n      ? (c = '$WINDOW')\n      : a && X === a\n      ? (c = '$DOCUMENT')\n      : ab(a) && (c = '$SCOPE')\n    return c\n  }\n  function eb (b, a) {\n    if ('undefined' === typeof b) return w\n    V(a) || (a = a ? 2 : null)\n    return JSON.stringify(b, Xd, a)\n  }\n  function vc (b) {\n    return G(b) ? JSON.parse(b) : b\n  }\n  function wc (b, a) {\n    var c = Date.parse('Jan 01, 1970 00:00:00 ' + b) / 6e4\n    return isNaN(c) ? a : c\n  }\n  function Ob (b, a, c) {\n    c = c ? -1 : 1\n    var d = wc(a, b.getTimezoneOffset())\n    a = b\n    b = c * (d - b.getTimezoneOffset())\n    a = new Date(a.getTime())\n    a.setMinutes(a.getMinutes() + b)\n    return a\n  }\n  function xa (b) {\n    b = B(b).clone()\n    try {\n      b.empty()\n    } catch (a) {}\n    var c = B('<div>')\n      .append(b)\n      .html()\n    try {\n      return b[0].nodeType === Pa\n        ? F(c)\n        : c.match(/^(<[^>]+>)/)[1].replace(/^<([\\w\\-]+)/, function (a, b) {\n            return '<' + F(b)\n          })\n    } catch (d) {\n      return F(c)\n    }\n  }\n  function xc (b) {\n    try {\n      return decodeURIComponent(b)\n    } catch (a) {}\n  }\n  function yc (b) {\n    var a = {}\n    m((b || '').split('&'), function (b) {\n      var d, e, f\n      b &&\n        ((e = b = b.replace(/\\+/g, '%20')),\n        (d = b.indexOf('=')),\n        -1 !== d && ((e = b.substring(0, d)), (f = b.substring(d + 1))),\n        (e = xc(e)),\n        A(e) && ((f = A(f) ? xc(f) : !0), ta.call(a, e) ? (J(a[e]) ? a[e].push(f) : (a[e] = [a[e], f])) : (a[e] = f)))\n    })\n    return a\n  }\n  function Pb (b) {\n    var a = []\n    m(b, function (b, d) {\n      J(b)\n        ? m(b, function (b) {\n            a.push(la(d, !0) + (!0 === b ? '' : '=' + la(b, !0)))\n          })\n        : a.push(la(d, !0) + (!0 === b ? '' : '=' + la(b, !0)))\n    })\n    return a.length ? a.join('&') : ''\n  }\n  function ob (b) {\n    return la(b, !0)\n      .replace(/%26/gi, '&')\n      .replace(/%3D/gi, '=')\n      .replace(/%2B/gi, '+')\n  }\n  function la (b, a) {\n    return encodeURIComponent(b)\n      .replace(/%40/gi, '@')\n      .replace(/%3A/gi, ':')\n      .replace(/%24/g, '$')\n      .replace(/%2C/gi, ',')\n      .replace(/%3B/gi, ';')\n      .replace(/%20/g, a ? '%20' : '+')\n  }\n  function Yd (b, a) {\n    var c,\n      d,\n      e = Qa.length\n    for (d = 0; d < e; ++d) if (((c = Qa[d] + a), G((c = b.getAttribute(c))))) return c\n    return null\n  }\n  function Zd (b, a) {\n    var c,\n      d,\n      e = {}\n    m(Qa, function (a) {\n      a += 'app'\n      !c && b.hasAttribute && b.hasAttribute(a) && ((c = b), (d = b.getAttribute(a)))\n    })\n    m(Qa, function (a) {\n      a += 'app'\n      var e\n      !c && (e = b.querySelector('[' + a.replace(':', '\\\\:') + ']')) && ((c = e), (d = e.getAttribute(a)))\n    })\n    c && ((e.strictDi = null !== Yd(c, 'strict-di')), a(c, d ? [d] : [], e))\n  }\n  function zc (b, a, c) {\n    C(c) || (c = {})\n    c = P({ strictDi: !1 }, c)\n    var d = function () {\n        b = B(b)\n        if (b.injector()) {\n          var d = b[0] === X ? 'document' : xa(b)\n          throw Ea('btstrpd', d.replace(/</, '&lt;').replace(/>/, '&gt;'))\n        }\n        a = a || []\n        a.unshift([\n          '$provide',\n          function (a) {\n            a.value('$rootElement', b)\n          }\n        ])\n        c.debugInfoEnabled &&\n          a.push([\n            '$compileProvider',\n            function (a) {\n              a.debugInfoEnabled(!0)\n            }\n          ])\n        a.unshift('ng')\n        d = fb(a, c.strictDi)\n        d.invoke([\n          '$rootScope',\n          '$rootElement',\n          '$compile',\n          '$injector',\n          function (a, b, c, d) {\n            a.$apply(function () {\n              b.data('$injector', d)\n              c(b)(a)\n            })\n          }\n        ])\n        return d\n      },\n      e = /^NG_ENABLE_DEBUG_INFO!/,\n      f = /^NG_DEFER_BOOTSTRAP!/\n    Q && e.test(Q.name) && ((c.debugInfoEnabled = !0), (Q.name = Q.name.replace(e, '')))\n    if (Q && !f.test(Q.name)) return d()\n    Q.name = Q.name.replace(f, '')\n    da.resumeBootstrap = function (b) {\n      m(b, function (b) {\n        a.push(b)\n      })\n      return d()\n    }\n    x(da.resumeDeferredBootstrap) && da.resumeDeferredBootstrap()\n  }\n  function $d () {\n    Q.name = 'NG_ENABLE_DEBUG_INFO!' + Q.name\n    Q.location.reload()\n  }\n  function ae (b) {\n    b = da.element(b).injector()\n    if (!b) throw Ea('test')\n    return b.get('$$testability')\n  }\n  function Ac (b, a) {\n    a = a || '_'\n    return b.replace(be, function (b, d) {\n      return (d ? a : '') + b.toLowerCase()\n    })\n  }\n  function ce () {\n    var b\n    if (!Bc) {\n      var a = pb()\n      ;(ra = v(a) ? __webpack_provided_window_dot_jQuery : a ? Q[a] : w) && ra.fn.on\n        ? ((B = ra),\n          P(ra.fn, {\n            scope: Ra.scope,\n            isolateScope: Ra.isolateScope,\n            controller: Ra.controller,\n            injector: Ra.injector,\n            inheritedData: Ra.inheritedData\n          }),\n          (b = ra.cleanData),\n          (ra.cleanData = function (a) {\n            var d\n            if (Qb) Qb = !1\n            else\n              for (var e = 0, f; null != (f = a[e]); e++)\n                (d = ra._data(f, 'events')) && d.$destroy && ra(f).triggerHandler('$destroy')\n            b(a)\n          }))\n        : (B = R)\n      da.element = B\n      Bc = !0\n    }\n  }\n  function qb (b, a, c) {\n    if (!b) throw Ea('areq', a || '?', c || 'required')\n    return b\n  }\n  function Sa (b, a, c) {\n    c && J(b) && (b = b[b.length - 1])\n    qb(x(b), a, 'not a function, got ' + (b && 'object' === typeof b ? b.constructor.name || 'Object' : typeof b))\n    return b\n  }\n  function Ta (b, a) {\n    if ('hasOwnProperty' === b) throw Ea('badname', a)\n  }\n  function Cc (b, a, c) {\n    if (!a) return b\n    a = a.split('.')\n    for (var d, e = b, f = a.length, h = 0; h < f; h++) (d = a[h]), b && (b = (e = b)[d])\n    return !c && x(b) ? uc(e, b) : b\n  }\n  function rb (b) {\n    for (var a = b[0], c = b[b.length - 1], d, e = 1; a !== c && (a = a.nextSibling); e++)\n      if (d || b[e] !== a) d || (d = B(ua.call(b, 0, e))), d.push(a)\n    return d || b\n  }\n  function fa () {\n    return Object.create(null)\n  }\n  function de (b) {\n    function a (a, b, c) {\n      return a[b] || (a[b] = c())\n    }\n    var c = I('$injector'),\n      d = I('ng')\n    b = a(b, 'angular', Object)\n    b.$$minErr = b.$$minErr || I\n    return a(b, 'module', function () {\n      var b = {}\n      return function (f, h, g) {\n        if ('hasOwnProperty' === f) throw d('badname', 'module')\n        h && b.hasOwnProperty(f) && (b[f] = null)\n        return a(b, f, function () {\n          function a (b, c, e, f) {\n            f || (f = d)\n            return function () {\n              f[e || 'push']([b, c, arguments])\n              return E\n            }\n          }\n          function b (a, c) {\n            return function (b, e) {\n              e && x(e) && (e.$$moduleName = f)\n              d.push([a, c, arguments])\n              return E\n            }\n          }\n          if (!h) throw c('nomod', f)\n          var d = [],\n            e = [],\n            r = [],\n            t = a('$injector', 'invoke', 'push', e),\n            E = {\n              _invokeQueue: d,\n              _configBlocks: e,\n              _runBlocks: r,\n              requires: h,\n              name: f,\n              provider: b('$provide', 'provider'),\n              factory: b('$provide', 'factory'),\n              service: b('$provide', 'service'),\n              value: a('$provide', 'value'),\n              constant: a('$provide', 'constant', 'unshift'),\n              decorator: b('$provide', 'decorator'),\n              animation: b('$animateProvider', 'register'),\n              filter: b('$filterProvider', 'register'),\n              controller: b('$controllerProvider', 'register'),\n              directive: b('$compileProvider', 'directive'),\n              config: t,\n              run: function (a) {\n                r.push(a)\n                return this\n              }\n            }\n          g && t(g)\n          return E\n        })\n      }\n    })\n  }\n  function ee (b) {\n    P(b, {\n      bootstrap: zc,\n      copy: ha,\n      extend: P,\n      merge: Vd,\n      equals: ka,\n      element: B,\n      forEach: m,\n      injector: fb,\n      noop: y,\n      bind: uc,\n      toJson: eb,\n      fromJson: vc,\n      identity: $a,\n      isUndefined: v,\n      isDefined: A,\n      isString: G,\n      isFunction: x,\n      isObject: C,\n      isNumber: V,\n      isElement: sc,\n      isArray: J,\n      version: fe,\n      isDate: ea,\n      lowercase: F,\n      uppercase: sb,\n      callbacks: { counter: 0 },\n      getTestability: ae,\n      $$minErr: I,\n      $$csp: Fa,\n      reloadWithDebugInfo: $d\n    })\n    Rb = de(Q)\n    Rb(\n      'ng',\n      ['ngLocale'],\n      [\n        '$provide',\n        function (a) {\n          a.provider({ $$sanitizeUri: ge })\n          a.provider('$compile', Dc)\n            .directive({\n              a: he,\n              input: Ec,\n              textarea: Ec,\n              form: ie,\n              script: je,\n              select: ke,\n              style: le,\n              option: me,\n              ngBind: ne,\n              ngBindHtml: oe,\n              ngBindTemplate: pe,\n              ngClass: qe,\n              ngClassEven: re,\n              ngClassOdd: se,\n              ngCloak: te,\n              ngController: ue,\n              ngForm: ve,\n              ngHide: we,\n              ngIf: xe,\n              ngInclude: ye,\n              ngInit: ze,\n              ngNonBindable: Ae,\n              ngPluralize: Be,\n              ngRepeat: Ce,\n              ngShow: De,\n              ngStyle: Ee,\n              ngSwitch: Fe,\n              ngSwitchWhen: Ge,\n              ngSwitchDefault: He,\n              ngOptions: Ie,\n              ngTransclude: Je,\n              ngModel: Ke,\n              ngList: Le,\n              ngChange: Me,\n              pattern: Fc,\n              ngPattern: Fc,\n              required: Gc,\n              ngRequired: Gc,\n              minlength: Hc,\n              ngMinlength: Hc,\n              maxlength: Ic,\n              ngMaxlength: Ic,\n              ngValue: Ne,\n              ngModelOptions: Oe\n            })\n            .directive({ ngInclude: Pe })\n            .directive(tb)\n            .directive(Jc)\n          a.provider({\n            $anchorScroll: Qe,\n            $animate: Re,\n            $animateCss: Se,\n            $$animateQueue: Te,\n            $$AnimateRunner: Ue,\n            $browser: Ve,\n            $cacheFactory: We,\n            $controller: Xe,\n            $document: Ye,\n            $exceptionHandler: Ze,\n            $filter: Kc,\n            $$forceReflow: $e,\n            $interpolate: af,\n            $interval: bf,\n            $http: cf,\n            $httpParamSerializer: df,\n            $httpParamSerializerJQLike: ef,\n            $httpBackend: ff,\n            $xhrFactory: gf,\n            $location: hf,\n            $log: jf,\n            $parse: kf,\n            $rootScope: lf,\n            $q: mf,\n            $$q: nf,\n            $sce: of,\n            $sceDelegate: pf,\n            $sniffer: qf,\n            $templateCache: rf,\n            $templateRequest: sf,\n            $$testability: tf,\n            $timeout: uf,\n            $window: vf,\n            $$rAF: wf,\n            $$jqLite: xf,\n            $$HashMap: yf,\n            $$cookieReader: zf\n          })\n        }\n      ]\n    )\n  }\n  function gb (b) {\n    return b\n      .replace(Af, function (a, b, d, e) {\n        return e ? d.toUpperCase() : d\n      })\n      .replace(Bf, 'Moz$1')\n  }\n  function Lc (b) {\n    b = b.nodeType\n    return b === pa || !b || 9 === b\n  }\n  function Mc (b, a) {\n    var c,\n      d,\n      e = a.createDocumentFragment(),\n      f = []\n    if (Sb.test(b)) {\n      c = c || e.appendChild(a.createElement('div'))\n      d = (Cf.exec(b) || ['', ''])[1].toLowerCase()\n      d = ma[d] || ma._default\n      c.innerHTML = d[1] + b.replace(Df, '<$1></$2>') + d[2]\n      for (d = d[0]; d--; ) c = c.lastChild\n      f = db(f, c.childNodes)\n      c = e.firstChild\n      c.textContent = ''\n    } else f.push(a.createTextNode(b))\n    e.textContent = ''\n    e.innerHTML = ''\n    m(f, function (a) {\n      e.appendChild(a)\n    })\n    return e\n  }\n  function R (b) {\n    if (b instanceof R) return b\n    var a\n    G(b) && ((b = T(b)), (a = !0))\n    if (!(this instanceof R)) {\n      if (a && '<' != b.charAt(0)) throw Tb('nosel')\n      return new R(b)\n    }\n    if (a) {\n      a = X\n      var c\n      b = (c = Ef.exec(b)) ? [a.createElement(c[1])] : (c = Mc(b, a)) ? c.childNodes : []\n    }\n    Nc(this, b)\n  }\n  function Ub (b) {\n    return b.cloneNode(!0)\n  }\n  function ub (b, a) {\n    a || vb(b)\n    if (b.querySelectorAll) for (var c = b.querySelectorAll('*'), d = 0, e = c.length; d < e; d++) vb(c[d])\n  }\n  function Oc (b, a, c, d) {\n    if (A(d)) throw Tb('offargs')\n    var e = (d = wb(b)) && d.events,\n      f = d && d.handle\n    if (f)\n      if (a)\n        m(a.split(' '), function (a) {\n          if (A(c)) {\n            var d = e[a]\n            cb(d || [], c)\n            if (d && 0 < d.length) return\n          }\n          b.removeEventListener(a, f, !1)\n          delete e[a]\n        })\n      else for (a in e) '$destroy' !== a && b.removeEventListener(a, f, !1), delete e[a]\n  }\n  function vb (b, a) {\n    var c = b.ng339,\n      d = c && hb[c]\n    d &&\n      (a\n        ? delete d.data[a]\n        : (d.handle && (d.events.$destroy && d.handle({}, '$destroy'), Oc(b)), delete hb[c], (b.ng339 = w)))\n  }\n  function wb (b, a) {\n    var c = b.ng339,\n      c = c && hb[c]\n    a && !c && ((b.ng339 = c = ++Ff), (c = hb[c] = { events: {}, data: {}, handle: w }))\n    return c\n  }\n  function Vb (b, a, c) {\n    if (Lc(b)) {\n      var d = A(c),\n        e = !d && a && !C(a),\n        f = !a\n      b = (b = wb(b, !e)) && b.data\n      if (d) b[a] = c\n      else {\n        if (f) return b\n        if (e) return b && b[a]\n        P(b, a)\n      }\n    }\n  }\n  function xb (b, a) {\n    return b.getAttribute\n      ? -1 < (' ' + (b.getAttribute('class') || '') + ' ').replace(/[\\n\\t]/g, ' ').indexOf(' ' + a + ' ')\n      : !1\n  }\n  function yb (b, a) {\n    a &&\n      b.setAttribute &&\n      m(a.split(' '), function (a) {\n        b.setAttribute(\n          'class',\n          T((' ' + (b.getAttribute('class') || '') + ' ').replace(/[\\n\\t]/g, ' ').replace(' ' + T(a) + ' ', ' '))\n        )\n      })\n  }\n  function zb (b, a) {\n    if (a && b.setAttribute) {\n      var c = (' ' + (b.getAttribute('class') || '') + ' ').replace(/[\\n\\t]/g, ' ')\n      m(a.split(' '), function (a) {\n        a = T(a)\n        ;-1 === c.indexOf(' ' + a + ' ') && (c += a + ' ')\n      })\n      b.setAttribute('class', T(c))\n    }\n  }\n  function Nc (b, a) {\n    if (a)\n      if (a.nodeType) b[b.length++] = a\n      else {\n        var c = a.length\n        if ('number' === typeof c && a.window !== a) {\n          if (c) for (var d = 0; d < c; d++) b[b.length++] = a[d]\n        } else b[b.length++] = a\n      }\n  }\n  function Pc (b, a) {\n    return Ab(b, '$' + (a || 'ngController') + 'Controller')\n  }\n  function Ab (b, a, c) {\n    9 == b.nodeType && (b = b.documentElement)\n    for (a = J(a) ? a : [a]; b; ) {\n      for (var d = 0, e = a.length; d < e; d++) if (A((c = B.data(b, a[d])))) return c\n      b = b.parentNode || (11 === b.nodeType && b.host)\n    }\n  }\n  function Qc (b) {\n    for (ub(b, !0); b.firstChild; ) b.removeChild(b.firstChild)\n  }\n  function Wb (b, a) {\n    a || ub(b)\n    var c = b.parentNode\n    c && c.removeChild(b)\n  }\n  function Gf (b, a) {\n    a = a || Q\n    if ('complete' === a.document.readyState) a.setTimeout(b)\n    else B(a).on('load', b)\n  }\n  function Rc (b, a) {\n    var c = Bb[a.toLowerCase()]\n    return c && Sc[wa(b)] && c\n  }\n  function Hf (b, a) {\n    var c = function (c, e) {\n      c.isDefaultPrevented = function () {\n        return c.defaultPrevented\n      }\n      var f = a[e || c.type],\n        h = f ? f.length : 0\n      if (h) {\n        if (v(c.immediatePropagationStopped)) {\n          var g = c.stopImmediatePropagation\n          c.stopImmediatePropagation = function () {\n            c.immediatePropagationStopped = !0\n            c.stopPropagation && c.stopPropagation()\n            g && g.call(c)\n          }\n        }\n        c.isImmediatePropagationStopped = function () {\n          return !0 === c.immediatePropagationStopped\n        }\n        1 < h && (f = ja(f))\n        for (var l = 0; l < h; l++) c.isImmediatePropagationStopped() || f[l].call(b, c)\n      }\n    }\n    c.elem = b\n    return c\n  }\n  function xf () {\n    this.$get = function () {\n      return P(R, {\n        hasClass: function (b, a) {\n          b.attr && (b = b[0])\n          return xb(b, a)\n        },\n        addClass: function (b, a) {\n          b.attr && (b = b[0])\n          return zb(b, a)\n        },\n        removeClass: function (b, a) {\n          b.attr && (b = b[0])\n          return yb(b, a)\n        }\n      })\n    }\n  }\n  function Ga (b, a) {\n    var c = b && b.$$hashKey\n    if (c) return 'function' === typeof c && (c = b.$$hashKey()), c\n    c = typeof b\n    return (c = 'function' == c || ('object' == c && null !== b) ? (b.$$hashKey = c + ':' + (a || Ud)()) : c + ':' + b)\n  }\n  function Ua (b, a) {\n    if (a) {\n      var c = 0\n      this.nextUid = function () {\n        return ++c\n      }\n    }\n    m(b, this.put, this)\n  }\n  function If (b) {\n    return (b = b\n      .toString()\n      .replace(Tc, '')\n      .match(Uc))\n      ? 'function(' + (b[1] || '').replace(/[\\s\\r\\n]+/, ' ') + ')'\n      : 'fn'\n  }\n  function fb (b, a) {\n    function c (a) {\n      return function (b, c) {\n        if (C(b)) m(b, oc(a))\n        else return a(b, c)\n      }\n    }\n    function d (a, b) {\n      Ta(a, 'service')\n      if (x(b) || J(b)) b = r.instantiate(b)\n      if (!b.$get) throw Ha('pget', a)\n      return (p[a + 'Provider'] = b)\n    }\n    function e (a, b) {\n      return function () {\n        var c = E.invoke(b, this)\n        if (v(c)) throw Ha('undef', a)\n        return c\n      }\n    }\n    function f (a, b, c) {\n      return d(a, { $get: !1 !== c ? e(a, b) : b })\n    }\n    function h (a) {\n      qb(v(a) || J(a), 'modulesToLoad', 'not an array')\n      var b = [],\n        c\n      m(a, function (a) {\n        function d (a) {\n          var b, c\n          b = 0\n          for (c = a.length; b < c; b++) {\n            var e = a[b],\n              f = r.get(e[0])\n            f[e[1]].apply(f, e[2])\n          }\n        }\n        if (!n.get(a)) {\n          n.put(a, !0)\n          try {\n            G(a)\n              ? ((c = Rb(a)), (b = b.concat(h(c.requires)).concat(c._runBlocks)), d(c._invokeQueue), d(c._configBlocks))\n              : x(a)\n              ? b.push(r.invoke(a))\n              : J(a)\n              ? b.push(r.invoke(a))\n              : Sa(a, 'module')\n          } catch (e) {\n            throw (J(a) && (a = a[a.length - 1]),\n            e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + '\\n' + e.stack),\n            Ha('modulerr', a, e.stack || e.message || e))\n          }\n        }\n      })\n      return b\n    }\n    function g (b, c) {\n      function d (a, e) {\n        if (b.hasOwnProperty(a)) {\n          if (b[a] === l) throw Ha('cdep', a + ' <- ' + k.join(' <- '))\n          return b[a]\n        }\n        try {\n          return k.unshift(a), (b[a] = l), (b[a] = c(a, e))\n        } catch (f) {\n          throw (b[a] === l && delete b[a], f)\n        } finally {\n          k.shift()\n        }\n      }\n      function e (b, c, f, g) {\n        'string' === typeof f && ((g = f), (f = null))\n        var h = [],\n          k = fb.$$annotate(b, a, g),\n          l,\n          r,\n          p\n        r = 0\n        for (l = k.length; r < l; r++) {\n          p = k[r]\n          if ('string' !== typeof p) throw Ha('itkn', p)\n          h.push(f && f.hasOwnProperty(p) ? f[p] : d(p, g))\n        }\n        J(b) && (b = b[l])\n        return b.apply(c, h)\n      }\n      return {\n        invoke: e,\n        instantiate: function (a, b, c) {\n          var d = Object.create((J(a) ? a[a.length - 1] : a).prototype || null)\n          a = e(a, d, b, c)\n          return C(a) || x(a) ? a : d\n        },\n        get: d,\n        annotate: fb.$$annotate,\n        has: function (a) {\n          return p.hasOwnProperty(a + 'Provider') || b.hasOwnProperty(a)\n        }\n      }\n    }\n    a = !0 === a\n    var l = {},\n      k = [],\n      n = new Ua([], !0),\n      p = {\n        $provide: {\n          provider: c(d),\n          factory: c(f),\n          service: c(function (a, b) {\n            return f(a, [\n              '$injector',\n              function (a) {\n                return a.instantiate(b)\n              }\n            ])\n          }),\n          value: c(function (a, b) {\n            return f(a, qa(b), !1)\n          }),\n          constant: c(function (a, b) {\n            Ta(a, 'constant')\n            p[a] = b\n            t[a] = b\n          }),\n          decorator: function (a, b) {\n            var c = r.get(a + 'Provider'),\n              d = c.$get\n            c.$get = function () {\n              var a = E.invoke(d, c)\n              return E.invoke(b, null, { $delegate: a })\n            }\n          }\n        }\n      },\n      r = (p.$injector = g(p, function (a, b) {\n        da.isString(b) && k.push(b)\n        throw Ha('unpr', k.join(' <- '))\n      })),\n      t = {},\n      E = (t.$injector = g(t, function (a, b) {\n        var c = r.get(a + 'Provider', b)\n        return E.invoke(c.$get, c, w, a)\n      }))\n    m(h(b), function (a) {\n      a && E.invoke(a)\n    })\n    return E\n  }\n  function Qe () {\n    var b = !0\n    this.disableAutoScrolling = function () {\n      b = !1\n    }\n    this.$get = [\n      '$window',\n      '$location',\n      '$rootScope',\n      function (a, c, d) {\n        function e (a) {\n          var b = null\n          Array.prototype.some.call(a, function (a) {\n            if ('a' === wa(a)) return (b = a), !0\n          })\n          return b\n        }\n        function f (b) {\n          if (b) {\n            b.scrollIntoView()\n            var c\n            c = h.yOffset\n            x(c)\n              ? (c = c())\n              : sc(c)\n              ? ((c = c[0]), (c = 'fixed' !== a.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom))\n              : V(c) || (c = 0)\n            c && ((b = b.getBoundingClientRect().top), a.scrollBy(0, b - c))\n          } else a.scrollTo(0, 0)\n        }\n        function h (a) {\n          a = G(a) ? a : c.hash()\n          var b\n          a\n            ? (b = g.getElementById(a))\n              ? f(b)\n              : (b = e(g.getElementsByName(a)))\n              ? f(b)\n              : 'top' === a && f(null)\n            : f(null)\n        }\n        var g = a.document\n        b &&\n          d.$watch(\n            function () {\n              return c.hash()\n            },\n            function (a, b) {\n              ;(a === b && '' === a) ||\n                Gf(function () {\n                  d.$evalAsync(h)\n                })\n            }\n          )\n        return h\n      }\n    ]\n  }\n  function ib (b, a) {\n    if (!b && !a) return ''\n    if (!b) return a\n    if (!a) return b\n    J(b) && (b = b.join(' '))\n    J(a) && (a = a.join(' '))\n    return b + ' ' + a\n  }\n  function Jf (b) {\n    G(b) && (b = b.split(' '))\n    var a = fa()\n    m(b, function (b) {\n      b.length && (a[b] = !0)\n    })\n    return a\n  }\n  function Ia (b) {\n    return C(b) ? b : {}\n  }\n  function Kf (b, a, c, d) {\n    function e (a) {\n      try {\n        a.apply(null, ua.call(arguments, 1))\n      } finally {\n        if ((E--, 0 === E))\n          for (; K.length; )\n            try {\n              K.pop()()\n            } catch (b) {\n              c.error(b)\n            }\n      }\n    }\n    function f () {\n      ia = null\n      h()\n      g()\n    }\n    function h () {\n      a: {\n        try {\n          u = n.state\n          break a\n        } catch (a) {}\n        u = void 0\n      }\n      u = v(u) ? null : u\n      ka(u, L) && (u = L)\n      L = u\n    }\n    function g () {\n      if (z !== l.url() || q !== u)\n        (z = l.url()),\n          (q = u),\n          m(O, function (a) {\n            a(l.url(), u)\n          })\n    }\n    var l = this,\n      k = b.location,\n      n = b.history,\n      p = b.setTimeout,\n      r = b.clearTimeout,\n      t = {}\n    l.isMock = !1\n    var E = 0,\n      K = []\n    l.$$completeOutstandingRequest = e\n    l.$$incOutstandingRequestCount = function () {\n      E++\n    }\n    l.notifyWhenNoOutstandingRequests = function (a) {\n      0 === E ? a() : K.push(a)\n    }\n    var u,\n      q,\n      z = k.href,\n      N = a.find('base'),\n      ia = null\n    h()\n    q = u\n    l.url = function (a, c, e) {\n      v(e) && (e = null)\n      k !== b.location && (k = b.location)\n      n !== b.history && (n = b.history)\n      if (a) {\n        var f = q === e\n        if (z === a && (!d.history || f)) return l\n        var g = z && Ja(z) === Ja(a)\n        z = a\n        q = e\n        if (!d.history || (g && f)) {\n          if (!g || ia) ia = a\n          c\n            ? k.replace(a)\n            : g\n            ? ((c = k), (e = a.indexOf('#')), (e = -1 === e ? '' : a.substr(e)), (c.hash = e))\n            : (k.href = a)\n          k.href !== a && (ia = a)\n        } else n[c ? 'replaceState' : 'pushState'](e, '', a), h(), (q = u)\n        return l\n      }\n      return ia || k.href.replace(/%27/g, \"'\")\n    }\n    l.state = function () {\n      return u\n    }\n    var O = [],\n      H = !1,\n      L = null\n    l.onUrlChange = function (a) {\n      if (!H) {\n        if (d.history) B(b).on('popstate', f)\n        B(b).on('hashchange', f)\n        H = !0\n      }\n      O.push(a)\n      return a\n    }\n    l.$$applicationDestroyed = function () {\n      B(b).off('hashchange popstate', f)\n    }\n    l.$$checkUrlChange = g\n    l.baseHref = function () {\n      var a = N.attr('href')\n      return a ? a.replace(/^(https?\\:)?\\/\\/[^\\/]*/, '') : ''\n    }\n    l.defer = function (a, b) {\n      var c\n      E++\n      c = p(function () {\n        delete t[c]\n        e(a)\n      }, b || 0)\n      t[c] = !0\n      return c\n    }\n    l.defer.cancel = function (a) {\n      return t[a] ? (delete t[a], r(a), e(y), !0) : !1\n    }\n  }\n  function Ve () {\n    this.$get = [\n      '$window',\n      '$log',\n      '$sniffer',\n      '$document',\n      function (b, a, c, d) {\n        return new Kf(b, d, a, c)\n      }\n    ]\n  }\n  function We () {\n    this.$get = function () {\n      function b (b, d) {\n        function e (a) {\n          a != p && (r ? r == a && (r = a.n) : (r = a), f(a.n, a.p), f(a, p), (p = a), (p.n = null))\n        }\n        function f (a, b) {\n          a != b && (a && (a.p = b), b && (b.n = a))\n        }\n        if (b in a) throw I('$cacheFactory')('iid', b)\n        var h = 0,\n          g = P({}, d, { id: b }),\n          l = {},\n          k = (d && d.capacity) || Number.MAX_VALUE,\n          n = {},\n          p = null,\n          r = null\n        return (a[b] = {\n          put: function (a, b) {\n            if (!v(b)) {\n              if (k < Number.MAX_VALUE) {\n                var c = n[a] || (n[a] = { key: a })\n                e(c)\n              }\n              a in l || h++\n              l[a] = b\n              h > k && this.remove(r.key)\n              return b\n            }\n          },\n          get: function (a) {\n            if (k < Number.MAX_VALUE) {\n              var b = n[a]\n              if (!b) return\n              e(b)\n            }\n            return l[a]\n          },\n          remove: function (a) {\n            if (k < Number.MAX_VALUE) {\n              var b = n[a]\n              if (!b) return\n              b == p && (p = b.p)\n              b == r && (r = b.n)\n              f(b.n, b.p)\n              delete n[a]\n            }\n            delete l[a]\n            h--\n          },\n          removeAll: function () {\n            l = {}\n            h = 0\n            n = {}\n            p = r = null\n          },\n          destroy: function () {\n            n = g = l = null\n            delete a[b]\n          },\n          info: function () {\n            return P({}, g, { size: h })\n          }\n        })\n      }\n      var a = {}\n      b.info = function () {\n        var b = {}\n        m(a, function (a, e) {\n          b[e] = a.info()\n        })\n        return b\n      }\n      b.get = function (b) {\n        return a[b]\n      }\n      return b\n    }\n  }\n  function rf () {\n    this.$get = [\n      '$cacheFactory',\n      function (b) {\n        return b('templates')\n      }\n    ]\n  }\n  function Dc (b, a) {\n    function c (a, b, c) {\n      var d = /^\\s*([@&]|=(\\*?))(\\??)\\s*(\\w*)\\s*$/,\n        e = {}\n      m(a, function (a, f) {\n        var g = a.match(d)\n        if (!g) throw ga('iscp', b, f, a, c ? 'controller bindings definition' : 'isolate scope definition')\n        e[f] = { mode: g[1][0], collection: '*' === g[2], optional: '?' === g[3], attrName: g[4] || f }\n      })\n      return e\n    }\n    function d (a) {\n      var b = a.charAt(0)\n      if (!b || b !== F(b)) throw ga('baddir', a)\n      if (a !== a.trim()) throw ga('baddir', a)\n    }\n    var e = {},\n      f = /^\\s*directive\\:\\s*([\\w\\-]+)\\s+(.*)$/,\n      h = /(([\\w\\-]+)(?:\\:([^;]+))?;?)/,\n      g = Wd('ngSrc,ngSrcset,src,srcset'),\n      l = /^(?:(\\^\\^?)?(\\?)?(\\^\\^?)?)?/,\n      k = /^(on[a-z]+|formaction)$/\n    this.directive = function r (a, f) {\n      Ta(a, 'directive')\n      G(a)\n        ? (d(a),\n          qb(f, 'directiveFactory'),\n          e.hasOwnProperty(a) ||\n            ((e[a] = []),\n            b.factory(a + 'Directive', [\n              '$injector',\n              '$exceptionHandler',\n              function (b, d) {\n                var f = []\n                m(e[a], function (e, g) {\n                  try {\n                    var h = b.invoke(e)\n                    x(h) ? (h = { compile: qa(h) }) : !h.compile && h.link && (h.compile = qa(h.link))\n                    h.priority = h.priority || 0\n                    h.index = g\n                    h.name = h.name || a\n                    h.require = h.require || (h.controller && h.name)\n                    h.restrict = h.restrict || 'EA'\n                    var k = h,\n                      l = h,\n                      r = h.name,\n                      n = { isolateScope: null, bindToController: null }\n                    C(l.scope) &&\n                      (!0 === l.bindToController\n                        ? ((n.bindToController = c(l.scope, r, !0)), (n.isolateScope = {}))\n                        : (n.isolateScope = c(l.scope, r, !1)))\n                    C(l.bindToController) && (n.bindToController = c(l.bindToController, r, !0))\n                    if (C(n.bindToController)) {\n                      var S = l.controller,\n                        E = l.controllerAs\n                      if (!S) throw ga('noctrl', r)\n                      var ca\n                      a: if (E && G(E)) ca = E\n                      else {\n                        if (G(S)) {\n                          var m = Vc.exec(S)\n                          if (m) {\n                            ca = m[3]\n                            break a\n                          }\n                        }\n                        ca = void 0\n                      }\n                      if (!ca) throw ga('noident', r)\n                    }\n                    var s = (k.$$bindings = n)\n                    C(s.isolateScope) && (h.$$isolateBindings = s.isolateScope)\n                    h.$$moduleName = e.$$moduleName\n                    f.push(h)\n                  } catch (w) {\n                    d(w)\n                  }\n                })\n                return f\n              }\n            ])),\n          e[a].push(f))\n        : m(a, oc(r))\n      return this\n    }\n    this.aHrefSanitizationWhitelist = function (b) {\n      return A(b) ? (a.aHrefSanitizationWhitelist(b), this) : a.aHrefSanitizationWhitelist()\n    }\n    this.imgSrcSanitizationWhitelist = function (b) {\n      return A(b) ? (a.imgSrcSanitizationWhitelist(b), this) : a.imgSrcSanitizationWhitelist()\n    }\n    var n = !0\n    this.debugInfoEnabled = function (a) {\n      return A(a) ? ((n = a), this) : n\n    }\n    this.$get = [\n      '$injector',\n      '$interpolate',\n      '$exceptionHandler',\n      '$templateRequest',\n      '$parse',\n      '$controller',\n      '$rootScope',\n      '$document',\n      '$sce',\n      '$animate',\n      '$$sanitizeUri',\n      function (a, b, c, d, u, q, z, N, ia, O, H) {\n        function L (a, b) {\n          try {\n            a.addClass(b)\n          } catch (c) {}\n        }\n        function W (a, b, c, d, e) {\n          a instanceof B || (a = B(a))\n          m(a, function (b, c) {\n            b.nodeType == Pa &&\n              b.nodeValue.match(/\\S+/) &&\n              (a[c] = B(b)\n                .wrap('<span></span>')\n                .parent()[0])\n          })\n          var f = S(a, b, a, c, d, e)\n          W.$$addScopeClass(a)\n          var g = null\n          return function (b, c, d) {\n            qb(b, 'scope')\n            d = d || {}\n            var e = d.parentBoundTranscludeFn,\n              h = d.transcludeControllers\n            d = d.futureParentElement\n            e && e.$$boundTransclude && (e = e.$$boundTransclude)\n            g ||\n              (g = (d = d && d[0]) ? ('foreignobject' !== wa(d) && d.toString().match(/SVG/) ? 'svg' : 'html') : 'html')\n            d =\n              'html' !== g\n                ? B(\n                    Xb(\n                      g,\n                      B('<div>')\n                        .append(a)\n                        .html()\n                    )\n                  )\n                : c\n                ? Ra.clone.call(a)\n                : a\n            if (h) for (var k in h) d.data('$' + k + 'Controller', h[k].instance)\n            W.$$addScopeInfo(d, b)\n            c && c(d, b)\n            f && f(b, d, d, e)\n            return d\n          }\n        }\n        function S (a, b, c, d, e, f) {\n          function g (a, c, d, e) {\n            var f, k, l, r, n, t, O\n            if (q) for (O = Array(c.length), r = 0; r < h.length; r += 3) (f = h[r]), (O[f] = c[f])\n            else O = c\n            r = 0\n            for (n = h.length; r < n; )\n              if (((k = O[h[r++]]), (c = h[r++]), (f = h[r++]), c)) {\n                if (c.scope) {\n                  if (((l = a.$new()), W.$$addScopeInfo(B(k), l), (t = c.$$destroyBindings)))\n                    (c.$$destroyBindings = null), l.$on('$destroyed', t)\n                } else l = a\n                t = c.transcludeOnThisElement\n                  ? ba(a, c.transclude, e)\n                  : !c.templateOnThisElement && e\n                  ? e\n                  : !e && b\n                  ? ba(a, b)\n                  : null\n                c(f, l, k, d, t, c)\n              } else f && f(a, k.childNodes, w, e)\n          }\n          for (var h = [], k, l, r, n, q, t = 0; t < a.length; t++) {\n            k = new Z()\n            l = ca(a[t], [], k, 0 === t ? d : w, e)\n            ;(f = l.length ? D(l, a[t], k, b, c, null, [], [], f) : null) && f.scope && W.$$addScopeClass(k.$$element)\n            k =\n              (f && f.terminal) || !(r = a[t].childNodes) || !r.length\n                ? null\n                : S(r, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b)\n            if (f || k) h.push(t, f, k), (n = !0), (q = q || f)\n            f = null\n          }\n          return n ? g : null\n        }\n        function ba (a, b, c) {\n          return function (d, e, f, g, h) {\n            d || ((d = a.$new(!1, h)), (d.$$transcluded = !0))\n            return b(d, e, { parentBoundTranscludeFn: c, transcludeControllers: f, futureParentElement: g })\n          }\n        }\n        function ca (a, b, c, d, e) {\n          var g = c.$attr,\n            k\n          switch (a.nodeType) {\n            case pa:\n              na(b, ya(wa(a)), 'E', d, e)\n              for (var l, r, n, q = a.attributes, t = 0, O = q && q.length; t < O; t++) {\n                var K = !1,\n                  H = !1\n                l = q[t]\n                k = l.name\n                r = T(l.value)\n                l = ya(k)\n                if ((n = ja.test(l)))\n                  k = k\n                    .replace(Wc, '')\n                    .substr(8)\n                    .replace(/_(.)/g, function (a, b) {\n                      return b.toUpperCase()\n                    })\n                var S = l.replace(/(Start|End)$/, '')\n                I(S) &&\n                  l === S + 'Start' &&\n                  ((K = k), (H = k.substr(0, k.length - 5) + 'end'), (k = k.substr(0, k.length - 6)))\n                l = ya(k.toLowerCase())\n                g[l] = k\n                if (n || !c.hasOwnProperty(l)) (c[l] = r), Rc(a, l) && (c[l] = !0)\n                V(a, b, r, l, n)\n                na(b, l, 'A', d, e, K, H)\n              }\n              a = a.className\n              C(a) && (a = a.animVal)\n              if (G(a) && '' !== a)\n                for (; (k = h.exec(a)); )\n                  (l = ya(k[2])), na(b, l, 'C', d, e) && (c[l] = T(k[3])), (a = a.substr(k.index + k[0].length))\n              break\n            case Pa:\n              if (11 === Wa)\n                for (; a.parentNode && a.nextSibling && a.nextSibling.nodeType === Pa; )\n                  (a.nodeValue += a.nextSibling.nodeValue), a.parentNode.removeChild(a.nextSibling)\n              Ka(b, a.nodeValue)\n              break\n            case 8:\n              try {\n                if ((k = f.exec(a.nodeValue))) (l = ya(k[1])), na(b, l, 'M', d, e) && (c[l] = T(k[2]))\n              } catch (E) {}\n          }\n          b.sort(M)\n          return b\n        }\n        function za (a, b, c) {\n          var d = [],\n            e = 0\n          if (b && a.hasAttribute && a.hasAttribute(b)) {\n            do {\n              if (!a) throw ga('uterdir', b, c)\n              a.nodeType == pa && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--)\n              d.push(a)\n              a = a.nextSibling\n            } while (0 < e)\n          } else d.push(a)\n          return B(d)\n        }\n        function s (a, b, c) {\n          return function (d, e, f, g, h) {\n            e = za(e[0], b, c)\n            return a(d, e, f, g, h)\n          }\n        }\n        function D (a, b, d, e, f, g, h, k, r) {\n          function n (a, b, c, d) {\n            if (a) {\n              c && (a = s(a, c, d))\n              a.require = D.require\n              a.directiveName = y\n              if (u === D || D.$$isolateScope) a = $(a, { isolateScope: !0 })\n              h.push(a)\n            }\n            if (b) {\n              c && (b = s(b, c, d))\n              b.require = D.require\n              b.directiveName = y\n              if (u === D || D.$$isolateScope) b = $(b, { isolateScope: !0 })\n              k.push(b)\n            }\n          }\n          function t (a, b, c, d) {\n            var e\n            if (G(b)) {\n              var f = b.match(l)\n              b = b.substring(f[0].length)\n              var g = f[1] || f[3],\n                f = '?' === f[2]\n              '^^' === g ? (c = c.parent()) : (e = (e = d && d[b]) && e.instance)\n              e || ((d = '$' + b + 'Controller'), (e = g ? c.inheritedData(d) : c.data(d)))\n              if (!e && !f) throw ga('ctreq', b, a)\n            } else if (J(b)) for (e = [], g = 0, f = b.length; g < f; g++) e[g] = t(a, b[g], c, d)\n            return e || null\n          }\n          function O (a, b, c, d, e, f) {\n            var g = fa(),\n              h\n            for (h in d) {\n              var k = d[h],\n                l = { $scope: k === u || k.$$isolateScope ? e : f, $element: a, $attrs: b, $transclude: c },\n                r = k.controller\n              '@' == r && (r = b[k.name])\n              l = q(r, l, !0, k.controllerAs)\n              g[k.name] = l\n              ia || a.data('$' + k.name + 'Controller', l.instance)\n            }\n            return g\n          }\n          function K (a, c, e, f, g, l) {\n            function r (a, b, c) {\n              var d\n              ab(a) || ((c = b), (b = a), (a = w))\n              ia && (d = ca)\n              c || (c = ia ? N.parent() : N)\n              return g(a, b, d, c, za)\n            }\n            var n, q, H, E, ca, z, N\n            b === e ? ((f = d), (N = d.$$element)) : ((N = B(e)), (f = new Z(N, d)))\n            u && (E = c.$new(!0))\n            g && ((z = r), (z.$$boundTransclude = g))\n            ba && (ca = O(N, f, z, ba, E, c))\n            u &&\n              (W.$$addScopeInfo(N, E, !0, !(L && (L === u || L === u.$$originalDirective))),\n              W.$$addScopeClass(N, !0),\n              (E.$$isolateBindings = u.$$isolateBindings),\n              Y(c, f, E, E.$$isolateBindings, u, E))\n            if (ca) {\n              var Va = u || S,\n                m\n              Va &&\n                ca[Va.name] &&\n                ((q = Va.$$bindings.bindToController),\n                (H = ca[Va.name]) && H.identifier && q && ((m = H), (l.$$destroyBindings = Y(c, f, H.instance, q, Va))))\n              for (n in ca) {\n                H = ca[n]\n                var D = H()\n                D !== H.instance &&\n                  ((H.instance = D),\n                  N.data('$' + n + 'Controller', D),\n                  H === m && (l.$$destroyBindings(), (l.$$destroyBindings = Y(c, f, D, q, Va))))\n              }\n            }\n            n = 0\n            for (l = h.length; n < l; n++)\n              (q = h[n]), aa(q, q.isolateScope ? E : c, N, f, q.require && t(q.directiveName, q.require, N, ca), z)\n            var za = c\n            u && (u.template || null === u.templateUrl) && (za = E)\n            a && a(za, e.childNodes, w, g)\n            for (n = k.length - 1; 0 <= n; n--)\n              (q = k[n]), aa(q, q.isolateScope ? E : c, N, f, q.require && t(q.directiveName, q.require, N, ca), z)\n          }\n          r = r || {}\n          for (\n            var H = -Number.MAX_VALUE,\n              S = r.newScopeDirective,\n              ba = r.controllerDirectives,\n              u = r.newIsolateScopeDirective,\n              L = r.templateDirective,\n              z = r.nonTlbTranscludeDirective,\n              N = !1,\n              m = !1,\n              ia = r.hasElementTranscludeDirective,\n              v = (d.$$element = B(b)),\n              D,\n              y,\n              M,\n              Ka = e,\n              na,\n              I = 0,\n              F = a.length;\n            I < F;\n            I++\n          ) {\n            D = a[I]\n            var P = D.$$start,\n              R = D.$$end\n            P && (v = za(b, P, R))\n            M = w\n            if (H > D.priority) break\n            if ((M = D.scope))\n              D.templateUrl ||\n                (C(M) ? (Q('new/isolated scope', u || S, D, v), (u = D)) : Q('new/isolated scope', u, D, v)),\n                (S = S || D)\n            y = D.name\n            !D.templateUrl &&\n              D.controller &&\n              ((M = D.controller), (ba = ba || fa()), Q(\"'\" + y + \"' controller\", ba[y], D, v), (ba[y] = D))\n            if ((M = D.transclude))\n              (N = !0),\n                D.$$tlb || (Q('transclusion', z, D, v), (z = D)),\n                'element' == M\n                  ? ((ia = !0),\n                    (H = D.priority),\n                    (M = v),\n                    (v = d.$$element = B(X.createComment(' ' + y + ': ' + d[y] + ' '))),\n                    (b = v[0]),\n                    U(f, ua.call(M, 0), b),\n                    (Ka = W(M, e, H, g && g.name, { nonTlbTranscludeDirective: z })))\n                  : ((M = B(Ub(b)).contents()), v.empty(), (Ka = W(M, e)))\n            if (D.template)\n              if (\n                ((m = !0),\n                Q('template', L, D, v),\n                (L = D),\n                (M = x(D.template) ? D.template(v, d) : D.template),\n                (M = ha(M)),\n                D.replace)\n              ) {\n                g = D\n                M = Sb.test(M) ? Xc(Xb(D.templateNamespace, T(M))) : []\n                b = M[0]\n                if (1 != M.length || b.nodeType !== pa) throw ga('tplrt', y, '')\n                U(f, v, b)\n                F = { $attr: {} }\n                M = ca(b, [], F)\n                var Lf = a.splice(I + 1, a.length - (I + 1))\n                u && A(M)\n                a = a.concat(M).concat(Lf)\n                Yc(d, F)\n                F = a.length\n              } else v.html(M)\n            if (D.templateUrl)\n              (m = !0),\n                Q('template', L, D, v),\n                (L = D),\n                D.replace && (g = D),\n                (K = Mf(a.splice(I, a.length - I), v, d, f, N && Ka, h, k, {\n                  controllerDirectives: ba,\n                  newScopeDirective: S !== D && S,\n                  newIsolateScopeDirective: u,\n                  templateDirective: L,\n                  nonTlbTranscludeDirective: z\n                })),\n                (F = a.length)\n            else if (D.compile)\n              try {\n                ;(na = D.compile(v, d, Ka)), x(na) ? n(null, na, P, R) : na && n(na.pre, na.post, P, R)\n              } catch (V) {\n                c(V, xa(v))\n              }\n            D.terminal && ((K.terminal = !0), (H = Math.max(H, D.priority)))\n          }\n          K.scope = S && !0 === S.scope\n          K.transcludeOnThisElement = N\n          K.templateOnThisElement = m\n          K.transclude = Ka\n          r.hasElementTranscludeDirective = ia\n          return K\n        }\n        function A (a) {\n          for (var b = 0, c = a.length; b < c; b++) a[b] = Nb(a[b], { $$isolateScope: !0 })\n        }\n        function na (b, d, f, g, h, k, l) {\n          if (d === h) return null\n          h = null\n          if (e.hasOwnProperty(d)) {\n            var n\n            d = a.get(d + 'Directive')\n            for (var q = 0, t = d.length; q < t; q++)\n              try {\n                ;(n = d[q]),\n                  (v(g) || g > n.priority) &&\n                    -1 != n.restrict.indexOf(f) &&\n                    (k && (n = Nb(n, { $$start: k, $$end: l })), b.push(n), (h = n))\n              } catch (H) {\n                c(H)\n              }\n          }\n          return h\n        }\n        function I (b) {\n          if (e.hasOwnProperty(b))\n            for (var c = a.get(b + 'Directive'), d = 0, f = c.length; d < f; d++)\n              if (((b = c[d]), b.multiElement)) return !0\n          return !1\n        }\n        function Yc (a, b) {\n          var c = b.$attr,\n            d = a.$attr,\n            e = a.$$element\n          m(a, function (d, e) {\n            '$' != e.charAt(0) &&\n              (b[e] && b[e] !== d && (d += ('style' === e ? ';' : ' ') + b[e]), a.$set(e, d, !0, c[e]))\n          })\n          m(b, function (b, f) {\n            'class' == f\n              ? (L(e, b), (a['class'] = (a['class'] ? a['class'] + ' ' : '') + b))\n              : 'style' == f\n              ? (e.attr('style', e.attr('style') + ';' + b), (a.style = (a.style ? a.style + ';' : '') + b))\n              : '$' == f.charAt(0) || a.hasOwnProperty(f) || ((a[f] = b), (d[f] = c[f]))\n          })\n        }\n        function Mf (a, b, c, e, f, g, h, k) {\n          var l = [],\n            r,\n            n,\n            q = b[0],\n            t = a.shift(),\n            H = Nb(t, { templateUrl: null, transclude: null, replace: null, $$originalDirective: t }),\n            O = x(t.templateUrl) ? t.templateUrl(b, c) : t.templateUrl,\n            E = t.templateNamespace\n          b.empty()\n          d(O).then(function (d) {\n            var K, u\n            d = ha(d)\n            if (t.replace) {\n              d = Sb.test(d) ? Xc(Xb(E, T(d))) : []\n              K = d[0]\n              if (1 != d.length || K.nodeType !== pa) throw ga('tplrt', t.name, O)\n              d = { $attr: {} }\n              U(e, b, K)\n              var z = ca(K, [], d)\n              C(t.scope) && A(z)\n              a = z.concat(a)\n              Yc(c, d)\n            } else (K = q), b.html(d)\n            a.unshift(H)\n            r = D(a, K, c, f, b, t, g, h, k)\n            m(e, function (a, c) {\n              a == K && (e[c] = b[0])\n            })\n            for (n = S(b[0].childNodes, f); l.length; ) {\n              d = l.shift()\n              u = l.shift()\n              var N = l.shift(),\n                W = l.shift(),\n                z = b[0]\n              if (!d.$$destroyed) {\n                if (u !== q) {\n                  var za = u.className\n                  ;(k.hasElementTranscludeDirective && t.replace) || (z = Ub(K))\n                  U(N, B(u), z)\n                  L(B(z), za)\n                }\n                u = r.transcludeOnThisElement ? ba(d, r.transclude, W) : W\n                r(n, d, z, e, u, r)\n              }\n            }\n            l = null\n          })\n          return function (a, b, c, d, e) {\n            a = e\n            b.$$destroyed ||\n              (l\n                ? l.push(b, c, d, a)\n                : (r.transcludeOnThisElement && (a = ba(b, r.transclude, e)), r(n, b, c, d, a, r)))\n          }\n        }\n        function M (a, b) {\n          var c = b.priority - a.priority\n          return 0 !== c ? c : a.name !== b.name ? (a.name < b.name ? -1 : 1) : a.index - b.index\n        }\n        function Q (a, b, c, d) {\n          function e (a) {\n            return a ? ' (module: ' + a + ')' : ''\n          }\n          if (b) throw ga('multidir', b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, xa(d))\n        }\n        function Ka (a, c) {\n          var d = b(c, !0)\n          d &&\n            a.push({\n              priority: 0,\n              compile: function (a) {\n                a = a.parent()\n                var b = !!a.length\n                b && W.$$addBindingClass(a)\n                return function (a, c) {\n                  var e = c.parent()\n                  b || W.$$addBindingClass(e)\n                  W.$$addBindingInfo(e, d.expressions)\n                  a.$watch(d, function (a) {\n                    c[0].nodeValue = a\n                  })\n                }\n              }\n            })\n        }\n        function Xb (a, b) {\n          a = F(a || 'html')\n          switch (a) {\n            case 'svg':\n            case 'math':\n              var c = X.createElement('div')\n              c.innerHTML = '<' + a + '>' + b + '</' + a + '>'\n              return c.childNodes[0].childNodes\n            default:\n              return b\n          }\n        }\n        function R (a, b) {\n          if ('srcdoc' == b) return ia.HTML\n          var c = wa(a)\n          if ('xlinkHref' == b || ('form' == c && 'action' == b) || ('img' != c && ('src' == b || 'ngSrc' == b)))\n            return ia.RESOURCE_URL\n        }\n        function V (a, c, d, e, f) {\n          var h = R(a, e)\n          f = g[e] || f\n          var l = b(d, !0, h, f)\n          if (l) {\n            if ('multiple' === e && 'select' === wa(a)) throw ga('selmulti', xa(a))\n            c.push({\n              priority: 100,\n              compile: function () {\n                return {\n                  pre: function (a, c, g) {\n                    c = g.$$observers || (g.$$observers = fa())\n                    if (k.test(e)) throw ga('nodomevents')\n                    var r = g[e]\n                    r !== d && ((l = r && b(r, !0, h, f)), (d = r))\n                    l &&\n                      ((g[e] = l(a)),\n                      ((c[e] || (c[e] = [])).$$inter = !0),\n                      ((g.$$observers && g.$$observers[e].$$scope) || a).$watch(l, function (a, b) {\n                        'class' === e && a != b ? g.$updateClass(a, b) : g.$set(e, a)\n                      }))\n                  }\n                }\n              }\n            })\n          }\n        }\n        function U (a, b, c) {\n          var d = b[0],\n            e = b.length,\n            f = d.parentNode,\n            g,\n            h\n          if (a)\n            for (g = 0, h = a.length; g < h; g++)\n              if (a[g] == d) {\n                a[g++] = c\n                h = g + e - 1\n                for (var k = a.length; g < k; g++, h++) h < k ? (a[g] = a[h]) : delete a[g]\n                a.length -= e - 1\n                a.context === d && (a.context = c)\n                break\n              }\n          f && f.replaceChild(c, d)\n          a = X.createDocumentFragment()\n          a.appendChild(d)\n          B.hasData(d) && (B(c).data(B(d).data()), ra ? ((Qb = !0), ra.cleanData([d])) : delete B.cache[d[B.expando]])\n          d = 1\n          for (e = b.length; d < e; d++) (f = b[d]), B(f).remove(), a.appendChild(f), delete b[d]\n          b[0] = c\n          b.length = 1\n        }\n        function $ (a, b) {\n          return P(\n            function () {\n              return a.apply(null, arguments)\n            },\n            a,\n            b\n          )\n        }\n        function aa (a, b, d, e, f, g) {\n          try {\n            a(b, d, e, f, g)\n          } catch (h) {\n            c(h, xa(d))\n          }\n        }\n        function Y (a, c, d, e, f, g) {\n          var h\n          m(e, function (e, g) {\n            var k = e.attrName,\n              l = e.optional,\n              r,\n              n,\n              q,\n              K\n            switch (e.mode) {\n              case '@':\n                l || ta.call(c, k) || (d[g] = c[k] = void 0)\n                c.$observe(k, function (a) {\n                  G(a) && (d[g] = a)\n                })\n                c.$$observers[k].$$scope = a\n                G(c[k]) && (d[g] = b(c[k])(a))\n                break\n              case '=':\n                if (!ta.call(c, k)) {\n                  if (l) break\n                  c[k] = void 0\n                }\n                if (l && !c[k]) break\n                n = u(c[k])\n                K = n.literal\n                  ? ka\n                  : function (a, b) {\n                      return a === b || (a !== a && b !== b)\n                    }\n                q =\n                  n.assign ||\n                  function () {\n                    r = d[g] = n(a)\n                    throw ga('nonassign', c[k], f.name)\n                  }\n                r = d[g] = n(a)\n                l = function (b) {\n                  K(b, d[g]) || (K(b, r) ? q(a, (b = d[g])) : (d[g] = b))\n                  return (r = b)\n                }\n                l.$stateful = !0\n                l = e.collection ? a.$watchCollection(c[k], l) : a.$watch(u(c[k], l), null, n.literal)\n                h = h || []\n                h.push(l)\n                break\n              case '&':\n                n = c.hasOwnProperty(k) ? u(c[k]) : y\n                if (n === y && l) break\n                d[g] = function (b) {\n                  return n(a, b)\n                }\n            }\n          })\n          e = h\n            ? function () {\n                for (var a = 0, b = h.length; a < b; ++a) h[a]()\n              }\n            : y\n          return g && e !== y ? (g.$on('$destroy', e), y) : e\n        }\n        var Z = function (a, b) {\n          if (b) {\n            var c = Object.keys(b),\n              d,\n              e,\n              f\n            d = 0\n            for (e = c.length; d < e; d++) (f = c[d]), (this[f] = b[f])\n          } else this.$attr = {}\n          this.$$element = a\n        }\n        Z.prototype = {\n          $normalize: ya,\n          $addClass: function (a) {\n            a && 0 < a.length && O.addClass(this.$$element, a)\n          },\n          $removeClass: function (a) {\n            a && 0 < a.length && O.removeClass(this.$$element, a)\n          },\n          $updateClass: function (a, b) {\n            var c = Zc(a, b)\n            c && c.length && O.addClass(this.$$element, c)\n            ;(c = Zc(b, a)) && c.length && O.removeClass(this.$$element, c)\n          },\n          $set: function (a, b, d, e) {\n            var f = Rc(this.$$element[0], a),\n              g = $c[a],\n              h = a\n            f ? (this.$$element.prop(a, b), (e = f)) : g && ((this[g] = b), (h = g))\n            this[a] = b\n            e ? (this.$attr[a] = e) : (e = this.$attr[a]) || (this.$attr[a] = e = Ac(a, '-'))\n            f = wa(this.$$element)\n            if (('a' === f && 'href' === a) || ('img' === f && 'src' === a)) this[a] = b = H(b, 'src' === a)\n            else if ('img' === f && 'srcset' === a) {\n              for (\n                var f = '',\n                  g = T(b),\n                  k = /(\\s+\\d+x\\s*,|\\s+\\d+w\\s*,|\\s+,|,\\s+)/,\n                  k = /\\s/.test(g) ? k : /(,)/,\n                  g = g.split(k),\n                  k = Math.floor(g.length / 2),\n                  l = 0;\n                l < k;\n                l++\n              )\n                var r = 2 * l, f = f + H(T(g[r]), !0), f = f + (' ' + T(g[r + 1]))\n              g = T(g[2 * l]).split(/\\s/)\n              f += H(T(g[0]), !0)\n              2 === g.length && (f += ' ' + T(g[1]))\n              this[a] = b = f\n            }\n            !1 !== d && (null === b || v(b) ? this.$$element.removeAttr(e) : this.$$element.attr(e, b))\n            ;(a = this.$$observers) &&\n              m(a[h], function (a) {\n                try {\n                  a(b)\n                } catch (d) {\n                  c(d)\n                }\n              })\n          },\n          $observe: function (a, b) {\n            var c = this,\n              d = c.$$observers || (c.$$observers = fa()),\n              e = d[a] || (d[a] = [])\n            e.push(b)\n            z.$evalAsync(function () {\n              e.$$inter || !c.hasOwnProperty(a) || v(c[a]) || b(c[a])\n            })\n            return function () {\n              cb(e, b)\n            }\n          }\n        }\n        var da = b.startSymbol(),\n          ea = b.endSymbol(),\n          ha =\n            '{{' == da || '}}' == ea\n              ? $a\n              : function (a) {\n                  return a.replace(/\\{\\{/g, da).replace(/}}/g, ea)\n                },\n          ja = /^ngAttr[A-Z]/\n        W.$$addBindingInfo = n\n          ? function (a, b) {\n              var c = a.data('$binding') || []\n              J(b) ? (c = c.concat(b)) : c.push(b)\n              a.data('$binding', c)\n            }\n          : y\n        W.$$addBindingClass = n\n          ? function (a) {\n              L(a, 'ng-binding')\n            }\n          : y\n        W.$$addScopeInfo = n\n          ? function (a, b, c, d) {\n              a.data(c ? (d ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope', b)\n            }\n          : y\n        W.$$addScopeClass = n\n          ? function (a, b) {\n              L(a, b ? 'ng-isolate-scope' : 'ng-scope')\n            }\n          : y\n        return W\n      }\n    ]\n  }\n  function ya (b) {\n    return gb(b.replace(Wc, ''))\n  }\n  function Zc (b, a) {\n    var c = '',\n      d = b.split(/\\s+/),\n      e = a.split(/\\s+/),\n      f = 0\n    a: for (; f < d.length; f++) {\n      for (var h = d[f], g = 0; g < e.length; g++) if (h == e[g]) continue a\n      c += (0 < c.length ? ' ' : '') + h\n    }\n    return c\n  }\n  function Xc (b) {\n    b = B(b)\n    var a = b.length\n    if (1 >= a) return b\n    for (; a--; ) 8 === b[a].nodeType && Nf.call(b, a, 1)\n    return b\n  }\n  function Xe () {\n    var b = {},\n      a = !1\n    this.register = function (a, d) {\n      Ta(a, 'controller')\n      C(a) ? P(b, a) : (b[a] = d)\n    }\n    this.allowGlobals = function () {\n      a = !0\n    }\n    this.$get = [\n      '$injector',\n      '$window',\n      function (c, d) {\n        function e (a, b, c, d) {\n          if (!a || !C(a.$scope)) throw I('$controller')('noscp', d, b)\n          a.$scope[b] = c\n        }\n        return function (f, h, g, l) {\n          var k, n, p\n          g = !0 === g\n          l && G(l) && (p = l)\n          if (G(f)) {\n            l = f.match(Vc)\n            if (!l) throw Of('ctrlfmt', f)\n            n = l[1]\n            p = p || l[3]\n            f = b.hasOwnProperty(n) ? b[n] : Cc(h.$scope, n, !0) || (a ? Cc(d, n, !0) : w)\n            Sa(f, n, !0)\n          }\n          if (g)\n            return (\n              (g = (J(f) ? f[f.length - 1] : f).prototype),\n              (k = Object.create(g || null)),\n              p && e(h, p, k, n || f.name),\n              P(\n                function () {\n                  var a = c.invoke(f, k, h, n)\n                  a !== k && (C(a) || x(a)) && ((k = a), p && e(h, p, k, n || f.name))\n                  return k\n                },\n                { instance: k, identifier: p }\n              )\n            )\n          k = c.instantiate(f, h, n)\n          p && e(h, p, k, n || f.name)\n          return k\n        }\n      }\n    ]\n  }\n  function Ye () {\n    this.$get = [\n      '$window',\n      function (b) {\n        return B(b.document)\n      }\n    ]\n  }\n  function Ze () {\n    this.$get = [\n      '$log',\n      function (b) {\n        return function (a, c) {\n          b.error.apply(b, arguments)\n        }\n      }\n    ]\n  }\n  function Yb (b) {\n    return C(b) ? (ea(b) ? b.toISOString() : eb(b)) : b\n  }\n  function df () {\n    this.$get = function () {\n      return function (b) {\n        if (!b) return ''\n        var a = []\n        nc(b, function (b, d) {\n          null === b ||\n            v(b) ||\n            (J(b)\n              ? m(b, function (b, c) {\n                  a.push(la(d) + '=' + la(Yb(b)))\n                })\n              : a.push(la(d) + '=' + la(Yb(b))))\n        })\n        return a.join('&')\n      }\n    }\n  }\n  function ef () {\n    this.$get = function () {\n      return function (b) {\n        function a (b, e, f) {\n          null === b ||\n            v(b) ||\n            (J(b)\n              ? m(b, function (b, c) {\n                  a(b, e + '[' + (C(b) ? c : '') + ']')\n                })\n              : C(b) && !ea(b)\n              ? nc(b, function (b, c) {\n                  a(b, e + (f ? '' : '[') + c + (f ? '' : ']'))\n                })\n              : c.push(la(e) + '=' + la(Yb(b))))\n        }\n        if (!b) return ''\n        var c = []\n        a(b, '', !0)\n        return c.join('&')\n      }\n    }\n  }\n  function Zb (b, a) {\n    if (G(b)) {\n      var c = b.replace(Pf, '').trim()\n      if (c) {\n        var d = a('Content-Type')\n        ;(d = d && 0 === d.indexOf(ad)) || (d = (d = c.match(Qf)) && Rf[d[0]].test(c))\n        d && (b = vc(c))\n      }\n    }\n    return b\n  }\n  function bd (b) {\n    var a = fa(),\n      c\n    G(b)\n      ? m(b.split('\\n'), function (b) {\n          c = b.indexOf(':')\n          var e = F(T(b.substr(0, c)))\n          b = T(b.substr(c + 1))\n          e && (a[e] = a[e] ? a[e] + ', ' + b : b)\n        })\n      : C(b) &&\n        m(b, function (b, c) {\n          var f = F(c),\n            h = T(b)\n          f && (a[f] = a[f] ? a[f] + ', ' + h : h)\n        })\n    return a\n  }\n  function cd (b) {\n    var a\n    return function (c) {\n      a || (a = bd(b))\n      return c ? ((c = a[F(c)]), void 0 === c && (c = null), c) : a\n    }\n  }\n  function dd (b, a, c, d) {\n    if (x(d)) return d(b, a, c)\n    m(d, function (d) {\n      b = d(b, a, c)\n    })\n    return b\n  }\n  function cf () {\n    var b = (this.defaults = {\n        transformResponse: [Zb],\n        transformRequest: [\n          function (a) {\n            return C(a) &&\n              '[object File]' !== va.call(a) &&\n              '[object Blob]' !== va.call(a) &&\n              '[object FormData]' !== va.call(a)\n              ? eb(a)\n              : a\n          }\n        ],\n        headers: { common: { Accept: 'application/json, text/plain, */*' }, post: ja($b), put: ja($b), patch: ja($b) },\n        xsrfCookieName: 'XSRF-TOKEN',\n        xsrfHeaderName: 'X-XSRF-TOKEN',\n        paramSerializer: '$httpParamSerializer'\n      }),\n      a = !1\n    this.useApplyAsync = function (b) {\n      return A(b) ? ((a = !!b), this) : a\n    }\n    var c = !0\n    this.useLegacyPromiseExtensions = function (a) {\n      return A(a) ? ((c = !!a), this) : c\n    }\n    var d = (this.interceptors = [])\n    this.$get = [\n      '$httpBackend',\n      '$$cookieReader',\n      '$cacheFactory',\n      '$rootScope',\n      '$q',\n      '$injector',\n      function (e, f, h, g, l, k) {\n        function n (a) {\n          function d (a) {\n            var b = P({}, a)\n            b.data = a.data ? dd(a.data, a.headers, a.status, f.transformResponse) : a.data\n            a = a.status\n            return 200 <= a && 300 > a ? b : l.reject(b)\n          }\n          function e (a, b) {\n            var c,\n              d = {}\n            m(a, function (a, e) {\n              x(a) ? ((c = a(b)), null != c && (d[e] = c)) : (d[e] = a)\n            })\n            return d\n          }\n          if (!da.isObject(a)) throw I('$http')('badreq', a)\n          var f = P(\n            {\n              method: 'get',\n              transformRequest: b.transformRequest,\n              transformResponse: b.transformResponse,\n              paramSerializer: b.paramSerializer\n            },\n            a\n          )\n          f.headers = (function (a) {\n            var c = b.headers,\n              d = P({}, a.headers),\n              f,\n              g,\n              h,\n              c = P({}, c.common, c[F(a.method)])\n            a: for (f in c) {\n              g = F(f)\n              for (h in d) if (F(h) === g) continue a\n              d[f] = c[f]\n            }\n            return e(d, ja(a))\n          })(a)\n          f.method = sb(f.method)\n          f.paramSerializer = G(f.paramSerializer) ? k.get(f.paramSerializer) : f.paramSerializer\n          var g = [\n              function (a) {\n                var c = a.headers,\n                  e = dd(a.data, cd(c), w, a.transformRequest)\n                v(e) &&\n                  m(c, function (a, b) {\n                    'content-type' === F(b) && delete c[b]\n                  })\n                v(a.withCredentials) && !v(b.withCredentials) && (a.withCredentials = b.withCredentials)\n                return p(a, e).then(d, d)\n              },\n              w\n            ],\n            h = l.when(f)\n          for (\n            m(E, function (a) {\n              ;(a.request || a.requestError) && g.unshift(a.request, a.requestError)\n              ;(a.response || a.responseError) && g.push(a.response, a.responseError)\n            });\n            g.length;\n\n          ) {\n            a = g.shift()\n            var r = g.shift(),\n              h = h.then(a, r)\n          }\n          c\n            ? ((h.success = function (a) {\n                Sa(a, 'fn')\n                h.then(function (b) {\n                  a(b.data, b.status, b.headers, f)\n                })\n                return h\n              }),\n              (h.error = function (a) {\n                Sa(a, 'fn')\n                h.then(null, function (b) {\n                  a(b.data, b.status, b.headers, f)\n                })\n                return h\n              }))\n            : ((h.success = ed('success')), (h.error = ed('error')))\n          return h\n        }\n        function p (c, d) {\n          function h (b, c, d, e) {\n            function f () {\n              k(c, b, d, e)\n            }\n            L && (200 <= b && 300 > b ? L.put(ba, [b, c, bd(d), e]) : L.remove(ba))\n            a ? g.$applyAsync(f) : (f(), g.$$phase || g.$apply())\n          }\n          function k (a, b, d, e) {\n            b = -1 <= b ? b : 0\n            ;(200 <= b && 300 > b ? O.resolve : O.reject)({\n              data: a,\n              status: b,\n              headers: cd(d),\n              config: c,\n              statusText: e\n            })\n          }\n          function p (a) {\n            k(a.data, a.status, ja(a.headers()), a.statusText)\n          }\n          function E () {\n            var a = n.pendingRequests.indexOf(c)\n            ;-1 !== a && n.pendingRequests.splice(a, 1)\n          }\n          var O = l.defer(),\n            H = O.promise,\n            L,\n            m,\n            S = c.headers,\n            ba = r(c.url, c.paramSerializer(c.params))\n          n.pendingRequests.push(c)\n          H.then(E, E)\n          ;(!c.cache && !b.cache) ||\n            !1 === c.cache ||\n            ('GET' !== c.method && 'JSONP' !== c.method) ||\n            (L = C(c.cache) ? c.cache : C(b.cache) ? b.cache : t)\n          L &&\n            ((m = L.get(ba)),\n            A(m)\n              ? m && x(m.then)\n                ? m.then(p, p)\n                : J(m)\n                ? k(m[1], m[0], ja(m[2]), m[3])\n                : k(m, 200, {}, 'OK')\n              : L.put(ba, H))\n          v(m) &&\n            ((m = fd(c.url) ? f()[c.xsrfCookieName || b.xsrfCookieName] : w) &&\n              (S[c.xsrfHeaderName || b.xsrfHeaderName] = m),\n            e(c.method, ba, d, h, S, c.timeout, c.withCredentials, c.responseType))\n          return H\n        }\n        function r (a, b) {\n          0 < b.length && (a += (-1 == a.indexOf('?') ? '?' : '&') + b)\n          return a\n        }\n        var t = h('$http')\n        b.paramSerializer = G(b.paramSerializer) ? k.get(b.paramSerializer) : b.paramSerializer\n        var E = []\n        m(d, function (a) {\n          E.unshift(G(a) ? k.get(a) : k.invoke(a))\n        })\n        n.pendingRequests = []\n        ;(function (a) {\n          m(arguments, function (a) {\n            n[a] = function (b, c) {\n              return n(P({}, c || {}, { method: a, url: b }))\n            }\n          })\n        })('get', 'delete', 'head', 'jsonp')\n        ;(function (a) {\n          m(arguments, function (a) {\n            n[a] = function (b, c, d) {\n              return n(P({}, d || {}, { method: a, url: b, data: c }))\n            }\n          })\n        })('post', 'put', 'patch')\n        n.defaults = b\n        return n\n      }\n    ]\n  }\n  function gf () {\n    this.$get = function () {\n      return function () {\n        return new Q.XMLHttpRequest()\n      }\n    }\n  }\n  function ff () {\n    this.$get = [\n      '$browser',\n      '$window',\n      '$document',\n      '$xhrFactory',\n      function (b, a, c, d) {\n        return Sf(b, d, b.defer, a.angular.callbacks, c[0])\n      }\n    ]\n  }\n  function Sf (b, a, c, d, e) {\n    function f (a, b, c) {\n      var f = e.createElement('script'),\n        n = null\n      f.type = 'text/javascript'\n      f.src = a\n      f.async = !0\n      n = function (a) {\n        f.removeEventListener('load', n, !1)\n        f.removeEventListener('error', n, !1)\n        e.body.removeChild(f)\n        f = null\n        var h = -1,\n          t = 'unknown'\n        a &&\n          ('load' !== a.type || d[b].called || (a = { type: 'error' }),\n          (t = a.type),\n          (h = 'error' === a.type ? 404 : 200))\n        c && c(h, t)\n      }\n      f.addEventListener('load', n, !1)\n      f.addEventListener('error', n, !1)\n      e.body.appendChild(f)\n      return n\n    }\n    return function (e, g, l, k, n, p, r, t) {\n      function E () {\n        q && q()\n        z && z.abort()\n      }\n      function K (a, d, e, f, g) {\n        A(s) && c.cancel(s)\n        q = z = null\n        a(d, e, f, g)\n        b.$$completeOutstandingRequest(y)\n      }\n      b.$$incOutstandingRequestCount()\n      g = g || b.url()\n      if ('jsonp' == F(e)) {\n        var u = '_' + (d.counter++).toString(36)\n        d[u] = function (a) {\n          d[u].data = a\n          d[u].called = !0\n        }\n        var q = f(g.replace('JSON_CALLBACK', 'angular.callbacks.' + u), u, function (a, b) {\n          K(k, a, d[u].data, '', b)\n          d[u] = y\n        })\n      } else {\n        var z = a(e, g)\n        z.open(e, g, !0)\n        m(n, function (a, b) {\n          A(a) && z.setRequestHeader(b, a)\n        })\n        z.onload = function () {\n          var a = z.statusText || '',\n            b = 'response' in z ? z.response : z.responseText,\n            c = 1223 === z.status ? 204 : z.status\n          0 === c && (c = b ? 200 : 'file' == Aa(g).protocol ? 404 : 0)\n          K(k, c, b, z.getAllResponseHeaders(), a)\n        }\n        e = function () {\n          K(k, -1, null, null, '')\n        }\n        z.onerror = e\n        z.onabort = e\n        r && (z.withCredentials = !0)\n        if (t)\n          try {\n            z.responseType = t\n          } catch (N) {\n            if ('json' !== t) throw N\n          }\n        z.send(v(l) ? null : l)\n      }\n      if (0 < p) var s = c(E, p)\n      else p && x(p.then) && p.then(E)\n    }\n  }\n  function af () {\n    var b = '{{',\n      a = '}}'\n    this.startSymbol = function (a) {\n      return a ? ((b = a), this) : b\n    }\n    this.endSymbol = function (b) {\n      return b ? ((a = b), this) : a\n    }\n    this.$get = [\n      '$parse',\n      '$exceptionHandler',\n      '$sce',\n      function (c, d, e) {\n        function f (a) {\n          return '\\\\\\\\\\\\' + a\n        }\n        function h (c) {\n          return c.replace(n, b).replace(p, a)\n        }\n        function g (f, g, n, p) {\n          function u (a) {\n            try {\n              var b = a\n              a = n ? e.getTrusted(n, b) : e.valueOf(b)\n              var c\n              if (p && !A(a)) c = a\n              else if (null == a) c = ''\n              else {\n                switch (typeof a) {\n                  case 'string':\n                    break\n                  case 'number':\n                    a = '' + a\n                    break\n                  default:\n                    a = eb(a)\n                }\n                c = a\n              }\n              return c\n            } catch (g) {\n              d(La.interr(f, g))\n            }\n          }\n          p = !!p\n          for (var q, m, N = 0, s = [], O = [], H = f.length, L = [], W = []; N < H; )\n            if (-1 != (q = f.indexOf(b, N)) && -1 != (m = f.indexOf(a, q + l)))\n              N !== q && L.push(h(f.substring(N, q))),\n                (N = f.substring(q + l, m)),\n                s.push(N),\n                O.push(c(N, u)),\n                (N = m + k),\n                W.push(L.length),\n                L.push('')\n            else {\n              N !== H && L.push(h(f.substring(N)))\n              break\n            }\n          n && 1 < L.length && La.throwNoconcat(f)\n          if (!g || s.length) {\n            var S = function (a) {\n              for (var b = 0, c = s.length; b < c; b++) {\n                if (p && v(a[b])) return\n                L[W[b]] = a[b]\n              }\n              return L.join('')\n            }\n            return P(\n              function (a) {\n                var b = 0,\n                  c = s.length,\n                  e = Array(c)\n                try {\n                  for (; b < c; b++) e[b] = O[b](a)\n                  return S(e)\n                } catch (g) {\n                  d(La.interr(f, g))\n                }\n              },\n              {\n                exp: f,\n                expressions: s,\n                $$watchDelegate: function (a, b) {\n                  var c\n                  return a.$watchGroup(O, function (d, e) {\n                    var f = S(d)\n                    x(b) && b.call(this, f, d !== e ? c : f, a)\n                    c = f\n                  })\n                }\n              }\n            )\n          }\n        }\n        var l = b.length,\n          k = a.length,\n          n = new RegExp(b.replace(/./g, f), 'g'),\n          p = new RegExp(a.replace(/./g, f), 'g')\n        g.startSymbol = function () {\n          return b\n        }\n        g.endSymbol = function () {\n          return a\n        }\n        return g\n      }\n    ]\n  }\n  function bf () {\n    this.$get = [\n      '$rootScope',\n      '$window',\n      '$q',\n      '$$q',\n      function (b, a, c, d) {\n        function e (e, g, l, k) {\n          var n = 4 < arguments.length,\n            p = n ? ua.call(arguments, 4) : [],\n            r = a.setInterval,\n            t = a.clearInterval,\n            E = 0,\n            K = A(k) && !k,\n            u = (K ? d : c).defer(),\n            q = u.promise\n          l = A(l) ? l : 0\n          q.then(\n            null,\n            null,\n            n\n              ? function () {\n                  e.apply(null, p)\n                }\n              : e\n          )\n          q.$$intervalId = r(function () {\n            u.notify(E++)\n            0 < l && E >= l && (u.resolve(E), t(q.$$intervalId), delete f[q.$$intervalId])\n            K || b.$apply()\n          }, g)\n          f[q.$$intervalId] = u\n          return q\n        }\n        var f = {}\n        e.cancel = function (b) {\n          return b && b.$$intervalId in f\n            ? (f[b.$$intervalId].reject('canceled'), a.clearInterval(b.$$intervalId), delete f[b.$$intervalId], !0)\n            : !1\n        }\n        return e\n      }\n    ]\n  }\n  function ac (b) {\n    b = b.split('/')\n    for (var a = b.length; a--; ) b[a] = ob(b[a])\n    return b.join('/')\n  }\n  function gd (b, a) {\n    var c = Aa(b)\n    a.$$protocol = c.protocol\n    a.$$host = c.hostname\n    a.$$port = Y(c.port) || Tf[c.protocol] || null\n  }\n  function hd (b, a) {\n    var c = '/' !== b.charAt(0)\n    c && (b = '/' + b)\n    var d = Aa(b)\n    a.$$path = decodeURIComponent(c && '/' === d.pathname.charAt(0) ? d.pathname.substring(1) : d.pathname)\n    a.$$search = yc(d.search)\n    a.$$hash = decodeURIComponent(d.hash)\n    a.$$path && '/' != a.$$path.charAt(0) && (a.$$path = '/' + a.$$path)\n  }\n  function sa (b, a) {\n    if (0 === a.indexOf(b)) return a.substr(b.length)\n  }\n  function Ja (b) {\n    var a = b.indexOf('#')\n    return -1 == a ? b : b.substr(0, a)\n  }\n  function Cb (b) {\n    return b.replace(/(#.+)|#$/, '$1')\n  }\n  function bc (b, a, c) {\n    this.$$html5 = !0\n    c = c || ''\n    gd(b, this)\n    this.$$parse = function (b) {\n      var c = sa(a, b)\n      if (!G(c)) throw Db('ipthprfx', b, a)\n      hd(c, this)\n      this.$$path || (this.$$path = '/')\n      this.$$compose()\n    }\n    this.$$compose = function () {\n      var b = Pb(this.$$search),\n        c = this.$$hash ? '#' + ob(this.$$hash) : ''\n      this.$$url = ac(this.$$path) + (b ? '?' + b : '') + c\n      this.$$absUrl = a + this.$$url.substr(1)\n    }\n    this.$$parseLinkUrl = function (d, e) {\n      if (e && '#' === e[0]) return this.hash(e.slice(1)), !0\n      var f, h\n      A((f = sa(b, d)))\n        ? ((h = f), (h = A((f = sa(c, f))) ? a + (sa('/', f) || f) : b + h))\n        : A((f = sa(a, d)))\n        ? (h = a + f)\n        : a == d + '/' && (h = a)\n      h && this.$$parse(h)\n      return !!h\n    }\n  }\n  function cc (b, a, c) {\n    gd(b, this)\n    this.$$parse = function (d) {\n      var e = sa(b, d) || sa(a, d),\n        f\n      v(e) || '#' !== e.charAt(0)\n        ? this.$$html5\n          ? (f = e)\n          : ((f = ''), v(e) && ((b = d), this.replace()))\n        : ((f = sa(c, e)), v(f) && (f = e))\n      hd(f, this)\n      d = this.$$path\n      var e = b,\n        h = /^\\/[A-Z]:(\\/.*)/\n      0 === f.indexOf(e) && (f = f.replace(e, ''))\n      h.exec(f) || (d = (f = h.exec(d)) ? f[1] : d)\n      this.$$path = d\n      this.$$compose()\n    }\n    this.$$compose = function () {\n      var a = Pb(this.$$search),\n        e = this.$$hash ? '#' + ob(this.$$hash) : ''\n      this.$$url = ac(this.$$path) + (a ? '?' + a : '') + e\n      this.$$absUrl = b + (this.$$url ? c + this.$$url : '')\n    }\n    this.$$parseLinkUrl = function (a, c) {\n      return Ja(b) == Ja(a) ? (this.$$parse(a), !0) : !1\n    }\n  }\n  function id (b, a, c) {\n    this.$$html5 = !0\n    cc.apply(this, arguments)\n    this.$$parseLinkUrl = function (d, e) {\n      if (e && '#' === e[0]) return this.hash(e.slice(1)), !0\n      var f, h\n      b == Ja(d) ? (f = d) : (h = sa(a, d)) ? (f = b + c + h) : a === d + '/' && (f = a)\n      f && this.$$parse(f)\n      return !!f\n    }\n    this.$$compose = function () {\n      var a = Pb(this.$$search),\n        e = this.$$hash ? '#' + ob(this.$$hash) : ''\n      this.$$url = ac(this.$$path) + (a ? '?' + a : '') + e\n      this.$$absUrl = b + c + this.$$url\n    }\n  }\n  function Eb (b) {\n    return function () {\n      return this[b]\n    }\n  }\n  function jd (b, a) {\n    return function (c) {\n      if (v(c)) return this[b]\n      this[b] = a(c)\n      this.$$compose()\n      return this\n    }\n  }\n  function hf () {\n    var b = '',\n      a = { enabled: !1, requireBase: !0, rewriteLinks: !0 }\n    this.hashPrefix = function (a) {\n      return A(a) ? ((b = a), this) : b\n    }\n    this.html5Mode = function (b) {\n      return bb(b)\n        ? ((a.enabled = b), this)\n        : C(b)\n        ? (bb(b.enabled) && (a.enabled = b.enabled),\n          bb(b.requireBase) && (a.requireBase = b.requireBase),\n          bb(b.rewriteLinks) && (a.rewriteLinks = b.rewriteLinks),\n          this)\n        : a\n    }\n    this.$get = [\n      '$rootScope',\n      '$browser',\n      '$sniffer',\n      '$rootElement',\n      '$window',\n      function (c, d, e, f, h) {\n        function g (a, b, c) {\n          var e = k.url(),\n            f = k.$$state\n          try {\n            d.url(a, b, c), (k.$$state = d.state())\n          } catch (g) {\n            throw (k.url(e), (k.$$state = f), g)\n          }\n        }\n        function l (a, b) {\n          c.$broadcast('$locationChangeSuccess', k.absUrl(), a, k.$$state, b)\n        }\n        var k, n\n        n = d.baseHref()\n        var p = d.url(),\n          r\n        if (a.enabled) {\n          if (!n && a.requireBase) throw Db('nobase')\n          r = p.substring(0, p.indexOf('/', p.indexOf('//') + 2)) + (n || '/')\n          n = e.history ? bc : id\n        } else (r = Ja(p)), (n = cc)\n        var t = r.substr(0, Ja(r).lastIndexOf('/') + 1)\n        k = new n(r, t, '#' + b)\n        k.$$parseLinkUrl(p, p)\n        k.$$state = d.state()\n        var E = /^\\s*(javascript|mailto):/i\n        f.on('click', function (b) {\n          if (a.rewriteLinks && !b.ctrlKey && !b.metaKey && !b.shiftKey && 2 != b.which && 2 != b.button) {\n            for (var e = B(b.target); 'a' !== wa(e[0]); ) if (e[0] === f[0] || !(e = e.parent())[0]) return\n            var g = e.prop('href'),\n              l = e.attr('href') || e.attr('xlink:href')\n            C(g) && '[object SVGAnimatedString]' === g.toString() && (g = Aa(g.animVal).href)\n            E.test(g) ||\n              !g ||\n              e.attr('target') ||\n              b.isDefaultPrevented() ||\n              !k.$$parseLinkUrl(g, l) ||\n              (b.preventDefault(), k.absUrl() != d.url() && (c.$apply(), (h.angular['ff-684208-preventDefault'] = !0)))\n          }\n        })\n        Cb(k.absUrl()) != Cb(p) && d.url(k.absUrl(), !0)\n        var K = !0\n        d.onUrlChange(function (a, b) {\n          v(sa(t, a))\n            ? (h.location.href = a)\n            : (c.$evalAsync(function () {\n                var d = k.absUrl(),\n                  e = k.$$state,\n                  f\n                k.$$parse(a)\n                k.$$state = b\n                f = c.$broadcast('$locationChangeStart', a, d, b, e).defaultPrevented\n                k.absUrl() === a && (f ? (k.$$parse(d), (k.$$state = e), g(d, !1, e)) : ((K = !1), l(d, e)))\n              }),\n              c.$$phase || c.$digest())\n        })\n        c.$watch(function () {\n          var a = Cb(d.url()),\n            b = Cb(k.absUrl()),\n            f = d.state(),\n            h = k.$$replace,\n            r = a !== b || (k.$$html5 && e.history && f !== k.$$state)\n          if (K || r)\n            (K = !1),\n              c.$evalAsync(function () {\n                var b = k.absUrl(),\n                  d = c.$broadcast('$locationChangeStart', b, a, k.$$state, f).defaultPrevented\n                k.absUrl() === b &&\n                  (d ? (k.$$parse(a), (k.$$state = f)) : (r && g(b, h, f === k.$$state ? null : k.$$state), l(a, f)))\n              })\n          k.$$replace = !1\n        })\n        return k\n      }\n    ]\n  }\n  function jf () {\n    var b = !0,\n      a = this\n    this.debugEnabled = function (a) {\n      return A(a) ? ((b = a), this) : b\n    }\n    this.$get = [\n      '$window',\n      function (c) {\n        function d (a) {\n          a instanceof Error &&\n            (a.stack\n              ? (a = a.message && -1 === a.stack.indexOf(a.message) ? 'Error: ' + a.message + '\\n' + a.stack : a.stack)\n              : a.sourceURL && (a = a.message + '\\n' + a.sourceURL + ':' + a.line))\n          return a\n        }\n        function e (a) {\n          var b = c.console || {},\n            e = b[a] || b.log || y\n          a = !1\n          try {\n            a = !!e.apply\n          } catch (l) {}\n          return a\n            ? function () {\n                var a = []\n                m(arguments, function (b) {\n                  a.push(d(b))\n                })\n                return e.apply(b, a)\n              }\n            : function (a, b) {\n                e(a, null == b ? '' : b)\n              }\n        }\n        return {\n          log: e('log'),\n          info: e('info'),\n          warn: e('warn'),\n          error: e('error'),\n          debug: (function () {\n            var c = e('debug')\n            return function () {\n              b && c.apply(a, arguments)\n            }\n          })()\n        }\n      }\n    ]\n  }\n  function Xa (b, a) {\n    if (\n      '__defineGetter__' === b ||\n      '__defineSetter__' === b ||\n      '__lookupGetter__' === b ||\n      '__lookupSetter__' === b ||\n      '__proto__' === b\n    )\n      throw Z('isecfld', a)\n    return b\n  }\n  function kd (b, a) {\n    b += ''\n    if (!G(b)) throw Z('iseccst', a)\n    return b\n  }\n  function Ba (b, a) {\n    if (b) {\n      if (b.constructor === b) throw Z('isecfn', a)\n      if (b.window === b) throw Z('isecwindow', a)\n      if (b.children && (b.nodeName || (b.prop && b.attr && b.find))) throw Z('isecdom', a)\n      if (b === Object) throw Z('isecobj', a)\n    }\n    return b\n  }\n  function ld (b, a) {\n    if (b) {\n      if (b.constructor === b) throw Z('isecfn', a)\n      if (b === Uf || b === Vf || b === Wf) throw Z('isecff', a)\n    }\n  }\n  function md (b, a) {\n    if (\n      b &&\n      (b === (0).constructor ||\n        b === (!1).constructor ||\n        b === ''.constructor ||\n        b === {}.constructor ||\n        b === [].constructor ||\n        b === Function.constructor)\n    )\n      throw Z('isecaf', a)\n  }\n  function Xf (b, a) {\n    return 'undefined' !== typeof b ? b : a\n  }\n  function nd (b, a) {\n    return 'undefined' === typeof b ? a : 'undefined' === typeof a ? b : b + a\n  }\n  function U (b, a) {\n    var c, d\n    switch (b.type) {\n      case s.Program:\n        c = !0\n        m(b.body, function (b) {\n          U(b.expression, a)\n          c = c && b.expression.constant\n        })\n        b.constant = c\n        break\n      case s.Literal:\n        b.constant = !0\n        b.toWatch = []\n        break\n      case s.UnaryExpression:\n        U(b.argument, a)\n        b.constant = b.argument.constant\n        b.toWatch = b.argument.toWatch\n        break\n      case s.BinaryExpression:\n        U(b.left, a)\n        U(b.right, a)\n        b.constant = b.left.constant && b.right.constant\n        b.toWatch = b.left.toWatch.concat(b.right.toWatch)\n        break\n      case s.LogicalExpression:\n        U(b.left, a)\n        U(b.right, a)\n        b.constant = b.left.constant && b.right.constant\n        b.toWatch = b.constant ? [] : [b]\n        break\n      case s.ConditionalExpression:\n        U(b.test, a)\n        U(b.alternate, a)\n        U(b.consequent, a)\n        b.constant = b.test.constant && b.alternate.constant && b.consequent.constant\n        b.toWatch = b.constant ? [] : [b]\n        break\n      case s.Identifier:\n        b.constant = !1\n        b.toWatch = [b]\n        break\n      case s.MemberExpression:\n        U(b.object, a)\n        b.computed && U(b.property, a)\n        b.constant = b.object.constant && (!b.computed || b.property.constant)\n        b.toWatch = [b]\n        break\n      case s.CallExpression:\n        c = b.filter ? !a(b.callee.name).$stateful : !1\n        d = []\n        m(b.arguments, function (b) {\n          U(b, a)\n          c = c && b.constant\n          b.constant || d.push.apply(d, b.toWatch)\n        })\n        b.constant = c\n        b.toWatch = b.filter && !a(b.callee.name).$stateful ? d : [b]\n        break\n      case s.AssignmentExpression:\n        U(b.left, a)\n        U(b.right, a)\n        b.constant = b.left.constant && b.right.constant\n        b.toWatch = [b]\n        break\n      case s.ArrayExpression:\n        c = !0\n        d = []\n        m(b.elements, function (b) {\n          U(b, a)\n          c = c && b.constant\n          b.constant || d.push.apply(d, b.toWatch)\n        })\n        b.constant = c\n        b.toWatch = d\n        break\n      case s.ObjectExpression:\n        c = !0\n        d = []\n        m(b.properties, function (b) {\n          U(b.value, a)\n          c = c && b.value.constant\n          b.value.constant || d.push.apply(d, b.value.toWatch)\n        })\n        b.constant = c\n        b.toWatch = d\n        break\n      case s.ThisExpression:\n        ;(b.constant = !1), (b.toWatch = [])\n    }\n  }\n  function od (b) {\n    if (1 == b.length) {\n      b = b[0].expression\n      var a = b.toWatch\n      return 1 !== a.length ? a : a[0] !== b ? a : w\n    }\n  }\n  function pd (b) {\n    return b.type === s.Identifier || b.type === s.MemberExpression\n  }\n  function qd (b) {\n    if (1 === b.body.length && pd(b.body[0].expression))\n      return {\n        type: s.AssignmentExpression,\n        left: b.body[0].expression,\n        right: { type: s.NGValueParameter },\n        operator: '='\n      }\n  }\n  function rd (b) {\n    return (\n      0 === b.body.length ||\n      (1 === b.body.length &&\n        (b.body[0].expression.type === s.Literal ||\n          b.body[0].expression.type === s.ArrayExpression ||\n          b.body[0].expression.type === s.ObjectExpression))\n    )\n  }\n  function sd (b, a) {\n    this.astBuilder = b\n    this.$filter = a\n  }\n  function td (b, a) {\n    this.astBuilder = b\n    this.$filter = a\n  }\n  function Fb (b) {\n    return 'constructor' == b\n  }\n  function dc (b) {\n    return x(b.valueOf) ? b.valueOf() : Yf.call(b)\n  }\n  function kf () {\n    var b = fa(),\n      a = fa()\n    this.$get = [\n      '$filter',\n      function (c) {\n        function d (a, b) {\n          return null == a || null == b\n            ? a === b\n            : 'object' === typeof a && ((a = dc(a)), 'object' === typeof a)\n            ? !1\n            : a === b || (a !== a && b !== b)\n        }\n        function e (a, b, c, e, f) {\n          var g = e.inputs,\n            h\n          if (1 === g.length) {\n            var k = d,\n              g = g[0]\n            return a.$watch(\n              function (a) {\n                var b = g(a)\n                d(b, k) || ((h = e(a, w, w, [b])), (k = b && dc(b)))\n                return h\n              },\n              b,\n              c,\n              f\n            )\n          }\n          for (var l = [], n = [], p = 0, m = g.length; p < m; p++) (l[p] = d), (n[p] = null)\n          return a.$watch(\n            function (a) {\n              for (var b = !1, c = 0, f = g.length; c < f; c++) {\n                var k = g[c](a)\n                if (b || (b = !d(k, l[c]))) (n[c] = k), (l[c] = k && dc(k))\n              }\n              b && (h = e(a, w, w, n))\n              return h\n            },\n            b,\n            c,\n            f\n          )\n        }\n        function f (a, b, c, d) {\n          var e, f\n          return (e = a.$watch(\n            function (a) {\n              return d(a)\n            },\n            function (a, c, d) {\n              f = a\n              x(b) && b.apply(this, arguments)\n              A(a) &&\n                d.$$postDigest(function () {\n                  A(f) && e()\n                })\n            },\n            c\n          ))\n        }\n        function h (a, b, c, d) {\n          function e (a) {\n            var b = !0\n            m(a, function (a) {\n              A(a) || (b = !1)\n            })\n            return b\n          }\n          var f, g\n          return (f = a.$watch(\n            function (a) {\n              return d(a)\n            },\n            function (a, c, d) {\n              g = a\n              x(b) && b.call(this, a, c, d)\n              e(a) &&\n                d.$$postDigest(function () {\n                  e(g) && f()\n                })\n            },\n            c\n          ))\n        }\n        function g (a, b, c, d) {\n          var e\n          return (e = a.$watch(\n            function (a) {\n              return d(a)\n            },\n            function (a, c, d) {\n              x(b) && b.apply(this, arguments)\n              e()\n            },\n            c\n          ))\n        }\n        function l (a, b) {\n          if (!b) return a\n          var c = a.$$watchDelegate,\n            c =\n              c !== h && c !== f\n                ? function (c, d, e, f) {\n                    e = a(c, d, e, f)\n                    return b(e, c, d)\n                  }\n                : function (c, d, e, f) {\n                    e = a(c, d, e, f)\n                    c = b(e, c, d)\n                    return A(e) ? c : e\n                  }\n          a.$$watchDelegate && a.$$watchDelegate !== e\n            ? (c.$$watchDelegate = a.$$watchDelegate)\n            : b.$stateful || ((c.$$watchDelegate = e), (c.inputs = a.inputs ? a.inputs : [a]))\n          return c\n        }\n        var k = Fa().noUnsafeEval,\n          n = { csp: k, expensiveChecks: !1 },\n          p = { csp: k, expensiveChecks: !0 }\n        return function (d, k, E) {\n          var m, u, q\n          switch (typeof d) {\n            case 'string':\n              q = d = d.trim()\n              var s = E ? a : b\n              m = s[q]\n              m ||\n                (':' === d.charAt(0) && ':' === d.charAt(1) && ((u = !0), (d = d.substring(2))),\n                (E = E ? p : n),\n                (m = new ec(E)),\n                (m = new fc(m, c, E).parse(d)),\n                m.constant\n                  ? (m.$$watchDelegate = g)\n                  : u\n                  ? (m.$$watchDelegate = m.literal ? h : f)\n                  : m.inputs && (m.$$watchDelegate = e),\n                (s[q] = m))\n              return l(m, k)\n            case 'function':\n              return l(d, k)\n            default:\n              return y\n          }\n        }\n      }\n    ]\n  }\n  function mf () {\n    this.$get = [\n      '$rootScope',\n      '$exceptionHandler',\n      function (b, a) {\n        return ud(function (a) {\n          b.$evalAsync(a)\n        }, a)\n      }\n    ]\n  }\n  function nf () {\n    this.$get = [\n      '$browser',\n      '$exceptionHandler',\n      function (b, a) {\n        return ud(function (a) {\n          b.defer(a)\n        }, a)\n      }\n    ]\n  }\n  function ud (b, a) {\n    function c (a, b, c) {\n      function d (b) {\n        return function (c) {\n          e || ((e = !0), b.call(a, c))\n        }\n      }\n      var e = !1\n      return [d(b), d(c)]\n    }\n    function d () {\n      this.$$state = { status: 0 }\n    }\n    function e (a, b) {\n      return function (c) {\n        b.call(a, c)\n      }\n    }\n    function f (c) {\n      !c.processScheduled &&\n        c.pending &&\n        ((c.processScheduled = !0),\n        b(function () {\n          var b, d, e\n          e = c.pending\n          c.processScheduled = !1\n          c.pending = w\n          for (var f = 0, g = e.length; f < g; ++f) {\n            d = e[f][0]\n            b = e[f][c.status]\n            try {\n              x(b) ? d.resolve(b(c.value)) : 1 === c.status ? d.resolve(c.value) : d.reject(c.value)\n            } catch (h) {\n              d.reject(h), a(h)\n            }\n          }\n        }))\n    }\n    function h () {\n      this.promise = new d()\n      this.resolve = e(this, this.resolve)\n      this.reject = e(this, this.reject)\n      this.notify = e(this, this.notify)\n    }\n    var g = I('$q', TypeError)\n    P(d.prototype, {\n      then: function (a, b, c) {\n        if (v(a) && v(b) && v(c)) return this\n        var d = new h()\n        this.$$state.pending = this.$$state.pending || []\n        this.$$state.pending.push([d, a, b, c])\n        0 < this.$$state.status && f(this.$$state)\n        return d.promise\n      },\n      catch: function (a) {\n        return this.then(null, a)\n      },\n      finally: function (a, b) {\n        return this.then(\n          function (b) {\n            return k(b, !0, a)\n          },\n          function (b) {\n            return k(b, !1, a)\n          },\n          b\n        )\n      }\n    })\n    P(h.prototype, {\n      resolve: function (a) {\n        this.promise.$$state.status || (a === this.promise ? this.$$reject(g('qcycle', a)) : this.$$resolve(a))\n      },\n      $$resolve: function (b) {\n        var d, e\n        e = c(this, this.$$resolve, this.$$reject)\n        try {\n          if (C(b) || x(b)) d = b && b.then\n          x(d)\n            ? ((this.promise.$$state.status = -1), d.call(b, e[0], e[1], this.notify))\n            : ((this.promise.$$state.value = b), (this.promise.$$state.status = 1), f(this.promise.$$state))\n        } catch (g) {\n          e[1](g), a(g)\n        }\n      },\n      reject: function (a) {\n        this.promise.$$state.status || this.$$reject(a)\n      },\n      $$reject: function (a) {\n        this.promise.$$state.value = a\n        this.promise.$$state.status = 2\n        f(this.promise.$$state)\n      },\n      notify: function (c) {\n        var d = this.promise.$$state.pending\n        0 >= this.promise.$$state.status &&\n          d &&\n          d.length &&\n          b(function () {\n            for (var b, e, f = 0, g = d.length; f < g; f++) {\n              e = d[f][0]\n              b = d[f][3]\n              try {\n                e.notify(x(b) ? b(c) : c)\n              } catch (h) {\n                a(h)\n              }\n            }\n          })\n      }\n    })\n    var l = function (a, b) {\n        var c = new h()\n        b ? c.resolve(a) : c.reject(a)\n        return c.promise\n      },\n      k = function (a, b, c) {\n        var d = null\n        try {\n          x(c) && (d = c())\n        } catch (e) {\n          return l(e, !1)\n        }\n        return d && x(d.then)\n          ? d.then(\n              function () {\n                return l(a, b)\n              },\n              function (a) {\n                return l(a, !1)\n              }\n            )\n          : l(a, b)\n      },\n      n = function (a, b, c, d) {\n        var e = new h()\n        e.resolve(a)\n        return e.promise.then(b, c, d)\n      },\n      p = function t (a) {\n        if (!x(a)) throw g('norslvr', a)\n        if (!(this instanceof t)) return new t(a)\n        var b = new h()\n        a(\n          function (a) {\n            b.resolve(a)\n          },\n          function (a) {\n            b.reject(a)\n          }\n        )\n        return b.promise\n      }\n    p.defer = function () {\n      return new h()\n    }\n    p.reject = function (a) {\n      var b = new h()\n      b.reject(a)\n      return b.promise\n    }\n    p.when = n\n    p.resolve = n\n    p.all = function (a) {\n      var b = new h(),\n        c = 0,\n        d = J(a) ? [] : {}\n      m(a, function (a, e) {\n        c++\n        n(a).then(\n          function (a) {\n            d.hasOwnProperty(e) || ((d[e] = a), --c || b.resolve(d))\n          },\n          function (a) {\n            d.hasOwnProperty(e) || b.reject(a)\n          }\n        )\n      })\n      0 === c && b.resolve(d)\n      return b.promise\n    }\n    return p\n  }\n  function wf () {\n    this.$get = [\n      '$window',\n      '$timeout',\n      function (b, a) {\n        var c = b.requestAnimationFrame || b.webkitRequestAnimationFrame,\n          d = b.cancelAnimationFrame || b.webkitCancelAnimationFrame || b.webkitCancelRequestAnimationFrame,\n          e = !!c,\n          f = e\n            ? function (a) {\n                var b = c(a)\n                return function () {\n                  d(b)\n                }\n              }\n            : function (b) {\n                var c = a(b, 16.66, !1)\n                return function () {\n                  a.cancel(c)\n                }\n              }\n        f.supported = e\n        return f\n      }\n    ]\n  }\n  function lf () {\n    function b (a) {\n      function b () {\n        this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null\n        this.$$listeners = {}\n        this.$$listenerCount = {}\n        this.$$watchersCount = 0\n        this.$id = ++nb\n        this.$$ChildScope = null\n      }\n      b.prototype = a\n      return b\n    }\n    var a = 10,\n      c = I('$rootScope'),\n      d = null,\n      e = null\n    this.digestTtl = function (b) {\n      arguments.length && (a = b)\n      return a\n    }\n    this.$get = [\n      '$injector',\n      '$exceptionHandler',\n      '$parse',\n      '$browser',\n      function (f, h, g, l) {\n        function k (a) {\n          a.currentScope.$$destroyed = !0\n        }\n        function n () {\n          this.$id = ++nb\n          this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null\n          this.$root = this\n          this.$$destroyed = !1\n          this.$$listeners = {}\n          this.$$listenerCount = {}\n          this.$$watchersCount = 0\n          this.$$isolateBindings = null\n        }\n        function p (a) {\n          if (q.$$phase) throw c('inprog', q.$$phase)\n          q.$$phase = a\n        }\n        function r (a, b) {\n          do a.$$watchersCount += b\n          while ((a = a.$parent))\n        }\n        function t (a, b, c) {\n          do (a.$$listenerCount[c] -= b), 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]\n          while ((a = a.$parent))\n        }\n        function E () {}\n        function s () {\n          for (; w.length; )\n            try {\n              w.shift()()\n            } catch (a) {\n              h(a)\n            }\n          e = null\n        }\n        function u () {\n          null === e &&\n            (e = l.defer(function () {\n              q.$apply(s)\n            }))\n        }\n        n.prototype = {\n          constructor: n,\n          $new: function (a, c) {\n            var d\n            c = c || this\n            a\n              ? ((d = new n()), (d.$root = this.$root))\n              : (this.$$ChildScope || (this.$$ChildScope = b(this)), (d = new this.$$ChildScope()))\n            d.$parent = c\n            d.$$prevSibling = c.$$childTail\n            c.$$childHead\n              ? ((c.$$childTail.$$nextSibling = d), (c.$$childTail = d))\n              : (c.$$childHead = c.$$childTail = d)\n            ;(a || c != this) && d.$on('$destroy', k)\n            return d\n          },\n          $watch: function (a, b, c, e) {\n            var f = g(a)\n            if (f.$$watchDelegate) return f.$$watchDelegate(this, b, c, f, a)\n            var h = this,\n              k = h.$$watchers,\n              l = { fn: b, last: E, get: f, exp: e || a, eq: !!c }\n            d = null\n            x(b) || (l.fn = y)\n            k || (k = h.$$watchers = [])\n            k.unshift(l)\n            r(this, 1)\n            return function () {\n              0 <= cb(k, l) && r(h, -1)\n              d = null\n            }\n          },\n          $watchGroup: function (a, b) {\n            function c () {\n              h = !1\n              k ? ((k = !1), b(e, e, g)) : b(e, d, g)\n            }\n            var d = Array(a.length),\n              e = Array(a.length),\n              f = [],\n              g = this,\n              h = !1,\n              k = !0\n            if (!a.length) {\n              var l = !0\n              g.$evalAsync(function () {\n                l && b(e, e, g)\n              })\n              return function () {\n                l = !1\n              }\n            }\n            if (1 === a.length)\n              return this.$watch(a[0], function (a, c, f) {\n                e[0] = a\n                d[0] = c\n                b(e, a === c ? e : d, f)\n              })\n            m(a, function (a, b) {\n              var k = g.$watch(a, function (a, f) {\n                e[b] = a\n                d[b] = f\n                h || ((h = !0), g.$evalAsync(c))\n              })\n              f.push(k)\n            })\n            return function () {\n              for (; f.length; ) f.shift()()\n            }\n          },\n          $watchCollection: function (a, b) {\n            function c (a) {\n              e = a\n              var b, d, g, h\n              if (!v(e)) {\n                if (C(e))\n                  if (Da(e))\n                    for (\n                      f !== p && ((f = p), (t = f.length = 0), l++),\n                        a = e.length,\n                        t !== a && (l++, (f.length = t = a)),\n                        b = 0;\n                      b < a;\n                      b++\n                    )\n                      (h = f[b]), (g = e[b]), (d = h !== h && g !== g), d || h === g || (l++, (f[b] = g))\n                  else {\n                    f !== r && ((f = r = {}), (t = 0), l++)\n                    a = 0\n                    for (b in e)\n                      ta.call(e, b) &&\n                        (a++,\n                        (g = e[b]),\n                        (h = f[b]),\n                        b in f ? ((d = h !== h && g !== g), d || h === g || (l++, (f[b] = g))) : (t++, (f[b] = g), l++))\n                    if (t > a) for (b in (l++, f)) ta.call(e, b) || (t--, delete f[b])\n                  }\n                else f !== e && ((f = e), l++)\n                return l\n              }\n            }\n            c.$stateful = !0\n            var d = this,\n              e,\n              f,\n              h,\n              k = 1 < b.length,\n              l = 0,\n              n = g(a, c),\n              p = [],\n              r = {},\n              q = !0,\n              t = 0\n            return this.$watch(n, function () {\n              q ? ((q = !1), b(e, e, d)) : b(e, h, d)\n              if (k)\n                if (C(e))\n                  if (Da(e)) {\n                    h = Array(e.length)\n                    for (var a = 0; a < e.length; a++) h[a] = e[a]\n                  } else for (a in ((h = {}), e)) ta.call(e, a) && (h[a] = e[a])\n                else h = e\n            })\n          },\n          $digest: function () {\n            var b,\n              f,\n              g,\n              k,\n              n,\n              r,\n              t = a,\n              m,\n              u = [],\n              D,\n              v\n            p('$digest')\n            l.$$checkUrlChange()\n            this === q && null !== e && (l.defer.cancel(e), s())\n            d = null\n            do {\n              r = !1\n              for (m = this; z.length; ) {\n                try {\n                  ;(v = z.shift()), v.scope.$eval(v.expression, v.locals)\n                } catch (w) {\n                  h(w)\n                }\n                d = null\n              }\n              a: do {\n                if ((k = m.$$watchers))\n                  for (n = k.length; n--; )\n                    try {\n                      if ((b = k[n]))\n                        if (\n                          (f = b.get(m)) !== (g = b.last) &&\n                          !(b.eq ? ka(f, g) : 'number' === typeof f && 'number' === typeof g && isNaN(f) && isNaN(g))\n                        )\n                          (r = !0),\n                            (d = b),\n                            (b.last = b.eq ? ha(f, null) : f),\n                            b.fn(f, g === E ? f : g, m),\n                            5 > t &&\n                              ((D = 4 - t),\n                              u[D] || (u[D] = []),\n                              u[D].push({\n                                msg: x(b.exp) ? 'fn: ' + (b.exp.name || b.exp.toString()) : b.exp,\n                                newVal: f,\n                                oldVal: g\n                              }))\n                        else if (b === d) {\n                          r = !1\n                          break a\n                        }\n                    } catch (y) {\n                      h(y)\n                    }\n                if (!(k = (m.$$watchersCount && m.$$childHead) || (m !== this && m.$$nextSibling)))\n                  for (; m !== this && !(k = m.$$nextSibling); ) m = m.$parent\n              } while ((m = k))\n              if ((r || z.length) && !t--) throw ((q.$$phase = null), c('infdig', a, u))\n            } while (r || z.length)\n            for (q.$$phase = null; N.length; )\n              try {\n                N.shift()()\n              } catch (A) {\n                h(A)\n              }\n          },\n          $destroy: function () {\n            if (!this.$$destroyed) {\n              var a = this.$parent\n              this.$broadcast('$destroy')\n              this.$$destroyed = !0\n              this === q && l.$$applicationDestroyed()\n              r(this, -this.$$watchersCount)\n              for (var b in this.$$listenerCount) t(this, this.$$listenerCount[b], b)\n              a && a.$$childHead == this && (a.$$childHead = this.$$nextSibling)\n              a && a.$$childTail == this && (a.$$childTail = this.$$prevSibling)\n              this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling)\n              this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling)\n              this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = y\n              this.$on = this.$watch = this.$watchGroup = function () {\n                return y\n              }\n              this.$$listeners = {}\n              this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null\n            }\n          },\n          $eval: function (a, b) {\n            return g(a)(this, b)\n          },\n          $evalAsync: function (a, b) {\n            q.$$phase ||\n              z.length ||\n              l.defer(function () {\n                z.length && q.$digest()\n              })\n            z.push({ scope: this, expression: a, locals: b })\n          },\n          $$postDigest: function (a) {\n            N.push(a)\n          },\n          $apply: function (a) {\n            try {\n              p('$apply')\n              try {\n                return this.$eval(a)\n              } finally {\n                q.$$phase = null\n              }\n            } catch (b) {\n              h(b)\n            } finally {\n              try {\n                q.$digest()\n              } catch (c) {\n                throw (h(c), c)\n              }\n            }\n          },\n          $applyAsync: function (a) {\n            function b () {\n              c.$eval(a)\n            }\n            var c = this\n            a && w.push(b)\n            u()\n          },\n          $on: function (a, b) {\n            var c = this.$$listeners[a]\n            c || (this.$$listeners[a] = c = [])\n            c.push(b)\n            var d = this\n            do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++\n            while ((d = d.$parent))\n            var e = this\n            return function () {\n              var d = c.indexOf(b)\n              ;-1 !== d && ((c[d] = null), t(e, 1, a))\n            }\n          },\n          $emit: function (a, b) {\n            var c = [],\n              d,\n              e = this,\n              f = !1,\n              g = {\n                name: a,\n                targetScope: e,\n                stopPropagation: function () {\n                  f = !0\n                },\n                preventDefault: function () {\n                  g.defaultPrevented = !0\n                },\n                defaultPrevented: !1\n              },\n              k = db([g], arguments, 1),\n              l,\n              n\n            do {\n              d = e.$$listeners[a] || c\n              g.currentScope = e\n              l = 0\n              for (n = d.length; l < n; l++)\n                if (d[l])\n                  try {\n                    d[l].apply(null, k)\n                  } catch (p) {\n                    h(p)\n                  }\n                else d.splice(l, 1), l--, n--\n              if (f) return (g.currentScope = null), g\n              e = e.$parent\n            } while (e)\n            g.currentScope = null\n            return g\n          },\n          $broadcast: function (a, b) {\n            var c = this,\n              d = this,\n              e = {\n                name: a,\n                targetScope: this,\n                preventDefault: function () {\n                  e.defaultPrevented = !0\n                },\n                defaultPrevented: !1\n              }\n            if (!this.$$listenerCount[a]) return e\n            for (var f = db([e], arguments, 1), g, k; (c = d); ) {\n              e.currentScope = c\n              d = c.$$listeners[a] || []\n              g = 0\n              for (k = d.length; g < k; g++)\n                if (d[g])\n                  try {\n                    d[g].apply(null, f)\n                  } catch (l) {\n                    h(l)\n                  }\n                else d.splice(g, 1), g--, k--\n              if (!(d = (c.$$listenerCount[a] && c.$$childHead) || (c !== this && c.$$nextSibling)))\n                for (; c !== this && !(d = c.$$nextSibling); ) c = c.$parent\n            }\n            e.currentScope = null\n            return e\n          }\n        }\n        var q = new n(),\n          z = (q.$$asyncQueue = []),\n          N = (q.$$postDigestQueue = []),\n          w = (q.$$applyAsyncQueue = [])\n        return q\n      }\n    ]\n  }\n  function ge () {\n    var b = /^\\s*(https?|ftp|mailto|tel|file):/,\n      a = /^\\s*((https?|ftp|file|blob):|data:image\\/)/\n    this.aHrefSanitizationWhitelist = function (a) {\n      return A(a) ? ((b = a), this) : b\n    }\n    this.imgSrcSanitizationWhitelist = function (b) {\n      return A(b) ? ((a = b), this) : a\n    }\n    this.$get = function () {\n      return function (c, d) {\n        var e = d ? a : b,\n          f\n        f = Aa(c).href\n        return '' === f || f.match(e) ? c : 'unsafe:' + f\n      }\n    }\n  }\n  function Zf (b) {\n    if ('self' === b) return b\n    if (G(b)) {\n      if (-1 < b.indexOf('***')) throw Ca('iwcard', b)\n      b = vd(b)\n        .replace('\\\\*\\\\*', '.*')\n        .replace('\\\\*', '[^:/.?&;]*')\n      return new RegExp('^' + b + '$')\n    }\n    if (Oa(b)) return new RegExp('^' + b.source + '$')\n    throw Ca('imatcher')\n  }\n  function wd (b) {\n    var a = []\n    A(b) &&\n      m(b, function (b) {\n        a.push(Zf(b))\n      })\n    return a\n  }\n  function pf () {\n    this.SCE_CONTEXTS = oa\n    var b = ['self'],\n      a = []\n    this.resourceUrlWhitelist = function (a) {\n      arguments.length && (b = wd(a))\n      return b\n    }\n    this.resourceUrlBlacklist = function (b) {\n      arguments.length && (a = wd(b))\n      return a\n    }\n    this.$get = [\n      '$injector',\n      function (c) {\n        function d (a, b) {\n          return 'self' === a ? fd(b) : !!a.exec(b.href)\n        }\n        function e (a) {\n          var b = function (a) {\n            this.$$unwrapTrustedValue = function () {\n              return a\n            }\n          }\n          a && (b.prototype = new a())\n          b.prototype.valueOf = function () {\n            return this.$$unwrapTrustedValue()\n          }\n          b.prototype.toString = function () {\n            return this.$$unwrapTrustedValue().toString()\n          }\n          return b\n        }\n        var f = function (a) {\n          throw Ca('unsafe')\n        }\n        c.has('$sanitize') && (f = c.get('$sanitize'))\n        var h = e(),\n          g = {}\n        g[oa.HTML] = e(h)\n        g[oa.CSS] = e(h)\n        g[oa.URL] = e(h)\n        g[oa.JS] = e(h)\n        g[oa.RESOURCE_URL] = e(g[oa.URL])\n        return {\n          trustAs: function (a, b) {\n            var c = g.hasOwnProperty(a) ? g[a] : null\n            if (!c) throw Ca('icontext', a, b)\n            if (null === b || v(b) || '' === b) return b\n            if ('string' !== typeof b) throw Ca('itype', a)\n            return new c(b)\n          },\n          getTrusted: function (c, e) {\n            if (null === e || v(e) || '' === e) return e\n            var h = g.hasOwnProperty(c) ? g[c] : null\n            if (h && e instanceof h) return e.$$unwrapTrustedValue()\n            if (c === oa.RESOURCE_URL) {\n              var h = Aa(e.toString()),\n                p,\n                r,\n                t = !1\n              p = 0\n              for (r = b.length; p < r; p++)\n                if (d(b[p], h)) {\n                  t = !0\n                  break\n                }\n              if (t)\n                for (p = 0, r = a.length; p < r; p++)\n                  if (d(a[p], h)) {\n                    t = !1\n                    break\n                  }\n              if (t) return e\n              throw Ca('insecurl', e.toString())\n            }\n            if (c === oa.HTML) return f(e)\n            throw Ca('unsafe')\n          },\n          valueOf: function (a) {\n            return a instanceof h ? a.$$unwrapTrustedValue() : a\n          }\n        }\n      }\n    ]\n  }\n  function of () {\n    var b = !0\n    this.enabled = function (a) {\n      arguments.length && (b = !!a)\n      return b\n    }\n    this.$get = [\n      '$parse',\n      '$sceDelegate',\n      function (a, c) {\n        if (b && 8 > Wa) throw Ca('iequirks')\n        var d = ja(oa)\n        d.isEnabled = function () {\n          return b\n        }\n        d.trustAs = c.trustAs\n        d.getTrusted = c.getTrusted\n        d.valueOf = c.valueOf\n        b ||\n          ((d.trustAs = d.getTrusted = function (a, b) {\n            return b\n          }),\n          (d.valueOf = $a))\n        d.parseAs = function (b, c) {\n          var e = a(c)\n          return e.literal && e.constant\n            ? e\n            : a(c, function (a) {\n                return d.getTrusted(b, a)\n              })\n        }\n        var e = d.parseAs,\n          f = d.getTrusted,\n          h = d.trustAs\n        m(oa, function (a, b) {\n          var c = F(b)\n          d[gb('parse_as_' + c)] = function (b) {\n            return e(a, b)\n          }\n          d[gb('get_trusted_' + c)] = function (b) {\n            return f(a, b)\n          }\n          d[gb('trust_as_' + c)] = function (b) {\n            return h(a, b)\n          }\n        })\n        return d\n      }\n    ]\n  }\n  function qf () {\n    this.$get = [\n      '$window',\n      '$document',\n      function (b, a) {\n        var c = {},\n          d = Y((/android (\\d+)/.exec(F((b.navigator || {}).userAgent)) || [])[1]),\n          e = /Boxee/i.test((b.navigator || {}).userAgent),\n          f = a[0] || {},\n          h,\n          g = /^(Moz|webkit|ms)(?=[A-Z])/,\n          l = f.body && f.body.style,\n          k = !1,\n          n = !1\n        if (l) {\n          for (var p in l)\n            if ((k = g.exec(p))) {\n              h = k[0]\n              h = h.substr(0, 1).toUpperCase() + h.substr(1)\n              break\n            }\n          h || (h = 'WebkitOpacity' in l && 'webkit')\n          k = !!('transition' in l || h + 'Transition' in l)\n          n = !!('animation' in l || h + 'Animation' in l)\n          !d || (k && n) || ((k = G(l.webkitTransition)), (n = G(l.webkitAnimation)))\n        }\n        return {\n          history: !(!b.history || !b.history.pushState || 4 > d || e),\n          hasEvent: function (a) {\n            if ('input' === a && 11 >= Wa) return !1\n            if (v(c[a])) {\n              var b = f.createElement('div')\n              c[a] = 'on' + a in b\n            }\n            return c[a]\n          },\n          csp: Fa(),\n          vendorPrefix: h,\n          transitions: k,\n          animations: n,\n          android: d\n        }\n      }\n    ]\n  }\n  function sf () {\n    this.$get = [\n      '$templateCache',\n      '$http',\n      '$q',\n      '$sce',\n      function (b, a, c, d) {\n        function e (f, h) {\n          e.totalPendingRequests++\n          ;(G(f) && b.get(f)) || (f = d.getTrustedResourceUrl(f))\n          var g = a.defaults && a.defaults.transformResponse\n          J(g)\n            ? (g = g.filter(function (a) {\n                return a !== Zb\n              }))\n            : g === Zb && (g = null)\n          return a\n            .get(f, { cache: b, transformResponse: g })\n            ['finally'](function () {\n              e.totalPendingRequests--\n            })\n            .then(\n              function (a) {\n                b.put(f, a.data)\n                return a.data\n              },\n              function (a) {\n                if (!h) throw ga('tpload', f, a.status, a.statusText)\n                return c.reject(a)\n              }\n            )\n        }\n        e.totalPendingRequests = 0\n        return e\n      }\n    ]\n  }\n  function tf () {\n    this.$get = [\n      '$rootScope',\n      '$browser',\n      '$location',\n      function (b, a, c) {\n        return {\n          findBindings: function (a, b, c) {\n            a = a.getElementsByClassName('ng-binding')\n            var h = []\n            m(a, function (a) {\n              var d = da.element(a).data('$binding')\n              d &&\n                m(d, function (d) {\n                  c\n                    ? new RegExp('(^|\\\\s)' + vd(b) + '(\\\\s|\\\\||$)').test(d) && h.push(a)\n                    : -1 != d.indexOf(b) && h.push(a)\n                })\n            })\n            return h\n          },\n          findModels: function (a, b, c) {\n            for (var h = ['ng-', 'data-ng-', 'ng\\\\:'], g = 0; g < h.length; ++g) {\n              var l = a.querySelectorAll('[' + h[g] + 'model' + (c ? '=' : '*=') + '\"' + b + '\"]')\n              if (l.length) return l\n            }\n          },\n          getLocation: function () {\n            return c.url()\n          },\n          setLocation: function (a) {\n            a !== c.url() && (c.url(a), b.$digest())\n          },\n          whenStable: function (b) {\n            a.notifyWhenNoOutstandingRequests(b)\n          }\n        }\n      }\n    ]\n  }\n  function uf () {\n    this.$get = [\n      '$rootScope',\n      '$browser',\n      '$q',\n      '$$q',\n      '$exceptionHandler',\n      function (b, a, c, d, e) {\n        function f (f, l, k) {\n          x(f) || ((k = l), (l = f), (f = y))\n          var n = ua.call(arguments, 3),\n            p = A(k) && !k,\n            r = (p ? d : c).defer(),\n            t = r.promise,\n            m\n          m = a.defer(function () {\n            try {\n              r.resolve(f.apply(null, n))\n            } catch (a) {\n              r.reject(a), e(a)\n            } finally {\n              delete h[t.$$timeoutId]\n            }\n            p || b.$apply()\n          }, l)\n          t.$$timeoutId = m\n          h[m] = r\n          return t\n        }\n        var h = {}\n        f.cancel = function (b) {\n          return b && b.$$timeoutId in h\n            ? (h[b.$$timeoutId].reject('canceled'), delete h[b.$$timeoutId], a.defer.cancel(b.$$timeoutId))\n            : !1\n        }\n        return f\n      }\n    ]\n  }\n  function Aa (b) {\n    Wa && ($.setAttribute('href', b), (b = $.href))\n    $.setAttribute('href', b)\n    return {\n      href: $.href,\n      protocol: $.protocol ? $.protocol.replace(/:$/, '') : '',\n      host: $.host,\n      search: $.search ? $.search.replace(/^\\?/, '') : '',\n      hash: $.hash ? $.hash.replace(/^#/, '') : '',\n      hostname: $.hostname,\n      port: $.port,\n      pathname: '/' === $.pathname.charAt(0) ? $.pathname : '/' + $.pathname\n    }\n  }\n  function fd (b) {\n    b = G(b) ? Aa(b) : b\n    return b.protocol === xd.protocol && b.host === xd.host\n  }\n  function vf () {\n    this.$get = qa(Q)\n  }\n  function yd (b) {\n    function a (a) {\n      try {\n        return decodeURIComponent(a)\n      } catch (b) {\n        return a\n      }\n    }\n    var c = b[0] || {},\n      d = {},\n      e = ''\n    return function () {\n      var b, h, g, l, k\n      b = c.cookie || ''\n      if (b !== e)\n        for (e = b, b = e.split('; '), d = {}, g = 0; g < b.length; g++)\n          (h = b[g]),\n            (l = h.indexOf('=')),\n            0 < l && ((k = a(h.substring(0, l))), v(d[k]) && (d[k] = a(h.substring(l + 1))))\n      return d\n    }\n  }\n  function zf () {\n    this.$get = yd\n  }\n  function Kc (b) {\n    function a (c, d) {\n      if (C(c)) {\n        var e = {}\n        m(c, function (b, c) {\n          e[c] = a(c, b)\n        })\n        return e\n      }\n      return b.factory(c + 'Filter', d)\n    }\n    this.register = a\n    this.$get = [\n      '$injector',\n      function (a) {\n        return function (b) {\n          return a.get(b + 'Filter')\n        }\n      }\n    ]\n    a('currency', zd)\n    a('date', Ad)\n    a('filter', $f)\n    a('json', ag)\n    a('limitTo', bg)\n    a('lowercase', cg)\n    a('number', Bd)\n    a('orderBy', Cd)\n    a('uppercase', dg)\n  }\n  function $f () {\n    return function (b, a, c) {\n      if (!Da(b)) {\n        if (null == b) return b\n        throw I('filter')('notarray', b)\n      }\n      var d\n      switch (gc(a)) {\n        case 'function':\n          break\n        case 'boolean':\n        case 'null':\n        case 'number':\n        case 'string':\n          d = !0\n        case 'object':\n          a = eg(a, c, d)\n          break\n        default:\n          return b\n      }\n      return Array.prototype.filter.call(b, a)\n    }\n  }\n  function eg (b, a, c) {\n    var d = C(b) && '$' in b\n    !0 === a\n      ? (a = ka)\n      : x(a) ||\n        (a = function (a, b) {\n          if (v(a)) return !1\n          if (null === a || null === b) return a === b\n          if (C(b) || (C(a) && !qc(a))) return !1\n          a = F('' + a)\n          b = F('' + b)\n          return -1 !== a.indexOf(b)\n        })\n    return function (e) {\n      return d && !C(e) ? Ma(e, b.$, a, !1) : Ma(e, b, a, c)\n    }\n  }\n  function Ma (b, a, c, d, e) {\n    var f = gc(b),\n      h = gc(a)\n    if ('string' === h && '!' === a.charAt(0)) return !Ma(b, a.substring(1), c, d)\n    if (J(b))\n      return b.some(function (b) {\n        return Ma(b, a, c, d)\n      })\n    switch (f) {\n      case 'object':\n        var g\n        if (d) {\n          for (g in b) if ('$' !== g.charAt(0) && Ma(b[g], a, c, !0)) return !0\n          return e ? !1 : Ma(b, a, c, !1)\n        }\n        if ('object' === h) {\n          for (g in a) if (((e = a[g]), !x(e) && !v(e) && ((f = '$' === g), !Ma(f ? b : b[g], e, c, f, f)))) return !1\n          return !0\n        }\n        return c(b, a)\n      case 'function':\n        return !1\n      default:\n        return c(b, a)\n    }\n  }\n  function gc (b) {\n    return null === b ? 'null' : typeof b\n  }\n  function zd (b) {\n    var a = b.NUMBER_FORMATS\n    return function (b, d, e) {\n      v(d) && (d = a.CURRENCY_SYM)\n      v(e) && (e = a.PATTERNS[1].maxFrac)\n      return null == b ? b : Dd(b, a.PATTERNS[1], a.GROUP_SEP, a.DECIMAL_SEP, e).replace(/\\u00A4/g, d)\n    }\n  }\n  function Bd (b) {\n    var a = b.NUMBER_FORMATS\n    return function (b, d) {\n      return null == b ? b : Dd(b, a.PATTERNS[0], a.GROUP_SEP, a.DECIMAL_SEP, d)\n    }\n  }\n  function Dd (b, a, c, d, e) {\n    if (C(b)) return ''\n    var f = 0 > b\n    b = Math.abs(b)\n    var h = Infinity === b\n    if (!h && !isFinite(b)) return ''\n    var g = b + '',\n      l = '',\n      k = !1,\n      n = []\n    h && (l = '\\u221e')\n    if (!h && -1 !== g.indexOf('e')) {\n      var p = g.match(/([\\d\\.]+)e(-?)(\\d+)/)\n      p && '-' == p[2] && p[3] > e + 1 ? (b = 0) : ((l = g), (k = !0))\n    }\n    if (h || k) 0 < e && 1 > b && ((l = b.toFixed(e)), (b = parseFloat(l)), (l = l.replace(hc, d)))\n    else {\n      h = (g.split(hc)[1] || '').length\n      v(e) && (e = Math.min(Math.max(a.minFrac, h), a.maxFrac))\n      b = +(Math.round(+(b.toString() + 'e' + e)).toString() + 'e' + -e)\n      var h = ('' + b).split(hc),\n        g = h[0],\n        h = h[1] || '',\n        p = 0,\n        r = a.lgSize,\n        t = a.gSize\n      if (g.length >= r + t)\n        for (p = g.length - r, k = 0; k < p; k++) 0 === (p - k) % t && 0 !== k && (l += c), (l += g.charAt(k))\n      for (k = p; k < g.length; k++) 0 === (g.length - k) % r && 0 !== k && (l += c), (l += g.charAt(k))\n      for (; h.length < e; ) h += '0'\n      e && '0' !== e && (l += d + h.substr(0, e))\n    }\n    0 === b && (f = !1)\n    n.push(f ? a.negPre : a.posPre, l, f ? a.negSuf : a.posSuf)\n    return n.join('')\n  }\n  function Gb (b, a, c) {\n    var d = ''\n    0 > b && ((d = '-'), (b = -b))\n    for (b = '' + b; b.length < a; ) b = '0' + b\n    c && (b = b.substr(b.length - a))\n    return d + b\n  }\n  function aa (b, a, c, d) {\n    c = c || 0\n    return function (e) {\n      e = e['get' + b]()\n      if (0 < c || e > -c) e += c\n      0 === e && -12 == c && (e = 12)\n      return Gb(e, a, d)\n    }\n  }\n  function Hb (b, a) {\n    return function (c, d) {\n      var e = c['get' + b](),\n        f = sb(a ? 'SHORT' + b : b)\n      return d[f][e]\n    }\n  }\n  function Ed (b) {\n    var a = new Date(b, 0, 1).getDay()\n    return new Date(b, 0, (4 >= a ? 5 : 12) - a)\n  }\n  function Fd (b) {\n    return function (a) {\n      var c = Ed(a.getFullYear())\n      a = +new Date(a.getFullYear(), a.getMonth(), a.getDate() + (4 - a.getDay())) - +c\n      a = 1 + Math.round(a / 6048e5)\n      return Gb(a, b)\n    }\n  }\n  function ic (b, a) {\n    return 0 >= b.getFullYear() ? a.ERAS[0] : a.ERAS[1]\n  }\n  function Ad (b) {\n    function a (a) {\n      var b\n      if ((b = a.match(c))) {\n        a = new Date(0)\n        var f = 0,\n          h = 0,\n          g = b[8] ? a.setUTCFullYear : a.setFullYear,\n          l = b[8] ? a.setUTCHours : a.setHours\n        b[9] && ((f = Y(b[9] + b[10])), (h = Y(b[9] + b[11])))\n        g.call(a, Y(b[1]), Y(b[2]) - 1, Y(b[3]))\n        f = Y(b[4] || 0) - f\n        h = Y(b[5] || 0) - h\n        g = Y(b[6] || 0)\n        b = Math.round(1e3 * parseFloat('0.' + (b[7] || 0)))\n        l.call(a, f, h, g, b)\n      }\n      return a\n    }\n    var c = /^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/\n    return function (c, e, f) {\n      var h = '',\n        g = [],\n        l,\n        k\n      e = e || 'mediumDate'\n      e = b.DATETIME_FORMATS[e] || e\n      G(c) && (c = fg.test(c) ? Y(c) : a(c))\n      V(c) && (c = new Date(c))\n      if (!ea(c) || !isFinite(c.getTime())) return c\n      for (; e; ) (k = gg.exec(e)) ? ((g = db(g, k, 1)), (e = g.pop())) : (g.push(e), (e = null))\n      var n = c.getTimezoneOffset()\n      f && ((n = wc(f, c.getTimezoneOffset())), (c = Ob(c, f, !0)))\n      m(g, function (a) {\n        l = hg[a]\n        h += l ? l(c, b.DATETIME_FORMATS, n) : a.replace(/(^'|'$)/g, '').replace(/''/g, \"'\")\n      })\n      return h\n    }\n  }\n  function ag () {\n    return function (b, a) {\n      v(a) && (a = 2)\n      return eb(b, a)\n    }\n  }\n  function bg () {\n    return function (b, a, c) {\n      a = Infinity === Math.abs(Number(a)) ? Number(a) : Y(a)\n      if (isNaN(a)) return b\n      V(b) && (b = b.toString())\n      if (!J(b) && !G(b)) return b\n      c = !c || isNaN(c) ? 0 : Y(c)\n      c = 0 > c && c >= -b.length ? b.length + c : c\n      return 0 <= a ? b.slice(c, c + a) : 0 === c ? b.slice(a, b.length) : b.slice(Math.max(0, c + a), c)\n    }\n  }\n  function Cd (b) {\n    function a (a, c) {\n      c = c ? -1 : 1\n      return a.map(function (a) {\n        var d = 1,\n          g = $a\n        if (x(a)) g = a\n        else if (G(a)) {\n          if ('+' == a.charAt(0) || '-' == a.charAt(0)) (d = '-' == a.charAt(0) ? -1 : 1), (a = a.substring(1))\n          if ('' !== a && ((g = b(a)), g.constant))\n            var l = g(),\n              g = function (a) {\n                return a[l]\n              }\n        }\n        return { get: g, descending: d * c }\n      })\n    }\n    function c (a) {\n      switch (typeof a) {\n        case 'number':\n        case 'boolean':\n        case 'string':\n          return !0\n        default:\n          return !1\n      }\n    }\n    return function (b, e, f) {\n      if (!Da(b)) return b\n      J(e) || (e = [e])\n      0 === e.length && (e = ['+'])\n      var h = a(e, f)\n      h.push({\n        get: function () {\n          return {}\n        },\n        descending: f ? -1 : 1\n      })\n      b = Array.prototype.map.call(b, function (a, b) {\n        return {\n          value: a,\n          predicateValues: h.map(function (d) {\n            var e = d.get(a)\n            d = typeof e\n            if (null === e) (d = 'string'), (e = 'null')\n            else if ('string' === d) e = e.toLowerCase()\n            else if ('object' === d)\n              a: {\n                if ('function' === typeof e.valueOf && ((e = e.valueOf()), c(e))) break a\n                if (qc(e) && ((e = e.toString()), c(e))) break a\n                e = b\n              }\n            return { value: e, type: d }\n          })\n        }\n      })\n      b.sort(function (a, b) {\n        for (var c = 0, d = 0, e = h.length; d < e; ++d) {\n          var c = a.predicateValues[d],\n            f = b.predicateValues[d],\n            t = 0\n          c.type === f.type ? c.value !== f.value && (t = c.value < f.value ? -1 : 1) : (t = c.type < f.type ? -1 : 1)\n          if ((c = t * h[d].descending)) break\n        }\n        return c\n      })\n      return (b = b.map(function (a) {\n        return a.value\n      }))\n    }\n  }\n  function Na (b) {\n    x(b) && (b = { link: b })\n    b.restrict = b.restrict || 'AC'\n    return qa(b)\n  }\n  function Gd (b, a, c, d, e) {\n    var f = this,\n      h = []\n    f.$error = {}\n    f.$$success = {}\n    f.$pending = w\n    f.$name = e(a.name || a.ngForm || '')(c)\n    f.$dirty = !1\n    f.$pristine = !0\n    f.$valid = !0\n    f.$invalid = !1\n    f.$submitted = !1\n    f.$$parentForm = Ib\n    f.$rollbackViewValue = function () {\n      m(h, function (a) {\n        a.$rollbackViewValue()\n      })\n    }\n    f.$commitViewValue = function () {\n      m(h, function (a) {\n        a.$commitViewValue()\n      })\n    }\n    f.$addControl = function (a) {\n      Ta(a.$name, 'input')\n      h.push(a)\n      a.$name && (f[a.$name] = a)\n      a.$$parentForm = f\n    }\n    f.$$renameControl = function (a, b) {\n      var c = a.$name\n      f[c] === a && delete f[c]\n      f[b] = a\n      a.$name = b\n    }\n    f.$removeControl = function (a) {\n      a.$name && f[a.$name] === a && delete f[a.$name]\n      m(f.$pending, function (b, c) {\n        f.$setValidity(c, null, a)\n      })\n      m(f.$error, function (b, c) {\n        f.$setValidity(c, null, a)\n      })\n      m(f.$$success, function (b, c) {\n        f.$setValidity(c, null, a)\n      })\n      cb(h, a)\n      a.$$parentForm = Ib\n    }\n    Hd({\n      ctrl: this,\n      $element: b,\n      set: function (a, b, c) {\n        var d = a[b]\n        d ? -1 === d.indexOf(c) && d.push(c) : (a[b] = [c])\n      },\n      unset: function (a, b, c) {\n        var d = a[b]\n        d && (cb(d, c), 0 === d.length && delete a[b])\n      },\n      $animate: d\n    })\n    f.$setDirty = function () {\n      d.removeClass(b, Ya)\n      d.addClass(b, Jb)\n      f.$dirty = !0\n      f.$pristine = !1\n      f.$$parentForm.$setDirty()\n    }\n    f.$setPristine = function () {\n      d.setClass(b, Ya, Jb + ' ng-submitted')\n      f.$dirty = !1\n      f.$pristine = !0\n      f.$submitted = !1\n      m(h, function (a) {\n        a.$setPristine()\n      })\n    }\n    f.$setUntouched = function () {\n      m(h, function (a) {\n        a.$setUntouched()\n      })\n    }\n    f.$setSubmitted = function () {\n      d.addClass(b, 'ng-submitted')\n      f.$submitted = !0\n      f.$$parentForm.$setSubmitted()\n    }\n  }\n  function jc (b) {\n    b.$formatters.push(function (a) {\n      return b.$isEmpty(a) ? a : a.toString()\n    })\n  }\n  function jb (b, a, c, d, e, f) {\n    var h = F(a[0].type)\n    if (!e.android) {\n      var g = !1\n      a.on('compositionstart', function (a) {\n        g = !0\n      })\n      a.on('compositionend', function () {\n        g = !1\n        l()\n      })\n    }\n    var l = function (b) {\n      k && (f.defer.cancel(k), (k = null))\n      if (!g) {\n        var e = a.val()\n        b = b && b.type\n        'password' === h || (c.ngTrim && 'false' === c.ngTrim) || (e = T(e))\n        ;(d.$viewValue !== e || ('' === e && d.$$hasNativeValidators)) && d.$setViewValue(e, b)\n      }\n    }\n    if (e.hasEvent('input')) a.on('input', l)\n    else {\n      var k,\n        n = function (a, b, c) {\n          k ||\n            (k = f.defer(function () {\n              k = null\n              ;(b && b.value === c) || l(a)\n            }))\n        }\n      a.on('keydown', function (a) {\n        var b = a.keyCode\n        91 === b || (15 < b && 19 > b) || (37 <= b && 40 >= b) || n(a, this, this.value)\n      })\n      if (e.hasEvent('paste')) a.on('paste cut', n)\n    }\n    a.on('change', l)\n    d.$render = function () {\n      var b = d.$isEmpty(d.$viewValue) ? '' : d.$viewValue\n      a.val() !== b && a.val(b)\n    }\n  }\n  function Kb (b, a) {\n    return function (c, d) {\n      var e, f\n      if (ea(c)) return c\n      if (G(c)) {\n        '\"' == c.charAt(0) && '\"' == c.charAt(c.length - 1) && (c = c.substring(1, c.length - 1))\n        if (ig.test(c)) return new Date(c)\n        b.lastIndex = 0\n        if ((e = b.exec(c)))\n          return (\n            e.shift(),\n            (f = d\n              ? {\n                  yyyy: d.getFullYear(),\n                  MM: d.getMonth() + 1,\n                  dd: d.getDate(),\n                  HH: d.getHours(),\n                  mm: d.getMinutes(),\n                  ss: d.getSeconds(),\n                  sss: d.getMilliseconds() / 1e3\n                }\n              : { yyyy: 1970, MM: 1, dd: 1, HH: 0, mm: 0, ss: 0, sss: 0 }),\n            m(e, function (b, c) {\n              c < a.length && (f[a[c]] = +b)\n            }),\n            new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1e3 * f.sss || 0)\n          )\n      }\n      return NaN\n    }\n  }\n  function kb (b, a, c, d) {\n    return function (e, f, h, g, l, k, n) {\n      function p (a) {\n        return a && !(a.getTime && a.getTime() !== a.getTime())\n      }\n      function r (a) {\n        return A(a) && !ea(a) ? c(a) || w : a\n      }\n      Id(e, f, h, g)\n      jb(e, f, h, g, l, k)\n      var t = g && g.$options && g.$options.timezone,\n        m\n      g.$$parserName = b\n      g.$parsers.push(function (b) {\n        return g.$isEmpty(b) ? null : a.test(b) ? ((b = c(b, m)), t && (b = Ob(b, t)), b) : w\n      })\n      g.$formatters.push(function (a) {\n        if (a && !ea(a)) throw lb('datefmt', a)\n        if (p(a)) return (m = a) && t && (m = Ob(m, t, !0)), n('date')(a, d, t)\n        m = null\n        return ''\n      })\n      if (A(h.min) || h.ngMin) {\n        var s\n        g.$validators.min = function (a) {\n          return !p(a) || v(s) || c(a) >= s\n        }\n        h.$observe('min', function (a) {\n          s = r(a)\n          g.$validate()\n        })\n      }\n      if (A(h.max) || h.ngMax) {\n        var u\n        g.$validators.max = function (a) {\n          return !p(a) || v(u) || c(a) <= u\n        }\n        h.$observe('max', function (a) {\n          u = r(a)\n          g.$validate()\n        })\n      }\n    }\n  }\n  function Id (b, a, c, d) {\n    ;(d.$$hasNativeValidators = C(a[0].validity)) &&\n      d.$parsers.push(function (b) {\n        var c = a.prop('validity') || {}\n        return c.badInput && !c.typeMismatch ? w : b\n      })\n  }\n  function Jd (b, a, c, d, e) {\n    if (A(d)) {\n      b = b(d)\n      if (!b.constant) throw lb('constexpr', c, d)\n      return b(a)\n    }\n    return e\n  }\n  function kc (b, a) {\n    b = 'ngClass' + b\n    return [\n      '$animate',\n      function (c) {\n        function d (a, b) {\n          var c = [],\n            d = 0\n          a: for (; d < a.length; d++) {\n            for (var e = a[d], n = 0; n < b.length; n++) if (e == b[n]) continue a\n            c.push(e)\n          }\n          return c\n        }\n        function e (a) {\n          var b = []\n          return J(a)\n            ? (m(a, function (a) {\n                b = b.concat(e(a))\n              }),\n              b)\n            : G(a)\n            ? a.split(' ')\n            : C(a)\n            ? (m(a, function (a, c) {\n                a && (b = b.concat(c.split(' ')))\n              }),\n              b)\n            : a\n        }\n        return {\n          restrict: 'AC',\n          link: function (f, h, g) {\n            function l (a, b) {\n              var c = h.data('$classCounts') || fa(),\n                d = []\n              m(a, function (a) {\n                if (0 < b || c[a]) (c[a] = (c[a] || 0) + b), c[a] === +(0 < b) && d.push(a)\n              })\n              h.data('$classCounts', c)\n              return d.join(' ')\n            }\n            function k (b) {\n              if (!0 === a || f.$index % 2 === a) {\n                var k = e(b || [])\n                if (!n) {\n                  var m = l(k, 1)\n                  g.$addClass(m)\n                } else if (!ka(b, n)) {\n                  var s = e(n),\n                    m = d(k, s),\n                    k = d(s, k),\n                    m = l(m, 1),\n                    k = l(k, -1)\n                  m && m.length && c.addClass(h, m)\n                  k && k.length && c.removeClass(h, k)\n                }\n              }\n              n = ja(b)\n            }\n            var n\n            f.$watch(g[b], k, !0)\n            g.$observe('class', function (a) {\n              k(f.$eval(g[b]))\n            })\n            'ngClass' !== b &&\n              f.$watch('$index', function (c, d) {\n                var h = c & 1\n                if (h !== (d & 1)) {\n                  var k = e(f.$eval(g[b]))\n                  h === a ? ((h = l(k, 1)), g.$addClass(h)) : ((h = l(k, -1)), g.$removeClass(h))\n                }\n              })\n          }\n        }\n      }\n    ]\n  }\n  function Hd (b) {\n    function a (a, b) {\n      b && !f[a] ? (l.addClass(e, a), (f[a] = !0)) : !b && f[a] && (l.removeClass(e, a), (f[a] = !1))\n    }\n    function c (b, c) {\n      b = b ? '-' + Ac(b, '-') : ''\n      a(mb + b, !0 === c)\n      a(Kd + b, !1 === c)\n    }\n    var d = b.ctrl,\n      e = b.$element,\n      f = {},\n      h = b.set,\n      g = b.unset,\n      l = b.$animate\n    f[Kd] = !(f[mb] = e.hasClass(mb))\n    d.$setValidity = function (b, e, f) {\n      v(e)\n        ? (d.$pending || (d.$pending = {}), h(d.$pending, b, f))\n        : (d.$pending && g(d.$pending, b, f), Ld(d.$pending) && (d.$pending = w))\n      bb(e)\n        ? e\n          ? (g(d.$error, b, f), h(d.$$success, b, f))\n          : (h(d.$error, b, f), g(d.$$success, b, f))\n        : (g(d.$error, b, f), g(d.$$success, b, f))\n      d.$pending\n        ? (a(Md, !0), (d.$valid = d.$invalid = w), c('', null))\n        : (a(Md, !1), (d.$valid = Ld(d.$error)), (d.$invalid = !d.$valid), c('', d.$valid))\n      e = d.$pending && d.$pending[b] ? w : d.$error[b] ? !1 : d.$$success[b] ? !0 : null\n      c(b, e)\n      d.$$parentForm.$setValidity(b, e, d)\n    }\n  }\n  function Ld (b) {\n    if (b) for (var a in b) if (b.hasOwnProperty(a)) return !1\n    return !0\n  }\n  var jg = /^\\/(.+)\\/([a-z]*)$/,\n    F = function (b) {\n      return G(b) ? b.toLowerCase() : b\n    },\n    ta = Object.prototype.hasOwnProperty,\n    sb = function (b) {\n      return G(b) ? b.toUpperCase() : b\n    },\n    Wa,\n    B,\n    ra,\n    ua = [].slice,\n    Nf = [].splice,\n    kg = [].push,\n    va = Object.prototype.toString,\n    rc = Object.getPrototypeOf,\n    Ea = I('ng'),\n    da = Q.angular || (Q.angular = {}),\n    Rb,\n    nb = 0\n  Wa = X.documentMode\n  y.$inject = []\n  $a.$inject = []\n  var J = Array.isArray,\n    tc = /^\\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\\]$/,\n    T = function (b) {\n      return G(b) ? b.trim() : b\n    },\n    vd = function (b) {\n      return b.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').replace(/\\x08/g, '\\\\x08')\n    },\n    Fa = function () {\n      if (!A(Fa.rules)) {\n        var b = X.querySelector('[ng-csp]') || X.querySelector('[data-ng-csp]')\n        if (b) {\n          var a = b.getAttribute('ng-csp') || b.getAttribute('data-ng-csp')\n          Fa.rules = {\n            noUnsafeEval: !a || -1 !== a.indexOf('no-unsafe-eval'),\n            noInlineStyle: !a || -1 !== a.indexOf('no-inline-style')\n          }\n        } else {\n          b = Fa\n          try {\n            new Function(''), (a = !1)\n          } catch (c) {\n            a = !0\n          }\n          b.rules = { noUnsafeEval: a, noInlineStyle: !1 }\n        }\n      }\n      return Fa.rules\n    },\n    pb = function () {\n      if (A(pb.name_)) return pb.name_\n      var b,\n        a,\n        c = Qa.length,\n        d,\n        e\n      for (a = 0; a < c; ++a)\n        if (((d = Qa[a]), (b = X.querySelector('[' + d.replace(':', '\\\\:') + 'jq]')))) {\n          e = b.getAttribute(d + 'jq')\n          break\n        }\n      return (pb.name_ = e)\n    },\n    Qa = ['ng-', 'data-ng-', 'ng:', 'x-ng-'],\n    be = /[A-Z]/g,\n    Bc = !1,\n    Qb,\n    pa = 1,\n    Pa = 3,\n    fe = { full: '1.4.7', major: 1, minor: 4, dot: 7, codeName: 'dark-luminescence' }\n  R.expando = 'ng339'\n  var hb = (R.cache = {}),\n    Ff = 1\n  R._data = function (b) {\n    return this.cache[b[this.expando]] || {}\n  }\n  var Af = /([\\:\\-\\_]+(.))/g,\n    Bf = /^moz([A-Z])/,\n    lg = { mouseleave: 'mouseout', mouseenter: 'mouseover' },\n    Tb = I('jqLite'),\n    Ef = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    Sb = /<|&#?\\w+;/,\n    Cf = /<([\\w:-]+)/,\n    Df = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n    ma = {\n      option: [1, '<select multiple=\"multiple\">', '</select>'],\n      thead: [1, '<table>', '</table>'],\n      col: [2, '<table><colgroup>', '</colgroup></table>'],\n      tr: [2, '<table><tbody>', '</tbody></table>'],\n      td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n      _default: [0, '', '']\n    }\n  ma.optgroup = ma.option\n  ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead\n  ma.th = ma.td\n  var Ra = (R.prototype = {\n      ready: function (b) {\n        function a () {\n          c || ((c = !0), b())\n        }\n        var c = !1\n        'complete' === X.readyState ? setTimeout(a) : (this.on('DOMContentLoaded', a), R(Q).on('load', a))\n      },\n      toString: function () {\n        var b = []\n        m(this, function (a) {\n          b.push('' + a)\n        })\n        return '[' + b.join(', ') + ']'\n      },\n      eq: function (b) {\n        return 0 <= b ? B(this[b]) : B(this[this.length + b])\n      },\n      length: 0,\n      push: kg,\n      sort: [].sort,\n      splice: [].splice\n    }),\n    Bb = {}\n  m('multiple selected checked disabled readOnly required open'.split(' '), function (b) {\n    Bb[F(b)] = b\n  })\n  var Sc = {}\n  m('input select option textarea button form details'.split(' '), function (b) {\n    Sc[b] = !0\n  })\n  var $c = { ngMinlength: 'minlength', ngMaxlength: 'maxlength', ngMin: 'min', ngMax: 'max', ngPattern: 'pattern' }\n  m(\n    {\n      data: Vb,\n      removeData: vb,\n      hasData: function (b) {\n        for (var a in hb[b.ng339]) return !0\n        return !1\n      }\n    },\n    function (b, a) {\n      R[a] = b\n    }\n  )\n  m(\n    {\n      data: Vb,\n      inheritedData: Ab,\n      scope: function (b) {\n        return B.data(b, '$scope') || Ab(b.parentNode || b, ['$isolateScope', '$scope'])\n      },\n      isolateScope: function (b) {\n        return B.data(b, '$isolateScope') || B.data(b, '$isolateScopeNoTemplate')\n      },\n      controller: Pc,\n      injector: function (b) {\n        return Ab(b, '$injector')\n      },\n      removeAttr: function (b, a) {\n        b.removeAttribute(a)\n      },\n      hasClass: xb,\n      css: function (b, a, c) {\n        a = gb(a)\n        if (A(c)) b.style[a] = c\n        else return b.style[a]\n      },\n      attr: function (b, a, c) {\n        var d = b.nodeType\n        if (d !== Pa && 2 !== d && 8 !== d)\n          if (((d = F(a)), Bb[d]))\n            if (A(c)) c ? ((b[a] = !0), b.setAttribute(a, d)) : ((b[a] = !1), b.removeAttribute(d))\n            else return b[a] || (b.attributes.getNamedItem(a) || y).specified ? d : w\n          else if (A(c)) b.setAttribute(a, c)\n          else if (b.getAttribute) return (b = b.getAttribute(a, 2)), null === b ? w : b\n      },\n      prop: function (b, a, c) {\n        if (A(c)) b[a] = c\n        else return b[a]\n      },\n      text: (function () {\n        function b (a, b) {\n          if (v(b)) {\n            var d = a.nodeType\n            return d === pa || d === Pa ? a.textContent : ''\n          }\n          a.textContent = b\n        }\n        b.$dv = ''\n        return b\n      })(),\n      val: function (b, a) {\n        if (v(a)) {\n          if (b.multiple && 'select' === wa(b)) {\n            var c = []\n            m(b.options, function (a) {\n              a.selected && c.push(a.value || a.text)\n            })\n            return 0 === c.length ? null : c\n          }\n          return b.value\n        }\n        b.value = a\n      },\n      html: function (b, a) {\n        if (v(a)) return b.innerHTML\n        ub(b, !0)\n        b.innerHTML = a\n      },\n      empty: Qc\n    },\n    function (b, a) {\n      R.prototype[a] = function (a, d) {\n        var e,\n          f,\n          h = this.length\n        if (b !== Qc && v(2 == b.length && b !== xb && b !== Pc ? a : d)) {\n          if (C(a)) {\n            for (e = 0; e < h; e++)\n              if (b === Vb) b(this[e], a)\n              else for (f in a) b(this[e], f, a[f])\n            return this\n          }\n          e = b.$dv\n          h = v(e) ? Math.min(h, 1) : h\n          for (f = 0; f < h; f++) {\n            var g = b(this[f], a, d)\n            e = e ? e + g : g\n          }\n          return e\n        }\n        for (e = 0; e < h; e++) b(this[e], a, d)\n        return this\n      }\n    }\n  )\n  m(\n    {\n      removeData: vb,\n      on: function a (c, d, e, f) {\n        if (A(f)) throw Tb('onargs')\n        if (Lc(c)) {\n          var h = wb(c, !0)\n          f = h.events\n          var g = h.handle\n          g || (g = h.handle = Hf(c, f))\n          for (var h = 0 <= d.indexOf(' ') ? d.split(' ') : [d], l = h.length; l--; ) {\n            d = h[l]\n            var k = f[d]\n            k ||\n              ((f[d] = []),\n              'mouseenter' === d || 'mouseleave' === d\n                ? a(c, lg[d], function (a) {\n                    var c = a.relatedTarget\n                    ;(c && (c === this || this.contains(c))) || g(a, d)\n                  })\n                : '$destroy' !== d && c.addEventListener(d, g, !1),\n              (k = f[d]))\n            k.push(e)\n          }\n        }\n      },\n      off: Oc,\n      one: function (a, c, d) {\n        a = B(a)\n        a.on(c, function f () {\n          a.off(c, d)\n          a.off(c, f)\n        })\n        a.on(c, d)\n      },\n      replaceWith: function (a, c) {\n        var d,\n          e = a.parentNode\n        ub(a)\n        m(new R(c), function (c) {\n          d ? e.insertBefore(c, d.nextSibling) : e.replaceChild(c, a)\n          d = c\n        })\n      },\n      children: function (a) {\n        var c = []\n        m(a.childNodes, function (a) {\n          a.nodeType === pa && c.push(a)\n        })\n        return c\n      },\n      contents: function (a) {\n        return a.contentDocument || a.childNodes || []\n      },\n      append: function (a, c) {\n        var d = a.nodeType\n        if (d === pa || 11 === d) {\n          c = new R(c)\n          for (var d = 0, e = c.length; d < e; d++) a.appendChild(c[d])\n        }\n      },\n      prepend: function (a, c) {\n        if (a.nodeType === pa) {\n          var d = a.firstChild\n          m(new R(c), function (c) {\n            a.insertBefore(c, d)\n          })\n        }\n      },\n      wrap: function (a, c) {\n        c = B(c)\n          .eq(0)\n          .clone()[0]\n        var d = a.parentNode\n        d && d.replaceChild(c, a)\n        c.appendChild(a)\n      },\n      remove: Wb,\n      detach: function (a) {\n        Wb(a, !0)\n      },\n      after: function (a, c) {\n        var d = a,\n          e = a.parentNode\n        c = new R(c)\n        for (var f = 0, h = c.length; f < h; f++) {\n          var g = c[f]\n          e.insertBefore(g, d.nextSibling)\n          d = g\n        }\n      },\n      addClass: zb,\n      removeClass: yb,\n      toggleClass: function (a, c, d) {\n        c &&\n          m(c.split(' '), function (c) {\n            var f = d\n            v(f) && (f = !xb(a, c))\n            ;(f ? zb : yb)(a, c)\n          })\n      },\n      parent: function (a) {\n        return (a = a.parentNode) && 11 !== a.nodeType ? a : null\n      },\n      next: function (a) {\n        return a.nextElementSibling\n      },\n      find: function (a, c) {\n        return a.getElementsByTagName ? a.getElementsByTagName(c) : []\n      },\n      clone: Ub,\n      triggerHandler: function (a, c, d) {\n        var e,\n          f,\n          h = c.type || c,\n          g = wb(a)\n        if ((g = (g = g && g.events) && g[h]))\n          (e = {\n            preventDefault: function () {\n              this.defaultPrevented = !0\n            },\n            isDefaultPrevented: function () {\n              return !0 === this.defaultPrevented\n            },\n            stopImmediatePropagation: function () {\n              this.immediatePropagationStopped = !0\n            },\n            isImmediatePropagationStopped: function () {\n              return !0 === this.immediatePropagationStopped\n            },\n            stopPropagation: y,\n            type: h,\n            target: a\n          }),\n            c.type && (e = P(e, c)),\n            (c = ja(g)),\n            (f = d ? [e].concat(d) : [e]),\n            m(c, function (c) {\n              e.isImmediatePropagationStopped() || c.apply(a, f)\n            })\n      }\n    },\n    function (a, c) {\n      R.prototype[c] = function (c, e, f) {\n        for (var h, g = 0, l = this.length; g < l; g++)\n          v(h) ? ((h = a(this[g], c, e, f)), A(h) && (h = B(h))) : Nc(h, a(this[g], c, e, f))\n        return A(h) ? h : this\n      }\n      R.prototype.bind = R.prototype.on\n      R.prototype.unbind = R.prototype.off\n    }\n  )\n  Ua.prototype = {\n    put: function (a, c) {\n      this[Ga(a, this.nextUid)] = c\n    },\n    get: function (a) {\n      return this[Ga(a, this.nextUid)]\n    },\n    remove: function (a) {\n      var c = this[(a = Ga(a, this.nextUid))]\n      delete this[a]\n      return c\n    }\n  }\n  var yf = [\n      function () {\n        this.$get = [\n          function () {\n            return Ua\n          }\n        ]\n      }\n    ],\n    Uc = /^[^\\(]*\\(\\s*([^\\)]*)\\)/m,\n    mg = /,/,\n    ng = /^\\s*(_?)(\\S+?)\\1\\s*$/,\n    Tc = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/gm,\n    Ha = I('$injector')\n  fb.$$annotate = function (a, c, d) {\n    var e\n    if ('function' === typeof a) {\n      if (!(e = a.$inject)) {\n        e = []\n        if (a.length) {\n          if (c) throw ((G(d) && d) || (d = a.name || If(a)), Ha('strictdi', d))\n          c = a.toString().replace(Tc, '')\n          c = c.match(Uc)\n          m(c[1].split(mg), function (a) {\n            a.replace(ng, function (a, c, d) {\n              e.push(d)\n            })\n          })\n        }\n        a.$inject = e\n      }\n    } else J(a) ? ((c = a.length - 1), Sa(a[c], 'fn'), (e = a.slice(0, c))) : Sa(a, 'fn', !0)\n    return e\n  }\n  var Nd = I('$animate'),\n    Ue = function () {\n      this.$get = [\n        '$q',\n        '$$rAF',\n        function (a, c) {\n          function d () {}\n          d.all = y\n          d.chain = y\n          d.prototype = {\n            end: y,\n            cancel: y,\n            resume: y,\n            pause: y,\n            complete: y,\n            then: function (d, f) {\n              return a(function (a) {\n                c(function () {\n                  a()\n                })\n              }).then(d, f)\n            }\n          }\n          return d\n        }\n      ]\n    },\n    Te = function () {\n      var a = new Ua(),\n        c = []\n      this.$get = [\n        '$$AnimateRunner',\n        '$rootScope',\n        function (d, e) {\n          function f (a, c, d) {\n            var e = !1\n            c &&\n              ((c = G(c) ? c.split(' ') : J(c) ? c : []),\n              m(c, function (c) {\n                c && ((e = !0), (a[c] = d))\n              }))\n            return e\n          }\n          function h () {\n            m(c, function (c) {\n              var d = a.get(c)\n              if (d) {\n                var e = Jf(c.attr('class')),\n                  f = '',\n                  h = ''\n                m(d, function (a, c) {\n                  a !== !!e[c] && (a ? (f += (f.length ? ' ' : '') + c) : (h += (h.length ? ' ' : '') + c))\n                })\n                m(c, function (a) {\n                  f && zb(a, f)\n                  h && yb(a, h)\n                })\n                a.remove(c)\n              }\n            })\n            c.length = 0\n          }\n          return {\n            enabled: y,\n            on: y,\n            off: y,\n            pin: y,\n            push: function (g, l, k, n) {\n              n && n()\n              k = k || {}\n              k.from && g.css(k.from)\n              k.to && g.css(k.to)\n              if (k.addClass || k.removeClass)\n                if (\n                  ((l = k.addClass),\n                  (n = k.removeClass),\n                  (k = a.get(g) || {}),\n                  (l = f(k, l, !0)),\n                  (n = f(k, n, !1)),\n                  l || n)\n                )\n                  a.put(g, k), c.push(g), 1 === c.length && e.$$postDigest(h)\n              return new d()\n            }\n          }\n        }\n      ]\n    },\n    Re = [\n      '$provide',\n      function (a) {\n        var c = this\n        this.$$registeredAnimations = Object.create(null)\n        this.register = function (d, e) {\n          if (d && '.' !== d.charAt(0)) throw Nd('notcsel', d)\n          var f = d + '-animation'\n          c.$$registeredAnimations[d.substr(1)] = f\n          a.factory(f, e)\n        }\n        this.classNameFilter = function (a) {\n          if (\n            1 === arguments.length &&\n            (this.$$classNameFilter = a instanceof RegExp ? a : null) &&\n            /(\\s+|\\/)ng-animate(\\s+|\\/)/.test(this.$$classNameFilter.toString())\n          )\n            throw Nd('nongcls', 'ng-animate')\n          return this.$$classNameFilter\n        }\n        this.$get = [\n          '$$animateQueue',\n          function (a) {\n            function c (a, d, e) {\n              if (e) {\n                var l\n                a: {\n                  for (l = 0; l < e.length; l++) {\n                    var k = e[l]\n                    if (1 === k.nodeType) {\n                      l = k\n                      break a\n                    }\n                  }\n                  l = void 0\n                }\n                !l || l.parentNode || l.previousElementSibling || (e = null)\n              }\n              e ? e.after(a) : d.prepend(a)\n            }\n            return {\n              on: a.on,\n              off: a.off,\n              pin: a.pin,\n              enabled: a.enabled,\n              cancel: function (a) {\n                a.end && a.end()\n              },\n              enter: function (f, h, g, l) {\n                h = h && B(h)\n                g = g && B(g)\n                h = h || g.parent()\n                c(f, h, g)\n                return a.push(f, 'enter', Ia(l))\n              },\n              move: function (f, h, g, l) {\n                h = h && B(h)\n                g = g && B(g)\n                h = h || g.parent()\n                c(f, h, g)\n                return a.push(f, 'move', Ia(l))\n              },\n              leave: function (c, e) {\n                return a.push(c, 'leave', Ia(e), function () {\n                  c.remove()\n                })\n              },\n              addClass: function (c, e, g) {\n                g = Ia(g)\n                g.addClass = ib(g.addclass, e)\n                return a.push(c, 'addClass', g)\n              },\n              removeClass: function (c, e, g) {\n                g = Ia(g)\n                g.removeClass = ib(g.removeClass, e)\n                return a.push(c, 'removeClass', g)\n              },\n              setClass: function (c, e, g, l) {\n                l = Ia(l)\n                l.addClass = ib(l.addClass, e)\n                l.removeClass = ib(l.removeClass, g)\n                return a.push(c, 'setClass', l)\n              },\n              animate: function (c, e, g, l, k) {\n                k = Ia(k)\n                k.from = k.from ? P(k.from, e) : e\n                k.to = k.to ? P(k.to, g) : g\n                k.tempClasses = ib(k.tempClasses, l || 'ng-inline-animate')\n                return a.push(c, 'animate', k)\n              }\n            }\n          }\n        ]\n      }\n    ],\n    Se = function () {\n      this.$get = [\n        '$$rAF',\n        '$q',\n        function (a, c) {\n          var d = function () {}\n          d.prototype = {\n            done: function (a) {\n              this.defer && this.defer[!0 === a ? 'reject' : 'resolve']()\n            },\n            end: function () {\n              this.done()\n            },\n            cancel: function () {\n              this.done(!0)\n            },\n            getPromise: function () {\n              this.defer || (this.defer = c.defer())\n              return this.defer.promise\n            },\n            then: function (a, c) {\n              return this.getPromise().then(a, c)\n            },\n            catch: function (a) {\n              return this.getPromise()['catch'](a)\n            },\n            finally: function (a) {\n              return this.getPromise()['finally'](a)\n            }\n          }\n          return function (c, f) {\n            function h () {\n              a(function () {\n                f.addClass && (c.addClass(f.addClass), (f.addClass = null))\n                f.removeClass && (c.removeClass(f.removeClass), (f.removeClass = null))\n                f.to && (c.css(f.to), (f.to = null))\n                g || l.done()\n                g = !0\n              })\n              return l\n            }\n            f.cleanupStyles && (f.from = f.to = null)\n            f.from && (c.css(f.from), (f.from = null))\n            var g,\n              l = new d()\n            return { start: h, end: h }\n          }\n        }\n      ]\n    },\n    ga = I('$compile')\n  Dc.$inject = ['$provide', '$$sanitizeUriProvider']\n  var Wc = /^((?:x|data)[\\:\\-_])/i,\n    Of = I('$controller'),\n    Vc = /^(\\S+)(\\s+as\\s+(\\w+))?$/,\n    $e = function () {\n      this.$get = [\n        '$document',\n        function (a) {\n          return function (c) {\n            c ? !c.nodeType && c instanceof B && (c = c[0]) : (c = a[0].body)\n            return c.offsetWidth + 1\n          }\n        }\n      ]\n    },\n    ad = 'application/json',\n    $b = { 'Content-Type': ad + ';charset=utf-8' },\n    Qf = /^\\[|^\\{(?!\\{)/,\n    Rf = { '[': /]$/, '{': /}$/ },\n    Pf = /^\\)\\]\\}',?\\n/,\n    og = I('$http'),\n    ed = function (a) {\n      return function () {\n        throw og('legacy', a)\n      }\n    },\n    La = (da.$interpolateMinErr = I('$interpolate'))\n  La.throwNoconcat = function (a) {\n    throw La('noconcat', a)\n  }\n  La.interr = function (a, c) {\n    return La('interr', a, c.toString())\n  }\n  var pg = /^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/,\n    Tf = { http: 80, https: 443, ftp: 21 },\n    Db = I('$location'),\n    qg = {\n      $$html5: !1,\n      $$replace: !1,\n      absUrl: Eb('$$absUrl'),\n      url: function (a) {\n        if (v(a)) return this.$$url\n        var c = pg.exec(a)\n        ;(c[1] || '' === a) && this.path(decodeURIComponent(c[1]))\n        ;(c[2] || c[1] || '' === a) && this.search(c[3] || '')\n        this.hash(c[5] || '')\n        return this\n      },\n      protocol: Eb('$$protocol'),\n      host: Eb('$$host'),\n      port: Eb('$$port'),\n      path: jd('$$path', function (a) {\n        a = null !== a ? a.toString() : ''\n        return '/' == a.charAt(0) ? a : '/' + a\n      }),\n      search: function (a, c) {\n        switch (arguments.length) {\n          case 0:\n            return this.$$search\n          case 1:\n            if (G(a) || V(a)) (a = a.toString()), (this.$$search = yc(a))\n            else if (C(a))\n              (a = ha(a, {})),\n                m(a, function (c, e) {\n                  null == c && delete a[e]\n                }),\n                (this.$$search = a)\n            else throw Db('isrcharg')\n            break\n          default:\n            v(c) || null === c ? delete this.$$search[a] : (this.$$search[a] = c)\n        }\n        this.$$compose()\n        return this\n      },\n      hash: jd('$$hash', function (a) {\n        return null !== a ? a.toString() : ''\n      }),\n      replace: function () {\n        this.$$replace = !0\n        return this\n      }\n    }\n  m([id, cc, bc], function (a) {\n    a.prototype = Object.create(qg)\n    a.prototype.state = function (c) {\n      if (!arguments.length) return this.$$state\n      if (a !== bc || !this.$$html5) throw Db('nostate')\n      this.$$state = v(c) ? null : c\n      return this\n    }\n  })\n  var Z = I('$parse'),\n    Uf = Function.prototype.call,\n    Vf = Function.prototype.apply,\n    Wf = Function.prototype.bind,\n    Lb = fa()\n  m('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (a) {\n    Lb[a] = !0\n  })\n  var rg = { n: '\\n', f: '\\f', r: '\\r', t: '\\t', v: '\\v', \"'\": \"'\", '\"': '\"' },\n    ec = function (a) {\n      this.options = a\n    }\n  ec.prototype = {\n    constructor: ec,\n    lex: function (a) {\n      this.text = a\n      this.index = 0\n      for (this.tokens = []; this.index < this.text.length; )\n        if (((a = this.text.charAt(this.index)), '\"' === a || \"'\" === a)) this.readString(a)\n        else if (this.isNumber(a) || ('.' === a && this.isNumber(this.peek()))) this.readNumber()\n        else if (this.isIdent(a)) this.readIdent()\n        else if (this.is(a, '(){}[].,;:?')) this.tokens.push({ index: this.index, text: a }), this.index++\n        else if (this.isWhitespace(a)) this.index++\n        else {\n          var c = a + this.peek(),\n            d = c + this.peek(2),\n            e = Lb[c],\n            f = Lb[d]\n          Lb[a] || e || f\n            ? ((a = f ? d : e ? c : a),\n              this.tokens.push({ index: this.index, text: a, operator: !0 }),\n              (this.index += a.length))\n            : this.throwError('Unexpected next character ', this.index, this.index + 1)\n        }\n      return this.tokens\n    },\n    is: function (a, c) {\n      return -1 !== c.indexOf(a)\n    },\n    peek: function (a) {\n      a = a || 1\n      return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1\n    },\n    isNumber: function (a) {\n      return '0' <= a && '9' >= a && 'string' === typeof a\n    },\n    isWhitespace: function (a) {\n      return ' ' === a || '\\r' === a || '\\t' === a || '\\n' === a || '\\v' === a || '\\u00a0' === a\n    },\n    isIdent: function (a) {\n      return ('a' <= a && 'z' >= a) || ('A' <= a && 'Z' >= a) || '_' === a || '$' === a\n    },\n    isExpOperator: function (a) {\n      return '-' === a || '+' === a || this.isNumber(a)\n    },\n    throwError: function (a, c, d) {\n      d = d || this.index\n      c = A(c) ? 's ' + c + '-' + this.index + ' [' + this.text.substring(c, d) + ']' : ' ' + d\n      throw Z('lexerr', a, c, this.text)\n    },\n    readNumber: function () {\n      for (var a = '', c = this.index; this.index < this.text.length; ) {\n        var d = F(this.text.charAt(this.index))\n        if ('.' == d || this.isNumber(d)) a += d\n        else {\n          var e = this.peek()\n          if ('e' == d && this.isExpOperator(e)) a += d\n          else if (this.isExpOperator(d) && e && this.isNumber(e) && 'e' == a.charAt(a.length - 1)) a += d\n          else if (!this.isExpOperator(d) || (e && this.isNumber(e)) || 'e' != a.charAt(a.length - 1)) break\n          else this.throwError('Invalid exponent')\n        }\n        this.index++\n      }\n      this.tokens.push({ index: c, text: a, constant: !0, value: Number(a) })\n    },\n    readIdent: function () {\n      for (var a = this.index; this.index < this.text.length; ) {\n        var c = this.text.charAt(this.index)\n        if (!this.isIdent(c) && !this.isNumber(c)) break\n        this.index++\n      }\n      this.tokens.push({ index: a, text: this.text.slice(a, this.index), identifier: !0 })\n    },\n    readString: function (a) {\n      var c = this.index\n      this.index++\n      for (var d = '', e = a, f = !1; this.index < this.text.length; ) {\n        var h = this.text.charAt(this.index),\n          e = e + h\n        if (f)\n          'u' === h\n            ? ((f = this.text.substring(this.index + 1, this.index + 5)),\n              f.match(/[\\da-f]{4}/i) || this.throwError('Invalid unicode escape [\\\\u' + f + ']'),\n              (this.index += 4),\n              (d += String.fromCharCode(parseInt(f, 16))))\n            : (d += rg[h] || h),\n            (f = !1)\n        else if ('\\\\' === h) f = !0\n        else {\n          if (h === a) {\n            this.index++\n            this.tokens.push({ index: c, text: e, constant: !0, value: d })\n            return\n          }\n          d += h\n        }\n        this.index++\n      }\n      this.throwError('Unterminated quote', c)\n    }\n  }\n  var s = function (a, c) {\n    this.lexer = a\n    this.options = c\n  }\n  s.Program = 'Program'\n  s.ExpressionStatement = 'ExpressionStatement'\n  s.AssignmentExpression = 'AssignmentExpression'\n  s.ConditionalExpression = 'ConditionalExpression'\n  s.LogicalExpression = 'LogicalExpression'\n  s.BinaryExpression = 'BinaryExpression'\n  s.UnaryExpression = 'UnaryExpression'\n  s.CallExpression = 'CallExpression'\n  s.MemberExpression = 'MemberExpression'\n  s.Identifier = 'Identifier'\n  s.Literal = 'Literal'\n  s.ArrayExpression = 'ArrayExpression'\n  s.Property = 'Property'\n  s.ObjectExpression = 'ObjectExpression'\n  s.ThisExpression = 'ThisExpression'\n  s.NGValueParameter = 'NGValueParameter'\n  s.prototype = {\n    ast: function (a) {\n      this.text = a\n      this.tokens = this.lexer.lex(a)\n      a = this.program()\n      0 !== this.tokens.length && this.throwError('is an unexpected token', this.tokens[0])\n      return a\n    },\n    program: function () {\n      for (var a = []; ; )\n        if (\n          (0 < this.tokens.length && !this.peek('}', ')', ';', ']') && a.push(this.expressionStatement()),\n          !this.expect(';'))\n        )\n          return { type: s.Program, body: a }\n    },\n    expressionStatement: function () {\n      return { type: s.ExpressionStatement, expression: this.filterChain() }\n    },\n    filterChain: function () {\n      for (var a = this.expression(); this.expect('|'); ) a = this.filter(a)\n      return a\n    },\n    expression: function () {\n      return this.assignment()\n    },\n    assignment: function () {\n      var a = this.ternary()\n      this.expect('=') && (a = { type: s.AssignmentExpression, left: a, right: this.assignment(), operator: '=' })\n      return a\n    },\n    ternary: function () {\n      var a = this.logicalOR(),\n        c,\n        d\n      return this.expect('?') && ((c = this.expression()), this.consume(':'))\n        ? ((d = this.expression()), { type: s.ConditionalExpression, test: a, alternate: c, consequent: d })\n        : a\n    },\n    logicalOR: function () {\n      for (var a = this.logicalAND(); this.expect('||'); )\n        a = { type: s.LogicalExpression, operator: '||', left: a, right: this.logicalAND() }\n      return a\n    },\n    logicalAND: function () {\n      for (var a = this.equality(); this.expect('&&'); )\n        a = { type: s.LogicalExpression, operator: '&&', left: a, right: this.equality() }\n      return a\n    },\n    equality: function () {\n      for (var a = this.relational(), c; (c = this.expect('==', '!=', '===', '!==')); )\n        a = { type: s.BinaryExpression, operator: c.text, left: a, right: this.relational() }\n      return a\n    },\n    relational: function () {\n      for (var a = this.additive(), c; (c = this.expect('<', '>', '<=', '>=')); )\n        a = { type: s.BinaryExpression, operator: c.text, left: a, right: this.additive() }\n      return a\n    },\n    additive: function () {\n      for (var a = this.multiplicative(), c; (c = this.expect('+', '-')); )\n        a = { type: s.BinaryExpression, operator: c.text, left: a, right: this.multiplicative() }\n      return a\n    },\n    multiplicative: function () {\n      for (var a = this.unary(), c; (c = this.expect('*', '/', '%')); )\n        a = { type: s.BinaryExpression, operator: c.text, left: a, right: this.unary() }\n      return a\n    },\n    unary: function () {\n      var a\n      return (a = this.expect('+', '-', '!'))\n        ? { type: s.UnaryExpression, operator: a.text, prefix: !0, argument: this.unary() }\n        : this.primary()\n    },\n    primary: function () {\n      var a\n      this.expect('(')\n        ? ((a = this.filterChain()), this.consume(')'))\n        : this.expect('[')\n        ? (a = this.arrayDeclaration())\n        : this.expect('{')\n        ? (a = this.object())\n        : this.constants.hasOwnProperty(this.peek().text)\n        ? (a = ha(this.constants[this.consume().text]))\n        : this.peek().identifier\n        ? (a = this.identifier())\n        : this.peek().constant\n        ? (a = this.constant())\n        : this.throwError('not a primary expression', this.peek())\n      for (var c; (c = this.expect('(', '[', '.')); )\n        '(' === c.text\n          ? ((a = { type: s.CallExpression, callee: a, arguments: this.parseArguments() }), this.consume(')'))\n          : '[' === c.text\n          ? ((a = { type: s.MemberExpression, object: a, property: this.expression(), computed: !0 }),\n            this.consume(']'))\n          : '.' === c.text\n          ? (a = { type: s.MemberExpression, object: a, property: this.identifier(), computed: !1 })\n          : this.throwError('IMPOSSIBLE')\n      return a\n    },\n    filter: function (a) {\n      a = [a]\n      for (var c = { type: s.CallExpression, callee: this.identifier(), arguments: a, filter: !0 }; this.expect(':'); )\n        a.push(this.expression())\n      return c\n    },\n    parseArguments: function () {\n      var a = []\n      if (')' !== this.peekToken().text) {\n        do a.push(this.expression())\n        while (this.expect(','))\n      }\n      return a\n    },\n    identifier: function () {\n      var a = this.consume()\n      a.identifier || this.throwError('is not a valid identifier', a)\n      return { type: s.Identifier, name: a.text }\n    },\n    constant: function () {\n      return { type: s.Literal, value: this.consume().value }\n    },\n    arrayDeclaration: function () {\n      var a = []\n      if (']' !== this.peekToken().text) {\n        do {\n          if (this.peek(']')) break\n          a.push(this.expression())\n        } while (this.expect(','))\n      }\n      this.consume(']')\n      return { type: s.ArrayExpression, elements: a }\n    },\n    object: function () {\n      var a = [],\n        c\n      if ('}' !== this.peekToken().text) {\n        do {\n          if (this.peek('}')) break\n          c = { type: s.Property, kind: 'init' }\n          this.peek().constant\n            ? (c.key = this.constant())\n            : this.peek().identifier\n            ? (c.key = this.identifier())\n            : this.throwError('invalid key', this.peek())\n          this.consume(':')\n          c.value = this.expression()\n          a.push(c)\n        } while (this.expect(','))\n      }\n      this.consume('}')\n      return { type: s.ObjectExpression, properties: a }\n    },\n    throwError: function (a, c) {\n      throw Z('syntax', c.text, a, c.index + 1, this.text, this.text.substring(c.index))\n    },\n    consume: function (a) {\n      if (0 === this.tokens.length) throw Z('ueoe', this.text)\n      var c = this.expect(a)\n      c || this.throwError('is unexpected, expecting [' + a + ']', this.peek())\n      return c\n    },\n    peekToken: function () {\n      if (0 === this.tokens.length) throw Z('ueoe', this.text)\n      return this.tokens[0]\n    },\n    peek: function (a, c, d, e) {\n      return this.peekAhead(0, a, c, d, e)\n    },\n    peekAhead: function (a, c, d, e, f) {\n      if (this.tokens.length > a) {\n        a = this.tokens[a]\n        var h = a.text\n        if (h === c || h === d || h === e || h === f || !(c || d || e || f)) return a\n      }\n      return !1\n    },\n    expect: function (a, c, d, e) {\n      return (a = this.peek(a, c, d, e)) ? (this.tokens.shift(), a) : !1\n    },\n    constants: {\n      true: { type: s.Literal, value: !0 },\n      false: { type: s.Literal, value: !1 },\n      null: { type: s.Literal, value: null },\n      undefined: { type: s.Literal, value: w },\n      this: { type: s.ThisExpression }\n    }\n  }\n  sd.prototype = {\n    compile: function (a, c) {\n      var d = this,\n        e = this.astBuilder.ast(a)\n      this.state = {\n        nextId: 0,\n        filters: {},\n        expensiveChecks: c,\n        fn: { vars: [], body: [], own: {} },\n        assign: { vars: [], body: [], own: {} },\n        inputs: []\n      }\n      U(e, d.$filter)\n      var f = '',\n        h\n      this.stage = 'assign'\n      if ((h = qd(e)))\n        (this.state.computing = 'assign'),\n          (f = this.nextId()),\n          this.recurse(h, f),\n          this.return_(f),\n          (f = 'fn.assign=' + this.generateFunction('assign', 's,v,l'))\n      h = od(e.body)\n      d.stage = 'inputs'\n      m(h, function (a, c) {\n        var e = 'fn' + c\n        d.state[e] = { vars: [], body: [], own: {} }\n        d.state.computing = e\n        var f = d.nextId()\n        d.recurse(a, f)\n        d.return_(f)\n        d.state.inputs.push(e)\n        a.watchId = c\n      })\n      this.state.computing = 'fn'\n      this.stage = 'main'\n      this.recurse(e)\n      f =\n        '\"' +\n        this.USE +\n        ' ' +\n        this.STRICT +\n        '\";\\n' +\n        this.filterPrefix() +\n        'var fn=' +\n        this.generateFunction('fn', 's,l,a,i') +\n        f +\n        this.watchFns() +\n        'return fn;'\n      f = new Function(\n        '$filter',\n        'ensureSafeMemberName',\n        'ensureSafeObject',\n        'ensureSafeFunction',\n        'getStringValue',\n        'ensureSafeAssignContext',\n        'ifDefined',\n        'plus',\n        'text',\n        f\n      )(this.$filter, Xa, Ba, ld, kd, md, Xf, nd, a)\n      this.state = this.stage = w\n      f.literal = rd(e)\n      f.constant = e.constant\n      return f\n    },\n    USE: 'use',\n    STRICT: 'strict',\n    watchFns: function () {\n      var a = [],\n        c = this.state.inputs,\n        d = this\n      m(c, function (c) {\n        a.push('var ' + c + '=' + d.generateFunction(c, 's'))\n      })\n      c.length && a.push('fn.inputs=[' + c.join(',') + '];')\n      return a.join('')\n    },\n    generateFunction: function (a, c) {\n      return 'function(' + c + '){' + this.varsPrefix(a) + this.body(a) + '};'\n    },\n    filterPrefix: function () {\n      var a = [],\n        c = this\n      m(this.state.filters, function (d, e) {\n        a.push(d + '=$filter(' + c.escape(e) + ')')\n      })\n      return a.length ? 'var ' + a.join(',') + ';' : ''\n    },\n    varsPrefix: function (a) {\n      return this.state[a].vars.length ? 'var ' + this.state[a].vars.join(',') + ';' : ''\n    },\n    body: function (a) {\n      return this.state[a].body.join('')\n    },\n    recurse: function (a, c, d, e, f, h) {\n      var g,\n        l,\n        k = this,\n        n,\n        p\n      e = e || y\n      if (!h && A(a.watchId))\n        (c = c || this.nextId()),\n          this.if_('i', this.lazyAssign(c, this.computedMember('i', a.watchId)), this.lazyRecurse(a, c, d, e, f, !0))\n      else\n        switch (a.type) {\n          case s.Program:\n            m(a.body, function (c, d) {\n              k.recurse(c.expression, w, w, function (a) {\n                l = a\n              })\n              d !== a.body.length - 1 ? k.current().body.push(l, ';') : k.return_(l)\n            })\n            break\n          case s.Literal:\n            p = this.escape(a.value)\n            this.assign(c, p)\n            e(p)\n            break\n          case s.UnaryExpression:\n            this.recurse(a.argument, w, w, function (a) {\n              l = a\n            })\n            p = a.operator + '(' + this.ifDefined(l, 0) + ')'\n            this.assign(c, p)\n            e(p)\n            break\n          case s.BinaryExpression:\n            this.recurse(a.left, w, w, function (a) {\n              g = a\n            })\n            this.recurse(a.right, w, w, function (a) {\n              l = a\n            })\n            p =\n              '+' === a.operator\n                ? this.plus(g, l)\n                : '-' === a.operator\n                ? this.ifDefined(g, 0) + a.operator + this.ifDefined(l, 0)\n                : '(' + g + ')' + a.operator + '(' + l + ')'\n            this.assign(c, p)\n            e(p)\n            break\n          case s.LogicalExpression:\n            c = c || this.nextId()\n            k.recurse(a.left, c)\n            k.if_('&&' === a.operator ? c : k.not(c), k.lazyRecurse(a.right, c))\n            e(c)\n            break\n          case s.ConditionalExpression:\n            c = c || this.nextId()\n            k.recurse(a.test, c)\n            k.if_(c, k.lazyRecurse(a.alternate, c), k.lazyRecurse(a.consequent, c))\n            e(c)\n            break\n          case s.Identifier:\n            c = c || this.nextId()\n            d &&\n              ((d.context =\n                'inputs' === k.stage ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', a.name) + '?l:s')),\n              (d.computed = !1),\n              (d.name = a.name))\n            Xa(a.name)\n            k.if_(\n              'inputs' === k.stage || k.not(k.getHasOwnProperty('l', a.name)),\n              function () {\n                k.if_('inputs' === k.stage || 's', function () {\n                  f &&\n                    1 !== f &&\n                    k.if_(k.not(k.nonComputedMember('s', a.name)), k.lazyAssign(k.nonComputedMember('s', a.name), '{}'))\n                  k.assign(c, k.nonComputedMember('s', a.name))\n                })\n              },\n              c && k.lazyAssign(c, k.nonComputedMember('l', a.name))\n            )\n            ;(k.state.expensiveChecks || Fb(a.name)) && k.addEnsureSafeObject(c)\n            e(c)\n            break\n          case s.MemberExpression:\n            g = (d && (d.context = this.nextId())) || this.nextId()\n            c = c || this.nextId()\n            k.recurse(\n              a.object,\n              g,\n              w,\n              function () {\n                k.if_(\n                  k.notNull(g),\n                  function () {\n                    if (a.computed)\n                      (l = k.nextId()),\n                        k.recurse(a.property, l),\n                        k.getStringValue(l),\n                        k.addEnsureSafeMemberName(l),\n                        f &&\n                          1 !== f &&\n                          k.if_(k.not(k.computedMember(g, l)), k.lazyAssign(k.computedMember(g, l), '{}')),\n                        (p = k.ensureSafeObject(k.computedMember(g, l))),\n                        k.assign(c, p),\n                        d && ((d.computed = !0), (d.name = l))\n                    else {\n                      Xa(a.property.name)\n                      f &&\n                        1 !== f &&\n                        k.if_(\n                          k.not(k.nonComputedMember(g, a.property.name)),\n                          k.lazyAssign(k.nonComputedMember(g, a.property.name), '{}')\n                        )\n                      p = k.nonComputedMember(g, a.property.name)\n                      if (k.state.expensiveChecks || Fb(a.property.name)) p = k.ensureSafeObject(p)\n                      k.assign(c, p)\n                      d && ((d.computed = !1), (d.name = a.property.name))\n                    }\n                  },\n                  function () {\n                    k.assign(c, 'undefined')\n                  }\n                )\n                e(c)\n              },\n              !!f\n            )\n            break\n          case s.CallExpression:\n            c = c || this.nextId()\n            a.filter\n              ? ((l = k.filter(a.callee.name)),\n                (n = []),\n                m(a.arguments, function (a) {\n                  var c = k.nextId()\n                  k.recurse(a, c)\n                  n.push(c)\n                }),\n                (p = l + '(' + n.join(',') + ')'),\n                k.assign(c, p),\n                e(c))\n              : ((l = k.nextId()),\n                (g = {}),\n                (n = []),\n                k.recurse(a.callee, l, g, function () {\n                  k.if_(\n                    k.notNull(l),\n                    function () {\n                      k.addEnsureSafeFunction(l)\n                      m(a.arguments, function (a) {\n                        k.recurse(a, k.nextId(), w, function (a) {\n                          n.push(k.ensureSafeObject(a))\n                        })\n                      })\n                      g.name\n                        ? (k.state.expensiveChecks || k.addEnsureSafeObject(g.context),\n                          (p = k.member(g.context, g.name, g.computed) + '(' + n.join(',') + ')'))\n                        : (p = l + '(' + n.join(',') + ')')\n                      p = k.ensureSafeObject(p)\n                      k.assign(c, p)\n                    },\n                    function () {\n                      k.assign(c, 'undefined')\n                    }\n                  )\n                  e(c)\n                }))\n            break\n          case s.AssignmentExpression:\n            l = this.nextId()\n            g = {}\n            if (!pd(a.left)) throw Z('lval')\n            this.recurse(\n              a.left,\n              w,\n              g,\n              function () {\n                k.if_(k.notNull(g.context), function () {\n                  k.recurse(a.right, l)\n                  k.addEnsureSafeObject(k.member(g.context, g.name, g.computed))\n                  k.addEnsureSafeAssignContext(g.context)\n                  p = k.member(g.context, g.name, g.computed) + a.operator + l\n                  k.assign(c, p)\n                  e(c || p)\n                })\n              },\n              1\n            )\n            break\n          case s.ArrayExpression:\n            n = []\n            m(a.elements, function (a) {\n              k.recurse(a, k.nextId(), w, function (a) {\n                n.push(a)\n              })\n            })\n            p = '[' + n.join(',') + ']'\n            this.assign(c, p)\n            e(p)\n            break\n          case s.ObjectExpression:\n            n = []\n            m(a.properties, function (a) {\n              k.recurse(a.value, k.nextId(), w, function (c) {\n                n.push(k.escape(a.key.type === s.Identifier ? a.key.name : '' + a.key.value) + ':' + c)\n              })\n            })\n            p = '{' + n.join(',') + '}'\n            this.assign(c, p)\n            e(p)\n            break\n          case s.ThisExpression:\n            this.assign(c, 's')\n            e('s')\n            break\n          case s.NGValueParameter:\n            this.assign(c, 'v'), e('v')\n        }\n    },\n    getHasOwnProperty: function (a, c) {\n      var d = a + '.' + c,\n        e = this.current().own\n      e.hasOwnProperty(d) || (e[d] = this.nextId(!1, a + '&&(' + this.escape(c) + ' in ' + a + ')'))\n      return e[d]\n    },\n    assign: function (a, c) {\n      if (a) return this.current().body.push(a, '=', c, ';'), a\n    },\n    filter: function (a) {\n      this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0))\n      return this.state.filters[a]\n    },\n    ifDefined: function (a, c) {\n      return 'ifDefined(' + a + ',' + this.escape(c) + ')'\n    },\n    plus: function (a, c) {\n      return 'plus(' + a + ',' + c + ')'\n    },\n    return_: function (a) {\n      this.current().body.push('return ', a, ';')\n    },\n    if_: function (a, c, d) {\n      if (!0 === a) c()\n      else {\n        var e = this.current().body\n        e.push('if(', a, '){')\n        c()\n        e.push('}')\n        d && (e.push('else{'), d(), e.push('}'))\n      }\n    },\n    not: function (a) {\n      return '!(' + a + ')'\n    },\n    notNull: function (a) {\n      return a + '!=null'\n    },\n    nonComputedMember: function (a, c) {\n      return a + '.' + c\n    },\n    computedMember: function (a, c) {\n      return a + '[' + c + ']'\n    },\n    member: function (a, c, d) {\n      return d ? this.computedMember(a, c) : this.nonComputedMember(a, c)\n    },\n    addEnsureSafeObject: function (a) {\n      this.current().body.push(this.ensureSafeObject(a), ';')\n    },\n    addEnsureSafeMemberName: function (a) {\n      this.current().body.push(this.ensureSafeMemberName(a), ';')\n    },\n    addEnsureSafeFunction: function (a) {\n      this.current().body.push(this.ensureSafeFunction(a), ';')\n    },\n    addEnsureSafeAssignContext: function (a) {\n      this.current().body.push(this.ensureSafeAssignContext(a), ';')\n    },\n    ensureSafeObject: function (a) {\n      return 'ensureSafeObject(' + a + ',text)'\n    },\n    ensureSafeMemberName: function (a) {\n      return 'ensureSafeMemberName(' + a + ',text)'\n    },\n    ensureSafeFunction: function (a) {\n      return 'ensureSafeFunction(' + a + ',text)'\n    },\n    getStringValue: function (a) {\n      this.assign(a, 'getStringValue(' + a + ',text)')\n    },\n    ensureSafeAssignContext: function (a) {\n      return 'ensureSafeAssignContext(' + a + ',text)'\n    },\n    lazyRecurse: function (a, c, d, e, f, h) {\n      var g = this\n      return function () {\n        g.recurse(a, c, d, e, f, h)\n      }\n    },\n    lazyAssign: function (a, c) {\n      var d = this\n      return function () {\n        d.assign(a, c)\n      }\n    },\n    stringEscapeRegex: /[^ a-zA-Z0-9]/g,\n    stringEscapeFn: function (a) {\n      return '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4)\n    },\n    escape: function (a) {\n      if (G(a)) return \"'\" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + \"'\"\n      if (V(a)) return a.toString()\n      if (!0 === a) return 'true'\n      if (!1 === a) return 'false'\n      if (null === a) return 'null'\n      if ('undefined' === typeof a) return 'undefined'\n      throw Z('esc')\n    },\n    nextId: function (a, c) {\n      var d = 'v' + this.state.nextId++\n      a || this.current().vars.push(d + (c ? '=' + c : ''))\n      return d\n    },\n    current: function () {\n      return this.state[this.state.computing]\n    }\n  }\n  td.prototype = {\n    compile: function (a, c) {\n      var d = this,\n        e = this.astBuilder.ast(a)\n      this.expression = a\n      this.expensiveChecks = c\n      U(e, d.$filter)\n      var f, h\n      if ((f = qd(e))) h = this.recurse(f)\n      f = od(e.body)\n      var g\n      f &&\n        ((g = []),\n        m(f, function (a, c) {\n          var e = d.recurse(a)\n          a.input = e\n          g.push(e)\n          a.watchId = c\n        }))\n      var l = []\n      m(e.body, function (a) {\n        l.push(d.recurse(a.expression))\n      })\n      f =\n        0 === e.body.length\n          ? function () {}\n          : 1 === e.body.length\n          ? l[0]\n          : function (a, c) {\n              var d\n              m(l, function (e) {\n                d = e(a, c)\n              })\n              return d\n            }\n      h &&\n        (f.assign = function (a, c, d) {\n          return h(a, d, c)\n        })\n      g && (f.inputs = g)\n      f.literal = rd(e)\n      f.constant = e.constant\n      return f\n    },\n    recurse: function (a, c, d) {\n      var e,\n        f,\n        h = this,\n        g\n      if (a.input) return this.inputs(a.input, a.watchId)\n      switch (a.type) {\n        case s.Literal:\n          return this.value(a.value, c)\n        case s.UnaryExpression:\n          return (f = this.recurse(a.argument)), this['unary' + a.operator](f, c)\n        case s.BinaryExpression:\n          return (e = this.recurse(a.left)), (f = this.recurse(a.right)), this['binary' + a.operator](e, f, c)\n        case s.LogicalExpression:\n          return (e = this.recurse(a.left)), (f = this.recurse(a.right)), this['binary' + a.operator](e, f, c)\n        case s.ConditionalExpression:\n          return this['ternary?:'](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), c)\n        case s.Identifier:\n          return Xa(a.name, h.expression), h.identifier(a.name, h.expensiveChecks || Fb(a.name), c, d, h.expression)\n        case s.MemberExpression:\n          return (\n            (e = this.recurse(a.object, !1, !!d)),\n            a.computed || (Xa(a.property.name, h.expression), (f = a.property.name)),\n            a.computed && (f = this.recurse(a.property)),\n            a.computed\n              ? this.computedMember(e, f, c, d, h.expression)\n              : this.nonComputedMember(e, f, h.expensiveChecks, c, d, h.expression)\n          )\n        case s.CallExpression:\n          return (\n            (g = []),\n            m(a.arguments, function (a) {\n              g.push(h.recurse(a))\n            }),\n            a.filter && (f = this.$filter(a.callee.name)),\n            a.filter || (f = this.recurse(a.callee, !0)),\n            a.filter\n              ? function (a, d, e, h) {\n                  for (var r = [], m = 0; m < g.length; ++m) r.push(g[m](a, d, e, h))\n                  a = f.apply(w, r, h)\n                  return c ? { context: w, name: w, value: a } : a\n                }\n              : function (a, d, e, p) {\n                  var r = f(a, d, e, p),\n                    m\n                  if (null != r.value) {\n                    Ba(r.context, h.expression)\n                    ld(r.value, h.expression)\n                    m = []\n                    for (var s = 0; s < g.length; ++s) m.push(Ba(g[s](a, d, e, p), h.expression))\n                    m = Ba(r.value.apply(r.context, m), h.expression)\n                  }\n                  return c ? { value: m } : m\n                }\n          )\n        case s.AssignmentExpression:\n          return (\n            (e = this.recurse(a.left, !0, 1)),\n            (f = this.recurse(a.right)),\n            function (a, d, g, p) {\n              var r = e(a, d, g, p)\n              a = f(a, d, g, p)\n              Ba(r.value, h.expression)\n              md(r.context)\n              r.context[r.name] = a\n              return c ? { value: a } : a\n            }\n          )\n        case s.ArrayExpression:\n          return (\n            (g = []),\n            m(a.elements, function (a) {\n              g.push(h.recurse(a))\n            }),\n            function (a, d, e, f) {\n              for (var h = [], m = 0; m < g.length; ++m) h.push(g[m](a, d, e, f))\n              return c ? { value: h } : h\n            }\n          )\n        case s.ObjectExpression:\n          return (\n            (g = []),\n            m(a.properties, function (a) {\n              g.push({ key: a.key.type === s.Identifier ? a.key.name : '' + a.key.value, value: h.recurse(a.value) })\n            }),\n            function (a, d, e, f) {\n              for (var h = {}, m = 0; m < g.length; ++m) h[g[m].key] = g[m].value(a, d, e, f)\n              return c ? { value: h } : h\n            }\n          )\n        case s.ThisExpression:\n          return function (a) {\n            return c ? { value: a } : a\n          }\n        case s.NGValueParameter:\n          return function (a, d, e, f) {\n            return c ? { value: e } : e\n          }\n      }\n    },\n    'unary+': function (a, c) {\n      return function (d, e, f, h) {\n        d = a(d, e, f, h)\n        d = A(d) ? +d : 0\n        return c ? { value: d } : d\n      }\n    },\n    'unary-': function (a, c) {\n      return function (d, e, f, h) {\n        d = a(d, e, f, h)\n        d = A(d) ? -d : 0\n        return c ? { value: d } : d\n      }\n    },\n    'unary!': function (a, c) {\n      return function (d, e, f, h) {\n        d = !a(d, e, f, h)\n        return c ? { value: d } : d\n      }\n    },\n    'binary+': function (a, c, d) {\n      return function (e, f, h, g) {\n        var l = a(e, f, h, g)\n        e = c(e, f, h, g)\n        l = nd(l, e)\n        return d ? { value: l } : l\n      }\n    },\n    'binary-': function (a, c, d) {\n      return function (e, f, h, g) {\n        var l = a(e, f, h, g)\n        e = c(e, f, h, g)\n        l = (A(l) ? l : 0) - (A(e) ? e : 0)\n        return d ? { value: l } : l\n      }\n    },\n    'binary*': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) * c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary/': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) / c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary%': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) % c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary===': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) === c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary!==': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) !== c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary==': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) == c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary!=': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) != c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary<': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) < c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary>': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) > c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary<=': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) <= c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary>=': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) >= c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary&&': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) && c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'binary||': function (a, c, d) {\n      return function (e, f, h, g) {\n        e = a(e, f, h, g) || c(e, f, h, g)\n        return d ? { value: e } : e\n      }\n    },\n    'ternary?:': function (a, c, d, e) {\n      return function (f, h, g, l) {\n        f = a(f, h, g, l) ? c(f, h, g, l) : d(f, h, g, l)\n        return e ? { value: f } : f\n      }\n    },\n    value: function (a, c) {\n      return function () {\n        return c ? { context: w, name: w, value: a } : a\n      }\n    },\n    identifier: function (a, c, d, e, f) {\n      return function (h, g, l, k) {\n        h = g && a in g ? g : h\n        e && 1 !== e && h && !h[a] && (h[a] = {})\n        g = h ? h[a] : w\n        c && Ba(g, f)\n        return d ? { context: h, name: a, value: g } : g\n      }\n    },\n    computedMember: function (a, c, d, e, f) {\n      return function (h, g, l, k) {\n        var n = a(h, g, l, k),\n          p,\n          m\n        null != n &&\n          ((p = c(h, g, l, k)), (p = kd(p)), Xa(p, f), e && 1 !== e && n && !n[p] && (n[p] = {}), (m = n[p]), Ba(m, f))\n        return d ? { context: n, name: p, value: m } : m\n      }\n    },\n    nonComputedMember: function (a, c, d, e, f, h) {\n      return function (g, l, k, n) {\n        g = a(g, l, k, n)\n        f && 1 !== f && g && !g[c] && (g[c] = {})\n        l = null != g ? g[c] : w\n        ;(d || Fb(c)) && Ba(l, h)\n        return e ? { context: g, name: c, value: l } : l\n      }\n    },\n    inputs: function (a, c) {\n      return function (d, e, f, h) {\n        return h ? h[c] : a(d, e, f)\n      }\n    }\n  }\n  var fc = function (a, c, d) {\n    this.lexer = a\n    this.$filter = c\n    this.options = d\n    this.ast = new s(this.lexer)\n    this.astCompiler = d.csp ? new td(this.ast, c) : new sd(this.ast, c)\n  }\n  fc.prototype = {\n    constructor: fc,\n    parse: function (a) {\n      return this.astCompiler.compile(a, this.options.expensiveChecks)\n    }\n  }\n  fa()\n  fa()\n  var Yf = Object.prototype.valueOf,\n    Ca = I('$sce'),\n    oa = { HTML: 'html', CSS: 'css', URL: 'url', RESOURCE_URL: 'resourceUrl', JS: 'js' },\n    ga = I('$compile'),\n    $ = X.createElement('a'),\n    xd = Aa(Q.location.href)\n  yd.$inject = ['$document']\n  Kc.$inject = ['$provide']\n  zd.$inject = ['$locale']\n  Bd.$inject = ['$locale']\n  var hc = '.',\n    hg = {\n      yyyy: aa('FullYear', 4),\n      yy: aa('FullYear', 2, 0, !0),\n      y: aa('FullYear', 1),\n      MMMM: Hb('Month'),\n      MMM: Hb('Month', !0),\n      MM: aa('Month', 2, 1),\n      M: aa('Month', 1, 1),\n      dd: aa('Date', 2),\n      d: aa('Date', 1),\n      HH: aa('Hours', 2),\n      H: aa('Hours', 1),\n      hh: aa('Hours', 2, -12),\n      h: aa('Hours', 1, -12),\n      mm: aa('Minutes', 2),\n      m: aa('Minutes', 1),\n      ss: aa('Seconds', 2),\n      s: aa('Seconds', 1),\n      sss: aa('Milliseconds', 3),\n      EEEE: Hb('Day'),\n      EEE: Hb('Day', !0),\n      a: function (a, c) {\n        return 12 > a.getHours() ? c.AMPMS[0] : c.AMPMS[1]\n      },\n      Z: function (a, c, d) {\n        a = -1 * d\n        return (a = (0 <= a ? '+' : '') + (Gb(Math[0 < a ? 'floor' : 'ceil'](a / 60), 2) + Gb(Math.abs(a % 60), 2)))\n      },\n      ww: Fd(2),\n      w: Fd(1),\n      G: ic,\n      GG: ic,\n      GGG: ic,\n      GGGG: function (a, c) {\n        return 0 >= a.getFullYear() ? c.ERANAMES[0] : c.ERANAMES[1]\n      }\n    },\n    gg = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/,\n    fg = /^\\-?\\d+$/\n  Ad.$inject = ['$locale']\n  var cg = qa(F),\n    dg = qa(sb)\n  Cd.$inject = ['$parse']\n  var he = qa({\n      restrict: 'E',\n      compile: function (a, c) {\n        if (!c.href && !c.xlinkHref)\n          return function (a, c) {\n            if ('a' === c[0].nodeName.toLowerCase()) {\n              var f = '[object SVGAnimatedString]' === va.call(c.prop('href')) ? 'xlink:href' : 'href'\n              c.on('click', function (a) {\n                c.attr(f) || a.preventDefault()\n              })\n            }\n          }\n      }\n    }),\n    tb = {}\n  m(Bb, function (a, c) {\n    function d (a, d, f) {\n      a.$watch(f[e], function (a) {\n        f.$set(c, !!a)\n      })\n    }\n    if ('multiple' != a) {\n      var e = ya('ng-' + c),\n        f = d\n      'checked' === a &&\n        (f = function (a, c, f) {\n          f.ngModel !== f[e] && d(a, c, f)\n        })\n      tb[e] = function () {\n        return { restrict: 'A', priority: 100, link: f }\n      }\n    }\n  })\n  m($c, function (a, c) {\n    tb[c] = function () {\n      return {\n        priority: 100,\n        link: function (a, e, f) {\n          if ('ngPattern' === c && '/' == f.ngPattern.charAt(0) && (e = f.ngPattern.match(jg))) {\n            f.$set('ngPattern', new RegExp(e[1], e[2]))\n            return\n          }\n          a.$watch(f[c], function (a) {\n            f.$set(c, a)\n          })\n        }\n      }\n    }\n  })\n  m(['src', 'srcset', 'href'], function (a) {\n    var c = ya('ng-' + a)\n    tb[c] = function () {\n      return {\n        priority: 99,\n        link: function (d, e, f) {\n          var h = a,\n            g = a\n          'href' === a &&\n            '[object SVGAnimatedString]' === va.call(e.prop('href')) &&\n            ((g = 'xlinkHref'), (f.$attr[g] = 'xlink:href'), (h = null))\n          f.$observe(c, function (c) {\n            c ? (f.$set(g, c), Wa && h && e.prop(h, f[g])) : 'href' === a && f.$set(g, null)\n          })\n        }\n      }\n    }\n  })\n  var Ib = {\n    $addControl: y,\n    $$renameControl: function (a, c) {\n      a.$name = c\n    },\n    $removeControl: y,\n    $setValidity: y,\n    $setDirty: y,\n    $setPristine: y,\n    $setSubmitted: y\n  }\n  Gd.$inject = ['$element', '$attrs', '$scope', '$animate', '$interpolate']\n  var Od = function (a) {\n      return [\n        '$timeout',\n        '$parse',\n        function (c, d) {\n          function e (a) {\n            return '' === a ? d('this[\"\"]').assign : d(a).assign || y\n          }\n          return {\n            name: 'form',\n            restrict: a ? 'EAC' : 'E',\n            require: ['form', '^^?form'],\n            controller: Gd,\n            compile: function (d, h) {\n              d.addClass(Ya).addClass(mb)\n              var g = h.name ? 'name' : a && h.ngForm ? 'ngForm' : !1\n              return {\n                pre: function (a, d, f, h) {\n                  var m = h[0]\n                  if (!('action' in f)) {\n                    var t = function (c) {\n                      a.$apply(function () {\n                        m.$commitViewValue()\n                        m.$setSubmitted()\n                      })\n                      c.preventDefault()\n                    }\n                    d[0].addEventListener('submit', t, !1)\n                    d.on('$destroy', function () {\n                      c(\n                        function () {\n                          d[0].removeEventListener('submit', t, !1)\n                        },\n                        0,\n                        !1\n                      )\n                    })\n                  }\n                  ;(h[1] || m.$$parentForm).$addControl(m)\n                  var s = g ? e(m.$name) : y\n                  g &&\n                    (s(a, m),\n                    f.$observe(g, function (c) {\n                      m.$name !== c && (s(a, w), m.$$parentForm.$$renameControl(m, c), (s = e(m.$name)), s(a, m))\n                    }))\n                  d.on('$destroy', function () {\n                    m.$$parentForm.$removeControl(m)\n                    s(a, w)\n                    P(m, Ib)\n                  })\n                }\n              }\n            }\n          }\n        }\n      ]\n    },\n    ie = Od(),\n    ve = Od(!0),\n    ig = /\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z)/,\n    sg = /^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/,\n    tg = /^[a-z0-9!#$%&'*+\\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i,\n    ug = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))([eE][+-]?\\d+)?\\s*$/,\n    Pd = /^(\\d{4})-(\\d{2})-(\\d{2})$/,\n    Qd = /^(\\d{4})-(\\d\\d)-(\\d\\d)T(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,\n    lc = /^(\\d{4})-W(\\d\\d)$/,\n    Rd = /^(\\d{4})-(\\d\\d)$/,\n    Sd = /^(\\d\\d):(\\d\\d)(?::(\\d\\d)(\\.\\d{1,3})?)?$/,\n    Td = {\n      text: function (a, c, d, e, f, h) {\n        jb(a, c, d, e, f, h)\n        jc(e)\n      },\n      date: kb('date', Pd, Kb(Pd, ['yyyy', 'MM', 'dd']), 'yyyy-MM-dd'),\n      'datetime-local': kb(\n        'datetimelocal',\n        Qd,\n        Kb(Qd, 'yyyy MM dd HH mm ss sss'.split(' ')),\n        'yyyy-MM-ddTHH:mm:ss.sss'\n      ),\n      time: kb('time', Sd, Kb(Sd, ['HH', 'mm', 'ss', 'sss']), 'HH:mm:ss.sss'),\n      week: kb(\n        'week',\n        lc,\n        function (a, c) {\n          if (ea(a)) return a\n          if (G(a)) {\n            lc.lastIndex = 0\n            var d = lc.exec(a)\n            if (d) {\n              var e = +d[1],\n                f = +d[2],\n                h = (d = 0),\n                g = 0,\n                l = 0,\n                k = Ed(e),\n                f = 7 * (f - 1)\n              c && ((d = c.getHours()), (h = c.getMinutes()), (g = c.getSeconds()), (l = c.getMilliseconds()))\n              return new Date(e, 0, k.getDate() + f, d, h, g, l)\n            }\n          }\n          return NaN\n        },\n        'yyyy-Www'\n      ),\n      month: kb('month', Rd, Kb(Rd, ['yyyy', 'MM']), 'yyyy-MM'),\n      number: function (a, c, d, e, f, h) {\n        Id(a, c, d, e)\n        jb(a, c, d, e, f, h)\n        e.$$parserName = 'number'\n        e.$parsers.push(function (a) {\n          return e.$isEmpty(a) ? null : ug.test(a) ? parseFloat(a) : w\n        })\n        e.$formatters.push(function (a) {\n          if (!e.$isEmpty(a)) {\n            if (!V(a)) throw lb('numfmt', a)\n            a = a.toString()\n          }\n          return a\n        })\n        if (A(d.min) || d.ngMin) {\n          var g\n          e.$validators.min = function (a) {\n            return e.$isEmpty(a) || v(g) || a >= g\n          }\n          d.$observe('min', function (a) {\n            A(a) && !V(a) && (a = parseFloat(a, 10))\n            g = V(a) && !isNaN(a) ? a : w\n            e.$validate()\n          })\n        }\n        if (A(d.max) || d.ngMax) {\n          var l\n          e.$validators.max = function (a) {\n            return e.$isEmpty(a) || v(l) || a <= l\n          }\n          d.$observe('max', function (a) {\n            A(a) && !V(a) && (a = parseFloat(a, 10))\n            l = V(a) && !isNaN(a) ? a : w\n            e.$validate()\n          })\n        }\n      },\n      url: function (a, c, d, e, f, h) {\n        jb(a, c, d, e, f, h)\n        jc(e)\n        e.$$parserName = 'url'\n        e.$validators.url = function (a, c) {\n          var d = a || c\n          return e.$isEmpty(d) || sg.test(d)\n        }\n      },\n      email: function (a, c, d, e, f, h) {\n        jb(a, c, d, e, f, h)\n        jc(e)\n        e.$$parserName = 'email'\n        e.$validators.email = function (a, c) {\n          var d = a || c\n          return e.$isEmpty(d) || tg.test(d)\n        }\n      },\n      radio: function (a, c, d, e) {\n        v(d.name) && c.attr('name', ++nb)\n        c.on('click', function (a) {\n          c[0].checked && e.$setViewValue(d.value, a && a.type)\n        })\n        e.$render = function () {\n          c[0].checked = d.value == e.$viewValue\n        }\n        d.$observe('value', e.$render)\n      },\n      checkbox: function (a, c, d, e, f, h, g, l) {\n        var k = Jd(l, a, 'ngTrueValue', d.ngTrueValue, !0),\n          n = Jd(l, a, 'ngFalseValue', d.ngFalseValue, !1)\n        c.on('click', function (a) {\n          e.$setViewValue(c[0].checked, a && a.type)\n        })\n        e.$render = function () {\n          c[0].checked = e.$viewValue\n        }\n        e.$isEmpty = function (a) {\n          return !1 === a\n        }\n        e.$formatters.push(function (a) {\n          return ka(a, k)\n        })\n        e.$parsers.push(function (a) {\n          return a ? k : n\n        })\n      },\n      hidden: y,\n      button: y,\n      submit: y,\n      reset: y,\n      file: y\n    },\n    Ec = [\n      '$browser',\n      '$sniffer',\n      '$filter',\n      '$parse',\n      function (a, c, d, e) {\n        return {\n          restrict: 'E',\n          require: ['?ngModel'],\n          link: {\n            pre: function (f, h, g, l) {\n              l[0] && (Td[F(g.type)] || Td.text)(f, h, g, l[0], c, a, d, e)\n            }\n          }\n        }\n      }\n    ],\n    vg = /^(true|false|\\d+)$/,\n    Ne = function () {\n      return {\n        restrict: 'A',\n        priority: 100,\n        compile: function (a, c) {\n          return vg.test(c.ngValue)\n            ? function (a, c, f) {\n                f.$set('value', a.$eval(f.ngValue))\n              }\n            : function (a, c, f) {\n                a.$watch(f.ngValue, function (a) {\n                  f.$set('value', a)\n                })\n              }\n        }\n      }\n    },\n    ne = [\n      '$compile',\n      function (a) {\n        return {\n          restrict: 'AC',\n          compile: function (c) {\n            a.$$addBindingClass(c)\n            return function (c, e, f) {\n              a.$$addBindingInfo(e, f.ngBind)\n              e = e[0]\n              c.$watch(f.ngBind, function (a) {\n                e.textContent = v(a) ? '' : a\n              })\n            }\n          }\n        }\n      }\n    ],\n    pe = [\n      '$interpolate',\n      '$compile',\n      function (a, c) {\n        return {\n          compile: function (d) {\n            c.$$addBindingClass(d)\n            return function (d, f, h) {\n              d = a(f.attr(h.$attr.ngBindTemplate))\n              c.$$addBindingInfo(f, d.expressions)\n              f = f[0]\n              h.$observe('ngBindTemplate', function (a) {\n                f.textContent = v(a) ? '' : a\n              })\n            }\n          }\n        }\n      }\n    ],\n    oe = [\n      '$sce',\n      '$parse',\n      '$compile',\n      function (a, c, d) {\n        return {\n          restrict: 'A',\n          compile: function (e, f) {\n            var h = c(f.ngBindHtml),\n              g = c(f.ngBindHtml, function (a) {\n                return (a || '').toString()\n              })\n            d.$$addBindingClass(e)\n            return function (c, e, f) {\n              d.$$addBindingInfo(e, f.ngBindHtml)\n              c.$watch(g, function () {\n                e.html(a.getTrustedHtml(h(c)) || '')\n              })\n            }\n          }\n        }\n      }\n    ],\n    Me = qa({\n      restrict: 'A',\n      require: 'ngModel',\n      link: function (a, c, d, e) {\n        e.$viewChangeListeners.push(function () {\n          a.$eval(d.ngChange)\n        })\n      }\n    }),\n    qe = kc('', !0),\n    se = kc('Odd', 0),\n    re = kc('Even', 1),\n    te = Na({\n      compile: function (a, c) {\n        c.$set('ngCloak', w)\n        a.removeClass('ng-cloak')\n      }\n    }),\n    ue = [\n      function () {\n        return { restrict: 'A', scope: !0, controller: '@', priority: 500 }\n      }\n    ],\n    Jc = {},\n    wg = { blur: !0, focus: !0 }\n  m(\n    'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(\n      ' '\n    ),\n    function (a) {\n      var c = ya('ng-' + a)\n      Jc[c] = [\n        '$parse',\n        '$rootScope',\n        function (d, e) {\n          return {\n            restrict: 'A',\n            compile: function (f, h) {\n              var g = d(h[c], null, !0)\n              return function (c, d) {\n                d.on(a, function (d) {\n                  var f = function () {\n                    g(c, { $event: d })\n                  }\n                  wg[a] && e.$$phase ? c.$evalAsync(f) : c.$apply(f)\n                })\n              }\n            }\n          }\n        }\n      ]\n    }\n  )\n  var xe = [\n      '$animate',\n      function (a) {\n        return {\n          multiElement: !0,\n          transclude: 'element',\n          priority: 600,\n          terminal: !0,\n          restrict: 'A',\n          $$tlb: !0,\n          link: function (c, d, e, f, h) {\n            var g, l, k\n            c.$watch(e.ngIf, function (c) {\n              c\n                ? l ||\n                  h(function (c, f) {\n                    l = f\n                    c[c.length++] = X.createComment(' end ngIf: ' + e.ngIf + ' ')\n                    g = { clone: c }\n                    a.enter(c, d.parent(), d)\n                  })\n                : (k && (k.remove(), (k = null)),\n                  l && (l.$destroy(), (l = null)),\n                  g &&\n                    ((k = rb(g.clone)),\n                    a.leave(k).then(function () {\n                      k = null\n                    }),\n                    (g = null)))\n            })\n          }\n        }\n      }\n    ],\n    ye = [\n      '$templateRequest',\n      '$anchorScroll',\n      '$animate',\n      function (a, c, d) {\n        return {\n          restrict: 'ECA',\n          priority: 400,\n          terminal: !0,\n          transclude: 'element',\n          controller: da.noop,\n          compile: function (e, f) {\n            var h = f.ngInclude || f.src,\n              g = f.onload || '',\n              l = f.autoscroll\n            return function (e, f, m, r, t) {\n              var s = 0,\n                v,\n                u,\n                q,\n                z = function () {\n                  u && (u.remove(), (u = null))\n                  v && (v.$destroy(), (v = null))\n                  q &&\n                    (d.leave(q).then(function () {\n                      u = null\n                    }),\n                    (u = q),\n                    (q = null))\n                }\n              e.$watch(h, function (h) {\n                var m = function () {\n                    !A(l) || (l && !e.$eval(l)) || c()\n                  },\n                  p = ++s\n                h\n                  ? (a(h, !0).then(\n                      function (a) {\n                        if (p === s) {\n                          var c = e.$new()\n                          r.template = a\n                          a = t(c, function (a) {\n                            z()\n                            d.enter(a, null, f).then(m)\n                          })\n                          v = c\n                          q = a\n                          v.$emit('$includeContentLoaded', h)\n                          e.$eval(g)\n                        }\n                      },\n                      function () {\n                        p === s && (z(), e.$emit('$includeContentError', h))\n                      }\n                    ),\n                    e.$emit('$includeContentRequested', h))\n                  : (z(), (r.template = null))\n              })\n            }\n          }\n        }\n      }\n    ],\n    Pe = [\n      '$compile',\n      function (a) {\n        return {\n          restrict: 'ECA',\n          priority: -400,\n          require: 'ngInclude',\n          link: function (c, d, e, f) {\n            ;/SVG/.test(d[0].toString())\n              ? (d.empty(),\n                a(Mc(f.template, X).childNodes)(\n                  c,\n                  function (a) {\n                    d.append(a)\n                  },\n                  { futureParentElement: d }\n                ))\n              : (d.html(f.template), a(d.contents())(c))\n          }\n        }\n      }\n    ],\n    ze = Na({\n      priority: 450,\n      compile: function () {\n        return {\n          pre: function (a, c, d) {\n            a.$eval(d.ngInit)\n          }\n        }\n      }\n    }),\n    Le = function () {\n      return {\n        restrict: 'A',\n        priority: 100,\n        require: 'ngModel',\n        link: function (a, c, d, e) {\n          var f = c.attr(d.$attr.ngList) || ', ',\n            h = 'false' !== d.ngTrim,\n            g = h ? T(f) : f\n          e.$parsers.push(function (a) {\n            if (!v(a)) {\n              var c = []\n              a &&\n                m(a.split(g), function (a) {\n                  a && c.push(h ? T(a) : a)\n                })\n              return c\n            }\n          })\n          e.$formatters.push(function (a) {\n            return J(a) ? a.join(f) : w\n          })\n          e.$isEmpty = function (a) {\n            return !a || !a.length\n          }\n        }\n      }\n    },\n    mb = 'ng-valid',\n    Kd = 'ng-invalid',\n    Ya = 'ng-pristine',\n    Jb = 'ng-dirty',\n    Md = 'ng-pending',\n    lb = I('ngModel'),\n    xg = [\n      '$scope',\n      '$exceptionHandler',\n      '$attrs',\n      '$element',\n      '$parse',\n      '$animate',\n      '$timeout',\n      '$rootScope',\n      '$q',\n      '$interpolate',\n      function (a, c, d, e, f, h, g, l, k, n) {\n        this.$modelValue = this.$viewValue = Number.NaN\n        this.$$rawModelValue = w\n        this.$validators = {}\n        this.$asyncValidators = {}\n        this.$parsers = []\n        this.$formatters = []\n        this.$viewChangeListeners = []\n        this.$untouched = !0\n        this.$touched = !1\n        this.$pristine = !0\n        this.$dirty = !1\n        this.$valid = !0\n        this.$invalid = !1\n        this.$error = {}\n        this.$$success = {}\n        this.$pending = w\n        this.$name = n(d.name || '', !1)(a)\n        this.$$parentForm = Ib\n        var p = f(d.ngModel),\n          r = p.assign,\n          t = p,\n          s = r,\n          K = null,\n          u,\n          q = this\n        this.$$setOptions = function (a) {\n          if ((q.$options = a) && a.getterSetter) {\n            var c = f(d.ngModel + '()'),\n              g = f(d.ngModel + '($$$p)')\n            t = function (a) {\n              var d = p(a)\n              x(d) && (d = c(a))\n              return d\n            }\n            s = function (a, c) {\n              x(p(a)) ? g(a, { $$$p: q.$modelValue }) : r(a, q.$modelValue)\n            }\n          } else if (!p.assign) throw lb('nonassign', d.ngModel, xa(e))\n        }\n        this.$render = y\n        this.$isEmpty = function (a) {\n          return v(a) || '' === a || null === a || a !== a\n        }\n        var z = 0\n        Hd({\n          ctrl: this,\n          $element: e,\n          set: function (a, c) {\n            a[c] = !0\n          },\n          unset: function (a, c) {\n            delete a[c]\n          },\n          $animate: h\n        })\n        this.$setPristine = function () {\n          q.$dirty = !1\n          q.$pristine = !0\n          h.removeClass(e, Jb)\n          h.addClass(e, Ya)\n        }\n        this.$setDirty = function () {\n          q.$dirty = !0\n          q.$pristine = !1\n          h.removeClass(e, Ya)\n          h.addClass(e, Jb)\n          q.$$parentForm.$setDirty()\n        }\n        this.$setUntouched = function () {\n          q.$touched = !1\n          q.$untouched = !0\n          h.setClass(e, 'ng-untouched', 'ng-touched')\n        }\n        this.$setTouched = function () {\n          q.$touched = !0\n          q.$untouched = !1\n          h.setClass(e, 'ng-touched', 'ng-untouched')\n        }\n        this.$rollbackViewValue = function () {\n          g.cancel(K)\n          q.$viewValue = q.$$lastCommittedViewValue\n          q.$render()\n        }\n        this.$validate = function () {\n          if (!V(q.$modelValue) || !isNaN(q.$modelValue)) {\n            var a = q.$$rawModelValue,\n              c = q.$valid,\n              d = q.$modelValue,\n              e = q.$options && q.$options.allowInvalid\n            q.$$runValidators(a, q.$$lastCommittedViewValue, function (f) {\n              e || c === f || ((q.$modelValue = f ? a : w), q.$modelValue !== d && q.$$writeModelToScope())\n            })\n          }\n        }\n        this.$$runValidators = function (a, c, d) {\n          function e () {\n            var d = !0\n            m(q.$validators, function (e, f) {\n              var h = e(a, c)\n              d = d && h\n              g(f, h)\n            })\n            return d\n              ? !0\n              : (m(q.$asyncValidators, function (a, c) {\n                  g(c, null)\n                }),\n                !1)\n          }\n          function f () {\n            var d = [],\n              e = !0\n            m(q.$asyncValidators, function (f, h) {\n              var k = f(a, c)\n              if (!k || !x(k.then)) throw lb('$asyncValidators', k)\n              g(h, w)\n              d.push(\n                k.then(\n                  function () {\n                    g(h, !0)\n                  },\n                  function (a) {\n                    e = !1\n                    g(h, !1)\n                  }\n                )\n              )\n            })\n            d.length\n              ? k.all(d).then(function () {\n                  h(e)\n                }, y)\n              : h(!0)\n          }\n          function g (a, c) {\n            l === z && q.$setValidity(a, c)\n          }\n          function h (a) {\n            l === z && d(a)\n          }\n          z++\n          var l = z\n          ;(function () {\n            var a = q.$$parserName || 'parse'\n            if (v(u)) g(a, null)\n            else\n              return (\n                u ||\n                  (m(q.$validators, function (a, c) {\n                    g(c, null)\n                  }),\n                  m(q.$asyncValidators, function (a, c) {\n                    g(c, null)\n                  })),\n                g(a, u),\n                u\n              )\n            return !0\n          })()\n            ? e()\n              ? f()\n              : h(!1)\n            : h(!1)\n        }\n        this.$commitViewValue = function () {\n          var a = q.$viewValue\n          g.cancel(K)\n          if (q.$$lastCommittedViewValue !== a || ('' === a && q.$$hasNativeValidators))\n            (q.$$lastCommittedViewValue = a), q.$pristine && this.$setDirty(), this.$$parseAndValidate()\n        }\n        this.$$parseAndValidate = function () {\n          var c = q.$$lastCommittedViewValue\n          if ((u = v(c) ? w : !0))\n            for (var d = 0; d < q.$parsers.length; d++)\n              if (((c = q.$parsers[d](c)), v(c))) {\n                u = !1\n                break\n              }\n          V(q.$modelValue) && isNaN(q.$modelValue) && (q.$modelValue = t(a))\n          var e = q.$modelValue,\n            f = q.$options && q.$options.allowInvalid\n          q.$$rawModelValue = c\n          f && ((q.$modelValue = c), q.$modelValue !== e && q.$$writeModelToScope())\n          q.$$runValidators(c, q.$$lastCommittedViewValue, function (a) {\n            f || ((q.$modelValue = a ? c : w), q.$modelValue !== e && q.$$writeModelToScope())\n          })\n        }\n        this.$$writeModelToScope = function () {\n          s(a, q.$modelValue)\n          m(q.$viewChangeListeners, function (a) {\n            try {\n              a()\n            } catch (d) {\n              c(d)\n            }\n          })\n        }\n        this.$setViewValue = function (a, c) {\n          q.$viewValue = a\n          ;(q.$options && !q.$options.updateOnDefault) || q.$$debounceViewValueCommit(c)\n        }\n        this.$$debounceViewValueCommit = function (c) {\n          var d = 0,\n            e = q.$options\n          e &&\n            A(e.debounce) &&\n            ((e = e.debounce), V(e) ? (d = e) : V(e[c]) ? (d = e[c]) : V(e['default']) && (d = e['default']))\n          g.cancel(K)\n          d\n            ? (K = g(function () {\n                q.$commitViewValue()\n              }, d))\n            : l.$$phase\n            ? q.$commitViewValue()\n            : a.$apply(function () {\n                q.$commitViewValue()\n              })\n        }\n        a.$watch(function () {\n          var c = t(a)\n          if (c !== q.$modelValue && (q.$modelValue === q.$modelValue || c === c)) {\n            q.$modelValue = q.$$rawModelValue = c\n            u = w\n            for (var d = q.$formatters, e = d.length, f = c; e--; ) f = d[e](f)\n            q.$viewValue !== f &&\n              ((q.$viewValue = q.$$lastCommittedViewValue = f), q.$render(), q.$$runValidators(c, f, y))\n          }\n          return c\n        })\n      }\n    ],\n    Ke = [\n      '$rootScope',\n      function (a) {\n        return {\n          restrict: 'A',\n          require: ['ngModel', '^?form', '^?ngModelOptions'],\n          controller: xg,\n          priority: 1,\n          compile: function (c) {\n            c.addClass(Ya)\n              .addClass('ng-untouched')\n              .addClass(mb)\n            return {\n              pre: function (a, c, f, h) {\n                var g = h[0]\n                c = h[1] || g.$$parentForm\n                g.$$setOptions(h[2] && h[2].$options)\n                c.$addControl(g)\n                f.$observe('name', function (a) {\n                  g.$name !== a && g.$$parentForm.$$renameControl(g, a)\n                })\n                a.$on('$destroy', function () {\n                  g.$$parentForm.$removeControl(g)\n                })\n              },\n              post: function (c, e, f, h) {\n                var g = h[0]\n                if (g.$options && g.$options.updateOn)\n                  e.on(g.$options.updateOn, function (a) {\n                    g.$$debounceViewValueCommit(a && a.type)\n                  })\n                e.on('blur', function (e) {\n                  g.$touched || (a.$$phase ? c.$evalAsync(g.$setTouched) : c.$apply(g.$setTouched))\n                })\n              }\n            }\n          }\n        }\n      }\n    ],\n    yg = /(\\s+|^)default(\\s+|$)/,\n    Oe = function () {\n      return {\n        restrict: 'A',\n        controller: [\n          '$scope',\n          '$attrs',\n          function (a, c) {\n            var d = this\n            this.$options = ha(a.$eval(c.ngModelOptions))\n            A(this.$options.updateOn)\n              ? ((this.$options.updateOnDefault = !1),\n                (this.$options.updateOn = T(\n                  this.$options.updateOn.replace(yg, function () {\n                    d.$options.updateOnDefault = !0\n                    return ' '\n                  })\n                )))\n              : (this.$options.updateOnDefault = !0)\n          }\n        ]\n      }\n    },\n    Ae = Na({ terminal: !0, priority: 1e3 }),\n    zg = I('ngOptions'),\n    Ag = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?))?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w]*)|(?:\\(\\s*([\\$\\w][\\$\\w]*)\\s*,\\s*([\\$\\w][\\$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/,\n    Ie = [\n      '$compile',\n      '$parse',\n      function (a, c) {\n        function d (a, d, e) {\n          function f (a, c, d, e, g) {\n            this.selectValue = a\n            this.viewValue = c\n            this.label = d\n            this.group = e\n            this.disabled = g\n          }\n          function n (a) {\n            var c\n            if (!s && Da(a)) c = a\n            else {\n              c = []\n              for (var d in a) a.hasOwnProperty(d) && '$' !== d.charAt(0) && c.push(d)\n            }\n            return c\n          }\n          var m = a.match(Ag)\n          if (!m) throw zg('iexp', a, xa(d))\n          var r = m[5] || m[7],\n            s = m[6]\n          a = / as /.test(m[0]) && m[1]\n          var v = m[9]\n          d = c(m[2] ? m[1] : r)\n          var w = (a && c(a)) || d,\n            u = v && c(v),\n            q = v\n              ? function (a, c) {\n                  return u(e, c)\n                }\n              : function (a) {\n                  return Ga(a)\n                },\n            z = function (a, c) {\n              return q(a, x(a, c))\n            },\n            y = c(m[2] || m[1]),\n            A = c(m[3] || ''),\n            O = c(m[4] || ''),\n            H = c(m[8]),\n            B = {},\n            x = s\n              ? function (a, c) {\n                  B[s] = c\n                  B[r] = a\n                  return B\n                }\n              : function (a) {\n                  B[r] = a\n                  return B\n                }\n          return {\n            trackBy: v,\n            getTrackByValue: z,\n            getWatchables: c(H, function (a) {\n              var c = []\n              a = a || []\n              for (var d = n(a), f = d.length, g = 0; g < f; g++) {\n                var h = a === d ? g : d[g],\n                  k = x(a[h], h),\n                  h = q(a[h], k)\n                c.push(h)\n                if (m[2] || m[1]) (h = y(e, k)), c.push(h)\n                m[4] && ((k = O(e, k)), c.push(k))\n              }\n              return c\n            }),\n            getOptions: function () {\n              for (var a = [], c = {}, d = H(e) || [], g = n(d), h = g.length, m = 0; m < h; m++) {\n                var p = d === g ? m : g[m],\n                  r = x(d[p], p),\n                  s = w(e, r),\n                  p = q(s, r),\n                  t = y(e, r),\n                  u = A(e, r),\n                  r = O(e, r),\n                  s = new f(p, s, t, u, r)\n                a.push(s)\n                c[p] = s\n              }\n              return {\n                items: a,\n                selectValueMap: c,\n                getOptionFromViewValue: function (a) {\n                  return c[z(a)]\n                },\n                getViewValueFromOption: function (a) {\n                  return v ? da.copy(a.viewValue) : a.viewValue\n                }\n              }\n            }\n          }\n        }\n        var e = X.createElement('option'),\n          f = X.createElement('optgroup')\n        return {\n          restrict: 'A',\n          terminal: !0,\n          require: ['select', '?ngModel'],\n          link: function (c, g, l, k) {\n            function n (a, c) {\n              a.element = c\n              c.disabled = a.disabled\n              a.label !== c.label && ((c.label = a.label), (c.textContent = a.label))\n              a.value !== c.value && (c.value = a.selectValue)\n            }\n            function p (a, c, d, e) {\n              c && F(c.nodeName) === d ? (d = c) : ((d = e.cloneNode(!1)), c ? a.insertBefore(d, c) : a.appendChild(d))\n              return d\n            }\n            function r (a) {\n              for (var c; a; ) (c = a.nextSibling), Wb(a), (a = c)\n            }\n            function s (a) {\n              var c = q && q[0],\n                d = H && H[0]\n              if (c || d) for (; a && (a === c || a === d || (c && 8 === c.nodeType)); ) a = a.nextSibling\n              return a\n            }\n            function v () {\n              var a = x && u.readValue()\n              x = C.getOptions()\n              var c = {},\n                d = g[0].firstChild\n              O && g.prepend(q)\n              d = s(d)\n              x.items.forEach(function (a) {\n                var h, k\n                a.group\n                  ? ((h = c[a.group]),\n                    h ||\n                      ((h = p(g[0], d, 'optgroup', f)),\n                      (d = h.nextSibling),\n                      (h.label = a.group),\n                      (h = c[a.group] = { groupElement: h, currentOptionElement: h.firstChild })),\n                    (k = p(h.groupElement, h.currentOptionElement, 'option', e)),\n                    n(a, k),\n                    (h.currentOptionElement = k.nextSibling))\n                  : ((k = p(g[0], d, 'option', e)), n(a, k), (d = k.nextSibling))\n              })\n              Object.keys(c).forEach(function (a) {\n                r(c[a].currentOptionElement)\n              })\n              r(d)\n              w.$render()\n              if (!w.$isEmpty(a)) {\n                var h = u.readValue()\n                ;(C.trackBy ? ka(a, h) : a === h) || (w.$setViewValue(h), w.$render())\n              }\n            }\n            var w = k[1]\n            if (w) {\n              var u = k[0]\n              k = l.multiple\n              for (var q, z = 0, y = g.children(), A = y.length; z < A; z++)\n                if ('' === y[z].value) {\n                  q = y.eq(z)\n                  break\n                }\n              var O = !!q,\n                H = B(e.cloneNode(!1))\n              H.val('?')\n              var x,\n                C = d(l.ngOptions, g, c)\n              k\n                ? ((w.$isEmpty = function (a) {\n                    return !a || 0 === a.length\n                  }),\n                  (u.writeValue = function (a) {\n                    x.items.forEach(function (a) {\n                      a.element.selected = !1\n                    })\n                    a &&\n                      a.forEach(function (a) {\n                        ;(a = x.getOptionFromViewValue(a)) && !a.disabled && (a.element.selected = !0)\n                      })\n                  }),\n                  (u.readValue = function () {\n                    var a = g.val() || [],\n                      c = []\n                    m(a, function (a) {\n                      ;(a = x.selectValueMap[a]) && !a.disabled && c.push(x.getViewValueFromOption(a))\n                    })\n                    return c\n                  }),\n                  C.trackBy &&\n                    c.$watchCollection(\n                      function () {\n                        if (J(w.$viewValue))\n                          return w.$viewValue.map(function (a) {\n                            return C.getTrackByValue(a)\n                          })\n                      },\n                      function () {\n                        w.$render()\n                      }\n                    ))\n                : ((u.writeValue = function (a) {\n                    var c = x.getOptionFromViewValue(a)\n                    c && !c.disabled\n                      ? g[0].value !== c.selectValue &&\n                        (H.remove(),\n                        O || q.remove(),\n                        (g[0].value = c.selectValue),\n                        (c.element.selected = !0),\n                        c.element.setAttribute('selected', 'selected'))\n                      : null === a || O\n                      ? (H.remove(), O || g.prepend(q), g.val(''), q.prop('selected', !0), q.attr('selected', !0))\n                      : (O || q.remove(), g.prepend(H), g.val('?'), H.prop('selected', !0), H.attr('selected', !0))\n                  }),\n                  (u.readValue = function () {\n                    var a = x.selectValueMap[g.val()]\n                    return a && !a.disabled ? (O || q.remove(), H.remove(), x.getViewValueFromOption(a)) : null\n                  }),\n                  C.trackBy &&\n                    c.$watch(\n                      function () {\n                        return C.getTrackByValue(w.$viewValue)\n                      },\n                      function () {\n                        w.$render()\n                      }\n                    ))\n              O ? (q.remove(), a(q)(c), q.removeClass('ng-scope')) : (q = B(e.cloneNode(!1)))\n              v()\n              c.$watchCollection(C.getWatchables, v)\n            }\n          }\n        }\n      }\n    ],\n    Be = [\n      '$locale',\n      '$interpolate',\n      '$log',\n      function (a, c, d) {\n        var e = /{}/g,\n          f = /^when(Minus)?(.+)$/\n        return {\n          link: function (h, g, l) {\n            function k (a) {\n              g.text(a || '')\n            }\n            var n = l.count,\n              p = l.$attr.when && g.attr(l.$attr.when),\n              r = l.offset || 0,\n              s = h.$eval(p) || {},\n              w = {},\n              A = c.startSymbol(),\n              u = c.endSymbol(),\n              q = A + n + '-' + r + u,\n              z = da.noop,\n              x\n            m(l, function (a, c) {\n              var d = f.exec(c)\n              d && ((d = (d[1] ? '-' : '') + F(d[2])), (s[d] = g.attr(l.$attr[c])))\n            })\n            m(s, function (a, d) {\n              w[d] = c(a.replace(e, q))\n            })\n            h.$watch(n, function (c) {\n              var e = parseFloat(c),\n                f = isNaN(e)\n              f || e in s || (e = a.pluralCat(e - r))\n              e === x ||\n                (f && V(x) && isNaN(x)) ||\n                (z(),\n                (f = w[e]),\n                v(f)\n                  ? (null != c && d.debug(\"ngPluralize: no rule defined for '\" + e + \"' in \" + p), (z = y), k())\n                  : (z = h.$watch(f, k)),\n                (x = e))\n            })\n          }\n        }\n      }\n    ],\n    Ce = [\n      '$parse',\n      '$animate',\n      function (a, c) {\n        var d = I('ngRepeat'),\n          e = function (a, c, d, e, k, m, p) {\n            a[d] = e\n            k && (a[k] = m)\n            a.$index = c\n            a.$first = 0 === c\n            a.$last = c === p - 1\n            a.$middle = !(a.$first || a.$last)\n            a.$odd = !(a.$even = 0 === (c & 1))\n          }\n        return {\n          restrict: 'A',\n          multiElement: !0,\n          transclude: 'element',\n          priority: 1e3,\n          terminal: !0,\n          $$tlb: !0,\n          compile: function (f, h) {\n            var g = h.ngRepeat,\n              l = X.createComment(' end ngRepeat: ' + g + ' '),\n              k = g.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/)\n            if (!k) throw d('iexp', g)\n            var n = k[1],\n              p = k[2],\n              r = k[3],\n              s = k[4],\n              k = n.match(/^(?:(\\s*[\\$\\w]+)|\\(\\s*([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\s*\\))$/)\n            if (!k) throw d('iidexp', n)\n            var v = k[3] || k[1],\n              y = k[2]\n            if (\n              r &&\n              (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r) ||\n                /^(null|undefined|this|\\$index|\\$first|\\$middle|\\$last|\\$even|\\$odd|\\$parent|\\$root|\\$id)$/.test(r))\n            )\n              throw d('badident', r)\n            var u,\n              q,\n              z,\n              A,\n              x = { $id: Ga }\n            s\n              ? (u = a(s))\n              : ((z = function (a, c) {\n                  return Ga(c)\n                }),\n                (A = function (a) {\n                  return a\n                }))\n            return function (a, f, h, k, n) {\n              u &&\n                (q = function (c, d, e) {\n                  y && (x[y] = c)\n                  x[v] = d\n                  x.$index = e\n                  return u(a, x)\n                })\n              var s = fa()\n              a.$watchCollection(p, function (h) {\n                var k,\n                  p,\n                  t = f[0],\n                  u,\n                  x = fa(),\n                  C,\n                  G,\n                  J,\n                  M,\n                  I,\n                  F,\n                  L\n                r && (a[r] = h)\n                if (Da(h)) (I = h), (p = q || z)\n                else for (L in ((p = q || A), (I = []), h)) ta.call(h, L) && '$' !== L.charAt(0) && I.push(L)\n                C = I.length\n                L = Array(C)\n                for (k = 0; k < C; k++)\n                  if (((G = h === I ? k : I[k]), (J = h[G]), (M = p(G, J, k)), s[M]))\n                    (F = s[M]), delete s[M], (x[M] = F), (L[k] = F)\n                  else {\n                    if (x[M])\n                      throw (m(L, function (a) {\n                        a && a.scope && (s[a.id] = a)\n                      }),\n                      d('dupes', g, M, J))\n                    L[k] = { id: M, scope: w, clone: w }\n                    x[M] = !0\n                  }\n                for (u in s) {\n                  F = s[u]\n                  M = rb(F.clone)\n                  c.leave(M)\n                  if (M[0].parentNode) for (k = 0, p = M.length; k < p; k++) M[k].$$NG_REMOVED = !0\n                  F.scope.$destroy()\n                }\n                for (k = 0; k < C; k++)\n                  if (((G = h === I ? k : I[k]), (J = h[G]), (F = L[k]), F.scope)) {\n                    u = t\n                    do u = u.nextSibling\n                    while (u && u.$$NG_REMOVED)\n                    F.clone[0] != u && c.move(rb(F.clone), null, B(t))\n                    t = F.clone[F.clone.length - 1]\n                    e(F.scope, k, v, J, y, G, C)\n                  } else\n                    n(function (a, d) {\n                      F.scope = d\n                      var f = l.cloneNode(!1)\n                      a[a.length++] = f\n                      c.enter(a, null, B(t))\n                      t = f\n                      F.clone = a\n                      x[F.id] = F\n                      e(F.scope, k, v, J, y, G, C)\n                    })\n                s = x\n              })\n            }\n          }\n        }\n      }\n    ],\n    De = [\n      '$animate',\n      function (a) {\n        return {\n          restrict: 'A',\n          multiElement: !0,\n          link: function (c, d, e) {\n            c.$watch(e.ngShow, function (c) {\n              a[c ? 'removeClass' : 'addClass'](d, 'ng-hide', { tempClasses: 'ng-hide-animate' })\n            })\n          }\n        }\n      }\n    ],\n    we = [\n      '$animate',\n      function (a) {\n        return {\n          restrict: 'A',\n          multiElement: !0,\n          link: function (c, d, e) {\n            c.$watch(e.ngHide, function (c) {\n              a[c ? 'addClass' : 'removeClass'](d, 'ng-hide', { tempClasses: 'ng-hide-animate' })\n            })\n          }\n        }\n      }\n    ],\n    Ee = Na(function (a, c, d) {\n      a.$watch(\n        d.ngStyle,\n        function (a, d) {\n          d &&\n            a !== d &&\n            m(d, function (a, d) {\n              c.css(d, '')\n            })\n          a && c.css(a)\n        },\n        !0\n      )\n    }),\n    Fe = [\n      '$animate',\n      function (a) {\n        return {\n          require: 'ngSwitch',\n          controller: [\n            '$scope',\n            function () {\n              this.cases = {}\n            }\n          ],\n          link: function (c, d, e, f) {\n            var h = [],\n              g = [],\n              l = [],\n              k = [],\n              n = function (a, c) {\n                return function () {\n                  a.splice(c, 1)\n                }\n              }\n            c.$watch(e.ngSwitch || e.on, function (c) {\n              var d, e\n              d = 0\n              for (e = l.length; d < e; ++d) a.cancel(l[d])\n              d = l.length = 0\n              for (e = k.length; d < e; ++d) {\n                var s = rb(g[d].clone)\n                k[d].$destroy()\n                ;(l[d] = a.leave(s)).then(n(l, d))\n              }\n              g.length = 0\n              k.length = 0\n              ;(h = f.cases['!' + c] || f.cases['?']) &&\n                m(h, function (c) {\n                  c.transclude(function (d, e) {\n                    k.push(e)\n                    var f = c.element\n                    d[d.length++] = X.createComment(' end ngSwitchWhen: ')\n                    g.push({ clone: d })\n                    a.enter(d, f.parent(), f)\n                  })\n                })\n            })\n          }\n        }\n      }\n    ],\n    Ge = Na({\n      transclude: 'element',\n      priority: 1200,\n      require: '^ngSwitch',\n      multiElement: !0,\n      link: function (a, c, d, e, f) {\n        e.cases['!' + d.ngSwitchWhen] = e.cases['!' + d.ngSwitchWhen] || []\n        e.cases['!' + d.ngSwitchWhen].push({ transclude: f, element: c })\n      }\n    }),\n    He = Na({\n      transclude: 'element',\n      priority: 1200,\n      require: '^ngSwitch',\n      multiElement: !0,\n      link: function (a, c, d, e, f) {\n        e.cases['?'] = e.cases['?'] || []\n        e.cases['?'].push({ transclude: f, element: c })\n      }\n    }),\n    Je = Na({\n      restrict: 'EAC',\n      link: function (a, c, d, e, f) {\n        if (!f) throw I('ngTransclude')('orphan', xa(c))\n        f(function (a) {\n          c.empty()\n          c.append(a)\n        })\n      }\n    }),\n    je = [\n      '$templateCache',\n      function (a) {\n        return {\n          restrict: 'E',\n          terminal: !0,\n          compile: function (c, d) {\n            'text/ng-template' == d.type && a.put(d.id, c[0].text)\n          }\n        }\n      }\n    ],\n    Bg = { $setViewValue: y, $render: y },\n    Cg = [\n      '$element',\n      '$scope',\n      '$attrs',\n      function (a, c, d) {\n        var e = this,\n          f = new Ua()\n        e.ngModelCtrl = Bg\n        e.unknownOption = B(X.createElement('option'))\n        e.renderUnknownOption = function (c) {\n          c = '? ' + Ga(c) + ' ?'\n          e.unknownOption.val(c)\n          a.prepend(e.unknownOption)\n          a.val(c)\n        }\n        c.$on('$destroy', function () {\n          e.renderUnknownOption = y\n        })\n        e.removeUnknownOption = function () {\n          e.unknownOption.parent() && e.unknownOption.remove()\n        }\n        e.readValue = function () {\n          e.removeUnknownOption()\n          return a.val()\n        }\n        e.writeValue = function (c) {\n          e.hasOption(c)\n            ? (e.removeUnknownOption(), a.val(c), '' === c && e.emptyOption.prop('selected', !0))\n            : null == c && e.emptyOption\n            ? (e.removeUnknownOption(), a.val(''))\n            : e.renderUnknownOption(c)\n        }\n        e.addOption = function (a, c) {\n          Ta(a, '\"option value\"')\n          '' === a && (e.emptyOption = c)\n          var d = f.get(a) || 0\n          f.put(a, d + 1)\n        }\n        e.removeOption = function (a) {\n          var c = f.get(a)\n          c && (1 === c ? (f.remove(a), '' === a && (e.emptyOption = w)) : f.put(a, c - 1))\n        }\n        e.hasOption = function (a) {\n          return !!f.get(a)\n        }\n      }\n    ],\n    ke = function () {\n      return {\n        restrict: 'E',\n        require: ['select', '?ngModel'],\n        controller: Cg,\n        link: function (a, c, d, e) {\n          var f = e[1]\n          if (f) {\n            var h = e[0]\n            h.ngModelCtrl = f\n            f.$render = function () {\n              h.writeValue(f.$viewValue)\n            }\n            c.on('change', function () {\n              a.$apply(function () {\n                f.$setViewValue(h.readValue())\n              })\n            })\n            if (d.multiple) {\n              h.readValue = function () {\n                var a = []\n                m(c.find('option'), function (c) {\n                  c.selected && a.push(c.value)\n                })\n                return a\n              }\n              h.writeValue = function (a) {\n                var d = new Ua(a)\n                m(c.find('option'), function (a) {\n                  a.selected = A(d.get(a.value))\n                })\n              }\n              var g,\n                l = NaN\n              a.$watch(function () {\n                l !== f.$viewValue || ka(g, f.$viewValue) || ((g = ja(f.$viewValue)), f.$render())\n                l = f.$viewValue\n              })\n              f.$isEmpty = function (a) {\n                return !a || 0 === a.length\n              }\n            }\n          }\n        }\n      }\n    },\n    me = [\n      '$interpolate',\n      function (a) {\n        return {\n          restrict: 'E',\n          priority: 100,\n          compile: function (c, d) {\n            if (A(d.value)) var e = a(d.value, !0)\n            else {\n              var f = a(c.text(), !0)\n              f || d.$set('value', c.text())\n            }\n            return function (a, c, d) {\n              function k (a) {\n                p.addOption(a, c)\n                p.ngModelCtrl.$render()\n                c[0].hasAttribute('selected') && (c[0].selected = !0)\n              }\n              var m = c.parent(),\n                p = m.data('$selectController') || m.parent().data('$selectController')\n              if (p && p.ngModelCtrl) {\n                if (e) {\n                  var r\n                  d.$observe('value', function (a) {\n                    A(r) && p.removeOption(r)\n                    r = a\n                    k(a)\n                  })\n                } else\n                  f\n                    ? a.$watch(f, function (a, c) {\n                        d.$set('value', a)\n                        c !== a && p.removeOption(c)\n                        k(a)\n                      })\n                    : k(d.value)\n                c.on('$destroy', function () {\n                  p.removeOption(d.value)\n                  p.ngModelCtrl.$render()\n                })\n              }\n            }\n          }\n        }\n      }\n    ],\n    le = qa({ restrict: 'E', terminal: !1 }),\n    Gc = function () {\n      return {\n        restrict: 'A',\n        require: '?ngModel',\n        link: function (a, c, d, e) {\n          e &&\n            ((d.required = !0),\n            (e.$validators.required = function (a, c) {\n              return !d.required || !e.$isEmpty(c)\n            }),\n            d.$observe('required', function () {\n              e.$validate()\n            }))\n        }\n      }\n    },\n    Fc = function () {\n      return {\n        restrict: 'A',\n        require: '?ngModel',\n        link: function (a, c, d, e) {\n          if (e) {\n            var f,\n              h = d.ngPattern || d.pattern\n            d.$observe('pattern', function (a) {\n              G(a) && 0 < a.length && (a = new RegExp('^' + a + '$'))\n              if (a && !a.test) throw I('ngPattern')('noregexp', h, a, xa(c))\n              f = a || w\n              e.$validate()\n            })\n            e.$validators.pattern = function (a, c) {\n              return e.$isEmpty(c) || v(f) || f.test(c)\n            }\n          }\n        }\n      }\n    },\n    Ic = function () {\n      return {\n        restrict: 'A',\n        require: '?ngModel',\n        link: function (a, c, d, e) {\n          if (e) {\n            var f = -1\n            d.$observe('maxlength', function (a) {\n              a = Y(a)\n              f = isNaN(a) ? -1 : a\n              e.$validate()\n            })\n            e.$validators.maxlength = function (a, c) {\n              return 0 > f || e.$isEmpty(c) || c.length <= f\n            }\n          }\n        }\n      }\n    },\n    Hc = function () {\n      return {\n        restrict: 'A',\n        require: '?ngModel',\n        link: function (a, c, d, e) {\n          if (e) {\n            var f = 0\n            d.$observe('minlength', function (a) {\n              f = Y(a) || 0\n              e.$validate()\n            })\n            e.$validators.minlength = function (a, c) {\n              return e.$isEmpty(c) || c.length >= f\n            }\n          }\n        }\n      }\n    }\n  Q.angular.bootstrap\n    ? console.log('WARNING: Tried to load angular more than once.')\n    : (ce(),\n      ee(da),\n      da.module(\n        'ngLocale',\n        [],\n        [\n          '$provide',\n          function (a) {\n            function c (a) {\n              a += ''\n              var c = a.indexOf('.')\n              return -1 == c ? 0 : a.length - c - 1\n            }\n            a.value('$locale', {\n              DATETIME_FORMATS: {\n                AMPMS: ['AM', 'PM'],\n                DAY: 'Sunday Monday Tuesday Wednesday Thursday Friday Saturday'.split(' '),\n                ERANAMES: ['Before Christ', 'Anno Domini'],\n                ERAS: ['BC', 'AD'],\n                FIRSTDAYOFWEEK: 6,\n                MONTH: 'January February March April May June July August September October November December'.split(\n                  ' '\n                ),\n                SHORTDAY: 'Sun Mon Tue Wed Thu Fri Sat'.split(' '),\n                SHORTMONTH: 'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec'.split(' '),\n                WEEKENDRANGE: [5, 6],\n                fullDate: 'EEEE, MMMM d, y',\n                longDate: 'MMMM d, y',\n                medium: 'MMM d, y h:mm:ss a',\n                mediumDate: 'MMM d, y',\n                mediumTime: 'h:mm:ss a',\n                short: 'M/d/yy h:mm a',\n                shortDate: 'M/d/yy',\n                shortTime: 'h:mm a'\n              },\n              NUMBER_FORMATS: {\n                CURRENCY_SYM: '$',\n                DECIMAL_SEP: '.',\n                GROUP_SEP: ',',\n                PATTERNS: [\n                  {\n                    gSize: 3,\n                    lgSize: 3,\n                    maxFrac: 3,\n                    minFrac: 0,\n                    minInt: 1,\n                    negPre: '-',\n                    negSuf: '',\n                    posPre: '',\n                    posSuf: ''\n                  },\n                  {\n                    gSize: 3,\n                    lgSize: 3,\n                    maxFrac: 2,\n                    minFrac: 2,\n                    minInt: 1,\n                    negPre: '-\\u00a4',\n                    negSuf: '',\n                    posPre: '\\u00a4',\n                    posSuf: ''\n                  }\n                ]\n              },\n              id: 'en-us',\n              pluralCat: function (a, e) {\n                var f = a | 0,\n                  h = e\n                w === h && (h = Math.min(c(a), 3))\n                Math.pow(10, h)\n                return 1 == f && 0 == h ? 'one' : 'other'\n              }\n            })\n          }\n        ]\n      ),\n      B(X).ready(function () {\n        Zd(X, zc)\n      }))\n})(window, document)\n!window.angular.$$csp().noInlineStyle &&\n  window.angular\n    .element(document.head)\n    .prepend(\n      '<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'\n    )\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = angular;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/angular/angular.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/dataTables.grouping.js":
/*!****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.grouping.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/*\n * File:        jquery.dataTables.grouping.js\n * Version:     1.2.9.\n * Author:      Jovan Popovic\n *\n * Copyright 2013 Jovan Popovic, all rights reserved.\n *\n * This source file is free software, under either the GPL v2 license or a\n * BSD style license, as supplied with this software.\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.\n * Parameters:\n * @iGroupingColumnIndex                                 Integer             Index of the column that will be used for grouping - default 0\n * @sGroupingColumnSortDirection                         Enumeration         Sort direction of the group\n * @iGroupingOrderByColumnIndex                          Integer             Index of the column that will be used for ordering groups\n * @sGroupingClass                                       String              Class that will be associated to the group row. Default - \"group\"\n * @sGroupItemClass                                      String              Class that will be associated to the group row of group items. Default - \"group-item\"\n * @bSetGroupingClassOnTR                                Boolean             If set class will be set to the TR instead of the TD withing the grouping TR\n * @bHideGroupingColumn                                  Boolean             Hide column used for grouping once results are grouped. Default - true\n * @bHideGroupingOrderByColumn                           Boolean             Hide column used for ordering groups once results are grouped. Default - true\n * @sGroupBy                                             Enumeration         Type of grouping that should be applied. Values \"name\"(default), \"letter\", \"year\"\n * @sGroupLabelPrefix                                    String              Prefix that will be added to each group cell\n * @bExpandableGrouping                                  Boolean             Attach expand/collapse handlers to the grouping rows\n * @bExpandSingleGroup                                   Boolean             Use accordon grouping\n * @iExpandGroupOffset                                   Integer             Number of pixels to set scroll position above the currently selected group. If -1 scroll will be alligned to the table\n * General settings\n * @sDateFormat: \"dd/MM/yyyy\"                            String              Date format used for grouping\n * @sEmptyGroupLabel                                     String              Lable that will be placed as group if grouping cells are empty. Default \"-\"\n\n * Parameters used in the second level grouping\n * @iGroupingColumnIndex2                                Integer             Index of the secondary column that will be used for grouping - default 0\n * @sGroupingColumnSortDirection2                        Enumeration         Sort direction of the secondary group\n * @iGroupingOrderByColumnIndex2                         Integer             Index of the column that will be used for ordering secondary groups\n * @sGroupingClass2                                      String              Class that will be associated to the secondary group row. Default \"subgroup\"\n * @sGroupItemClass2                                     String              Class that will be associated to the secondary group row of group items. Default \"subgroup-item\"\n * @bHideGroupingColumn2                                 Boolean             Hide column used for secondary grouping once results are grouped. Default - true,\n * @bHideGroupingOrderByColumn2                          Boolean             Hide column used for ordering secondary groups once results are grouped. Default - true,\n * @sGroupBy2                                            Enumeration         Type of grouping that should be applied to secondary column. Values \"name\"(default), \"letter\", \"year\",\n * @sGroupLabelPrefix2                                   String              Prefix that will be added to each secondary group cell\n * @fnOnGrouped                                          Function            Function that is called when grouping is finished. Function has no parameters.\n */\n;(function (a) {\n  a.fn.rowGrouping = function (e) {\n    function b () {}\n    function c (j, h, i) {}\n    function d (j, h, i) {}\n    function g (i) {\n      var h = [\n        'January',\n        'February',\n        'March',\n        'April',\n        'May',\n        'June',\n        'July',\n        'August',\n        'September',\n        'October',\n        'November',\n        'December'\n      ]\n      return h[i - 1]\n    }\n    var f = {\n      iGroupingColumnIndex: 0,\n      sGroupingColumnSortDirection: '',\n      iGroupingOrderByColumnIndex: -1,\n      sGroupingClass: 'group',\n      sGroupItemClass: 'group-item',\n      bHideGroupingColumn: true,\n      bHideGroupingOrderByColumn: true,\n      sGroupBy: 'name',\n      sGroupLabelPrefix: '',\n      fnGroupLabelFormat: function (h) {\n        return h\n      },\n      bExpandableGrouping: false,\n      bExpandSingleGroup: false,\n      iExpandGroupOffset: 100,\n      asExpandedGroups: null,\n      sDateFormat: 'dd/MM/yyyy',\n      sEmptyGroupLabel: '-',\n      bSetGroupingClassOnTR: false,\n      iGroupingColumnIndex2: -1,\n      sGroupingColumnSortDirection2: '',\n      iGroupingOrderByColumnIndex2: -1,\n      sGroupingClass2: 'subgroup',\n      sGroupItemClass2: 'subgroup-item',\n      bHideGroupingColumn2: true,\n      bHideGroupingOrderByColumn2: true,\n      sGroupBy2: 'name',\n      sGroupLabelPrefix2: '',\n      fnGroupLabelFormat2: function (h) {\n        return h\n      },\n      bExpandableGrouping2: false,\n      fnOnGrouped: b,\n      fnOnGroupCreated: c,\n      fnOnGroupCompleted: d,\n      oHideEffect: null,\n      oShowEffect: null,\n      bUseFilteringForGrouping: false\n    }\n    return this.each(function (s, J) {\n      var E = a(J).dataTable()\n      var B = new Array()\n      a(this).dataTableExt.aoGroups = B\n      function q (T, i, P) {\n        var R = document.createElement('tr')\n        var S = document.createElement('td')\n        R.id = 'group-id-' + E.attr('id') + '_' + T\n        var Q = {\n          id: R.id,\n          key: T,\n          text: i,\n          level: 0,\n          groupItemClass: '.group-item-' + T,\n          dataGroup: T,\n          aoSubgroups: new Array()\n        }\n        if (t.bSetGroupingClassOnTR) {\n          R.className = t.sGroupingClass + ' ' + T\n        } else {\n          S.className = t.sGroupingClass + ' ' + T\n        }\n        S.colSpan = P\n        S.innerHTML = t.sGroupLabelPrefix + t.fnGroupLabelFormat(i == '' ? t.sEmptyGroupLabel : i, Q)\n        if (t.bExpandableGrouping) {\n          if (!I(T)) {\n            S.className += ' expanded-group'\n            Q.state = 'expanded'\n          } else {\n            S.className += ' collapsed-group'\n            Q.state = 'collapsed'\n          }\n          S.className += ' group-item-expander'\n          a(S).attr('data-group', Q.dataGroup)\n          a(S).attr('data-group-level', Q.level)\n          a(S).click(h)\n        }\n        R.appendChild(S)\n        B[T] = Q\n        Q.nGroup = R\n        t.fnOnGroupCreated(Q, T, 1)\n        return Q\n      }\n      function w (R, Q, P, T) {\n        var i = document.createElement('tr')\n        i.id = T.id + '_' + R\n        var V = document.createElement('td')\n        var U = T.dataGroup + '_' + R\n        var S = {\n          id: i.id,\n          key: R,\n          text: Q,\n          level: T.level + 1,\n          groupItemClass: '.group-item-' + U,\n          dataGroup: U,\n          aoSubgroups: new Array()\n        }\n        if (t.bSetGroupingClassOnTR) {\n          i.className = t.sGroupingClass2 + ' ' + R\n        } else {\n          V.className = t.sGroupingClass2 + ' ' + R\n        }\n        V.colSpan = P\n        V.innerHTML = t.sGroupLabelPrefix2 + t.fnGroupLabelFormat2(Q == '' ? t.sEmptyGroupLabel : Q, S)\n        if (t.bExpandableGrouping) {\n          i.className += ' group-item-' + T.dataGroup\n        }\n        if (t.bExpandableGrouping && t.bExpandableGrouping2) {\n          if (!I(S.dataGroup)) {\n            V.className += ' expanded-group'\n            S.state = 'expanded'\n          } else {\n            V.className += ' collapsed-group'\n            S.state = 'collapsed'\n          }\n          V.className += ' group-item-expander'\n          a(V).attr('data-group', S.dataGroup)\n          a(V).attr('data-group-level', S.level)\n          a(V).click(h)\n        }\n        i.appendChild(V)\n        T.aoSubgroups[S.dataGroup] = S\n        B[S.dataGroup] = S\n        S.nGroup = i\n        t.fnOnGroupCreated(S, R, 2)\n        return S\n      }\n      function I (i) {\n        if (B[i] != null) {\n          return B[i].state == 'collapsed'\n        } else {\n          if (i.indexOf('_') > -1) {\n            true\n          } else {\n            if (l && (j == null || j.length == 0)) {\n              return false\n            } else {\n              return a.inArray(i, j) == -1\n            }\n          }\n        }\n      }\n      function L (i) {\n        if (i.length < x + K) {\n          return i\n        } else {\n          return i.substr(x, K)\n        }\n      }\n      function y (i) {\n        return i\n      }\n      function M (i) {\n        return i.substr(0, 1)\n      }\n      function O (i) {\n        return L(i)\n      }\n      function C (i) {\n        return i.substr(x, K) + ' ' + g(i.substr(r, H))\n      }\n      function u (i) {\n        if (i === '') {\n          return '-'\n        }\n        return i.toLowerCase().replace(/[^a-zA-Z0-9\\u0080-\\uFFFF]+/g, '-')\n      }\n      function D (R, P, i) {\n        if (R.nTable.id !== E[0].id) {\n          return true\n        }\n        var Q = P[t.iGroupingColumnIndex]\n        if (typeof Q === 'undefined') {\n          Q = P[R.aoColumns[t.iGroupingColumnIndex].mDataProp]\n        }\n        if (I(u(Q))) {\n          if (E.fnIsOpen(E.fnGetNodes(i))) {\n            if (t.fnOnRowClosed != null) {\n              t.fnOnRowClosed(this)\n            }\n            E.fnClose(E.fnGetNodes(i))\n          }\n          return false\n        }\n        return true\n      }\n      function p (i) {\n        B[i].state = 'expanded'\n        a(\"td[data-group^='\" + i + \"']\").removeClass('collapsed-group')\n        a(\"td[data-group^='\" + i + \"']\").addClass('expanded-group')\n        if (t.bUseFilteringForGrouping) {\n          E.fnDraw()\n          return\n        }\n        if (jQuery.inArray(i, j) == -1) {\n          j.push(i)\n        }\n        if (t.oHideEffect != null) {\n          a('.group-item-' + i, E)[t.oShowEffect.method](t.oShowEffect.duration, t.oShowEffect.easing, function () {})\n        } else {\n          a('.group-item-' + i, E).show()\n        }\n      }\n      function m (i) {\n        B[i].state = 'collapsed'\n        a(\"td[data-group^='\" + i + \"']\").removeClass('expanded-group')\n        a(\"td[data-group^='\" + i + \"']\").addClass('collapsed-group')\n        if (t.bUseFilteringForGrouping) {\n          E.fnDraw()\n          return\n        }\n        a('.group-item-' + i).each(function () {\n          if (E.fnIsOpen(this)) {\n            if (t.fnOnRowClosed != null) {\n              t.fnOnRowClosed(this)\n            }\n            E.fnClose(this)\n          }\n        })\n        if (t.oHideEffect != null) {\n          a('.group-item-' + i, E)[t.oHideEffect.method](t.oHideEffect.duration, t.oHideEffect.easing, function () {})\n        } else {\n          a('.group-item-' + i, E).hide()\n        }\n      }\n      function h (T) {\n        var Q = a(this).attr('data-group')\n        var S = a(this).attr('data-group-level')\n        var R = !I(Q)\n        if (t.bExpandSingleGroup) {\n          if (!R) {\n            var P = a('td.expanded-group').attr('data-group')\n            m(P)\n            p(Q)\n            if (t.iExpandGroupOffset != -1) {\n              var i = a('#group-id-' + E.attr('id') + '_' + Q).offset().top - t.iExpandGroupOffset\n              window.scroll(0, i)\n            } else {\n              var i = E.offset().top\n              window.scroll(0, i)\n            }\n          }\n        } else {\n          if (R) {\n            m(Q)\n          } else {\n            p(Q)\n          }\n        }\n        T.preventDefault()\n      }\n      function A (V) {\n        if (E.fnSettings().oFeatures.bServerSide) {\n          l = true\n        }\n        var Z = false\n        if (t.iGroupingColumnIndex2 != -1) {\n          Z = true\n        }\n        if (V.aiDisplayMaster.length == 0) {\n          return\n        }\n        var T = a('tbody tr', E)\n        var Q = 0\n        for (var ae = 0; ae < V.aoColumns.length; ae++) {\n          if (V.aoColumns[ae].bVisible) {\n            Q += 1\n          }\n        }\n        var ah = null\n        var aa = null\n        if (V.aiDisplay.length > 0) {\n          for (var ag = 0; ag < T.length; ag++) {\n            var U = V._iDisplayStart + ag\n            if (E.fnSettings().oFeatures.bServerSide) {\n              U = ag\n            }\n            var S = ''\n            var af = null\n            var P = ''\n            var Y = null\n            S = this.fnGetData(T[ag], t.iGroupingColumnIndex)\n            var af = S\n            if (t.sGroupBy != 'year') {\n              af = N(S)\n            }\n            if (Z) {\n              P = V.aoData[V.aiDisplay[U]]._aData[t.iGroupingColumnIndex2]\n              if (P == undefined) {\n                P = V.aoData[V.aiDisplay[U]]._aData[V.aoColumns[t.iGroupingColumnIndex2].mDataProp]\n              }\n              if (t.sGroupBy2 != 'year') {\n                Y = N(P)\n              }\n            }\n            if (ah == null || u(af) != u(ah)) {\n              var ab = u(af)\n              if (ah != null) {\n                t.fnOnGroupCompleted(B[u(ah)])\n              }\n              if (t.bAddAllGroupsAsExpanded && jQuery.inArray(ab, j) == -1) {\n                j.push(ab)\n              }\n              var W = q(ab, af, Q)\n              var R = W.nGroup\n              if (T[ag].parentNode != null) {\n                T[ag].parentNode.insertBefore(R, T[ag])\n              } else {\n                a(T[ag]).before(R)\n              }\n              ah = af\n              aa = null\n            }\n            a(T[ag]).attr('data-group', B[ab].dataGroup)\n            a(T[ag]).addClass(t.sGroupItemClass)\n            a(T[ag]).addClass('group-item-' + ab)\n            if (t.bExpandableGrouping) {\n              if (I(ab) && !t.bUseFilteringForGrouping) {\n                a(T[ag]).hide()\n              }\n            }\n            if (Z) {\n              if (aa == null || u(Y) != u(aa)) {\n                var X = u(af) + '-' + u(Y)\n                var ac = w(X, Y, Q, B[ab])\n                var ad = ac.nGroup\n                T[ag].parentNode.insertBefore(ad, T[ag])\n                aa = Y\n              }\n              a(T[ag])\n                .attr('data-group', ac.dataGroup)\n                .addClass(t.sGroupItemClass2)\n                .addClass('group-item-' + ac.dataGroup)\n            }\n          }\n        }\n        if (ah != null) {\n          t.fnOnGroupCompleted(B[u(ah)])\n        }\n        t.fnOnGrouped(B)\n        l = false\n      }\n      var x = 6\n      var K = 4\n      var j = new Array()\n      var l = true\n      var t = a.extend(f, e)\n      if (t.iGroupingOrderByColumnIndex == -1) {\n        t.bCustomColumnOrdering = false\n        t.iGroupingOrderByColumnIndex = t.iGroupingColumnIndex\n      } else {\n        t.bCustomColumnOrdering = true\n      }\n      if (t.sGroupingColumnSortDirection == '') {\n        if (t.sGroupBy == 'year') {\n          t.sGroupingColumnSortDirection = 'desc'\n        } else {\n          t.sGroupingColumnSortDirection = 'asc'\n        }\n      }\n      if (t.iGroupingOrderByColumnIndex2 == -1) {\n        t.bCustomColumnOrdering2 = false\n        t.iGroupingOrderByColumnIndex2 = t.iGroupingColumnIndex2\n      } else {\n        t.bCustomColumnOrdering2 = true\n      }\n      if (t.sGroupingColumnSortDirection2 == '') {\n        if (t.sGroupBy2 == 'year') {\n          t.sGroupingColumnSortDirection2 = 'desc'\n        } else {\n          t.sGroupingColumnSortDirection2 = 'asc'\n        }\n      }\n      x = t.sDateFormat.toLowerCase().indexOf('yy')\n      K = t.sDateFormat.toLowerCase().lastIndexOf('y') - t.sDateFormat.toLowerCase().indexOf('y') + 1\n      var r = t.sDateFormat.toLowerCase().indexOf('mm')\n      var H = t.sDateFormat.toLowerCase().lastIndexOf('m') - t.sDateFormat.toLowerCase().indexOf('m') + 1\n      var N = y\n      switch (t.sGroupBy) {\n        case 'letter':\n          N = M\n          break\n        case 'year':\n          N = O\n          break\n        case 'month':\n          N = C\n          break\n        default:\n          N = y\n          break\n      }\n      if (t.asExpandedGroups != null) {\n        if (t.asExpandedGroups == 'NONE') {\n          t.asExpandedGroups = []\n          j = t.asExpandedGroups\n          l = false\n        } else {\n          if (t.asExpandedGroups == 'ALL') {\n            t.bAddAllGroupsAsExpanded = true\n          } else {\n            if (t.asExpandedGroups.constructor == String) {\n              var k = t.asExpandedGroups\n              t.asExpandedGroups = new Array()\n              t.asExpandedGroups.push(u(k))\n              j = t.asExpandedGroups\n              l = false\n            } else {\n              if (t.asExpandedGroups.constructor == Array) {\n                for (var G = 0; G < t.asExpandedGroups.length; G++) {\n                  j.push(u(t.asExpandedGroups[G]))\n                  if (t.bExpandSingleGroup) {\n                    break\n                  }\n                }\n                l = false\n              }\n            }\n          }\n        }\n      } else {\n        t.asExpandedGroups = new Array()\n        t.bAddAllGroupsAsExpanded = true\n      }\n      if (t.bExpandSingleGroup) {\n        var o = a('tbody tr', E)\n        var n = E.fnGetData(o[0], t.iGroupingColumnIndex)\n        var F = n\n        if (t.sGroupBy != 'year') {\n          F = N(n)\n        }\n        var z = u(F)\n        t.asExpandedGroups = new Array()\n        t.asExpandedGroups.push(z)\n      }\n      E.fnSetColumnVis(t.iGroupingColumnIndex, !t.bHideGroupingColumn)\n      if (t.bCustomColumnOrdering) {\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex, !t.bHideGroupingOrderByColumn)\n      }\n      if (t.iGroupingColumnIndex2 != -1) {\n        E.fnSetColumnVis(t.iGroupingColumnIndex2, !t.bHideGroupingColumn2)\n      }\n      if (t.bCustomColumnOrdering2) {\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex2, !t.bHideGroupingOrderByColumn2)\n      }\n      E.fnSettings().aoDrawCallback.push({ fn: A, sName: 'fnRowGrouping' })\n      var v = new Array()\n      v.push([t.iGroupingOrderByColumnIndex, t.sGroupingColumnSortDirection])\n      if (t.iGroupingColumnIndex2 != -1) {\n        v.push([t.iGroupingOrderByColumnIndex2, t.sGroupingColumnSortDirection2])\n      }\n      E.fnSettings().aaSortingFixed = v\n      switch (t.sGroupBy) {\n        case 'name':\n          break\n        case 'letter':\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-letter'\n          a.fn.dataTableExt.afnSortData['rg-letter'] = function (Q, P) {\n            var i = []\n            a('td:eq(' + P + ')', Q.oApi._fnGetTrNodes(Q)).each(function () {\n              i.push(M(this.innerHTML))\n            })\n            return i\n          }\n          break\n        case 'year':\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-date'\n          a.fn.dataTableExt.afnSortData['rg-date'] = function (R, P) {\n            var i = []\n            var Q = R.oApi._fnGetTrNodes(R)\n            for (G = 0; G < Q.length; G++) {\n              i.push(L(E.fnGetData(Q[G], P)))\n            }\n            return i\n          }\n          break\n        default:\n          break\n      }\n      if (t.bUseFilteringForGrouping) {\n        a.fn.dataTableExt.afnFiltering.push(D)\n      }\n      E.fnDraw()\n    })\n  }\n})(jQuery)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/dataTables.grouping.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/dataTables.ipaddress.js":
/*!*****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.ipaddress.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/**\n * Sorts a column containing IP addresses (IPv4 and IPv6) in typical dot\n * notation / colon. This can be most useful when using DataTables for a\n * networking application, and reporting information containing IP address.\n *\n *  @name IP addresses\n *  @summary Sort IP addresses numerically\n *  @author Dominique Fournier\n *  @author Brad Wasson\n *\n *  @example\n *    $('#example').dataTable( {\n *       columnDefs: [\n *         { type: 'ip-address', targets: 0 }\n *       ]\n *    } );\n */\n\njQuery.extend(jQuery.fn.dataTableExt.oSort, {\n  'ip-address-pre': function (a) {\n    var i, item\n    var m = a.split('.'),\n      n = a.split(':'),\n      x = '',\n      xa = ''\n\n    if (m.length == 4) {\n      // IPV4\n      for (i = 0; i < m.length; i++) {\n        item = m[i]\n\n        if (item.length == 1) {\n          x += '00' + item\n        } else if (item.length == 2) {\n          x += '0' + item\n        } else {\n          x += item\n        }\n      }\n    } else if (n.length > 0) {\n      // IPV6\n      var count = 0\n      for (i = 0; i < n.length; i++) {\n        item = n[i]\n\n        if (i > 0) {\n          xa += ':'\n        }\n\n        if (item.length === 0) {\n          count += 0\n        } else if (item.length == 1) {\n          xa += '000' + item\n          count += 4\n        } else if (item.length == 2) {\n          xa += '00' + item\n          count += 4\n        } else if (item.length == 3) {\n          xa += '0' + item\n          count += 4\n        } else {\n          xa += item\n          count += 4\n        }\n      }\n\n      // Padding the ::\n      n = xa.split(':')\n      var paddDone = 0\n\n      for (i = 0; i < n.length; i++) {\n        item = n[i]\n\n        if (item.length === 0 && paddDone === 0) {\n          for (var padding = 0; padding < 32 - count; padding++) {\n            x += '0'\n            paddDone = 1\n          }\n        } else {\n          x += item\n        }\n      }\n    }\n\n    return x\n  },\n\n  'ip-address-asc': function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0\n  },\n\n  'ip-address-desc': function (a, b) {\n    return a < b ? 1 : a > b ? -1 : 0\n  }\n})\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/dataTables.ipaddress.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/dataTables.responsive.js":
/*!******************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.responsive.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 1.0.1\n * 2014 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Responsive\n * @description Responsive tables plug-in for DataTables\n * @version     1.0.1\n * @file        dataTables.responsive.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2014 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n;(function (window, document, undefined) {\n  var factory = function ($, DataTable) {\n    'use strict'\n\n    /**\n     * Responsive is a plug-in for the DataTables library that makes use of\n     * DataTables' ability to change the visibility of columns, changing the\n     * visibility of columns so the displayed columns fit into the table container.\n     * The end result is that complex tables will be dynamically adjusted to fit\n     * into the viewport, be it on a desktop, tablet or mobile browser.\n     *\n     * Responsive for DataTables has two modes of operation, which can used\n     * individually or combined:\n     *\n     * * Class name based control - columns assigned class names that match the\n     *   breakpoint logic can be shown / hidden as required for each breakpoint.\n     * * Automatic control - columns are automatically hidden when there is no\n     *   room left to display them. Columns removed from the right.\n     *\n     * In additional to column visibility control, Responsive also has built into\n     * options to use DataTables' child row display to show / hide the information\n     * from the table that has been hidden. There are also two modes of operation\n     * for this child row display:\n     *\n     * * Inline - when the control element that the user can use to show / hide\n     *   child rows is displayed inside the first column of the table.\n     * * Column - where a whole column is dedicated to be the show / hide control.\n     *\n     * Initialisation of Responsive is performed by:\n     *\n     * * Adding the class `responsive` or `dt-responsive` to the table. In this case\n     *   Responsive will automatically be initialised with the default configuration\n     *   options when the DataTable is created.\n     * * Using the `responsive` option in the DataTables configuration options. This\n     *   can also be used to specify the configuration options, or simply set to\n     *   `true` to use the defaults.\n     *\n     *  @class\n     *  @param {object} settings DataTables settings object for the host table\n     *  @param {object} [opts] Configuration options\n     *  @requires jQuery 1.7+\n     *  @requires DataTables 1.10.1+\n     *\n     *  @example\n     *      $('#example').DataTable( {\n     *        responsive: true\n     *      } );\n     *    } );\n     */\n    var Responsive = function (settings, opts) {\n      // Sanity check that we are using DataTables 1.10 or newer\n      if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.1')) {\n        throw 'DataTables Responsive requires DataTables 1.10.1 or newer'\n      } else if (settings.responsive) {\n        return\n      }\n\n      this.s = {\n        dt: new DataTable.Api(settings),\n        columns: []\n      }\n\n      // details is an object, but for simplicity the user can give it as a string\n      if (opts && typeof opts.details === 'string') {\n        opts.details = { type: opts.details }\n      }\n\n      this.c = $.extend(true, {}, Responsive.defaults, opts)\n      settings.responsive = this\n      this._constructor()\n    }\n\n    Responsive.prototype = {\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Constructor\n       */\n\n      /**\n       * Initialise the Responsive instance\n       *\n       * @private\n       */\n      _constructor: function () {\n        var that = this\n        var dt = this.s.dt\n\n        dt.settings()[0]._responsive = this\n\n        // Use DataTables' private throttle function to avoid processor thrashing\n        $(window).on(\n          'resize.dtr orientationchange.dtr',\n          dt.settings()[0].oApi._fnThrottle(function () {\n            that._resize()\n          })\n        )\n\n        // Destroy event handler\n        dt.on('destroy.dtr', function () {\n          $(window).off('resize.dtr orientationchange.dtr')\n        })\n\n        // Reorder the breakpoints array here in case they have been added out\n        // of order\n        this.c.breakpoints.sort(function (a, b) {\n          return a.width < b.width ? 1 : a.width > b.width ? -1 : 0\n        })\n\n        this._classLogic()\n        this._resizeAuto()\n\n        // First pass - draw the table for the current viewport size\n        this._resize()\n\n        // Details handler\n        var details = this.c.details\n        if (details.type) {\n          that._detailsInit()\n          this._detailsVis()\n\n          dt.on('column-visibility.dtr', function () {\n            that._detailsVis()\n          })\n\n          $(dt.table().node()).addClass('dtr-' + details.type)\n        }\n      },\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Private methods\n       */\n\n      /**\n       * Calculate the visibility for the columns in a table for a given\n       * breakpoint. The result is pre-determined based on the class logic if\n       * class names are used to control all columns, but the width of the table\n       * is also used if there are columns which are to be automatically shown\n       * and hidden.\n       *\n       * @param  {string} breakpoint Breakpoint name to use for the calculation\n       * @return {array} Array of boolean values initiating the visibility of each\n       *   column.\n       *  @private\n       */\n      _columnsVisiblity: function (breakpoint) {\n        var dt = this.s.dt\n        var columns = this.s.columns\n        var i, ien\n\n        // Class logic - determine which columns are in this breakpoint based\n        // on the classes. If no class control (i.e. `auto`) then `-` is used\n        // to indicate this to the rest of the function\n        var display = $.map(columns, function (col) {\n          return col.auto && col.minWidth === null\n            ? false\n            : col.auto === true\n            ? '-'\n            : col.includeIn.indexOf(breakpoint) !== -1\n        })\n\n        // Auto column control - first pass: how much width is taken by the\n        // ones that must be included from the non-auto columns\n        var requiredWidth = 0\n        for (i = 0, ien = display.length; i < ien; i++) {\n          if (display[i] === true) {\n            requiredWidth += columns[i].minWidth\n          }\n        }\n\n        // Second pass, use up any remaining width for other columns\n        var widthAvailable = dt.table().container().offsetWidth\n        var usedWidth = widthAvailable - requiredWidth\n\n        for (i = 0, ien = display.length; i < ien; i++) {\n          // Control column needs to always be included. This makes it sub-\n          // optimal in terms of using the available with, but to stop layout\n          // thrashing or overflow\n          if (columns[i].control) {\n            usedWidth -= columns[i].minWidth\n          } else if (display[i] === '-') {\n            // Otherwise, remove the width\n            display[i] = usedWidth - columns[i].minWidth < 0 ? false : true\n\n            // Continue counting down the width, so a smaller column to the\n            // left won't be shown\n            usedWidth -= columns[i].minWidth\n          }\n        }\n\n        // Determine if the 'control' column should be shown (if there is one).\n        // This is the case when there is a hidden column (that is not the\n        // control column). The two loops look inefficient here, but they are\n        // trivial and will fly through. We need to know the outcome from the\n        // first , before the action in the second can be taken\n        var showControl = false\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (!columns[i].control && !display[i]) {\n            showControl = true\n            break\n          }\n        }\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (columns[i].control) {\n            display[i] = showControl\n          }\n        }\n\n        return display\n      },\n\n      /**\n       * Create the internal `columns` array with information about the columns\n       * for the table. This includes determining which breakpoints the column\n       * will appear in, based upon class names in the column, which makes up the\n       * vast majority of this method.\n       *\n       * @private\n       */\n      _classLogic: function () {\n        var that = this\n        var calc = {}\n        var breakpoints = this.c.breakpoints\n        var columns = this.s.dt\n          .columns()\n          .eq(0)\n          .map(function (i) {\n            return {\n              className: this.column(i).header().className,\n              includeIn: [],\n              auto: false,\n              control: false\n            }\n          })\n\n        // Simply add a breakpoint to `includeIn` array, ensuring that there are\n        // no duplicates\n        var add = function (colIdx, name) {\n          var includeIn = columns[colIdx].includeIn\n\n          if (includeIn.indexOf(name) === -1) {\n            includeIn.push(name)\n          }\n        }\n\n        var column = function (colIdx, name, operator, matched) {\n          var size, i, ien\n\n          if (!operator) {\n            columns[colIdx].includeIn.push(name)\n          } else if (operator === 'max-') {\n            // Add this breakpoint and all smaller\n            size = that._find(name).width\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].width <= size) {\n                add(colIdx, breakpoints[i].name)\n              }\n            }\n          } else if (operator === 'min-') {\n            // Add this breakpoint and all larger\n            size = that._find(name).width\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].width >= size) {\n                add(colIdx, breakpoints[i].name)\n              }\n            }\n          } else if (operator === 'not-') {\n            // Add all but this breakpoint (xxx need extra information)\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].name.indexOf(matched) === -1) {\n                add(colIdx, breakpoints[i].name)\n              }\n            }\n          }\n        }\n\n        // Loop over each column and determine if it has a responsive control\n        // class\n        columns.each(function (col, i) {\n          var classNames = col.className.split(' ')\n          var hasClass = false\n\n          // Split the class name up so multiple rules can be applied if needed\n          for (var k = 0, ken = classNames.length; k < ken; k++) {\n            var className = $.trim(classNames[k])\n\n            if (className === 'all') {\n              // Include in all\n              hasClass = true\n              col.includeIn = $.map(breakpoints, function (a) {\n                return a.name\n              })\n              return\n            } else if (className === 'none') {\n              // Include in none (default) and no auto\n              hasClass = true\n              return\n            } else if (className === 'control') {\n              // Special column that is only visible, when one of the other\n              // columns is hidden. This is used for the details control\n              hasClass = true\n              col.control = true\n              return\n            }\n\n            $.each(breakpoints, function (j, breakpoint) {\n              // Does this column have a class that matches this breakpoint?\n              var brokenPoint = breakpoint.name.split('-')\n              var re = new RegExp('(min\\\\-|max\\\\-|not\\\\-)?(' + brokenPoint[0] + ')(\\\\-[_a-zA-Z0-9])?')\n              var match = className.match(re)\n\n              if (match) {\n                hasClass = true\n\n                if (match[2] === brokenPoint[0] && match[3] === '-' + brokenPoint[1]) {\n                  // Class name matches breakpoint name fully\n                  column(i, breakpoint.name, match[1], match[2] + match[3])\n                } else if (match[2] === brokenPoint[0] && !match[3]) {\n                  // Class name matched primary breakpoint name with no qualifier\n                  column(i, breakpoint.name, match[1], match[2])\n                }\n              }\n            })\n          }\n\n          // If there was no control class, then automatic sizing is used\n          if (!hasClass) {\n            col.auto = true\n          }\n        })\n\n        this.s.columns = columns\n      },\n\n      /**\n       * Initialisation for the details handler\n       *\n       * @private\n       */\n      _detailsInit: function () {\n        var that = this\n        var dt = this.s.dt\n        var details = this.c.details\n\n        // The inline type always uses the first child as the target\n        if (details.type === 'inline') {\n          details.target = 'td:first-child'\n        }\n\n        // type.target can be a string jQuery selector or a column index\n        var target = details.target\n        var selector = typeof target === 'string' ? target : 'td'\n\n        // Click handler to show / hide the details rows when they are available\n        $(dt.table().body()).on('click', selector, function (e) {\n          // If the table is not collapsed (i.e. there is no hidden columns)\n          // then take no action\n          if (!$(dt.table().node()).hasClass('collapsed')) {\n            return\n          }\n\n          // For column index, we determine if we should act or not in the\n          // handler - otherwise it is already okay\n          if (typeof target === 'number') {\n            var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target\n\n            if (dt.cell(this).index().column !== targetIdx) {\n              return\n            }\n          }\n\n          // $().closest() includes itself in its check\n          var row = dt.row($(this).closest('tr'))\n\n          if (row.child.isShown()) {\n            row.child(false)\n            $(row.node()).removeClass('parent')\n          } else {\n            var info = that.c.details.renderer(dt, row[0])\n            row.child(info, 'child').show()\n            $(row.node()).addClass('parent')\n          }\n        })\n      },\n\n      /**\n       * Update the child rows in the table whenever the column visibility changes\n       *\n       * @private\n       */\n      _detailsVis: function () {\n        var that = this\n        var dt = this.s.dt\n\n        var hiddenColumns = dt\n          .columns(':hidden')\n          .indexes()\n          .flatten()\n        var haveHidden = true\n\n        if (hiddenColumns.length === 0 || (hiddenColumns.length === 1 && this.s.columns[hiddenColumns[0]].control)) {\n          haveHidden = false\n        }\n\n        if (haveHidden) {\n          // Got hidden columns\n          $(dt.table().node()).addClass('collapsed')\n\n          // Show all existing child rows\n          dt.rows()\n            .eq(0)\n            .each(function (idx) {\n              var row = dt.row(idx)\n\n              if (row.child()) {\n                var info = that.c.details.renderer(dt, row[0])\n\n                // The renderer can return false to have no child row\n                if (info === false) {\n                  row.child.hide()\n                } else {\n                  row.child(info, 'child').show()\n                }\n              }\n            })\n        } else {\n          // No hidden columns\n          $(dt.table().node()).removeClass('collapsed')\n\n          // Hide all existing child rows\n          dt.rows()\n            .eq(0)\n            .each(function (idx) {\n              dt.row(idx).child.hide()\n            })\n        }\n      },\n\n      /**\n       * Find a breakpoint object from a name\n       * @param  {string} name Breakpoint name to find\n       * @return {object}      Breakpoint description object\n       */\n      _find: function (name) {\n        var breakpoints = this.c.breakpoints\n\n        for (var i = 0, ien = breakpoints.length; i < ien; i++) {\n          if (breakpoints[i].name === name) {\n            return breakpoints[i]\n          }\n        }\n      },\n\n      /**\n       * Alter the table display for a resized viewport. This involves first\n       * determining what breakpoint the window currently is in, getting the\n       * column visibilities to apply and then setting them.\n       *\n       * @private\n       */\n      _resize: function () {\n        var dt = this.s.dt\n        var width = $(window).width()\n        var breakpoints = this.c.breakpoints\n        var breakpoint = breakpoints[0].name\n\n        // Determine what breakpoint we are currently at\n        for (var i = breakpoints.length - 1; i >= 0; i--) {\n          if (width <= breakpoints[i].width) {\n            breakpoint = breakpoints[i].name\n            break\n          }\n        }\n\n        // Show the columns for that break point\n        var columns = this._columnsVisiblity(breakpoint)\n\n        dt.columns()\n          .eq(0)\n          .each(function (colIdx, i) {\n            dt.column(colIdx).visible(columns[i])\n          })\n      },\n\n      /**\n       * Determine the width of each column in the table so the auto column hiding\n       * has that information to work with. This method is never going to be 100%\n       * perfect since column widths can change slightly per page, but without\n       * seriously compromising performance this is quite effective.\n       *\n       * @private\n       */\n      _resizeAuto: function () {\n        var dt = this.s.dt\n        var columns = this.s.columns\n\n        // Are we allowed to do auto sizing?\n        if (!this.c.auto) {\n          return\n        }\n\n        // Are there any columns that actually need auto-sizing, or do they all\n        // have classes defined\n        if (\n          $.inArray(\n            true,\n            $.map(columns, function (c) {\n              return c.auto\n            })\n          ) === -1\n        ) {\n          return\n        }\n\n        // Clone the table with the current data in it\n        var tableWidth = dt.table().node().offsetWidth\n        var columnWidths = dt.columns\n        var clonedTable = dt\n          .table()\n          .node()\n          .cloneNode(false)\n        var clonedHeader = $(\n          dt\n            .table()\n            .header()\n            .cloneNode(false)\n        ).appendTo(clonedTable)\n        var clonedBody = $(\n          dt\n            .table()\n            .body()\n            .cloneNode(false)\n        ).appendTo(clonedTable)\n\n        // This is a bit slow, but we need to get a clone of each row that\n        // includes all columns. As such, try to do this as little as possible.\n        dt.rows({ page: 'current' })\n          .indexes()\n          .each(function (idx) {\n            var clone = dt\n              .row(idx)\n              .node()\n              .cloneNode(true)\n\n            if (dt.columns(':hidden').flatten().length) {\n              $(clone).append(\n                dt\n                  .cells(idx, ':hidden')\n                  .nodes()\n                  .to$()\n                  .clone()\n              )\n            }\n\n            $(clone).appendTo(clonedBody)\n          })\n\n        var cells = dt\n          .columns()\n          .header()\n          .to$()\n          .clone(false)\n          .wrapAll('tr')\n          .appendTo(clonedHeader)\n        var inserted = $('<div/>')\n          .css({\n            width: 1,\n            height: 1,\n            overflow: 'hidden'\n          })\n          .append(clonedTable)\n          .insertBefore(dt.table().node())\n\n        // The cloned header now contains the smallest that each column can be\n        dt.columns()\n          .eq(0)\n          .each(function (idx) {\n            columns[idx].minWidth = cells[idx].offsetWidth || 0\n          })\n\n        inserted.remove()\n      }\n    }\n\n    /**\n     * List of default breakpoints. Each item in the array is an object with two\n     * properties:\n     *\n     * * `name` - the breakpoint name.\n     * * `width` - the breakpoint width\n     *\n     * @name Responsive.breakpoints\n     * @static\n     */\n    Responsive.breakpoints = [\n      { name: 'desktop', width: Infinity },\n      { name: 'tablet-l', width: 1024 },\n      { name: 'tablet-p', width: 768 },\n      { name: 'mobile-l', width: 480 },\n      { name: 'mobile-p', width: 320 }\n    ]\n\n    /**\n     * Responsive default settings for initialisation\n     *\n     * @namespace\n     * @name Responsive.defaults\n     * @static\n     */\n    Responsive.defaults = {\n      /**\n       * List of breakpoints for the instance. Note that this means that each\n       * instance can have its own breakpoints. Additionally, the breakpoints\n       * cannot be changed once an instance has been creased.\n       *\n       * @type {Array}\n       * @default Takes the value of `Responsive.breakpoints`\n       */\n      breakpoints: Responsive.breakpoints,\n\n      /**\n       * Enable / disable auto hiding calculations. It can help to increase\n       * performance slightly if you disable this option, but all columns would\n       * need to have breakpoint classes assigned to them\n       *\n       * @type {Boolean}\n       * @default  `true`\n       */\n      auto: true,\n\n      /**\n       * Details control. If given as a string value, the `type` property of the\n       * default object is set to that value, and the defaults used for the rest\n       * of the object - this is for ease of implementation.\n       *\n       * The object consists of the following properties:\n       *\n       * * `renderer` - function that is called for display of the child row data.\n       *   The default function will show the data from the hidden columns\n       * * `target` - Used as the selector for what objects to attach the child\n       *   open / close to\n       * * `type` - `false` to disable the details display, `inline` or `column`\n       *   for the two control types\n       *\n       * @type {Object|string}\n       */\n      details: {\n        renderer: function (api, rowIdx) {\n          var data = api\n            .cells(rowIdx, ':hidden')\n            .eq(0)\n            .map(function (cell) {\n              var header = $(api.column(cell.column).header())\n\n              if (header.hasClass('control')) {\n                return ''\n              }\n\n              return (\n                '<li>' +\n                '<span class=\"dtr-title\">' +\n                header.text() +\n                ':' +\n                '</span> ' +\n                '<span class=\"dtr-data\">' +\n                api.cell(cell).data() +\n                '</span>' +\n                '</li>'\n              )\n            })\n            .toArray()\n            .join('')\n\n          return data ? $('<ul/>').append(data) : false\n        },\n\n        target: 0,\n\n        type: 'inline'\n      }\n    }\n\n    /*\n     * API\n     */\n    var Api = $.fn.dataTable.Api\n\n    // Doesn't do anything - work around for a bug in DT... Not documented\n    Api.register('responsive()', function () {\n      return this\n    })\n\n    Api.register('responsive.recalc()', function (rowIdx, intParse, virtual) {\n      this.iterator('table', function (ctx) {\n        if (ctx._responsive) {\n          ctx._responsive._resizeAuto()\n          ctx._responsive._resize()\n        }\n      })\n    })\n\n    /**\n     * Version information\n     *\n     * @name Responsive.version\n     * @static\n     */\n    Responsive.version = '1.0.1'\n\n    $.fn.dataTable.Responsive = Responsive\n    $.fn.DataTable.Responsive = Responsive\n\n    // Attach a listener to the document which listens for DataTables initialisation\n    // events so we can automatically initialise\n    $(document).on('init.dt.dtr', function (e, settings, json) {\n      if (\n        $(settings.nTable).hasClass('responsive') ||\n        $(settings.nTable).hasClass('dt-responsive') ||\n        settings.oInit.responsive\n      ) {\n        var init = settings.oInit.responsive\n\n        if (init !== false) {\n          new Responsive(settings, $.isPlainObject(init) ? init : {})\n        }\n      }\n    })\n\n    return Responsive\n  } // /factory\n\n  // Define as an AMD module if possible\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! datatables */ \"./src/public/js/vendor/datatables/jquery.dataTables.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(window, document)\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/dataTables.responsive.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/jquery.dataTables.js":
/*!**************************************************************!*\
  !*** ./src/public/js/vendor/datatables/jquery.dataTables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.2\n * 2008-2014 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     DataTables\n * @description Paginate, search and order HTML tables\n * @version     1.10.2\n * @file        jquery.dataTables.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2008-2014 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/*jslint evil: true, undef: true, browser: true */\n/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidateRow,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/\n\n/** @lends <global> */ ;(function (window, document, undefined) {\n  ;(function (factory) {\n    'use strict'\n\n    if (true) {\n      // Define as an AMD module if possible\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else {}\n  })(\n    /** @lends <global> */ function ($) {\n      'use strict'\n\n      /**\n       * DataTables is a plug-in for the jQuery Javascript library. It is a highly\n       * flexible tool, based upon the foundations of progressive enhancement,\n       * which will add advanced interaction controls to any HTML table. For a\n       * full list of features please refer to\n       * [DataTables.net](href=\"http://datatables.net).\n       *\n       * Note that the `DataTable` object is not a global variable but is aliased\n       * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may\n       * be  accessed.\n       *\n       *  @class\n       *  @param {object} [init={}] Configuration object for DataTables. Options\n       *    are defined by {@link DataTable.defaults}\n       *  @requires jQuery 1.7+\n       *\n       *  @example\n       *    // Basic initialisation\n       *    $(document).ready( function {\n       *      $('#example').dataTable();\n       *    } );\n       *\n       *  @example\n       *    // Initialisation with configuration options - in this case, disable\n       *    // pagination and sorting.\n       *    $(document).ready( function {\n       *      $('#example').dataTable( {\n       *        \"paginate\": false,\n       *        \"sort\": false\n       *      } );\n       *    } );\n       */\n      var DataTable\n\n      /*\n       * It is useful to have variables which are scoped locally so only the\n       * DataTables functions can access them and they don't leak into global space.\n       * At the same time these functions are often useful over multiple files in the\n       * core and API, so we list, or at least document, all variables which are used\n       * by DataTables as private variables here. This also ensures that there is no\n       * clashing of variable names and that they can easily referenced for reuse.\n       */\n\n      // Defined else where\n      //  _selector_run\n      //  _selector_opts\n      //  _selector_first\n      //  _selector_row_indexes\n\n      var _ext // DataTable.ext\n      var _Api // DataTable.Api\n      var _api_register // DataTable.Api.register\n      var _api_registerPlural // DataTable.Api.registerPlural\n\n      var _re_dic = {}\n      var _re_new_lines = /[\\r\\n]/g\n      var _re_html = /<.*?>/g\n      var _re_date_start = /^[\\w\\+\\-]/\n      var _re_date_end = /[\\w\\+\\-]$/\n\n      // Escape regular expression special characters\n      var _re_escape_regex = new RegExp(\n        '(\\\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-'].join('|\\\\') + ')',\n        'g'\n      )\n\n      // U+2009 is thin space and U+202F is narrow no-break space, both used in many\n      // standards as thousands separators\n      var _re_formatted_numeric = /[',$%\\u2009\\u202F]/g\n\n      var _empty = function (d) {\n        return !d || d === true || d === '-' ? true : false\n      }\n\n      var _intVal = function (s) {\n        var integer = parseInt(s, 10)\n        return !isNaN(integer) && isFinite(s) ? integer : null\n      }\n\n      // Convert from a formatted number with characters other than `.` as the\n      // decimal place, to a Javascript number\n      var _numToDecimal = function (num, decimalPoint) {\n        // Cache created regular expressions for speed as this function is called often\n        if (!_re_dic[decimalPoint]) {\n          _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g')\n        }\n        return typeof num === 'string' ? num.replace(/\\./g, '').replace(_re_dic[decimalPoint], '.') : num\n      }\n\n      var _isNumber = function (d, decimalPoint, formatted) {\n        var strType = typeof d === 'string'\n\n        if (decimalPoint && strType) {\n          d = _numToDecimal(d, decimalPoint)\n        }\n\n        if (formatted && strType) {\n          d = d.replace(_re_formatted_numeric, '')\n        }\n\n        return _empty(d) || (!isNaN(parseFloat(d)) && isFinite(d))\n      }\n\n      // A string without HTML in it can be considered to be HTML still\n      var _isHtml = function (d) {\n        return _empty(d) || typeof d === 'string'\n      }\n\n      var _htmlNumeric = function (d, decimalPoint, formatted) {\n        if (_empty(d)) {\n          return true\n        }\n\n        var html = _isHtml(d)\n        return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null\n      }\n\n      var _pluck = function (a, prop, prop2) {\n        var out = []\n        var i = 0,\n          ien = a.length\n\n        // Could have the test in the loop for slightly smaller code, but speed\n        // is essential here\n        if (prop2 !== undefined) {\n          for (; i < ien; i++) {\n            if (a[i] && a[i][prop]) {\n              out.push(a[i][prop][prop2])\n            }\n          }\n        } else {\n          for (; i < ien; i++) {\n            if (a[i]) {\n              out.push(a[i][prop])\n            }\n          }\n        }\n\n        return out\n      }\n\n      // Basically the same as _pluck, but rather than looping over `a` we use `order`\n      // as the indexes to pick from `a`\n      var _pluck_order = function (a, order, prop, prop2) {\n        var out = []\n        var i = 0,\n          ien = order.length\n\n        // Could have the test in the loop for slightly smaller code, but speed\n        // is essential here\n        if (prop2 !== undefined) {\n          for (; i < ien; i++) {\n            out.push(a[order[i]][prop][prop2])\n          }\n        } else {\n          for (; i < ien; i++) {\n            out.push(a[order[i]][prop])\n          }\n        }\n\n        return out\n      }\n\n      var _range = function (len, start) {\n        var out = []\n        var end\n\n        if (start === undefined) {\n          start = 0\n          end = len\n        } else {\n          end = start\n          start = len\n        }\n\n        for (var i = start; i < end; i++) {\n          out.push(i)\n        }\n\n        return out\n      }\n\n      var _stripHtml = function (d) {\n        return d.replace(_re_html, '')\n      }\n\n      /**\n       * Find the unique elements in a source array.\n       *\n       * @param  {array} src Source array\n       * @return {array} Array of unique items\n       * @ignore\n       */\n      var _unique = function (src) {\n        // A faster unique method is to use object keys to identify used values,\n        // but this doesn't work with arrays or objects, which we must also\n        // consider. See jsperf.com/compare-array-unique-versions/4 for more\n        // information.\n        var out = [],\n          val,\n          i,\n          ien = src.length,\n          j,\n          k = 0\n\n        again: for (i = 0; i < ien; i++) {\n          val = src[i]\n\n          for (j = 0; j < k; j++) {\n            if (out[j] === val) {\n              continue again\n            }\n          }\n\n          out.push(val)\n          k++\n        }\n\n        return out\n      }\n\n      /**\n       * Create a mapping object that allows camel case parameters to be looked up\n       * for their Hungarian counterparts. The mapping is stored in a private\n       * parameter called `_hungarianMap` which can be accessed on the source object.\n       *  @param {object} o\n       *  @memberof DataTable#oApi\n       */\n      function _fnHungarianMap (o) {\n        var hungarian = 'a aa ai ao as b fn i m o s ',\n          match,\n          newKey,\n          map = {}\n\n        $.each(o, function (key, val) {\n          match = key.match(/^([^A-Z]+?)([A-Z])/)\n\n          if (match && hungarian.indexOf(match[1] + ' ') !== -1) {\n            newKey = key.replace(match[0], match[2].toLowerCase())\n            map[newKey] = key\n\n            //console.log( key, match );\n            if (match[1] === 'o') {\n              _fnHungarianMap(o[key])\n            }\n          }\n        })\n\n        o._hungarianMap = map\n      }\n\n      /**\n       * Convert from camel case parameters to Hungarian, based on a Hungarian map\n       * created by _fnHungarianMap.\n       *  @param {object} src The model object which holds all parameters that can be\n       *    mapped.\n       *  @param {object} user The object to convert from camel case to Hungarian.\n       *  @param {boolean} force When set to `true`, properties which already have a\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\n       *    won't be.\n       *  @memberof DataTable#oApi\n       */\n      function _fnCamelToHungarian (src, user, force) {\n        if (!src._hungarianMap) {\n          _fnHungarianMap(src)\n        }\n\n        var hungarianKey\n\n        $.each(user, function (key, val) {\n          hungarianKey = src._hungarianMap[key]\n\n          if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {\n            // For objects, we need to buzz down into the object to copy parameters\n            if (hungarianKey.charAt(0) === 'o') {\n              // Copy the camelCase options over to the hungarian\n              if (!user[hungarianKey]) {\n                user[hungarianKey] = {}\n              }\n              $.extend(true, user[hungarianKey], user[key])\n\n              _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force)\n            } else {\n              user[hungarianKey] = user[key]\n            }\n          }\n        })\n      }\n\n      /**\n       * Language compatibility - when certain options are given, and others aren't, we\n       * need to duplicate the values over, in order to provide backwards compatibility\n       * with older language files.\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnLanguageCompat (lang) {\n        var defaults = DataTable.defaults.oLanguage\n        var zeroRecords = lang.sZeroRecords\n\n        /* Backwards compatibility - if there is no sEmptyTable given, then use the same as\n         * sZeroRecords - assuming that is given.\n         */\n        if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === 'No data available in table') {\n          _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable')\n        }\n\n        /* Likewise with loading records */\n        if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === 'Loading...') {\n          _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords')\n        }\n\n        // Old parameter name of the thousands separator mapped onto the new\n        if (lang.sInfoThousands) {\n          lang.sThousands = lang.sInfoThousands\n        }\n\n        var decimal = lang.sDecimal\n        if (decimal) {\n          _addNumericSort(decimal)\n        }\n      }\n\n      /**\n       * Map one parameter onto another\n       *  @param {object} o Object to map\n       *  @param {*} knew The new parameter name\n       *  @param {*} old The old parameter name\n       */\n      var _fnCompatMap = function (o, knew, old) {\n        if (o[knew] !== undefined) {\n          o[old] = o[knew]\n        }\n      }\n\n      /**\n       * Provide backwards compatibility for the main DT options. Note that the new\n       * options are mapped onto the old parameters, so this is an external interface\n       * change only.\n       *  @param {object} init Object to map\n       */\n      function _fnCompatOpts (init) {\n        _fnCompatMap(init, 'ordering', 'bSort')\n        _fnCompatMap(init, 'orderMulti', 'bSortMulti')\n        _fnCompatMap(init, 'orderClasses', 'bSortClasses')\n        _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop')\n        _fnCompatMap(init, 'order', 'aaSorting')\n        _fnCompatMap(init, 'orderFixed', 'aaSortingFixed')\n        _fnCompatMap(init, 'paging', 'bPaginate')\n        _fnCompatMap(init, 'pagingType', 'sPaginationType')\n        _fnCompatMap(init, 'pageLength', 'iDisplayLength')\n        _fnCompatMap(init, 'searching', 'bFilter')\n\n        // Column search objects are in an array, so it needs to be converted\n        // element by element\n        var searchCols = init.aoSearchCols\n\n        if (searchCols) {\n          for (var i = 0, ien = searchCols.length; i < ien; i++) {\n            if (searchCols[i]) {\n              _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i])\n            }\n          }\n        }\n      }\n\n      /**\n       * Provide backwards compatibility for column options. Note that the new options\n       * are mapped onto the old parameters, so this is an external interface change\n       * only.\n       *  @param {object} init Object to map\n       */\n      function _fnCompatCols (init) {\n        _fnCompatMap(init, 'orderable', 'bSortable')\n        _fnCompatMap(init, 'orderData', 'aDataSort')\n        _fnCompatMap(init, 'orderSequence', 'asSorting')\n        _fnCompatMap(init, 'orderDataType', 'sortDataType')\n      }\n\n      /**\n       * Browser feature detection for capabilities, quirks\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnBrowserDetect (settings) {\n        var browser = settings.oBrowser\n\n        // Scrolling feature / quirks detection\n        var n = $('<div/>')\n          .css({\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            height: 1,\n            width: 1,\n            overflow: 'hidden'\n          })\n          .append(\n            $('<div/>')\n              .css({\n                position: 'absolute',\n                top: 1,\n                left: 1,\n                width: 100,\n                overflow: 'scroll'\n              })\n              .append(\n                $('<div class=\"test\"/>').css({\n                  width: '100%',\n                  height: 10\n                })\n              )\n          )\n          .appendTo('body')\n\n        var test = n.find('.test')\n\n        // IE6/7 will oversize a width 100% element inside a scrolling element, to\n        // include the width of the scrollbar, while other browsers ensure the inner\n        // element is contained without forcing scrolling\n        browser.bScrollOversize = test[0].offsetWidth === 100\n\n        // In rtl text layout, some browsers (most, but not all) will place the\n        // scrollbar on the left, rather than the right.\n        browser.bScrollbarLeft = test.offset().left !== 1\n\n        n.remove()\n      }\n\n      /**\n       * Array.prototype reduce[Right] method, used for browsers which don't support\n       * JS 1.6. Done this way to reduce code size, since we iterate either way\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnReduce (that, fn, init, start, end, inc) {\n        var i = start,\n          value,\n          isSet = false\n\n        if (init !== undefined) {\n          value = init\n          isSet = true\n        }\n\n        while (i !== end) {\n          if (!that.hasOwnProperty(i)) {\n            continue\n          }\n\n          value = isSet ? fn(value, that[i], i, that) : that[i]\n\n          isSet = true\n          i += inc\n        }\n\n        return value\n      }\n\n      /**\n       * Add a column to the list used for the table with default values\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} nTh The th element for this column\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddColumn (oSettings, nTh) {\n        // Add column to aoColumns array\n        var oDefaults = DataTable.defaults.column\n        var iCol = oSettings.aoColumns.length\n        var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {\n          nTh: nTh ? nTh : document.createElement('th'),\n          sTitle: oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',\n          aDataSort: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\n          mData: oDefaults.mData ? oDefaults.mData : iCol,\n          idx: iCol\n        })\n        oSettings.aoColumns.push(oCol)\n\n        // Add search object for column specific search. Note that the `searchCols[ iCol ]`\n        // passed into extend can be undefined. This allows the user to give a default\n        // with only some of the parameters defined, and also not give a default\n        var searchCols = oSettings.aoPreSearchCols\n        searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol])\n\n        // Use the default column options function to initialise classes etc\n        _fnColumnOptions(oSettings, iCol, null)\n      }\n\n      /**\n       * Apply options for a column\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iCol column index to consider\n       *  @param {object} oOptions object with sType, bVisible and bSearchable etc\n       *  @memberof DataTable#oApi\n       */\n      function _fnColumnOptions (oSettings, iCol, oOptions) {\n        var oCol = oSettings.aoColumns[iCol]\n        var oClasses = oSettings.oClasses\n        var th = $(oCol.nTh)\n\n        // Try to get width information from the DOM. We can't get it from CSS\n        // as we'd need to parse the CSS stylesheet. `width` option can override\n        if (!oCol.sWidthOrig) {\n          // Width attribute\n          oCol.sWidthOrig = th.attr('width') || null\n\n          // Style attribute\n          var t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/)\n          if (t) {\n            oCol.sWidthOrig = t[1]\n          }\n        }\n\n        /* User specified column options */\n        if (oOptions !== undefined && oOptions !== null) {\n          // Backwards compatibility\n          _fnCompatCols(oOptions)\n\n          // Map camel case parameters to their Hungarian counterparts\n          _fnCamelToHungarian(DataTable.defaults.column, oOptions)\n\n          /* Backwards compatibility for mDataProp */\n          if (oOptions.mDataProp !== undefined && !oOptions.mData) {\n            oOptions.mData = oOptions.mDataProp\n          }\n\n          if (oOptions.sType) {\n            oCol._sManualType = oOptions.sType\n          }\n\n          // `class` is a reserved word in Javascript, so we need to provide\n          // the ability to use a valid name for the camel case input\n          if (oOptions.className && !oOptions.sClass) {\n            oOptions.sClass = oOptions.className\n          }\n\n          $.extend(oCol, oOptions)\n          _fnMap(oCol, oOptions, 'sWidth', 'sWidthOrig')\n\n          /* iDataSort to be applied (backwards compatibility), but aDataSort will take\n           * priority if defined\n           */\n          if (typeof oOptions.iDataSort === 'number') {\n            oCol.aDataSort = [oOptions.iDataSort]\n          }\n          _fnMap(oCol, oOptions, 'aDataSort')\n        }\n\n        /* Cache the data get and set functions for speed */\n        var mDataSrc = oCol.mData\n        var mData = _fnGetObjectDataFn(mDataSrc)\n        var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null\n\n        var attrTest = function (src) {\n          return typeof src === 'string' && src.indexOf('@') !== -1\n        }\n        oCol._bAttrSrc =\n          $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter))\n\n        oCol.fnGetData = function (rowData, type, meta) {\n          var innerData = mData(rowData, type, undefined, meta)\n\n          return mRender && type ? mRender(innerData, type, rowData, meta) : innerData\n        }\n        oCol.fnSetData = function (rowData, val, meta) {\n          return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta)\n        }\n\n        /* Feature sorting overrides column specific when off */\n        if (!oSettings.oFeatures.bSort) {\n          oCol.bSortable = false\n          th.addClass(oClasses.sSortableNone) // Have to add class here as order event isn't called\n        }\n\n        /* Check that the class assignment is correct for sorting */\n        var bAsc = $.inArray('asc', oCol.asSorting) !== -1\n        var bDesc = $.inArray('desc', oCol.asSorting) !== -1\n        if (!oCol.bSortable || (!bAsc && !bDesc)) {\n          oCol.sSortingClass = oClasses.sSortableNone\n          oCol.sSortingClassJUI = ''\n        } else if (bAsc && !bDesc) {\n          oCol.sSortingClass = oClasses.sSortableAsc\n          oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed\n        } else if (!bAsc && bDesc) {\n          oCol.sSortingClass = oClasses.sSortableDesc\n          oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed\n        } else {\n          oCol.sSortingClass = oClasses.sSortable\n          oCol.sSortingClassJUI = oClasses.sSortJUI\n        }\n      }\n\n      /**\n       * Adjust the table column widths for new data. Note: you would probably want to\n       * do a redraw after calling this function!\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnAdjustColumnSizing (settings) {\n        /* Not interested in doing column width calculation if auto-width is disabled */\n        if (settings.oFeatures.bAutoWidth !== false) {\n          var columns = settings.aoColumns\n\n          _fnCalculateColumnWidths(settings)\n          for (var i = 0, iLen = columns.length; i < iLen; i++) {\n            columns[i].nTh.style.width = columns[i].sWidth\n          }\n        }\n\n        var scroll = settings.oScroll\n        if (scroll.sY !== '' || scroll.sX !== '') {\n          _fnScrollDraw(settings)\n        }\n\n        _fnCallbackFire(settings, null, 'column-sizing', [settings])\n      }\n\n      /**\n       * Covert the index of a visible column to the index in the data array (take account\n       * of hidden columns)\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iMatch Visible column index to lookup\n       *  @returns {int} i the data index\n       *  @memberof DataTable#oApi\n       */\n      function _fnVisibleToColumnIndex (oSettings, iMatch) {\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\n\n        return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null\n      }\n\n      /**\n       * Covert the index of an index in the data array and convert it to the visible\n       *   column index (take account of hidden columns)\n       *  @param {int} iMatch Column index to lookup\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {int} i the data index\n       *  @memberof DataTable#oApi\n       */\n      function _fnColumnIndexToVisible (oSettings, iMatch) {\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\n        var iPos = $.inArray(iMatch, aiVis)\n\n        return iPos !== -1 ? iPos : null\n      }\n\n      /**\n       * Get the number of visible columns\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {int} i the number of visible columns\n       *  @memberof DataTable#oApi\n       */\n      function _fnVisbleColumns (oSettings) {\n        return _fnGetColumns(oSettings, 'bVisible').length\n      }\n\n      /**\n       * Get an array of column indexes that match a given property\n       *  @param {object} oSettings dataTables settings object\n       *  @param {string} sParam Parameter in aoColumns to look for - typically\n       *    bVisible or bSearchable\n       *  @returns {array} Array of indexes with matched properties\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetColumns (oSettings, sParam) {\n        var a = []\n\n        $.map(oSettings.aoColumns, function (val, i) {\n          if (val[sParam]) {\n            a.push(i)\n          }\n        })\n\n        return a\n      }\n\n      /**\n       * Calculate the 'type' of a column\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnColumnTypes (settings) {\n        var columns = settings.aoColumns\n        var data = settings.aoData\n        var types = DataTable.ext.type.detect\n        var i, ien, j, jen, k, ken\n        var col, cell, detectedType, cache\n\n        // For each column, spin over the\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          col = columns[i]\n          cache = []\n\n          if (!col.sType && col._sManualType) {\n            col.sType = col._sManualType\n          } else if (!col.sType) {\n            for (j = 0, jen = types.length; j < jen; j++) {\n              for (k = 0, ken = data.length; k < ken; k++) {\n                // Use a cache array so we only need to get the type data\n                // from the formatter once (when using multiple detectors)\n                if (cache[k] === undefined) {\n                  cache[k] = _fnGetCellData(settings, k, i, 'type')\n                }\n\n                detectedType = types[j](cache[k], settings)\n\n                // Doesn't match, so break early, since this type can't\n                // apply to this column. Also, HTML is a special case since\n                // it is so similar to `string`. Just a single match is\n                // needed for a column to be html type\n                if (!detectedType || detectedType === 'html') {\n                  break\n                }\n              }\n\n              // Type is valid for all data points in the column - use this\n              // type\n              if (detectedType) {\n                col.sType = detectedType\n                break\n              }\n            }\n\n            // Fall back - if no type was detected, always use string\n            if (!col.sType) {\n              col.sType = 'string'\n            }\n          }\n        }\n      }\n\n      /**\n       * Take the column definitions and static columns arrays and calculate how\n       * they relate to column indexes. The callback function will then apply the\n       * definition found for a column to a suitable configuration object.\n       *  @param {object} oSettings dataTables settings object\n       *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\n       *  @param {array} aoCols The aoColumns array that defines columns individually\n       *  @param {function} fn Callback function - takes two parameters, the calculated\n       *    column index and the definition for that column.\n       *  @memberof DataTable#oApi\n       */\n      function _fnApplyColumnDefs (oSettings, aoColDefs, aoCols, fn) {\n        var i, iLen, j, jLen, k, kLen, def\n        var columns = oSettings.aoColumns\n\n        // Column definitions with aTargets\n        if (aoColDefs) {\n          /* Loop over the definitions array - loop in reverse so first instance has priority */\n          for (i = aoColDefs.length - 1; i >= 0; i--) {\n            def = aoColDefs[i]\n\n            /* Each definition can target multiple columns, as it is an array */\n            var aTargets = def.targets !== undefined ? def.targets : def.aTargets\n\n            if (!$.isArray(aTargets)) {\n              aTargets = [aTargets]\n            }\n\n            for (j = 0, jLen = aTargets.length; j < jLen; j++) {\n              if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {\n                /* Add columns that we don't yet know about */\n                while (columns.length <= aTargets[j]) {\n                  _fnAddColumn(oSettings)\n                }\n\n                /* Integer, basic index */\n                fn(aTargets[j], def)\n              } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {\n                /* Negative integer, right to left column counting */\n                fn(columns.length + aTargets[j], def)\n              } else if (typeof aTargets[j] === 'string') {\n                /* Class name matching on TH element */\n                for (k = 0, kLen = columns.length; k < kLen; k++) {\n                  if (aTargets[j] == '_all' || $(columns[k].nTh).hasClass(aTargets[j])) {\n                    fn(k, def)\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Statically defined columns array\n        if (aoCols) {\n          for (i = 0, iLen = aoCols.length; i < iLen; i++) {\n            fn(i, aoCols[i])\n          }\n        }\n      }\n\n      /**\n       * Add a data array to the table, creating DOM node etc. This is the parallel to\n       * _fnGatherData, but for adding rows from a Javascript source, rather than a\n       * DOM source.\n       *  @param {object} oSettings dataTables settings object\n       *  @param {array} aData data array to be added\n       *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n       *    DataTables will create a row automatically\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n       *    if nTr is.\n       *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddData (oSettings, aDataIn, nTr, anTds) {\n        /* Create the object for storing information about this new row */\n        var iRow = oSettings.aoData.length\n        var oData = $.extend(true, {}, DataTable.models.oRow, {\n          src: nTr ? 'dom' : 'data'\n        })\n\n        oData._aData = aDataIn\n        oSettings.aoData.push(oData)\n\n        /* Create the cells */\n        var nTd, sThisType\n        var columns = oSettings.aoColumns\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\n          // When working with a row, the data source object must be populated. In\n          // all other cases, the data source object is already populated, so we\n          // don't overwrite it, which might break bindings etc\n          if (nTr) {\n            _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i))\n          }\n          columns[i].sType = null\n        }\n\n        /* Add to the display array */\n        oSettings.aiDisplayMaster.push(iRow)\n\n        /* Create the DOM information, or register it if already present */\n        if (nTr || !oSettings.oFeatures.bDeferRender) {\n          _fnCreateTr(oSettings, iRow, nTr, anTds)\n        }\n\n        return iRow\n      }\n\n      /**\n       * Add one or more TR elements to the table. Generally we'd expect to\n       * use this for reading data from a DOM sourced table, but it could be\n       * used for an TR element. Note that if a TR is given, it is used (i.e.\n       * it is not cloned).\n       *  @param {object} settings dataTables settings object\n       *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n       *  @returns {array} Array of indexes for the added rows\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddTr (settings, trs) {\n        var row\n\n        // Allow an individual node to be passed in\n        if (!(trs instanceof $)) {\n          trs = $(trs)\n        }\n\n        return trs.map(function (i, el) {\n          row = _fnGetRowElements(settings, el)\n          return _fnAddData(settings, row.data, el, row.cells)\n        })\n      }\n\n      /**\n       * Take a TR element and convert it to an index in aoData\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} n the TR element to find\n       *  @returns {int} index if the node is found, null if not\n       *  @memberof DataTable#oApi\n       */\n      function _fnNodeToDataIndex (oSettings, n) {\n        return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null\n      }\n\n      /**\n       * Take a TD element and convert it into a column data index (not the visible index)\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iRow The row number the TD/TH can be found in\n       *  @param {node} n The TD/TH element to find\n       *  @returns {int} index if the node is found, -1 if not\n       *  @memberof DataTable#oApi\n       */\n      function _fnNodeToColumnIndex (oSettings, iRow, n) {\n        return $.inArray(n, oSettings.aoData[iRow].anCells)\n      }\n\n      /**\n       * Get the data for a given cell from the internal cache, taking into account data mapping\n       *  @param {object} settings dataTables settings object\n       *  @param {int} rowIdx aoData row id\n       *  @param {int} colIdx Column index\n       *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\n       *  @returns {*} Cell data\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetCellData (settings, rowIdx, colIdx, type) {\n        var draw = settings.iDraw\n        var col = settings.aoColumns[colIdx]\n        var rowData = settings.aoData[rowIdx]._aData\n        var defaultContent = col.sDefaultContent\n        var cellData = col.fnGetData(rowData, type, {\n          settings: settings,\n          row: rowIdx,\n          col: colIdx\n        })\n\n        if (cellData === undefined) {\n          if (settings.iDrawError != draw && defaultContent === null) {\n            _fnLog(\n              settings,\n              0,\n              'Requested unknown parameter ' +\n                (typeof col.mData == 'function' ? '{function}' : \"'\" + col.mData + \"'\") +\n                ' for row ' +\n                rowIdx,\n              4\n            )\n            settings.iDrawError = draw\n          }\n          return defaultContent\n        }\n\n        /* When the data source is null, we can use default column data */\n        if ((cellData === rowData || cellData === null) && defaultContent !== null) {\n          cellData = defaultContent\n        } else if (typeof cellData === 'function') {\n          // If the data source is a function, then we run it and use the return,\n          // executing in the scope of the data object (for instances)\n          return cellData.call(rowData)\n        }\n\n        if (cellData === null && type == 'display') {\n          return ''\n        }\n        return cellData\n      }\n\n      /**\n       * Set the value for a specific cell, into the internal data cache\n       *  @param {object} settings dataTables settings object\n       *  @param {int} rowIdx aoData row id\n       *  @param {int} colIdx Column index\n       *  @param {*} val Value to set\n       *  @memberof DataTable#oApi\n       */\n      function _fnSetCellData (settings, rowIdx, colIdx, val) {\n        var col = settings.aoColumns[colIdx]\n        var rowData = settings.aoData[rowIdx]._aData\n\n        col.fnSetData(rowData, val, {\n          settings: settings,\n          row: rowIdx,\n          col: colIdx\n        })\n      }\n\n      // Private variable that is used to match action syntax in the data property object\n      var __reArray = /\\[.*?\\]$/\n      var __reFn = /\\(\\)$/\n\n      /**\n       * Split string on periods, taking into account escaped periods\n       * @param  {string} str String to split\n       * @return {array} Split string\n       */\n      function _fnSplitObjNotation (str) {\n        return $.map(str.match(/(\\\\.|[^\\.])+/g), function (s) {\n          return s.replace(/\\\\./g, '.')\n        })\n      }\n\n      /**\n       * Return a function that can be used to get data from a source object, taking\n       * into account the ability to use nested objects as a source\n       *  @param {string|int|function} mSource The data source for the object\n       *  @returns {function} Data get function\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetObjectDataFn (mSource) {\n        if ($.isPlainObject(mSource)) {\n          /* Build an object of get functions, and wrap them in a single call */\n          var o = {}\n          $.each(mSource, function (key, val) {\n            if (val) {\n              o[key] = _fnGetObjectDataFn(val)\n            }\n          })\n\n          return function (data, type, row, meta) {\n            var t = o[type] || o._\n            return t !== undefined ? t(data, type, row, meta) : data\n          }\n        } else if (mSource === null) {\n          /* Give an empty string for rendering / sorting etc */\n          return function (data) {\n            // type, row and meta also passed, but not used\n            return data\n          }\n        } else if (typeof mSource === 'function') {\n          return function (data, type, row, meta) {\n            return mSource(data, type, row, meta)\n          }\n        } else if (\n          typeof mSource === 'string' &&\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\n        ) {\n          /* If there is a . in the source string then the data source is in a\n           * nested object so we loop over the data for each level to get the next\n           * level down. On each loop we test for undefined, and if found immediately\n           * return. This allows entire objects to be missing and sDefaultContent to\n           * be used if defined, rather than throwing an error\n           */\n          var fetchData = function (data, type, src) {\n            var arrayNotation, funcNotation, out, innerSrc\n\n            if (src !== '') {\n              var a = _fnSplitObjNotation(src)\n\n              for (var i = 0, iLen = a.length; i < iLen; i++) {\n                // Check if we are dealing with special notation\n                arrayNotation = a[i].match(__reArray)\n                funcNotation = a[i].match(__reFn)\n\n                if (arrayNotation) {\n                  // Array notation\n                  a[i] = a[i].replace(__reArray, '')\n\n                  // Condition allows simply [] to be passed in\n                  if (a[i] !== '') {\n                    data = data[a[i]]\n                  }\n                  out = []\n\n                  // Get the remainder of the nested object to get\n                  a.splice(0, i + 1)\n                  innerSrc = a.join('.')\n\n                  // Traverse each entry in the array getting the properties requested\n                  for (var j = 0, jLen = data.length; j < jLen; j++) {\n                    out.push(fetchData(data[j], type, innerSrc))\n                  }\n\n                  // If a string is given in between the array notation indicators, that\n                  // is used to join the strings together, otherwise an array is returned\n                  var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1)\n                  data = join === '' ? out : out.join(join)\n\n                  // The inner call to fetchData has already traversed through the remainder\n                  // of the source requested, so we exit from the loop\n                  break\n                } else if (funcNotation) {\n                  // Function call\n                  a[i] = a[i].replace(__reFn, '')\n                  data = data[a[i]]()\n                  continue\n                }\n\n                if (data === null || data[a[i]] === undefined) {\n                  return undefined\n                }\n                data = data[a[i]]\n              }\n            }\n\n            return data\n          }\n\n          return function (data, type) {\n            // row and meta also passed, but not used\n            return fetchData(data, type, mSource)\n          }\n        } else {\n          /* Array or flat object mapping */\n          return function (data, type) {\n            // row and meta also passed, but not used\n            return data[mSource]\n          }\n        }\n      }\n\n      /**\n       * Return a function that can be used to set data from a source object, taking\n       * into account the ability to use nested objects as a source\n       *  @param {string|int|function} mSource The data source for the object\n       *  @returns {function} Data set function\n       *  @memberof DataTable#oApi\n       */\n      function _fnSetObjectDataFn (mSource) {\n        if ($.isPlainObject(mSource)) {\n          /* Unlike get, only the underscore (global) option is used for for\n           * setting data since we don't know the type here. This is why an object\n           * option is not documented for `mData` (which is read/write), but it is\n           * for `mRender` which is read only.\n           */\n          return _fnSetObjectDataFn(mSource._)\n        } else if (mSource === null) {\n          /* Nothing to do when the data source is null */\n          return function () {}\n        } else if (typeof mSource === 'function') {\n          return function (data, val, meta) {\n            mSource(data, 'set', val, meta)\n          }\n        } else if (\n          typeof mSource === 'string' &&\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\n        ) {\n          /* Like the get, we need to get data from a nested object */\n          var setData = function (data, val, src) {\n            var a = _fnSplitObjNotation(src),\n              b\n            var aLast = a[a.length - 1]\n            var arrayNotation, funcNotation, o, innerSrc\n\n            for (var i = 0, iLen = a.length - 1; i < iLen; i++) {\n              // Check if we are dealing with an array notation request\n              arrayNotation = a[i].match(__reArray)\n              funcNotation = a[i].match(__reFn)\n\n              if (arrayNotation) {\n                a[i] = a[i].replace(__reArray, '')\n                data[a[i]] = []\n\n                // Get the remainder of the nested object to set so we can recurse\n                b = a.slice()\n                b.splice(0, i + 1)\n                innerSrc = b.join('.')\n\n                // Traverse each entry in the array setting the properties requested\n                for (var j = 0, jLen = val.length; j < jLen; j++) {\n                  o = {}\n                  setData(o, val[j], innerSrc)\n                  data[a[i]].push(o)\n                }\n\n                // The inner call to setData has already traversed through the remainder\n                // of the source and has set the data, thus we can exit here\n                return\n              } else if (funcNotation) {\n                // Function call\n                a[i] = a[i].replace(__reFn, '')\n                data = data[a[i]](val)\n              }\n\n              // If the nested object doesn't currently exist - since we are\n              // trying to set the value - create it\n              if (data[a[i]] === null || data[a[i]] === undefined) {\n                data[a[i]] = {}\n              }\n              data = data[a[i]]\n            }\n\n            // Last item in the input - i.e, the actual set\n            if (aLast.match(__reFn)) {\n              // Function call\n              data = data[aLast.replace(__reFn, '')](val)\n            } else {\n              // If array notation is used, we just want to strip it and use the property name\n              // and assign the value. If it isn't used, then we get the result we want anyway\n              data[aLast.replace(__reArray, '')] = val\n            }\n          }\n\n          return function (data, val) {\n            // meta is also passed in, but not used\n            return setData(data, val, mSource)\n          }\n        } else {\n          /* Array or flat object mapping */\n          return function (data, val) {\n            // meta is also passed in, but not used\n            data[mSource] = val\n          }\n        }\n      }\n\n      /**\n       * Return an array with the full table data\n       *  @param {object} oSettings dataTables settings object\n       *  @returns array {array} aData Master data array\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetDataMaster (settings) {\n        return _pluck(settings.aoData, '_aData')\n      }\n\n      /**\n       * Nuke the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnClearTable (settings) {\n        settings.aoData.length = 0\n        settings.aiDisplayMaster.length = 0\n        settings.aiDisplay.length = 0\n      }\n\n      /**\n       * Take an array of integers (index array) and remove a target integer (value - not\n       * the key!)\n       *  @param {array} a Index array to target\n       *  @param {int} iTarget value to find\n       *  @memberof DataTable#oApi\n       */\n      function _fnDeleteIndex (a, iTarget, splice) {\n        var iTargetIndex = -1\n\n        for (var i = 0, iLen = a.length; i < iLen; i++) {\n          if (a[i] == iTarget) {\n            iTargetIndex = i\n          } else if (a[i] > iTarget) {\n            a[i]--\n          }\n        }\n\n        if (iTargetIndex != -1 && splice === undefined) {\n          a.splice(iTargetIndex, 1)\n        }\n      }\n\n      /**\n       * Mark cached data as invalid such that a re-read of the data will occur when\n       * the cached data is next requested. Also update from the data source object.\n       *\n       * @param {object} settings DataTables settings object\n       * @param  {int}    rowIdx   Row index to invalidate\n       * @memberof DataTable#oApi\n       *\n       * @todo For the modularisation of v1.11 this will need to become a callback, so\n       *   the sort and filter methods can subscribe to it. That will required\n       *   initialisation options for sorting, which is why it is not already baked in\n       */\n      function _fnInvalidateRow (settings, rowIdx, src, column) {\n        var row = settings.aoData[rowIdx]\n        var i, ien\n\n        // Are we reading last data from DOM or the data object?\n        if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {\n          // Read the data from the DOM\n          row._aData = _fnGetRowElements(settings, row).data\n        } else {\n          // Reading from data object, update the DOM\n          var cells = row.anCells\n          var cell\n\n          if (cells) {\n            for (i = 0, ien = cells.length; i < ien; i++) {\n              cell = cells[i]\n\n              // This is very frustrating, but in IE if you just write directly\n              // to innerHTML, and elements that are overwritten are GC'ed,\n              // even if there is a reference to them elsewhere\n              while (cell.childNodes.length) {\n                cell.removeChild(cell.firstChild)\n              }\n\n              cells[i].innerHTML = _fnGetCellData(settings, rowIdx, i, 'display')\n            }\n          }\n        }\n\n        row._aSortData = null\n        row._aFilterData = null\n\n        // Invalidate the type for a specific column (if given) or all columns since\n        // the data might have changed\n        var cols = settings.aoColumns\n        if (column !== undefined) {\n          cols[column].sType = null\n        } else {\n          for (i = 0, ien = cols.length; i < ien; i++) {\n            cols[i].sType = null\n          }\n        }\n\n        // Update DataTables special `DT_*` attributes for the row\n        _fnRowAttributes(row)\n      }\n\n      /**\n       * Build a data source object from an HTML row, reading the contents of the\n       * cells that are in the row.\n       *\n       * @param {object} settings DataTables settings object\n       * @param {node|object} TR element from which to read data or existing row\n       *   object from which to re-read the data from the cells\n       * @returns {object} Object with two parameters: `data` the data read, in\n       *   document order, and `cells` and array of nodes (they can be useful to the\n       *   caller, so rather than needing a second traversal to get them, just return\n       *   them from here).\n       * @memberof DataTable#oApi\n       */\n      function _fnGetRowElements (settings, row) {\n        var d = [],\n          tds = [],\n          td = row.firstChild,\n          name,\n          col,\n          o,\n          i = 0,\n          contents,\n          columns = settings.aoColumns\n\n        var attr = function (str, data, td) {\n          if (typeof str === 'string') {\n            var idx = str.indexOf('@')\n\n            if (idx !== -1) {\n              var src = str.substring(idx + 1)\n              o['@' + src] = td.getAttribute(src)\n            }\n          }\n        }\n\n        var cellProcess = function (cell) {\n          col = columns[i]\n          contents = $.trim(cell.innerHTML)\n\n          if (col && col._bAttrSrc) {\n            o = {\n              display: contents\n            }\n\n            attr(col.mData.sort, o, cell)\n            attr(col.mData.type, o, cell)\n            attr(col.mData.filter, o, cell)\n\n            d.push(o)\n          } else {\n            d.push(contents)\n          }\n\n          i++\n        }\n\n        if (td) {\n          // `tr` element passed in\n          while (td) {\n            name = td.nodeName.toUpperCase()\n\n            if (name == 'TD' || name == 'TH') {\n              cellProcess(td)\n              tds.push(td)\n            }\n\n            td = td.nextSibling\n          }\n        } else {\n          // Existing row object passed in\n          tds = row.anCells\n\n          for (var j = 0, jen = tds.length; j < jen; j++) {\n            cellProcess(tds[j])\n          }\n        }\n\n        return {\n          data: d,\n          cells: tds\n        }\n      }\n      /**\n       * Create a new TR element (and it's TD children) for a row\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iRow Row to consider\n       *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\n       *    DataTables will create a row automatically\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n       *    if nTr is.\n       *  @memberof DataTable#oApi\n       */\n      function _fnCreateTr (oSettings, iRow, nTrIn, anTds) {\n        var row = oSettings.aoData[iRow],\n          rowData = row._aData,\n          cells = [],\n          nTr,\n          nTd,\n          oCol,\n          i,\n          iLen\n\n        if (row.nTr === null) {\n          nTr = nTrIn || document.createElement('tr')\n\n          row.nTr = nTr\n          row.anCells = cells\n\n          /* Use a private property on the node to allow reserve mapping from the node\n           * to the aoData array for fast look up\n           */\n          nTr._DT_RowIndex = iRow\n\n          /* Special parameters can be given by the data source to be used on the row */\n          _fnRowAttributes(row)\n\n          /* Process each column */\n          for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {\n            oCol = oSettings.aoColumns[i]\n\n            nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType)\n            cells.push(nTd)\n\n            // Need to create the HTML if new, or if a rendering function is defined\n            if (!nTrIn || oCol.mRender || oCol.mData !== i) {\n              nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display')\n            }\n\n            /* Add user defined class */\n            if (oCol.sClass) {\n              nTd.className += ' ' + oCol.sClass\n            }\n\n            // Visibility - add or remove as required\n            if (oCol.bVisible && !nTrIn) {\n              nTr.appendChild(nTd)\n            } else if (!oCol.bVisible && nTrIn) {\n              nTd.parentNode.removeChild(nTd)\n            }\n\n            if (oCol.fnCreatedCell) {\n              oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i)\n            }\n          }\n\n          _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow])\n        }\n\n        // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved\n        // and deployed\n        row.nTr.setAttribute('role', 'row')\n      }\n\n      /**\n       * Add attributes to a row based on the special `DT_*` parameters in a data\n       * source object.\n       *  @param {object} DataTables row object for the row to be modified\n       *  @memberof DataTable#oApi\n       */\n      function _fnRowAttributes (row) {\n        var tr = row.nTr\n        var data = row._aData\n\n        if (tr) {\n          if (data.DT_RowId) {\n            tr.id = data.DT_RowId\n          }\n\n          if (data.DT_RowClass) {\n            // Remove any classes added by DT_RowClass before\n            var a = data.DT_RowClass.split(' ')\n            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a\n\n            $(tr)\n              .removeClass(row.__rowc.join(' '))\n              .addClass(data.DT_RowClass)\n          }\n\n          if (data.DT_RowData) {\n            $(tr).data(data.DT_RowData)\n          }\n        }\n      }\n\n      /**\n       * Create the HTML header for the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnBuildHead (oSettings) {\n        var i, ien, cell, row, column\n        var thead = oSettings.nTHead\n        var tfoot = oSettings.nTFoot\n        var createHeader = $('th, td', thead).length === 0\n        var classes = oSettings.oClasses\n        var columns = oSettings.aoColumns\n\n        if (createHeader) {\n          row = $('<tr/>').appendTo(thead)\n        }\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          column = columns[i]\n          cell = $(column.nTh).addClass(column.sClass)\n\n          if (createHeader) {\n            cell.appendTo(row)\n          }\n\n          // 1.11 move into sorting\n          if (oSettings.oFeatures.bSort) {\n            cell.addClass(column.sSortingClass)\n\n            if (column.bSortable !== false) {\n              cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId)\n\n              _fnSortAttachListener(oSettings, column.nTh, i)\n            }\n          }\n\n          if (column.sTitle != cell.html()) {\n            cell.html(column.sTitle)\n          }\n\n          _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes)\n        }\n\n        if (createHeader) {\n          _fnDetectHeader(oSettings.aoHeader, thead)\n        }\n\n        /* ARIA role for the rows */\n        $(thead)\n          .find('>tr')\n          .attr('role', 'row')\n\n        /* Deal with the footer - add classes if required */\n        $(thead)\n          .find('>tr>th, >tr>td')\n          .addClass(classes.sHeaderTH)\n        $(tfoot)\n          .find('>tr>th, >tr>td')\n          .addClass(classes.sFooterTH)\n\n        // Cache the footer cells. Note that we only take the cells from the first\n        // row in the footer. If there is more than one row the user wants to\n        // interact with, they need to use the table().foot() method. Note also this\n        // allows cells to be used for multiple columns using colspan\n        if (tfoot !== null) {\n          var cells = oSettings.aoFooter[0]\n\n          for (i = 0, ien = cells.length; i < ien; i++) {\n            column = columns[i]\n            column.nTf = cells[i].cell\n\n            if (column.sClass) {\n              $(column.nTf).addClass(column.sClass)\n            }\n          }\n        }\n      }\n\n      /**\n       * Draw the header (or footer) element based on the column visibility states. The\n       * methodology here is to use the layout array from _fnDetectHeader, modified for\n       * the instantaneous column visibility, to construct the new layout. The grid is\n       * traversed over cell at a time in a rows x columns grid fashion, although each\n       * cell insert can cover multiple elements in the grid - which is tracks using the\n       * aApplied array. Cell inserts in the grid will only occur where there isn't\n       * already a cell in that position.\n       *  @param {object} oSettings dataTables settings object\n       *  @param array {objects} aoSource Layout array from _fnDetectHeader\n       *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\n       *  @memberof DataTable#oApi\n       */\n      function _fnDrawHead (oSettings, aoSource, bIncludeHidden) {\n        var i, iLen, j, jLen, k, kLen, n, nLocalTr\n        var aoLocal = []\n        var aApplied = []\n        var iColumns = oSettings.aoColumns.length\n        var iRowspan, iColspan\n\n        if (!aoSource) {\n          return\n        }\n\n        if (bIncludeHidden === undefined) {\n          bIncludeHidden = false\n        }\n\n        /* Make a copy of the master layout array, but without the visible columns in it */\n        for (i = 0, iLen = aoSource.length; i < iLen; i++) {\n          aoLocal[i] = aoSource[i].slice()\n          aoLocal[i].nTr = aoSource[i].nTr\n\n          /* Remove any columns which are currently hidden */\n          for (j = iColumns - 1; j >= 0; j--) {\n            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {\n              aoLocal[i].splice(j, 1)\n            }\n          }\n\n          /* Prep the applied array - it needs an element for each row */\n          aApplied.push([])\n        }\n\n        for (i = 0, iLen = aoLocal.length; i < iLen; i++) {\n          nLocalTr = aoLocal[i].nTr\n\n          /* All cells are going to be replaced, so empty out the row */\n          if (nLocalTr) {\n            while ((n = nLocalTr.firstChild)) {\n              nLocalTr.removeChild(n)\n            }\n          }\n\n          for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {\n            iRowspan = 1\n            iColspan = 1\n\n            /* Check to see if there is already a cell (row/colspan) covering our target\n             * insert point. If there is, then there is nothing to do.\n             */\n            if (aApplied[i][j] === undefined) {\n              nLocalTr.appendChild(aoLocal[i][j].cell)\n              aApplied[i][j] = 1\n\n              /* Expand the cell to cover as many rows as needed */\n              while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {\n                aApplied[i + iRowspan][j] = 1\n                iRowspan++\n              }\n\n              /* Expand the cell to cover as many columns as needed */\n              while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {\n                /* Must update the applied array over the rows for the columns */\n                for (k = 0; k < iRowspan; k++) {\n                  aApplied[i + k][j + iColspan] = 1\n                }\n                iColspan++\n              }\n\n              /* Do the actual expansion in the DOM */\n              $(aoLocal[i][j].cell)\n                .attr('rowspan', iRowspan)\n                .attr('colspan', iColspan)\n            }\n          }\n        }\n      }\n\n      /**\n       * Insert the required TR nodes into the table for display\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnDraw (oSettings) {\n        /* Provide a pre-callback function which can be used to cancel the draw is false is returned */\n        var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings])\n        if ($.inArray(false, aPreDraw) !== -1) {\n          _fnProcessingDisplay(oSettings, false)\n          return\n        }\n\n        var i, iLen, n\n        var anRows = []\n        var iRowCount = 0\n        var asStripeClasses = oSettings.asStripeClasses\n        var iStripes = asStripeClasses.length\n        var iOpenRows = oSettings.aoOpenRows.length\n        var oLang = oSettings.oLanguage\n        var iInitDisplayStart = oSettings.iInitDisplayStart\n        var bServerSide = _fnDataSource(oSettings) == 'ssp'\n        var aiDisplay = oSettings.aiDisplay\n\n        oSettings.bDrawing = true\n\n        /* Check and see if we have an initial draw position from state saving */\n        if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {\n          oSettings._iDisplayStart = bServerSide\n            ? iInitDisplayStart\n            : iInitDisplayStart >= oSettings.fnRecordsDisplay()\n            ? 0\n            : iInitDisplayStart\n\n          oSettings.iInitDisplayStart = -1\n        }\n\n        var iDisplayStart = oSettings._iDisplayStart\n        var iDisplayEnd = oSettings.fnDisplayEnd()\n\n        /* Server-side processing draw intercept */\n        if (oSettings.bDeferLoading) {\n          oSettings.bDeferLoading = false\n          oSettings.iDraw++\n          _fnProcessingDisplay(oSettings, false)\n        } else if (!bServerSide) {\n          oSettings.iDraw++\n        } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {\n          return\n        }\n\n        if (aiDisplay.length !== 0) {\n          var iStart = bServerSide ? 0 : iDisplayStart\n          var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd\n\n          for (var j = iStart; j < iEnd; j++) {\n            var iDataIndex = aiDisplay[j]\n            var aoData = oSettings.aoData[iDataIndex]\n            if (aoData.nTr === null) {\n              _fnCreateTr(oSettings, iDataIndex)\n            }\n\n            var nRow = aoData.nTr\n\n            /* Remove the old striping classes and then add the new one */\n            if (iStripes !== 0) {\n              var sStripe = asStripeClasses[iRowCount % iStripes]\n              if (aoData._sRowStripe != sStripe) {\n                $(nRow)\n                  .removeClass(aoData._sRowStripe)\n                  .addClass(sStripe)\n                aoData._sRowStripe = sStripe\n              }\n            }\n\n            /* Row callback functions - might want to manipulate the row */\n            _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j])\n\n            anRows.push(nRow)\n            iRowCount++\n          }\n        } else {\n          /* Table is empty - create a row with an empty message in it */\n          var sZero = oLang.sZeroRecords\n          if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {\n            sZero = oLang.sLoadingRecords\n          } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {\n            sZero = oLang.sEmptyTable\n          }\n\n          anRows[0] = $('<tr/>', { class: iStripes ? asStripeClasses[0] : '' }).append(\n            $('<td />', {\n              valign: 'top',\n              colSpan: _fnVisbleColumns(oSettings),\n              class: oSettings.oClasses.sRowEmpty\n            }).html(sZero)\n          )[0]\n        }\n\n        /* Header and footer callbacks */\n        _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [\n          $(oSettings.nTHead).children('tr')[0],\n          _fnGetDataMaster(oSettings),\n          iDisplayStart,\n          iDisplayEnd,\n          aiDisplay\n        ])\n\n        _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [\n          $(oSettings.nTFoot).children('tr')[0],\n          _fnGetDataMaster(oSettings),\n          iDisplayStart,\n          iDisplayEnd,\n          aiDisplay\n        ])\n\n        var body = $(oSettings.nTBody)\n\n        body.children().detach()\n        body.append($(anRows))\n\n        /* Call all required callback functions for the end of a draw */\n        _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings])\n\n        /* Draw is complete, sorting and filtering must be as well */\n        oSettings.bSorted = false\n        oSettings.bFiltered = false\n        oSettings.bDrawing = false\n      }\n\n      /**\n       * Redraw the table - taking account of the various features which are enabled\n       *  @param {object} oSettings dataTables settings object\n       *  @param {boolean} [holdPosition] Keep the current paging position. By default\n       *    the paging is reset to the first page\n       *  @memberof DataTable#oApi\n       */\n      function _fnReDraw (settings, holdPosition) {\n        var features = settings.oFeatures,\n          sort = features.bSort,\n          filter = features.bFilter\n\n        if (sort) {\n          _fnSort(settings)\n        }\n\n        if (filter) {\n          _fnFilterComplete(settings, settings.oPreviousSearch)\n        } else {\n          // No filtering, so we want to just use the display master\n          settings.aiDisplay = settings.aiDisplayMaster.slice()\n        }\n\n        if (holdPosition !== true) {\n          settings._iDisplayStart = 0\n        }\n\n        // Let any modules know about the draw hold position state (used by\n        // scrolling internally)\n        settings._drawHold = holdPosition\n\n        _fnDraw(settings)\n\n        settings._drawHold = false\n      }\n\n      /**\n       * Add the options to the page HTML for the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddOptionsHtml (oSettings) {\n        var classes = oSettings.oClasses\n        var table = $(oSettings.nTable)\n        var holding = $('<div/>').insertBefore(table) // Holding element for speed\n        var features = oSettings.oFeatures\n\n        // All DataTables are wrapped in a div\n        var insert = $('<div/>', {\n          id: oSettings.sTableId + '_wrapper',\n          class: classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)\n        })\n\n        oSettings.nHolding = holding[0]\n        oSettings.nTableWrapper = insert[0]\n        oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling\n\n        /* Loop over the user set positioning and place the elements as needed */\n        var aDom = oSettings.sDom.split('')\n        var featureNode, cOption, nNewNode, cNext, sAttr, j\n        for (var i = 0; i < aDom.length; i++) {\n          featureNode = null\n          cOption = aDom[i]\n\n          if (cOption == '<') {\n            /* New container div */\n            nNewNode = $('<div/>')[0]\n\n            /* Check to see if we should append an id and/or a class name to the container */\n            cNext = aDom[i + 1]\n            if (cNext == \"'\" || cNext == '\"') {\n              sAttr = ''\n              j = 2\n              while (aDom[i + j] != cNext) {\n                sAttr += aDom[i + j]\n                j++\n              }\n\n              /* Replace jQuery UI constants @todo depreciated */\n              if (sAttr == 'H') {\n                sAttr = classes.sJUIHeader\n              } else if (sAttr == 'F') {\n                sAttr = classes.sJUIFooter\n              }\n\n              /* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\n               * breaks the string into parts and applies them as needed\n               */\n              if (sAttr.indexOf('.') != -1) {\n                var aSplit = sAttr.split('.')\n                nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1)\n                nNewNode.className = aSplit[1]\n              } else if (sAttr.charAt(0) == '#') {\n                nNewNode.id = sAttr.substr(1, sAttr.length - 1)\n              } else {\n                nNewNode.className = sAttr\n              }\n\n              i += j /* Move along the position array */\n            }\n\n            insert.append(nNewNode)\n            insert = $(nNewNode)\n          } else if (cOption == '>') {\n            /* End container div */\n            insert = insert.parent()\n          }\n          // @todo Move options into their own plugins?\n          else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {\n            /* Length */\n            featureNode = _fnFeatureHtmlLength(oSettings)\n          } else if (cOption == 'f' && features.bFilter) {\n            /* Filter */\n            featureNode = _fnFeatureHtmlFilter(oSettings)\n          } else if (cOption == 'r' && features.bProcessing) {\n            /* pRocessing */\n            featureNode = _fnFeatureHtmlProcessing(oSettings)\n          } else if (cOption == 't') {\n            /* Table */\n            featureNode = _fnFeatureHtmlTable(oSettings)\n          } else if (cOption == 'i' && features.bInfo) {\n            /* Info */\n            featureNode = _fnFeatureHtmlInfo(oSettings)\n          } else if (cOption == 'p' && features.bPaginate) {\n            /* Pagination */\n            featureNode = _fnFeatureHtmlPaginate(oSettings)\n          } else if (DataTable.ext.feature.length !== 0) {\n            /* Plug-in features */\n            var aoFeatures = DataTable.ext.feature\n            for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {\n              if (cOption == aoFeatures[k].cFeature) {\n                featureNode = aoFeatures[k].fnInit(oSettings)\n                break\n              }\n            }\n          }\n\n          /* Add to the 2D features array */\n          if (featureNode) {\n            var aanFeatures = oSettings.aanFeatures\n\n            if (!aanFeatures[cOption]) {\n              aanFeatures[cOption] = []\n            }\n\n            aanFeatures[cOption].push(featureNode)\n            insert.append(featureNode)\n          }\n        }\n\n        /* Built our DOM structure - replace the holding div with what we want */\n        holding.replaceWith(insert)\n      }\n\n      /**\n       * Use the DOM source to create up an array of header cells. The idea here is to\n       * create a layout grid (array) of rows x columns, which contains a reference\n       * to the cell that that point in the grid (regardless of col/rowspan), such that\n       * any column / row could be removed and the new grid constructed\n       *  @param array {object} aLayout Array to store the calculated layout in\n       *  @param {node} nThead The header/footer element for the table\n       *  @memberof DataTable#oApi\n       */\n      function _fnDetectHeader (aLayout, nThead) {\n        var nTrs = $(nThead).children('tr')\n        var nTr, nCell\n        var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan\n        var bUnique\n        var fnShiftCol = function (a, i, j) {\n          var k = a[i]\n          while (k[j]) {\n            j++\n          }\n          return j\n        }\n\n        aLayout.splice(0, aLayout.length)\n\n        /* We know how many rows there are in the layout - so prep it */\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n          aLayout.push([])\n        }\n\n        /* Calculate a layout array */\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n          nTr = nTrs[i]\n          iColumn = 0\n\n          /* For every cell in the row... */\n          nCell = nTr.firstChild\n          while (nCell) {\n            if (nCell.nodeName.toUpperCase() == 'TD' || nCell.nodeName.toUpperCase() == 'TH') {\n              /* Get the col and rowspan attributes from the DOM and sanitise them */\n              iColspan = nCell.getAttribute('colspan') * 1\n              iRowspan = nCell.getAttribute('rowspan') * 1\n              iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan\n              iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan\n\n              /* There might be colspan cells already in this row, so shift our target\n               * accordingly\n               */\n              iColShifted = fnShiftCol(aLayout, i, iColumn)\n\n              /* Cache calculation for unique columns */\n              bUnique = iColspan === 1 ? true : false\n\n              /* If there is col / rowspan, copy the information into the layout grid */\n              for (l = 0; l < iColspan; l++) {\n                for (k = 0; k < iRowspan; k++) {\n                  aLayout[i + k][iColShifted + l] = {\n                    cell: nCell,\n                    unique: bUnique\n                  }\n                  aLayout[i + k].nTr = nTr\n                }\n              }\n            }\n            nCell = nCell.nextSibling\n          }\n        }\n      }\n\n      /**\n       * Get an array of unique th elements, one for each column\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} nHeader automatically detect the layout from this node - optional\n       *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\n       *  @returns array {node} aReturn list of unique th's\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetUniqueThs (oSettings, nHeader, aLayout) {\n        var aReturn = []\n        if (!aLayout) {\n          aLayout = oSettings.aoHeader\n          if (nHeader) {\n            aLayout = []\n            _fnDetectHeader(aLayout, nHeader)\n          }\n        }\n\n        for (var i = 0, iLen = aLayout.length; i < iLen; i++) {\n          for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {\n            if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {\n              aReturn[j] = aLayout[i][j].cell\n            }\n          }\n        }\n\n        return aReturn\n      }\n\n      /**\n       * Create an Ajax call based on the table's settings, taking into account that\n       * parameters can have multiple forms, and backwards compatibility.\n       *\n       * @param {object} oSettings dataTables settings object\n       * @param {array} data Data to send to the server, required by\n       *     DataTables - may be augmented by developer callbacks\n       * @param {function} fn Callback function to run when data is obtained\n       */\n      function _fnBuildAjax (oSettings, data, fn) {\n        // Compatibility with 1.9-, allow fnServerData and event to manipulate\n        _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data])\n\n        // Convert to object based for 1.10+ if using the old array scheme which can\n        // come from server-side processing or serverParams\n        if (data && $.isArray(data)) {\n          var tmp = {}\n          var rbracket = /(.*?)\\[\\]$/\n\n          $.each(data, function (key, val) {\n            var match = val.name.match(rbracket)\n\n            if (match) {\n              // Support for arrays\n              var name = match[0]\n\n              if (!tmp[name]) {\n                tmp[name] = []\n              }\n              tmp[name].push(val.value)\n            } else {\n              tmp[val.name] = val.value\n            }\n          })\n          data = tmp\n        }\n\n        var ajaxData\n        var ajax = oSettings.ajax\n        var instance = oSettings.oInstance\n\n        if ($.isPlainObject(ajax) && ajax.data) {\n          ajaxData = ajax.data\n\n          var newData = $.isFunction(ajaxData)\n            ? ajaxData(data) // fn can manipulate data or return an object\n            : ajaxData // object or array to merge\n\n          // If the function returned an object, use that alone\n          data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData)\n\n          // Remove the data property as we've resolved it already and don't want\n          // jQuery to do it again (it is restored at the end of the function)\n          delete ajax.data\n        }\n\n        var baseAjax = {\n          data: data,\n          success: function (json) {\n            var error = json.error || json.sError\n            if (error) {\n              oSettings.oApi._fnLog(oSettings, 0, error)\n            }\n\n            oSettings.json = json\n            _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json])\n            fn(json)\n          },\n          dataType: 'json',\n          cache: false,\n          type: oSettings.sServerMethod,\n          error: function (xhr, error, thrown) {\n            var log = oSettings.oApi._fnLog\n\n            if (error == 'parsererror') {\n              log(oSettings, 0, 'Invalid JSON response', 1)\n            } else if (xhr.readyState === 4) {\n              log(oSettings, 0, 'Ajax error', 7)\n            }\n\n            _fnProcessingDisplay(oSettings, false)\n          }\n        }\n\n        // Store the data submitted for the API\n        oSettings.oAjaxData = data\n\n        // Allow plug-ins and external processes to modify the data\n        _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data])\n\n        if (oSettings.fnServerData) {\n          // DataTables 1.9- compatibility\n          oSettings.fnServerData.call(\n            instance,\n            oSettings.sAjaxSource,\n            $.map(data, function (val, key) {\n              // Need to convert back to 1.9 trad format\n              return { name: key, value: val }\n            }),\n            fn,\n            oSettings\n          )\n        } else if (oSettings.sAjaxSource || typeof ajax === 'string') {\n          // DataTables 1.9- compatibility\n          oSettings.jqXHR = $.ajax(\n            $.extend(baseAjax, {\n              url: ajax || oSettings.sAjaxSource\n            })\n          )\n        } else if ($.isFunction(ajax)) {\n          // Is a function - let the caller define what needs to be done\n          oSettings.jqXHR = ajax.call(instance, data, fn, oSettings)\n        } else {\n          // Object to extend the base settings\n          oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax))\n\n          // Restore for next time around\n          ajax.data = ajaxData\n        }\n      }\n\n      /**\n       * Update the table using an Ajax call\n       *  @param {object} settings dataTables settings object\n       *  @returns {boolean} Block the table drawing or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnAjaxUpdate (settings) {\n        if (settings.bAjaxDataGet) {\n          settings.iDraw++\n          _fnProcessingDisplay(settings, true)\n\n          _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {\n            _fnAjaxUpdateDraw(settings, json)\n          })\n\n          return false\n        }\n        return true\n      }\n\n      /**\n       * Build up the parameters in an object needed for a server-side processing\n       * request. Note that this is basically done twice, is different ways - a modern\n       * method which is used by default in DataTables 1.10 which uses objects and\n       * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\n       * the sAjaxSource option is used in the initialisation, or the legacyAjax\n       * option is set.\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {bool} block the table drawing or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnAjaxParameters (settings) {\n        var columns = settings.aoColumns,\n          columnCount = columns.length,\n          features = settings.oFeatures,\n          preSearch = settings.oPreviousSearch,\n          preColSearch = settings.aoPreSearchCols,\n          i,\n          data = [],\n          dataProp,\n          column,\n          columnSearch,\n          sort = _fnSortFlatten(settings),\n          displayStart = settings._iDisplayStart,\n          displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1\n\n        var param = function (name, value) {\n          data.push({ name: name, value: value })\n        }\n\n        // DataTables 1.9- compatible method\n        param('sEcho', settings.iDraw)\n        param('iColumns', columnCount)\n        param('sColumns', _pluck(columns, 'sName').join(','))\n        param('iDisplayStart', displayStart)\n        param('iDisplayLength', displayLength)\n\n        // DataTables 1.10+ method\n        var d = {\n          draw: settings.iDraw,\n          columns: [],\n          order: [],\n          start: displayStart,\n          length: displayLength,\n          search: {\n            value: preSearch.sSearch,\n            regex: preSearch.bRegex\n          }\n        }\n\n        for (i = 0; i < columnCount; i++) {\n          column = columns[i]\n          columnSearch = preColSearch[i]\n          dataProp = typeof column.mData == 'function' ? 'function' : column.mData\n\n          d.columns.push({\n            data: dataProp,\n            name: column.sName,\n            searchable: column.bSearchable,\n            orderable: column.bSortable,\n            search: {\n              value: columnSearch.sSearch,\n              regex: columnSearch.bRegex\n            }\n          })\n\n          param('mDataProp_' + i, dataProp)\n\n          if (features.bFilter) {\n            param('sSearch_' + i, columnSearch.sSearch)\n            param('bRegex_' + i, columnSearch.bRegex)\n            param('bSearchable_' + i, column.bSearchable)\n          }\n\n          if (features.bSort) {\n            param('bSortable_' + i, column.bSortable)\n          }\n        }\n\n        if (features.bFilter) {\n          param('sSearch', preSearch.sSearch)\n          param('bRegex', preSearch.bRegex)\n        }\n\n        if (features.bSort) {\n          $.each(sort, function (i, val) {\n            d.order.push({ column: val.col, dir: val.dir })\n\n            param('iSortCol_' + i, val.col)\n            param('sSortDir_' + i, val.dir)\n          })\n\n          param('iSortingCols', sort.length)\n        }\n\n        // If the legacy.ajax parameter is null, then we automatically decide which\n        // form to use, based on sAjaxSource\n        var legacy = DataTable.ext.legacy.ajax\n        if (legacy === null) {\n          return settings.sAjaxSource ? data : d\n        }\n\n        // Otherwise, if legacy has been specified then we use that to decide on the\n        // form\n        return legacy ? data : d\n      }\n\n      /**\n       * Data the data from the server (nuking the old) and redraw the table\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} json json data return from the server.\n       *  @param {string} json.sEcho Tracking flag for DataTables to match requests\n       *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\n       *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\n       *  @param {array} json.aaData The data to display on this page\n       *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\n       *  @memberof DataTable#oApi\n       */\n      function _fnAjaxUpdateDraw (settings, json) {\n        // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\n        // Support both\n        var compat = function (old, modern) {\n          return json[old] !== undefined ? json[old] : json[modern]\n        }\n\n        var draw = compat('sEcho', 'draw')\n        var recordsTotal = compat('iTotalRecords', 'recordsTotal')\n        var rocordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered')\n\n        if (draw) {\n          // Protect against out of sequence returns\n          if (draw * 1 < settings.iDraw) {\n            return\n          }\n          settings.iDraw = draw * 1\n        }\n\n        _fnClearTable(settings)\n        settings._iRecordsTotal = parseInt(recordsTotal, 10)\n        settings._iRecordsDisplay = parseInt(rocordsFiltered, 10)\n\n        var data = _fnAjaxDataSrc(settings, json)\n        for (var i = 0, ien = data.length; i < ien; i++) {\n          _fnAddData(settings, data[i])\n        }\n        settings.aiDisplay = settings.aiDisplayMaster.slice()\n\n        settings.bAjaxDataGet = false\n        _fnDraw(settings)\n\n        if (!settings._bInitComplete) {\n          _fnInitComplete(settings, json)\n        }\n\n        settings.bAjaxDataGet = true\n        _fnProcessingDisplay(settings, false)\n      }\n\n      /**\n       * Get the data from the JSON data source to use for drawing a table. Using\n       * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\n       * source object, or from a processing function.\n       *  @param {object} oSettings dataTables settings object\n       *  @param  {object} json Data source object / array from the server\n       *  @return {array} Array of data to use\n       */\n      function _fnAjaxDataSrc (oSettings, json) {\n        var dataSrc =\n          $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined\n            ? oSettings.ajax.dataSrc\n            : oSettings.sAjaxDataProp // Compatibility with 1.9-.\n\n        // Compatibility with 1.9-. In order to read from aaData, check if the\n        // default has been changed, if not, check for aaData\n        if (dataSrc === 'data') {\n          return json.aaData || json[dataSrc]\n        }\n\n        return dataSrc !== '' ? _fnGetObjectDataFn(dataSrc)(json) : json\n      }\n\n      /**\n       * Generate the node required for filtering text\n       *  @returns {node} Filter control element\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlFilter (settings) {\n        var classes = settings.oClasses\n        var tableId = settings.sTableId\n        var language = settings.oLanguage\n        var previousSearch = settings.oPreviousSearch\n        var features = settings.aanFeatures\n        var input = '<input type=\"search\" class=\"' + classes.sFilterInput + '\"/>'\n\n        var str = language.sSearch\n        str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input\n\n        var filter = $('<div/>', {\n          id: !features.f ? tableId + '_filter' : null,\n          class: classes.sFilter\n        }).append($('<label/>').append(str))\n\n        var searchFn = function () {\n          /* Update all other filter input elements for the new display */\n          var n = features.f\n          var val = !this.value ? '' : this.value // mental IE8 fix :-(\n\n          /* Now do the filter */\n          if (val != previousSearch.sSearch) {\n            _fnFilterComplete(settings, {\n              sSearch: val,\n              bRegex: previousSearch.bRegex,\n              bSmart: previousSearch.bSmart,\n              bCaseInsensitive: previousSearch.bCaseInsensitive\n            })\n\n            // Need to redraw, without resorting\n            settings._iDisplayStart = 0\n            _fnDraw(settings)\n          }\n        }\n        var jqFilter = $('input', filter)\n          .val(previousSearch.sSearch)\n          .attr('placeholder', language.sSearchPlaceholder)\n          .bind(\n            'keyup.DT search.DT input.DT paste.DT cut.DT',\n            _fnDataSource(settings) === 'ssp' ? _fnThrottle(searchFn, 400) : searchFn\n          )\n          .bind('keypress.DT', function (e) {\n            /* Prevent form submission */\n            if (e.keyCode == 13) {\n              return false\n            }\n          })\n          .attr('aria-controls', tableId)\n\n        // Update the input elements whenever the table is filtered\n        $(settings.nTable).on('search.dt.DT', function (ev, s) {\n          if (settings === s) {\n            // IE9 throws an 'unknown error' if document.activeElement is used\n            // inside an iframe or frame...\n            try {\n              if (jqFilter[0] !== document.activeElement) {\n                jqFilter.val(previousSearch.sSearch)\n              }\n            } catch (e) {}\n          }\n        })\n\n        return filter[0]\n      }\n\n      /**\n       * Filter the table using both the global filter and column based filtering\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} oSearch search information\n       *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterComplete (oSettings, oInput, iForce) {\n        var oPrevSearch = oSettings.oPreviousSearch\n        var aoPrevSearch = oSettings.aoPreSearchCols\n        var fnSaveFilter = function (oFilter) {\n          /* Save the filtering values */\n          oPrevSearch.sSearch = oFilter.sSearch\n          oPrevSearch.bRegex = oFilter.bRegex\n          oPrevSearch.bSmart = oFilter.bSmart\n          oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive\n        }\n        var fnRegex = function (o) {\n          // Backwards compatibility with the bEscapeRegex option\n          return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex\n        }\n\n        // Resolve any column types that are unknown due to addition or invalidation\n        // @todo As per sort - can this be moved into an event handler?\n        _fnColumnTypes(oSettings)\n\n        /* In server-side processing all filtering is done by the server, so no point hanging around here */\n        if (_fnDataSource(oSettings) != 'ssp') {\n          /* Global filter */\n          _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive)\n          fnSaveFilter(oInput)\n\n          /* Now do the individual column filter */\n          for (var i = 0; i < aoPrevSearch.length; i++) {\n            _fnFilterColumn(\n              oSettings,\n              aoPrevSearch[i].sSearch,\n              i,\n              fnRegex(aoPrevSearch[i]),\n              aoPrevSearch[i].bSmart,\n              aoPrevSearch[i].bCaseInsensitive\n            )\n          }\n\n          /* Custom filtering */\n          _fnFilterCustom(oSettings)\n        } else {\n          fnSaveFilter(oInput)\n        }\n\n        /* Tell the draw function we have been filtering */\n        oSettings.bFiltered = true\n        _fnCallbackFire(oSettings, null, 'search', [oSettings])\n      }\n\n      /**\n       * Apply custom filtering functions\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterCustom (settings) {\n        var filters = DataTable.ext.search\n        var displayRows = settings.aiDisplay\n        var row, rowIdx\n\n        for (var i = 0, ien = filters.length; i < ien; i++) {\n          var rows = []\n\n          // Loop over each row and see if it should be included\n          for (var j = 0, jen = displayRows.length; j < jen; j++) {\n            rowIdx = displayRows[j]\n            row = settings.aoData[rowIdx]\n\n            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {\n              rows.push(rowIdx)\n            }\n          }\n\n          // So the array reference doesn't break set the results into the\n          // existing array\n          displayRows.length = 0\n          displayRows.push.apply(displayRows, rows)\n        }\n      }\n\n      /**\n       * Filter the table on a per-column basis\n       *  @param {object} oSettings dataTables settings object\n       *  @param {string} sInput string to filter on\n       *  @param {int} iColumn column to filter\n       *  @param {bool} bRegex treat search string as a regular expression or not\n       *  @param {bool} bSmart use smart filtering or not\n       *  @param {bool} bCaseInsensitive Do case insenstive matching or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterColumn (settings, searchStr, colIdx, regex, smart, caseInsensitive) {\n        if (searchStr === '') {\n          return\n        }\n\n        var data\n        var display = settings.aiDisplay\n        var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive)\n\n        for (var i = display.length - 1; i >= 0; i--) {\n          data = settings.aoData[display[i]]._aFilterData[colIdx]\n\n          if (!rpSearch.test(data)) {\n            display.splice(i, 1)\n          }\n        }\n      }\n\n      /**\n       * Filter the data table based on user input and draw the table\n       *  @param {object} settings dataTables settings object\n       *  @param {string} input string to filter on\n       *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\n       *  @param {bool} regex treat as a regular expression or not\n       *  @param {bool} smart perform smart filtering or not\n       *  @param {bool} caseInsensitive Do case insenstive matching or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilter (settings, input, force, regex, smart, caseInsensitive) {\n        var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive)\n        var prevSearch = settings.oPreviousSearch.sSearch\n        var displayMaster = settings.aiDisplayMaster\n        var display, invalidated, i\n\n        // Need to take account of custom filtering functions - always filter\n        if (DataTable.ext.search.length !== 0) {\n          force = true\n        }\n\n        // Check if any of the rows were invalidated\n        invalidated = _fnFilterData(settings)\n\n        // If the input is blank - we just want the full data set\n        if (input.length <= 0) {\n          settings.aiDisplay = displayMaster.slice()\n        } else {\n          // New search - start from the master array\n          if (\n            invalidated ||\n            force ||\n            prevSearch.length > input.length ||\n            input.indexOf(prevSearch) !== 0 ||\n            settings.bSorted // On resort, the display master needs to be\n            // re-filtered since indexes will have changed\n          ) {\n            settings.aiDisplay = displayMaster.slice()\n          }\n\n          // Search the display array\n          display = settings.aiDisplay\n\n          for (i = display.length - 1; i >= 0; i--) {\n            if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {\n              display.splice(i, 1)\n            }\n          }\n        }\n      }\n\n      /**\n       * Build a regular expression object suitable for searching a table\n       *  @param {string} sSearch string to search for\n       *  @param {bool} bRegex treat as a regular expression or not\n       *  @param {bool} bSmart perform smart filtering or not\n       *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n       *  @returns {RegExp} constructed object\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterCreateSearch (search, regex, smart, caseInsensitive) {\n        search = regex ? search : _fnEscapeRegex(search)\n\n        if (smart) {\n          /* For smart filtering we want to allow the search to work regardless of\n           * word order. We also want double quoted text to be preserved, so word\n           * order is important - a la google. So this is what we want to\n           * generate:\n           *\n           * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\n           */\n          var a = $.map(search.match(/\"[^\"]+\"|[^ ]+/g) || '', function (word) {\n            return word.charAt(0) === '\"' ? word.match(/^\"(.*)\"$/)[1] : word\n          })\n\n          search = '^(?=.*?' + a.join(')(?=.*?') + ').*$'\n        }\n\n        return new RegExp(search, caseInsensitive ? 'i' : '')\n      }\n\n      /**\n       * scape a string such that it can be used in a regular expression\n       *  @param {string} sVal string to escape\n       *  @returns {string} escaped string\n       *  @memberof DataTable#oApi\n       */\n      function _fnEscapeRegex (sVal) {\n        return sVal.replace(_re_escape_regex, '\\\\$1')\n      }\n\n      var __filter_div = $('<div>')[0]\n      var __filter_div_textContent = __filter_div.textContent !== undefined\n\n      // Update the filtering data for each row if needed (by invalidation or first run)\n      function _fnFilterData (settings) {\n        var columns = settings.aoColumns\n        var column\n        var i, j, ien, jen, filterData, cellData, row\n        var fomatters = DataTable.ext.type.search\n        var wasInvalidated = false\n\n        for (i = 0, ien = settings.aoData.length; i < ien; i++) {\n          row = settings.aoData[i]\n\n          if (!row._aFilterData) {\n            filterData = []\n\n            for (j = 0, jen = columns.length; j < jen; j++) {\n              column = columns[j]\n\n              if (column.bSearchable) {\n                cellData = _fnGetCellData(settings, i, j, 'filter')\n\n                if (fomatters[column.sType]) {\n                  cellData = fomatters[column.sType](cellData)\n                }\n\n                // Search in DataTables 1.10 is string based. In 1.11 this\n                // should be altered to also allow strict type checking.\n                if (cellData === null) {\n                  cellData = ''\n                }\n\n                if (typeof cellData !== 'string' && cellData.toString) {\n                  cellData = cellData.toString()\n                }\n              } else {\n                cellData = ''\n              }\n\n              // If it looks like there is an HTML entity in the string,\n              // attempt to decode it so sorting works as expected. Note that\n              // we could use a single line of jQuery to do this, but the DOM\n              // method used here is much faster http://jsperf.com/html-decode\n              if (cellData.indexOf && cellData.indexOf('&') !== -1) {\n                __filter_div.innerHTML = cellData\n                cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText\n              }\n\n              if (cellData.replace) {\n                cellData = cellData.replace(/[\\r\\n]/g, '')\n              }\n\n              filterData.push(cellData)\n            }\n\n            row._aFilterData = filterData\n            row._sFilterRow = filterData.join('  ')\n            wasInvalidated = true\n          }\n        }\n\n        return wasInvalidated\n      }\n\n      /**\n       * Convert from the internal Hungarian notation to camelCase for external\n       * interaction\n       *  @param {object} obj Object to convert\n       *  @returns {object} Inverted object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSearchToCamel (obj) {\n        return {\n          search: obj.sSearch,\n          smart: obj.bSmart,\n          regex: obj.bRegex,\n          caseInsensitive: obj.bCaseInsensitive\n        }\n      }\n\n      /**\n       * Convert from camelCase notation to the internal Hungarian. We could use the\n       * Hungarian convert function here, but this is cleaner\n       *  @param {object} obj Object to convert\n       *  @returns {object} Inverted object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSearchToHung (obj) {\n        return {\n          sSearch: obj.search,\n          bSmart: obj.smart,\n          bRegex: obj.regex,\n          bCaseInsensitive: obj.caseInsensitive\n        }\n      }\n\n      /**\n       * Generate the node required for the info display\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {node} Information element\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlInfo (settings) {\n        var tid = settings.sTableId,\n          nodes = settings.aanFeatures.i,\n          n = $('<div/>', {\n            class: settings.oClasses.sInfo,\n            id: !nodes ? tid + '_info' : null\n          })\n\n        if (!nodes) {\n          // Update display on each draw\n          settings.aoDrawCallback.push({\n            fn: _fnUpdateInfo,\n            sName: 'information'\n          })\n\n          n.attr('role', 'status').attr('aria-live', 'polite')\n\n          // Table is described by our info div\n          $(settings.nTable).attr('aria-describedby', tid + '_info')\n        }\n\n        return n[0]\n      }\n\n      /**\n       * Update the information elements in the display\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnUpdateInfo (settings) {\n        /* Show information about the table */\n        var nodes = settings.aanFeatures.i\n        if (nodes.length === 0) {\n          return\n        }\n\n        var lang = settings.oLanguage,\n          start = settings._iDisplayStart + 1,\n          end = settings.fnDisplayEnd(),\n          max = settings.fnRecordsTotal(),\n          total = settings.fnRecordsDisplay(),\n          out = total ? lang.sInfo : lang.sInfoEmpty\n\n        if (total !== max) {\n          /* Record set after filtering */\n          out += ' ' + lang.sInfoFiltered\n        }\n\n        // Convert the macros\n        out += lang.sInfoPostFix\n        out = _fnInfoMacros(settings, out)\n\n        var callback = lang.fnInfoCallback\n        if (callback !== null) {\n          out = callback.call(settings.oInstance, settings, start, end, max, total, out)\n        }\n\n        $(nodes).html(out)\n      }\n\n      function _fnInfoMacros (settings, str) {\n        // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\n        // internally\n        var formatter = settings.fnFormatNumber,\n          start = settings._iDisplayStart + 1,\n          len = settings._iDisplayLength,\n          vis = settings.fnRecordsDisplay(),\n          all = len === -1\n\n        return str\n          .replace(/_START_/g, formatter.call(settings, start))\n          .replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd()))\n          .replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal()))\n          .replace(/_TOTAL_/g, formatter.call(settings, vis))\n          .replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len)))\n          .replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)))\n      }\n\n      /**\n       * Draw the table for the first time, adding all required features\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnInitialise (settings) {\n        var i,\n          iLen,\n          iAjaxStart = settings.iInitDisplayStart\n        var columns = settings.aoColumns,\n          column\n        var features = settings.oFeatures\n\n        /* Ensure that the table data is fully initialised */\n        if (!settings.bInitialised) {\n          setTimeout(function () {\n            _fnInitialise(settings)\n          }, 200)\n          return\n        }\n\n        /* Show the display HTML options */\n        _fnAddOptionsHtml(settings)\n\n        /* Build and draw the header / footer for the table */\n        _fnBuildHead(settings)\n        _fnDrawHead(settings, settings.aoHeader)\n        _fnDrawHead(settings, settings.aoFooter)\n\n        /* Okay to show that something is going on now */\n        _fnProcessingDisplay(settings, true)\n\n        /* Calculate sizes for columns */\n        if (features.bAutoWidth) {\n          _fnCalculateColumnWidths(settings)\n        }\n\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\n          column = columns[i]\n\n          if (column.sWidth) {\n            column.nTh.style.width = _fnStringToCss(column.sWidth)\n          }\n        }\n\n        // If there is default sorting required - let's do it. The sort function\n        // will do the drawing for us. Otherwise we draw the table regardless of the\n        // Ajax source - this allows the table to look initialised for Ajax sourcing\n        // data (show 'loading' message possibly)\n        _fnReDraw(settings)\n\n        // Server-side processing init complete is done by _fnAjaxUpdateDraw\n        var dataSrc = _fnDataSource(settings)\n        if (dataSrc != 'ssp') {\n          // if there is an ajax source load the data\n          if (dataSrc == 'ajax') {\n            _fnBuildAjax(\n              settings,\n              [],\n              function (json) {\n                var aData = _fnAjaxDataSrc(settings, json)\n\n                // Got the data - add it to the table\n                for (i = 0; i < aData.length; i++) {\n                  _fnAddData(settings, aData[i])\n                }\n\n                // Reset the init display for cookie saving. We've already done\n                // a filter, and therefore cleared it before. So we need to make\n                // it appear 'fresh'\n                settings.iInitDisplayStart = iAjaxStart\n\n                _fnReDraw(settings)\n\n                _fnProcessingDisplay(settings, false)\n                _fnInitComplete(settings, json)\n              },\n              settings\n            )\n          } else {\n            _fnProcessingDisplay(settings, false)\n            _fnInitComplete(settings)\n          }\n        }\n      }\n\n      /**\n       * Draw the table for the first time, adding all required features\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\n       *    with client-side processing (optional)\n       *  @memberof DataTable#oApi\n       */\n      function _fnInitComplete (settings, json) {\n        settings._bInitComplete = true\n\n        // On an Ajax load we now have data and therefore want to apply the column\n        // sizing\n        if (json) {\n          _fnAdjustColumnSizing(settings)\n        }\n\n        _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json])\n      }\n\n      function _fnLengthChange (settings, val) {\n        var len = parseInt(val, 10)\n        settings._iDisplayLength = len\n\n        _fnLengthOverflow(settings)\n\n        // Fire length change event\n        _fnCallbackFire(settings, null, 'length', [settings, len])\n      }\n\n      /**\n       * Generate the node required for user display length changing\n       *  @param {object} settings dataTables settings object\n       *  @returns {node} Display length feature node\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlLength (settings) {\n        var classes = settings.oClasses,\n          tableId = settings.sTableId,\n          menu = settings.aLengthMenu,\n          d2 = $.isArray(menu[0]),\n          lengths = d2 ? menu[0] : menu,\n          language = d2 ? menu[1] : menu\n\n        var select = $('<select/>', {\n          name: tableId + '_length',\n          'aria-controls': tableId,\n          class: classes.sLengthSelect\n        })\n\n        for (var i = 0, ien = lengths.length; i < ien; i++) {\n          select[0][i] = new Option(language[i], lengths[i])\n        }\n\n        var div = $('<div><label/></div>').addClass(classes.sLength)\n        if (!settings.aanFeatures.l) {\n          div[0].id = tableId + '_length'\n        }\n\n        div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML))\n\n        // Can't use `select` variable as user might provide their own and the\n        // reference is broken by the use of outerHTML\n        $('select', div)\n          .val(settings._iDisplayLength)\n          .bind('change.DT', function (e) {\n            _fnLengthChange(settings, $(this).val())\n            _fnDraw(settings)\n          })\n\n        // Update node value whenever anything changes the table's length\n        $(settings.nTable).bind('length.dt.DT', function (e, s, len) {\n          if (settings === s) {\n            $('select', div).val(len)\n          }\n        })\n\n        return div[0]\n      }\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Note that most of the paging logic is done in\n       * DataTable.ext.pager\n       */\n\n      /**\n       * Generate the node required for default pagination\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {node} Pagination feature node\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlPaginate (settings) {\n        var type = settings.sPaginationType,\n          plugin = DataTable.ext.pager[type],\n          modern = typeof plugin === 'function',\n          redraw = function (settings) {\n            _fnDraw(settings)\n          },\n          node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],\n          features = settings.aanFeatures\n\n        if (!modern) {\n          plugin.fnInit(settings, node, redraw)\n        }\n\n        /* Add a draw callback for the pagination on first instance, to update the paging display */\n        if (!features.p) {\n          node.id = settings.sTableId + '_paginate'\n\n          settings.aoDrawCallback.push({\n            fn: function (settings) {\n              if (modern) {\n                var start = settings._iDisplayStart,\n                  len = settings._iDisplayLength,\n                  visRecords = settings.fnRecordsDisplay(),\n                  all = len === -1,\n                  page = all ? 0 : Math.ceil(start / len),\n                  pages = all ? 1 : Math.ceil(visRecords / len),\n                  buttons = plugin(page, pages),\n                  i,\n                  ien\n\n                for (i = 0, ien = features.p.length; i < ien; i++) {\n                  _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages)\n                }\n              } else {\n                plugin.fnUpdate(settings, redraw)\n              }\n            },\n            sName: 'pagination'\n          })\n        }\n\n        return node\n      }\n\n      /**\n       * Alter the display settings to change the page\n       *  @param {object} settings DataTables settings object\n       *  @param {string|int} action Paging action to take: \"first\", \"previous\",\n       *    \"next\" or \"last\" or page number to jump to (integer)\n       *  @param [bool] redraw Automatically draw the update or not\n       *  @returns {bool} true page has changed, false - no change\n       *  @memberof DataTable#oApi\n       */\n      function _fnPageChange (settings, action, redraw) {\n        var start = settings._iDisplayStart,\n          len = settings._iDisplayLength,\n          records = settings.fnRecordsDisplay()\n\n        if (records === 0 || len === -1) {\n          start = 0\n        } else if (typeof action === 'number') {\n          start = action * len\n\n          if (start > records) {\n            start = 0\n          }\n        } else if (action == 'first') {\n          start = 0\n        } else if (action == 'previous') {\n          start = len >= 0 ? start - len : 0\n\n          if (start < 0) {\n            start = 0\n          }\n        } else if (action == 'next') {\n          if (start + len < records) {\n            start += len\n          }\n        } else if (action == 'last') {\n          start = Math.floor((records - 1) / len) * len\n        } else {\n          _fnLog(settings, 0, 'Unknown paging action: ' + action, 5)\n        }\n\n        var changed = settings._iDisplayStart !== start\n        settings._iDisplayStart = start\n\n        if (changed) {\n          _fnCallbackFire(settings, null, 'page', [settings])\n\n          if (redraw) {\n            _fnDraw(settings)\n          }\n        }\n\n        return changed\n      }\n\n      /**\n       * Generate the node required for the processing node\n       *  @param {object} settings dataTables settings object\n       *  @returns {node} Processing element\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlProcessing (settings) {\n        return $('<div/>', {\n          id: !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,\n          class: settings.oClasses.sProcessing\n        })\n          .html(settings.oLanguage.sProcessing)\n          .insertBefore(settings.nTable)[0]\n      }\n\n      /**\n       * Display or hide the processing indicator\n       *  @param {object} settings dataTables settings object\n       *  @param {bool} show Show the processing indicator (true) or not (false)\n       *  @memberof DataTable#oApi\n       */\n      function _fnProcessingDisplay (settings, show) {\n        if (settings.oFeatures.bProcessing) {\n          $(settings.aanFeatures.r).css('display', show ? 'block' : 'none')\n        }\n\n        _fnCallbackFire(settings, null, 'processing', [settings, show])\n      }\n\n      /**\n       * Add any control elements for the table - specifically scrolling\n       *  @param {object} settings dataTables settings object\n       *  @returns {node} Node to add to the DOM\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlTable (settings) {\n        var table = $(settings.nTable)\n\n        // Add the ARIA grid role to the table\n        table.attr('role', 'grid')\n\n        // Scrolling from here on in\n        var scroll = settings.oScroll\n\n        if (scroll.sX === '' && scroll.sY === '') {\n          return settings.nTable\n        }\n\n        var scrollX = scroll.sX\n        var scrollY = scroll.sY\n        var classes = settings.oClasses\n        var caption = table.children('caption')\n        var captionSide = caption.length ? caption[0]._captionSide : null\n        var headerClone = $(table[0].cloneNode(false))\n        var footerClone = $(table[0].cloneNode(false))\n        var footer = table.children('tfoot')\n        var _div = '<div/>'\n        var size = function (s) {\n          return !s ? null : _fnStringToCss(s)\n        }\n\n        // This is fairly messy, but with x scrolling enabled, if the table has a\n        // width attribute, regardless of any width applied using the column width\n        // options, the browser will shrink or grow the table as needed to fit into\n        // that 100%. That would make the width options useless. So we remove it.\n        // This is okay, under the assumption that width:100% is applied to the\n        // table in CSS (it is in the default stylesheet) which will set the table\n        // width as appropriate (the attribute and css behave differently...)\n        if (scroll.sX && table.attr('width') === '100%') {\n          table.removeAttr('width')\n        }\n\n        if (!footer.length) {\n          footer = null\n        }\n\n        /*\n         * The HTML structure that we want to generate in this function is:\n         *  div - scroller\n         *    div - scroll head\n         *      div - scroll head inner\n         *        table - scroll head table\n         *          thead - thead\n         *    div - scroll body\n         *      table - table (master table)\n         *        thead - thead clone for sizing\n         *        tbody - tbody\n         *    div - scroll foot\n         *      div - scroll foot inner\n         *        table - scroll foot table\n         *          tfoot - tfoot\n         */\n        var scroller = $(_div, { class: classes.sScrollWrapper })\n          .append(\n            $(_div, { class: classes.sScrollHead })\n              .css({\n                overflow: 'hidden',\n                position: 'relative',\n                border: 0,\n                width: scrollX ? size(scrollX) : '100%'\n              })\n              .append(\n                $(_div, { class: classes.sScrollHeadInner })\n                  .css({\n                    'box-sizing': 'content-box',\n                    width: scroll.sXInner || '100%'\n                  })\n                  .append(\n                    headerClone\n                      .removeAttr('id')\n                      .css('margin-left', 0)\n                      .append(table.children('thead'))\n                  )\n              )\n              .append(captionSide === 'top' ? caption : null)\n          )\n          .append(\n            $(_div, { class: classes.sScrollBody })\n              .css({\n                overflow: 'auto',\n                height: size(scrollY),\n                width: size(scrollX)\n              })\n              .append(table)\n          )\n\n        if (footer) {\n          scroller.append(\n            $(_div, { class: classes.sScrollFoot })\n              .css({\n                overflow: 'hidden',\n                border: 0,\n                width: scrollX ? size(scrollX) : '100%'\n              })\n              .append(\n                $(_div, { class: classes.sScrollFootInner }).append(\n                  footerClone\n                    .removeAttr('id')\n                    .css('margin-left', 0)\n                    .append(table.children('tfoot'))\n                )\n              )\n              .append(captionSide === 'bottom' ? caption : null)\n          )\n        }\n\n        var children = scroller.children()\n        var scrollHead = children[0]\n        var scrollBody = children[1]\n        var scrollFoot = footer ? children[2] : null\n\n        // When the body is scrolled, then we also want to scroll the headers\n        if (scrollX) {\n          $(scrollBody).scroll(function (e) {\n            var scrollLeft = this.scrollLeft\n\n            scrollHead.scrollLeft = scrollLeft\n\n            if (footer) {\n              scrollFoot.scrollLeft = scrollLeft\n            }\n          })\n        }\n\n        settings.nScrollHead = scrollHead\n        settings.nScrollBody = scrollBody\n        settings.nScrollFoot = scrollFoot\n\n        // On redraw - align columns\n        settings.aoDrawCallback.push({\n          fn: _fnScrollDraw,\n          sName: 'scrolling'\n        })\n\n        return scroller[0]\n      }\n\n      /**\n       * Update the header, footer and body tables for resizing - i.e. column\n       * alignment.\n       *\n       * Welcome to the most horrible function DataTables. The process that this\n       * function follows is basically:\n       *   1. Re-create the table inside the scrolling div\n       *   2. Take live measurements from the DOM\n       *   3. Apply the measurements to align the columns\n       *   4. Clean up\n       *\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnScrollDraw (settings) {\n        // Given that this is such a monster function, a lot of variables are use\n        // to try and keep the minimised size as small as possible\n        var scroll = settings.oScroll,\n          scrollX = scroll.sX,\n          scrollXInner = scroll.sXInner,\n          scrollY = scroll.sY,\n          barWidth = scroll.iBarWidth,\n          divHeader = $(settings.nScrollHead),\n          divHeaderStyle = divHeader[0].style,\n          divHeaderInner = divHeader.children('div'),\n          divHeaderInnerStyle = divHeaderInner[0].style,\n          divHeaderTable = divHeaderInner.children('table'),\n          divBodyEl = settings.nScrollBody,\n          divBody = $(divBodyEl),\n          divBodyStyle = divBodyEl.style,\n          divFooter = $(settings.nScrollFoot),\n          divFooterInner = divFooter.children('div'),\n          divFooterTable = divFooterInner.children('table'),\n          header = $(settings.nTHead),\n          table = $(settings.nTable),\n          tableEl = table[0],\n          tableStyle = tableEl.style,\n          footer = settings.nTFoot ? $(settings.nTFoot) : null,\n          browser = settings.oBrowser,\n          ie67 = browser.bScrollOversize,\n          headerTrgEls,\n          footerTrgEls,\n          headerSrcEls,\n          footerSrcEls,\n          headerCopy,\n          footerCopy,\n          headerWidths = [],\n          footerWidths = [],\n          headerContent = [],\n          idx,\n          correction,\n          sanityWidth,\n          zeroOut = function (nSizer) {\n            var style = nSizer.style\n            style.paddingTop = '0'\n            style.paddingBottom = '0'\n            style.borderTopWidth = '0'\n            style.borderBottomWidth = '0'\n            style.height = 0\n          }\n\n        /*\n         * 1. Re-create the table inside the scrolling div\n         */\n\n        // Remove the old minimised thead and tfoot elements in the inner table\n        table.children('thead, tfoot').remove()\n\n        // Clone the current header and footer elements and then place it into the inner table\n        headerCopy = header.clone().prependTo(table)\n        headerTrgEls = header.find('tr') // original header is in its own table\n        headerSrcEls = headerCopy.find('tr')\n        headerCopy.find('th, td').removeAttr('tabindex')\n\n        if (footer) {\n          footerCopy = footer.clone().prependTo(table)\n          footerTrgEls = footer.find('tr') // the original tfoot is in its own table and must be sized\n          footerSrcEls = footerCopy.find('tr')\n        }\n\n        /*\n         * 2. Take live measurements from the DOM - do not alter the DOM itself!\n         */\n\n        // Remove old sizing and apply the calculated column widths\n        // Get the unique column headers in the newly created (cloned) header. We want to apply the\n        // calculated sizes to this header\n        if (!scrollX) {\n          divBodyStyle.width = '100%'\n          divHeader[0].style.width = '100%'\n        }\n\n        $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {\n          idx = _fnVisibleToColumnIndex(settings, i)\n          el.style.width = settings.aoColumns[idx].sWidth\n        })\n\n        if (footer) {\n          _fnApplyToChildren(function (n) {\n            n.style.width = ''\n          }, footerSrcEls)\n        }\n\n        // If scroll collapse is enabled, when we put the headers back into the body for sizing, we\n        // will end up forcing the scrollbar to appear, making our measurements wrong for when we\n        // then hide it (end of this function), so add the header height to the body scroller.\n        if (scroll.bCollapse && scrollY !== '') {\n          divBodyStyle.height = divBody[0].offsetHeight + header[0].offsetHeight + 'px'\n        }\n\n        // Size the table as a whole\n        sanityWidth = table.outerWidth()\n        if (scrollX === '') {\n          // No x scrolling\n          tableStyle.width = '100%'\n\n          // IE7 will make the width of the table when 100% include the scrollbar\n          // - which is shouldn't. When there is a scrollbar we need to take this\n          // into account.\n          if (\n            ie67 &&\n            (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')\n          ) {\n            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth)\n          }\n        } else {\n          // x scrolling\n          if (scrollXInner !== '') {\n            // x scroll inner has been given - use it\n            tableStyle.width = _fnStringToCss(scrollXInner)\n          } else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {\n            // There is y-scrolling - try to take account of the y scroll bar\n            tableStyle.width = _fnStringToCss(sanityWidth - barWidth)\n            if (table.outerWidth() > sanityWidth - barWidth) {\n              // Not possible to take account of it\n              tableStyle.width = _fnStringToCss(sanityWidth)\n            }\n          } else {\n            // When all else fails\n            tableStyle.width = _fnStringToCss(sanityWidth)\n          }\n        }\n\n        // Recalculate the sanity width - now that we've applied the required width,\n        // before it was a temporary variable. This is required because the column\n        // width calculation is done before this table DOM is created.\n        sanityWidth = table.outerWidth()\n\n        // Hidden header should have zero height, so remove padding and borders. Then\n        // set the width based on the real headers\n\n        // Apply all styles in one pass\n        _fnApplyToChildren(zeroOut, headerSrcEls)\n\n        // Read all widths in next pass\n        _fnApplyToChildren(function (nSizer) {\n          headerContent.push(nSizer.innerHTML)\n          headerWidths.push(_fnStringToCss($(nSizer).css('width')))\n        }, headerSrcEls)\n\n        // Apply all widths in final pass\n        _fnApplyToChildren(function (nToSize, i) {\n          nToSize.style.width = headerWidths[i]\n        }, headerTrgEls)\n\n        $(headerSrcEls).height(0)\n\n        /* Same again with the footer if we have one */\n        if (footer) {\n          _fnApplyToChildren(zeroOut, footerSrcEls)\n\n          _fnApplyToChildren(function (nSizer) {\n            footerWidths.push(_fnStringToCss($(nSizer).css('width')))\n          }, footerSrcEls)\n\n          _fnApplyToChildren(function (nToSize, i) {\n            nToSize.style.width = footerWidths[i]\n          }, footerTrgEls)\n\n          $(footerSrcEls).height(0)\n        }\n\n        /*\n         * 3. Apply the measurements\n         */\n\n        // \"Hide\" the header and footer that we used for the sizing. We need to keep\n        // the content of the cell so that the width applied to the header and body\n        // both match, but we want to hide it completely. We want to also fix their\n        // width to what they currently are\n        _fnApplyToChildren(function (nSizer, i) {\n          nSizer.innerHTML =\n            '<div class=\"dataTables_sizing\" style=\"height:0;overflow:hidden;\">' + headerContent[i] + '</div>'\n          nSizer.style.width = headerWidths[i]\n        }, headerSrcEls)\n\n        if (footer) {\n          _fnApplyToChildren(function (nSizer, i) {\n            nSizer.innerHTML = ''\n            nSizer.style.width = footerWidths[i]\n          }, footerSrcEls)\n        }\n\n        // Sanity check that the table is of a sensible width. If not then we are going to get\n        // misalignment - try to prevent this by not allowing the table to shrink below its min width\n        if (table.outerWidth() < sanityWidth) {\n          // The min width depends upon if we have a vertical scrollbar visible or not */\n          correction =\n            divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll'\n              ? sanityWidth + barWidth\n              : sanityWidth\n\n          // IE6/7 are a law unto themselves...\n          if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')) {\n            tableStyle.width = _fnStringToCss(correction - barWidth)\n          }\n\n          // And give the user a warning that we've stopped the table getting too small\n          if (scrollX === '' || scrollXInner !== '') {\n            _fnLog(settings, 1, 'Possible column misalignment', 6)\n          }\n        } else {\n          correction = '100%'\n        }\n\n        // Apply to the container elements\n        divBodyStyle.width = _fnStringToCss(correction)\n        divHeaderStyle.width = _fnStringToCss(correction)\n\n        if (footer) {\n          settings.nScrollFoot.style.width = _fnStringToCss(correction)\n        }\n\n        /*\n         * 4. Clean up\n         */\n        if (!scrollY) {\n          /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\n           * the scrollbar height from the visible display, rather than adding it on. We need to\n           * set the height in order to sort this. Don't want to do it in any other browsers.\n           */\n          if (ie67) {\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth)\n          }\n        }\n\n        if (scrollY && scroll.bCollapse) {\n          divBodyStyle.height = _fnStringToCss(scrollY)\n\n          var iExtra = scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth ? barWidth : 0\n\n          if (tableEl.offsetHeight < divBodyEl.offsetHeight) {\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra)\n          }\n        }\n\n        /* Finally set the width's of the header and footer tables */\n        var iOuterWidth = table.outerWidth()\n        divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth)\n        divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth)\n\n        // Figure out if there are scrollbar present - if so then we need a the header and footer to\n        // provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\n        var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == 'scroll'\n        var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right')\n        divHeaderInnerStyle[padding] = bScrolling ? barWidth + 'px' : '0px'\n\n        if (footer) {\n          divFooterTable[0].style.width = _fnStringToCss(iOuterWidth)\n          divFooterInner[0].style.width = _fnStringToCss(iOuterWidth)\n          divFooterInner[0].style[padding] = bScrolling ? barWidth + 'px' : '0px'\n        }\n\n        /* Adjust the position of the header in case we loose the y-scrollbar */\n        divBody.scroll()\n\n        // If sorting or filtering has occurred, jump the scrolling back to the top\n        // only if we aren't holding the position\n        if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {\n          divBodyEl.scrollTop = 0\n        }\n      }\n\n      /**\n       * Apply a given function to the display child nodes of an element array (typically\n       * TD children of TR rows\n       *  @param {function} fn Method to apply to the objects\n       *  @param array {nodes} an1 List of elements to look through for display children\n       *  @param array {nodes} an2 Another list (identical structure to the first) - optional\n       *  @memberof DataTable#oApi\n       */\n      function _fnApplyToChildren (fn, an1, an2) {\n        var index = 0,\n          i = 0,\n          iLen = an1.length\n        var nNode1, nNode2\n\n        while (i < iLen) {\n          nNode1 = an1[i].firstChild\n          nNode2 = an2 ? an2[i].firstChild : null\n\n          while (nNode1) {\n            if (nNode1.nodeType === 1) {\n              if (an2) {\n                fn(nNode1, nNode2, index)\n              } else {\n                fn(nNode1, index)\n              }\n\n              index++\n            }\n\n            nNode1 = nNode1.nextSibling\n            nNode2 = an2 ? nNode2.nextSibling : null\n          }\n\n          i++\n        }\n      }\n\n      var __re_html_remove = /<.*?>/g\n\n      /**\n       * Calculate the width of columns for the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnCalculateColumnWidths (oSettings) {\n        var table = oSettings.nTable,\n          columns = oSettings.aoColumns,\n          scroll = oSettings.oScroll,\n          scrollY = scroll.sY,\n          scrollX = scroll.sX,\n          scrollXInner = scroll.sXInner,\n          columnCount = columns.length,\n          visibleColumns = _fnGetColumns(oSettings, 'bVisible'),\n          headerCells = $('th', oSettings.nTHead),\n          tableWidthAttr = table.getAttribute('width'),\n          tableContainer = table.parentNode,\n          userInputs = false,\n          i,\n          column,\n          columnIdx,\n          width,\n          outerWidth\n\n        /* Convert any user input sizes into pixel sizes */\n        for (i = 0; i < visibleColumns.length; i++) {\n          column = columns[visibleColumns[i]]\n\n          if (column.sWidth !== null) {\n            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer)\n\n            userInputs = true\n          }\n        }\n\n        /* If the number of columns in the DOM equals the number that we have to\n         * process in DataTables, then we can use the offsets that are created by\n         * the web- browser. No custom sizes can be set in order for this to happen,\n         * nor scrolling used\n         */\n        if (\n          !userInputs &&\n          !scrollX &&\n          !scrollY &&\n          columnCount == _fnVisbleColumns(oSettings) &&\n          columnCount == headerCells.length\n        ) {\n          for (i = 0; i < columnCount; i++) {\n            columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width())\n          }\n        } else {\n          // Otherwise construct a single row table with the widest node in the\n          // data, assign any user defined widths, then insert it into the DOM and\n          // allow the browser to do all the hard work of calculating table widths\n          var tmpTable = $(table)\n            .clone() // don't use cloneNode - IE8 will remove events on the main table\n            .empty()\n            .css('visibility', 'hidden')\n            .removeAttr('id')\n            .append($(oSettings.nTHead).clone(false))\n            .append($(oSettings.nTFoot).clone(false))\n            .append($('<tbody><tr/></tbody>'))\n\n          // Remove any assigned widths from the footer (from scrolling)\n          tmpTable.find('tfoot th, tfoot td').css('width', '')\n\n          var tr = tmpTable.find('tbody tr')\n\n          // Apply custom sizing to the cloned header\n          headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0])\n\n          for (i = 0; i < visibleColumns.length; i++) {\n            column = columns[visibleColumns[i]]\n\n            headerCells[i].style.width =\n              column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''\n          }\n\n          // Find the widest cell for each column and put it into the table\n          if (oSettings.aoData.length) {\n            for (i = 0; i < visibleColumns.length; i++) {\n              columnIdx = visibleColumns[i]\n              column = columns[columnIdx]\n\n              $(_fnGetWidestNode(oSettings, columnIdx))\n                .clone(false)\n                .append(column.sContentPadding)\n                .appendTo(tr)\n            }\n          }\n\n          // Table has been built, attach to the document so we can work with it\n          tmpTable.appendTo(tableContainer)\n\n          // When scrolling (X or Y) we want to set the width of the table as\n          // appropriate. However, when not scrolling leave the table width as it\n          // is. This results in slightly different, but I think correct behaviour\n          if (scrollX && scrollXInner) {\n            tmpTable.width(scrollXInner)\n          } else if (scrollX) {\n            tmpTable.css('width', 'auto')\n\n            if (tmpTable.width() < tableContainer.offsetWidth) {\n              tmpTable.width(tableContainer.offsetWidth)\n            }\n          } else if (scrollY) {\n            tmpTable.width(tableContainer.offsetWidth)\n          } else if (tableWidthAttr) {\n            tmpTable.width(tableWidthAttr)\n          }\n\n          // Take into account the y scrollbar\n          _fnScrollingWidthAdjust(oSettings, tmpTable[0])\n\n          // Browsers need a bit of a hand when a width is assigned to any columns\n          // when x-scrolling as they tend to collapse the table to the min-width,\n          // even if we sent the column widths. So we need to keep track of what\n          // the table width should be by summing the user given values, and the\n          // automatic values\n          if (scrollX) {\n            var total = 0\n\n            for (i = 0; i < visibleColumns.length; i++) {\n              column = columns[visibleColumns[i]]\n              outerWidth = $(headerCells[i]).outerWidth()\n\n              total +=\n                column.sWidthOrig === null\n                  ? outerWidth\n                  : parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width()\n            }\n\n            tmpTable.width(_fnStringToCss(total))\n            table.style.width = _fnStringToCss(total)\n          }\n\n          // Get the width of each column in the constructed table\n          for (i = 0; i < visibleColumns.length; i++) {\n            column = columns[visibleColumns[i]]\n            width = $(headerCells[i]).width()\n\n            if (width) {\n              column.sWidth = _fnStringToCss(width)\n            }\n          }\n\n          table.style.width = _fnStringToCss(tmpTable.css('width'))\n\n          // Finished with the table - ditch it\n          tmpTable.remove()\n        }\n\n        // If there is a width attr, we want to attach an event listener which\n        // allows the table sizing to automatically adjust when the window is\n        // resized. Use the width attr rather than CSS, since we can't know if the\n        // CSS is a relative value or absolute - DOM read is always px.\n        if (tableWidthAttr) {\n          table.style.width = _fnStringToCss(tableWidthAttr)\n        }\n\n        if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {\n          $(window).bind(\n            'resize.DT-' + oSettings.sInstance,\n            _fnThrottle(function () {\n              _fnAdjustColumnSizing(oSettings)\n            })\n          )\n\n          oSettings._reszEvt = true\n        }\n      }\n\n      /**\n       * Throttle the calls to a function. Arguments and context are maintained for\n       * the throttled function\n       *  @param {function} fn Function to be called\n       *  @param {int} [freq=200] call frequency in mS\n       *  @returns {function} wrapped function\n       *  @memberof DataTable#oApi\n       */\n      function _fnThrottle (fn, freq) {\n        var frequency = freq || 200,\n          last,\n          timer\n\n        return function () {\n          var that = this,\n            now = +new Date(),\n            args = arguments\n\n          if (last && now < last + frequency) {\n            clearTimeout(timer)\n\n            timer = setTimeout(function () {\n              last = undefined\n              fn.apply(that, args)\n            }, frequency)\n          } else if (last) {\n            last = now\n            fn.apply(that, args)\n          } else {\n            last = now\n          }\n        }\n      }\n\n      /**\n       * Convert a CSS unit width to pixels (e.g. 2em)\n       *  @param {string} width width to be converted\n       *  @param {node} parent parent to get the with for (required for relative widths) - optional\n       *  @returns {int} width in pixels\n       *  @memberof DataTable#oApi\n       */\n      function _fnConvertToWidth (width, parent) {\n        if (!width) {\n          return 0\n        }\n\n        var n = $('<div/>')\n          .css('width', _fnStringToCss(width))\n          .appendTo(parent || document.body)\n\n        var val = n[0].offsetWidth\n        n.remove()\n\n        return val\n      }\n\n      /**\n       * Adjust a table's width to take account of vertical scroll bar\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} n table node\n       *  @memberof DataTable#oApi\n       */\n\n      function _fnScrollingWidthAdjust (settings, n) {\n        var scroll = settings.oScroll\n\n        if (scroll.sX || scroll.sY) {\n          // When y-scrolling only, we want to remove the width of the scroll bar\n          // so the table + scroll bar will fit into the area available, otherwise\n          // we fix the table at its current size with no adjustment\n          var correction = !scroll.sX ? scroll.iBarWidth : 0\n          n.style.width = _fnStringToCss($(n).outerWidth() - correction)\n        }\n      }\n\n      /**\n       * Get the widest node\n       *  @param {object} settings dataTables settings object\n       *  @param {int} colIdx column of interest\n       *  @returns {node} widest table node\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetWidestNode (settings, colIdx) {\n        var idx = _fnGetMaxLenString(settings, colIdx)\n        if (idx < 0) {\n          return null\n        }\n\n        var data = settings.aoData[idx]\n        return !data.nTr // Might not have been created when deferred rendering\n          ? $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0]\n          : data.anCells[colIdx]\n      }\n\n      /**\n       * Get the maximum strlen for each data column\n       *  @param {object} settings dataTables settings object\n       *  @param {int} colIdx column of interest\n       *  @returns {string} max string length for each column\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetMaxLenString (settings, colIdx) {\n        var s,\n          max = -1,\n          maxIdx = -1\n\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n          s = _fnGetCellData(settings, i, colIdx, 'display') + ''\n          s = s.replace(__re_html_remove, '')\n\n          if (s.length > max) {\n            max = s.length\n            maxIdx = i\n          }\n        }\n\n        return maxIdx\n      }\n\n      /**\n       * Append a CSS unit (only if required) to a string\n       *  @param {string} value to css-ify\n       *  @returns {string} value with css unit\n       *  @memberof DataTable#oApi\n       */\n      function _fnStringToCss (s) {\n        if (s === null) {\n          return '0px'\n        }\n\n        if (typeof s == 'number') {\n          return s < 0 ? '0px' : s + 'px'\n        }\n\n        // Check it has a unit character already\n        return s.match(/\\d$/) ? s + 'px' : s\n      }\n\n      /**\n       * Get the width of a scroll bar in this browser being used\n       *  @returns {int} width in pixels\n       *  @memberof DataTable#oApi\n       */\n      function _fnScrollBarWidth () {\n        // On first run a static variable is set, since this is only needed once.\n        // Subsequent runs will just use the previously calculated value\n        if (!DataTable.__scrollbarWidth) {\n          var inner = $('<p/>').css({\n            width: '100%',\n            height: 200,\n            padding: 0\n          })[0]\n\n          var outer = $('<div/>')\n            .css({\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: 200,\n              height: 150,\n              padding: 0,\n              overflow: 'hidden',\n              visibility: 'hidden'\n            })\n            .append(inner)\n            .appendTo('body')\n\n          var w1 = inner.offsetWidth\n          outer.css('overflow', 'scroll')\n          var w2 = inner.offsetWidth\n\n          if (w1 === w2) {\n            w2 = outer[0].clientWidth\n          }\n\n          outer.remove()\n\n          DataTable.__scrollbarWidth = w1 - w2\n        }\n\n        return DataTable.__scrollbarWidth\n      }\n\n      function _fnSortFlatten (settings) {\n        var i,\n          iLen,\n          k,\n          kLen,\n          aSort = [],\n          aiOrig = [],\n          aoColumns = settings.aoColumns,\n          aDataSort,\n          iCol,\n          sType,\n          srcCol,\n          fixed = settings.aaSortingFixed,\n          fixedObj = $.isPlainObject(fixed),\n          nestedSort = [],\n          add = function (a) {\n            if (a.length && !$.isArray(a[0])) {\n              // 1D array\n              nestedSort.push(a)\n            } else {\n              // 2D array\n              nestedSort.push.apply(nestedSort, a)\n            }\n          }\n\n        // Build the sort array, with pre-fix and post-fix options if they have been\n        // specified\n        if ($.isArray(fixed)) {\n          add(fixed)\n        }\n\n        if (fixedObj && fixed.pre) {\n          add(fixed.pre)\n        }\n\n        add(settings.aaSorting)\n\n        if (fixedObj && fixed.post) {\n          add(fixed.post)\n        }\n\n        for (i = 0; i < nestedSort.length; i++) {\n          srcCol = nestedSort[i][0]\n          aDataSort = aoColumns[srcCol].aDataSort\n\n          for (k = 0, kLen = aDataSort.length; k < kLen; k++) {\n            iCol = aDataSort[k]\n            sType = aoColumns[iCol].sType || 'string'\n\n            aSort.push({\n              src: srcCol,\n              col: iCol,\n              dir: nestedSort[i][1],\n              index: nestedSort[i][2],\n              type: sType,\n              formatter: DataTable.ext.type.order[sType + '-pre']\n            })\n          }\n        }\n\n        return aSort\n      }\n\n      /**\n       * Change the order of the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       *  @todo This really needs split up!\n       */\n      function _fnSort (oSettings) {\n        var i,\n          ien,\n          iLen,\n          j,\n          jLen,\n          k,\n          kLen,\n          sDataType,\n          nTh,\n          aiOrig = [],\n          oExtSort = DataTable.ext.type.order,\n          aoData = oSettings.aoData,\n          aoColumns = oSettings.aoColumns,\n          aDataSort,\n          data,\n          iCol,\n          sType,\n          oSort,\n          formatters = 0,\n          sortCol,\n          displayMaster = oSettings.aiDisplayMaster,\n          aSort\n\n        // Resolve any column types that are unknown due to addition or invalidation\n        // @todo Can this be moved into a 'data-ready' handler which is called when\n        //   data is going to be used in the table?\n        _fnColumnTypes(oSettings)\n\n        aSort = _fnSortFlatten(oSettings)\n\n        for (i = 0, ien = aSort.length; i < ien; i++) {\n          sortCol = aSort[i]\n\n          // Track if we can use the fast sort algorithm\n          if (sortCol.formatter) {\n            formatters++\n          }\n\n          // Load the data needed for the sort, for each cell\n          _fnSortData(oSettings, sortCol.col)\n        }\n\n        /* No sorting required if server-side or no sorting array */\n        if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {\n          // Create a value - key array of the current row positions such that we can use their\n          // current position during the sort, if values match, in order to perform stable sorting\n          for (i = 0, iLen = displayMaster.length; i < iLen; i++) {\n            aiOrig[displayMaster[i]] = i\n          }\n\n          /* Do the sort - here we want multi-column sorting based on a given data source (column)\n           * and sorting function (from oSort) in a certain direction. It's reasonably complex to\n           * follow on it's own, but this is what we want (example two column sorting):\n           *  fnLocalSorting = function(a,b){\n           *    var iTest;\n           *    iTest = oSort['string-asc']('data11', 'data12');\n           *      if (iTest !== 0)\n           *        return iTest;\n           *    iTest = oSort['numeric-desc']('data21', 'data22');\n           *    if (iTest !== 0)\n           *      return iTest;\n           *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\n           *  }\n           * Basically we have a test for each sorting column, if the data in that column is equal,\n           * test the next column. If all columns match, then we use a numeric sort on the row\n           * positions in the original data array to provide a stable sort.\n           *\n           * Note - I know it seems excessive to have two sorting methods, but the first is around\n           * 15% faster, so the second is only maintained for backwards compatibility with sorting\n           * methods which do not have a pre-sort formatting function.\n           */\n          if (formatters === aSort.length) {\n            // All sort types have formatting functions\n            displayMaster.sort(function (a, b) {\n              var x,\n                y,\n                k,\n                test,\n                sort,\n                len = aSort.length,\n                dataA = aoData[a]._aSortData,\n                dataB = aoData[b]._aSortData\n\n              for (k = 0; k < len; k++) {\n                sort = aSort[k]\n\n                x = dataA[sort.col]\n                y = dataB[sort.col]\n\n                test = x < y ? -1 : x > y ? 1 : 0\n                if (test !== 0) {\n                  return sort.dir === 'asc' ? test : -test\n                }\n              }\n\n              x = aiOrig[a]\n              y = aiOrig[b]\n              return x < y ? -1 : x > y ? 1 : 0\n            })\n          } else {\n            // Depreciated - remove in 1.11 (providing a plug-in option)\n            // Not all sort types have formatting methods, so we have to call their sorting\n            // methods.\n            displayMaster.sort(function (a, b) {\n              var x,\n                y,\n                k,\n                l,\n                test,\n                sort,\n                fn,\n                len = aSort.length,\n                dataA = aoData[a]._aSortData,\n                dataB = aoData[b]._aSortData\n\n              for (k = 0; k < len; k++) {\n                sort = aSort[k]\n\n                x = dataA[sort.col]\n                y = dataB[sort.col]\n\n                fn = oExtSort[sort.type + '-' + sort.dir] || oExtSort['string-' + sort.dir]\n                test = fn(x, y)\n                if (test !== 0) {\n                  return test\n                }\n              }\n\n              x = aiOrig[a]\n              y = aiOrig[b]\n              return x < y ? -1 : x > y ? 1 : 0\n            })\n          }\n        }\n\n        /* Tell the draw function that we have sorted the data */\n        oSettings.bSorted = true\n      }\n\n      function _fnSortAria (settings) {\n        var label\n        var nextSort\n        var columns = settings.aoColumns\n        var aSort = _fnSortFlatten(settings)\n        var oAria = settings.oLanguage.oAria\n\n        // ARIA attributes - need to loop all columns, to update all (removing old\n        // attributes as needed)\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\n          var col = columns[i]\n          var asSorting = col.asSorting\n          var sTitle = col.sTitle.replace(/<.*?>/g, '')\n          var th = col.nTh\n\n          // IE7 is throwing an error when setting these properties with jQuery's\n          // attr() and removeAttr() methods...\n          th.removeAttribute('aria-sort')\n\n          /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\n          if (col.bSortable) {\n            if (aSort.length > 0 && aSort[0].col == i) {\n              th.setAttribute('aria-sort', aSort[0].dir == 'asc' ? 'ascending' : 'descending')\n              nextSort = asSorting[aSort[0].index + 1] || asSorting[0]\n            } else {\n              nextSort = asSorting[0]\n            }\n\n            label = sTitle + (nextSort === 'asc' ? oAria.sSortAscending : oAria.sSortDescending)\n          } else {\n            label = sTitle\n          }\n\n          th.setAttribute('aria-label', label)\n        }\n      }\n\n      /**\n       * Function to run on user sort request\n       *  @param {object} settings dataTables settings object\n       *  @param {node} attachTo node to attach the handler to\n       *  @param {int} colIdx column sorting index\n       *  @param {boolean} [append=false] Append the requested sort to the existing\n       *    sort if true (i.e. multi-column sort)\n       *  @param {function} [callback] callback function\n       *  @memberof DataTable#oApi\n       */\n      function _fnSortListener (settings, colIdx, append, callback) {\n        var col = settings.aoColumns[colIdx]\n        var sorting = settings.aaSorting\n        var asSorting = col.asSorting\n        var nextSortIdx\n        var next = function (a) {\n          var idx = a._idx\n          if (idx === undefined) {\n            idx = $.inArray(a[1], asSorting)\n          }\n\n          return idx + 1 >= asSorting.length ? 0 : idx + 1\n        }\n\n        // Convert to 2D array if needed\n        if (typeof sorting[0] === 'number') {\n          sorting = settings.aaSorting = [sorting]\n        }\n\n        // If appending the sort then we are multi-column sorting\n        if (append && settings.oFeatures.bSortMulti) {\n          // Are we already doing some kind of sort on this column?\n          var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'))\n\n          if (sortIdx !== -1) {\n            // Yes, modify the sort\n            nextSortIdx = next(sorting[sortIdx])\n\n            sorting[sortIdx][1] = asSorting[nextSortIdx]\n            sorting[sortIdx]._idx = nextSortIdx\n          } else {\n            // No sort on this column yet\n            sorting.push([colIdx, asSorting[0], 0])\n            sorting[sorting.length - 1]._idx = 0\n          }\n        } else if (sorting.length && sorting[0][0] == colIdx) {\n          // Single column - already sorting on this column, modify the sort\n          nextSortIdx = next(sorting[0])\n\n          sorting.length = 1\n          sorting[0][1] = asSorting[nextSortIdx]\n          sorting[0]._idx = nextSortIdx\n        } else {\n          // Single column - sort only on this column\n          sorting.length = 0\n          sorting.push([colIdx, asSorting[0]])\n          sorting[0]._idx = 0\n        }\n\n        // Run the sort by calling a full redraw\n        _fnReDraw(settings)\n\n        // callback used for async user interaction\n        if (typeof callback == 'function') {\n          callback(settings)\n        }\n      }\n\n      /**\n       * Attach a sort handler (click) to a node\n       *  @param {object} settings dataTables settings object\n       *  @param {node} attachTo node to attach the handler to\n       *  @param {int} colIdx column sorting index\n       *  @param {function} [callback] callback function\n       *  @memberof DataTable#oApi\n       */\n      function _fnSortAttachListener (settings, attachTo, colIdx, callback) {\n        var col = settings.aoColumns[colIdx]\n\n        _fnBindAction(attachTo, {}, function (e) {\n          /* If the column is not sortable - don't to anything */\n          if (col.bSortable === false) {\n            return\n          }\n\n          // If processing is enabled use a timeout to allow the processing\n          // display to be shown - otherwise to it synchronously\n          if (settings.oFeatures.bProcessing) {\n            _fnProcessingDisplay(settings, true)\n\n            setTimeout(function () {\n              _fnSortListener(settings, colIdx, e.shiftKey, callback)\n\n              // In server-side processing, the draw callback will remove the\n              // processing display\n              if (_fnDataSource(settings) !== 'ssp') {\n                _fnProcessingDisplay(settings, false)\n              }\n            }, 0)\n          } else {\n            _fnSortListener(settings, colIdx, e.shiftKey, callback)\n          }\n        })\n      }\n\n      /**\n       * Set the sorting classes on table's body, Note: it is safe to call this function\n       * when bSort and bSortClasses are false\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSortingClasses (settings) {\n        var oldSort = settings.aLastSort\n        var sortClass = settings.oClasses.sSortColumn\n        var sort = _fnSortFlatten(settings)\n        var features = settings.oFeatures\n        var i, ien, colIdx\n\n        if (features.bSort && features.bSortClasses) {\n          // Remove old sorting classes\n          for (i = 0, ien = oldSort.length; i < ien; i++) {\n            colIdx = oldSort[i].src\n\n            // Remove column sorting\n            $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3))\n          }\n\n          // Add new column sorting\n          for (i = 0, ien = sort.length; i < ien; i++) {\n            colIdx = sort[i].src\n\n            $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3))\n          }\n        }\n\n        settings.aLastSort = sort\n      }\n\n      // Get the data to sort a column, be it from cache, fresh (populating the\n      // cache), or from a sort formatter\n      function _fnSortData (settings, idx) {\n        // Custom sorting function - provided by the sort data type\n        var column = settings.aoColumns[idx]\n        var customSort = DataTable.ext.order[column.sSortDataType]\n        var customData\n\n        if (customSort) {\n          customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx))\n        }\n\n        // Use / populate cache\n        var row, cellData\n        var formatter = DataTable.ext.type.order[column.sType + '-pre']\n\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n          row = settings.aoData[i]\n\n          if (!row._aSortData) {\n            row._aSortData = []\n          }\n\n          if (!row._aSortData[idx] || customSort) {\n            cellData = customSort\n              ? customData[i] // If there was a custom sort function, use data from there\n              : _fnGetCellData(settings, i, idx, 'sort')\n\n            row._aSortData[idx] = formatter ? formatter(cellData) : cellData\n          }\n        }\n      }\n\n      /**\n       * Save the state of a table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSaveState (settings) {\n        if (!settings.oFeatures.bStateSave || settings.bDestroying) {\n          return\n        }\n\n        /* Store the interesting variables */\n        var state = {\n          time: +new Date(),\n          start: settings._iDisplayStart,\n          length: settings._iDisplayLength,\n          order: $.extend(true, [], settings.aaSorting),\n          search: _fnSearchToCamel(settings.oPreviousSearch),\n          columns: $.map(settings.aoColumns, function (col, i) {\n            return {\n              visible: col.bVisible,\n              search: _fnSearchToCamel(settings.aoPreSearchCols[i])\n            }\n          })\n        }\n\n        _fnCallbackFire(settings, 'aoStateSaveParams', 'stateSaveParams', [settings, state])\n\n        settings.oSavedState = state\n        settings.fnStateSaveCallback.call(settings.oInstance, settings, state)\n      }\n\n      /**\n       * Attempt to load a saved table state\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} oInit DataTables init object so we can override settings\n       *  @memberof DataTable#oApi\n       */\n      function _fnLoadState (settings, oInit) {\n        var i, ien\n        var columns = settings.aoColumns\n\n        if (!settings.oFeatures.bStateSave) {\n          return\n        }\n\n        var state = settings.fnStateLoadCallback.call(settings.oInstance, settings)\n        if (!state || !state.time) {\n          return\n        }\n\n        /* Allow custom and plug-in manipulation functions to alter the saved data set and\n         * cancelling of loading by returning false\n         */\n        var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state])\n        if ($.inArray(false, abStateLoad) !== -1) {\n          return\n        }\n\n        /* Reject old data */\n        var duration = settings.iStateDuration\n        if (duration > 0 && state.time < +new Date() - duration * 1000) {\n          return\n        }\n\n        // Number of columns have changed - all bets are off, no restore of settings\n        if (columns.length !== state.columns.length) {\n          return\n        }\n\n        // Store the saved state so it might be accessed at any time\n        settings.oLoadedState = $.extend(true, {}, state)\n\n        // Restore key features - todo - for 1.11 this needs to be done by\n        // subscribed events\n        settings._iDisplayStart = state.start\n        settings.iInitDisplayStart = state.start\n        settings._iDisplayLength = state.length\n        settings.aaSorting = []\n\n        // Order\n        $.each(state.order, function (i, col) {\n          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col)\n        })\n\n        // Search\n        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search))\n\n        // Columns\n        for (i = 0, ien = state.columns.length; i < ien; i++) {\n          var col = state.columns[i]\n\n          // Visibility\n          columns[i].bVisible = col.visible\n\n          // Search\n          $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search))\n        }\n\n        _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state])\n      }\n\n      /**\n       * Return the settings object for a particular table\n       *  @param {node} table table we are using as a dataTable\n       *  @returns {object} Settings object - or null if not found\n       *  @memberof DataTable#oApi\n       */\n      function _fnSettingsFromNode (table) {\n        var settings = DataTable.settings\n        var idx = $.inArray(table, _pluck(settings, 'nTable'))\n\n        return idx !== -1 ? settings[idx] : null\n      }\n\n      /**\n       * Log an error message\n       *  @param {object} settings dataTables settings object\n       *  @param {int} level log error messages, or display them to the user\n       *  @param {string} msg error message\n       *  @param {int} tn Technical note id to get more information about the error.\n       *  @memberof DataTable#oApi\n       */\n      function _fnLog (settings, level, msg, tn) {\n        msg = 'DataTables warning: ' + (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg\n\n        if (tn) {\n          msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn\n        }\n\n        if (!level) {\n          // Backwards compatibility pre 1.10\n          var ext = DataTable.ext\n          var type = ext.sErrMode || ext.errMode\n\n          if (type == 'alert') {\n            alert(msg)\n          } else {\n            throw new Error(msg)\n          }\n        } else if (window.console && console.log) {\n          console.log(msg)\n        }\n      }\n\n      /**\n       * See if a property is defined on one object, if so assign it to the other object\n       *  @param {object} ret target object\n       *  @param {object} src source object\n       *  @param {string} name property\n       *  @param {string} [mappedName] name to map too - optional, name used if not given\n       *  @memberof DataTable#oApi\n       */\n      function _fnMap (ret, src, name, mappedName) {\n        if ($.isArray(name)) {\n          $.each(name, function (i, val) {\n            if ($.isArray(val)) {\n              _fnMap(ret, src, val[0], val[1])\n            } else {\n              _fnMap(ret, src, val)\n            }\n          })\n\n          return\n        }\n\n        if (mappedName === undefined) {\n          mappedName = name\n        }\n\n        if (src[name] !== undefined) {\n          ret[mappedName] = src[name]\n        }\n      }\n\n      /**\n       * Extend objects - very similar to jQuery.extend, but deep copy objects, and\n       * shallow copy arrays. The reason we need to do this, is that we don't want to\n       * deep copy array init values (such as aaSorting) since the dev wouldn't be\n       * able to override them, but we do want to deep copy arrays.\n       *  @param {object} out Object to extend\n       *  @param {object} extender Object from which the properties will be applied to\n       *      out\n       *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\n       *      independent copy with the exception of the `data` or `aaData` parameters\n       *      if they are present. This is so you can pass in a collection to\n       *      DataTables and have that used as your data source without breaking the\n       *      references\n       *  @returns {object} out Reference, just for convenience - out === the return.\n       *  @memberof DataTable#oApi\n       *  @todo This doesn't take account of arrays inside the deep copied objects.\n       */\n      function _fnExtend (out, extender, breakRefs) {\n        var val\n\n        for (var prop in extender) {\n          if (extender.hasOwnProperty(prop)) {\n            val = extender[prop]\n\n            if ($.isPlainObject(val)) {\n              if (!$.isPlainObject(out[prop])) {\n                out[prop] = {}\n              }\n              $.extend(true, out[prop], val)\n            } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {\n              out[prop] = val.slice()\n            } else {\n              out[prop] = val\n            }\n          }\n        }\n\n        return out\n      }\n\n      /**\n       * Bind an event handers to allow a click or return key to activate the callback.\n       * This is good for accessibility since a return on the keyboard will have the\n       * same effect as a click, if the element has focus.\n       *  @param {element} n Element to bind the action to\n       *  @param {object} oData Data object to pass to the triggered function\n       *  @param {function} fn Callback function for when the event is triggered\n       *  @memberof DataTable#oApi\n       */\n      function _fnBindAction (n, oData, fn) {\n        $(n)\n          .bind('click.DT', oData, function (e) {\n            n.blur() // Remove focus outline for mouse users\n            fn(e)\n          })\n          .bind('keypress.DT', oData, function (e) {\n            if (e.which === 13) {\n              e.preventDefault()\n              fn(e)\n            }\n          })\n          .bind('selectstart.DT', function () {\n            /* Take the brutal approach to cancelling text selection */\n            return false\n          })\n      }\n\n      /**\n       * Register a callback function. Easily allows a callback function to be added to\n       * an array store of callback functions that can then all be called together.\n       *  @param {object} oSettings dataTables settings object\n       *  @param {string} sStore Name of the array storage for the callbacks in oSettings\n       *  @param {function} fn Function to be called back\n       *  @param {string} sName Identifying name for the callback (i.e. a label)\n       *  @memberof DataTable#oApi\n       */\n      function _fnCallbackReg (oSettings, sStore, fn, sName) {\n        if (fn) {\n          oSettings[sStore].push({\n            fn: fn,\n            sName: sName\n          })\n        }\n      }\n\n      /**\n       * Fire callback functions and trigger events. Note that the loop over the\n       * callback array store is done backwards! Further note that you do not want to\n       * fire off triggers in time sensitive applications (for example cell creation)\n       * as its slow.\n       *  @param {object} settings dataTables settings object\n       *  @param {string} callbackArr Name of the array storage for the callbacks in\n       *      oSettings\n       *  @param {string} event Name of the jQuery custom event to trigger. If null no\n       *      trigger is fired\n       *  @param {array} args Array of arguments to pass to the callback function /\n       *      trigger\n       *  @memberof DataTable#oApi\n       */\n      function _fnCallbackFire (settings, callbackArr, e, args) {\n        var ret = []\n\n        if (callbackArr) {\n          ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {\n            return val.fn.apply(settings.oInstance, args)\n          })\n        }\n\n        if (e !== null) {\n          $(settings.nTable).trigger(e + '.dt', args)\n        }\n\n        return ret\n      }\n\n      function _fnLengthOverflow (settings) {\n        var start = settings._iDisplayStart,\n          end = settings.fnDisplayEnd(),\n          len = settings._iDisplayLength\n\n        /* If we have space to show extra rows (backing up from the end point - then do so */\n        if (end === settings.fnRecordsDisplay()) {\n          start = end - len\n        }\n\n        if (len === -1 || start < 0) {\n          start = 0\n        }\n\n        settings._iDisplayStart = start\n      }\n\n      function _fnRenderer (settings, type) {\n        var renderer = settings.renderer\n        var host = DataTable.ext.renderer[type]\n\n        if ($.isPlainObject(renderer) && renderer[type]) {\n          // Specific renderer for this type. If available use it, otherwise use\n          // the default.\n          return host[renderer[type]] || host._\n        } else if (typeof renderer === 'string') {\n          // Common renderer - if there is one available for this type use it,\n          // otherwise use the default\n          return host[renderer] || host._\n        }\n\n        // Use the default\n        return host._\n      }\n\n      /**\n       * Detect the data source being used for the table. Used to simplify the code\n       * a little (ajax) and to make it compress a little smaller.\n       *\n       *  @param {object} settings dataTables settings object\n       *  @returns {string} Data source\n       *  @memberof DataTable#oApi\n       */\n      function _fnDataSource (settings) {\n        if (settings.oFeatures.bServerSide) {\n          return 'ssp'\n        } else if (settings.ajax || settings.sAjaxSource) {\n          return 'ajax'\n        }\n        return 'dom'\n      }\n\n      DataTable = function (options) {\n        /**\n         * Perform a jQuery selector action on the table's TR elements (from the tbody) and\n         * return the resulting jQuery object.\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n         *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\n         *    criterion (\"applied\") or all TR elements (i.e. no filter).\n         *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\n         *    Can be either 'current', whereby the current sorting of the table is used, or\n         *    'original' whereby the original order the data was read into the table is used.\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n         *    'current' and filter is 'applied', regardless of what they might be given as.\n         *  @returns {object} jQuery object, filtered by the given selector.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Highlight every second row\n         *      oTable.$('tr:odd').css('backgroundColor', 'blue');\n         *    } );\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Filter to rows with 'Webkit' in them, add a background colour and then\n         *      // remove the filter, thus highlighting the 'Webkit' rows only.\n         *      oTable.fnFilter('Webkit');\n         *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\n         *      oTable.fnFilter('');\n         *    } );\n         */\n        this.$ = function (sSelector, oOpts) {\n          return this.api(true).$(sSelector, oOpts)\n        }\n\n        /**\n         * Almost identical to $ in operation, but in this case returns the data for the matched\n         * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\n         * rather than any descendants, so the data can be obtained for the row/cell. If matching\n         * rows are found, the data returned is the original data array/object that was used to\n         * create the row (or a generated array if from a DOM source).\n         *\n         * This method is often useful in-combination with $ where both functions are given the\n         * same parameters and the array indexes will match identically.\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n         *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\n         *    criterion (\"applied\") or all elements (i.e. no filter).\n         *  @param {string} [oOpts.order=current] Order of the data in the processed array.\n         *    Can be either 'current', whereby the current sorting of the table is used, or\n         *    'original' whereby the original order the data was read into the table is used.\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n         *    'current' and filter is 'applied', regardless of what they might be given as.\n         *  @returns {array} Data for the matched elements. If any elements, as a result of the\n         *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\n         *    entry in the array.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Get the data from the first row in the table\n         *      var data = oTable._('tr:first');\n         *\n         *      // Do something useful with the data\n         *      alert( \"First cell is: \"+data[0] );\n         *    } );\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Filter to 'Webkit' and get all data for\n         *      oTable.fnFilter('Webkit');\n         *      var data = oTable._('tr', {\"search\": \"applied\"});\n         *\n         *      // Do something with the data\n         *      alert( data.length+\" rows matched the search\" );\n         *    } );\n         */\n        this._ = function (sSelector, oOpts) {\n          return this.api(true)\n            .rows(sSelector, oOpts)\n            .data()\n        }\n\n        /**\n         * Create a DataTables Api instance, with the currently selected tables for\n         * the Api's context.\n         * @param {boolean} [traditional=false] Set the API instance's context to be\n         *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\n         *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\n         *   or if all tables captured in the jQuery object should be used.\n         * @return {DataTables.Api}\n         */\n        this.api = function (traditional) {\n          return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this)\n        }\n\n        /**\n         * Add a single new row or multiple rows of data to the table. Please note\n         * that this is suitable for client-side processing only - if you are using\n         * server-side processing (i.e. \"bServerSide\": true), then to add data, you\n         * must add it to the data source, i.e. the server-side, through an Ajax call.\n         *  @param {array|object} data The data to be added to the table. This can be:\n         *    <ul>\n         *      <li>1D array of data - add a single row with the data provided</li>\n         *      <li>2D array of arrays - add multiple rows in a single call</li>\n         *      <li>object - data object when using <i>mData</i></li>\n         *      <li>array of objects - multiple data objects when using <i>mData</i></li>\n         *    </ul>\n         *  @param {bool} [redraw=true] redraw the table or not\n         *  @returns {array} An array of integers, representing the list of indexes in\n         *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\n         *    the table.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    // Global var for counter\n         *    var giCount = 2;\n         *\n         *    $(document).ready(function() {\n         *      $('#example').dataTable();\n         *    } );\n         *\n         *    function fnClickAddRow() {\n         *      $('#example').dataTable().fnAddData( [\n         *        giCount+\".1\",\n         *        giCount+\".2\",\n         *        giCount+\".3\",\n         *        giCount+\".4\" ]\n         *      );\n         *\n         *      giCount++;\n         *    }\n         */\n        this.fnAddData = function (data, redraw) {\n          var api = this.api(true)\n\n          /* Check if we want to add multiple rows or not */\n          var rows =\n            $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data)\n\n          if (redraw === undefined || redraw) {\n            api.draw()\n          }\n\n          return rows.flatten().toArray()\n        }\n\n        /**\n         * This function will make DataTables recalculate the column sizes, based on the data\n         * contained in the table and the sizes applied to the columns (in the DOM, CSS or\n         * through the sWidth parameter). This can be useful when the width of the table's\n         * parent element changes (for example a window resize).\n         *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable( {\n         *        \"sScrollY\": \"200px\",\n         *        \"bPaginate\": false\n         *      } );\n         *\n         *      $(window).bind('resize', function () {\n         *        oTable.fnAdjustColumnSizing();\n         *      } );\n         *    } );\n         */\n        this.fnAdjustColumnSizing = function (bRedraw) {\n          var api = this.api(true).columns.adjust()\n          var settings = api.settings()[0]\n          var scroll = settings.oScroll\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw(false)\n          } else if (scroll.sX !== '' || scroll.sY !== '') {\n            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\n            _fnScrollDraw(settings)\n          }\n        }\n\n        /**\n         * Quickly and simply clear a table\n         *  @param {bool} [bRedraw=true] redraw the table or not\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\n         *      oTable.fnClearTable();\n         *    } );\n         */\n        this.fnClearTable = function (bRedraw) {\n          var api = this.api(true).clear()\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw()\n          }\n        }\n\n        /**\n         * The exact opposite of 'opening' a row, this function will close any rows which\n         * are currently 'open'.\n         *  @param {node} nTr the table row to 'close'\n         *  @returns {int} 0 on success, or 1 if failed (can't find the row)\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable;\n         *\n         *      // 'open' an information row when a row is clicked on\n         *      $('#example tbody tr').click( function () {\n         *        if ( oTable.fnIsOpen(this) ) {\n         *          oTable.fnClose( this );\n         *        } else {\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n         *        }\n         *      } );\n         *\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnClose = function (nTr) {\n          this.api(true)\n            .row(nTr)\n            .child.hide()\n        }\n\n        /**\n         * Remove a row for the table\n         *  @param {mixed} target The index of the row from aoData to be deleted, or\n         *    the TR element you want to delete\n         *  @param {function|null} [callBack] Callback function\n         *  @param {bool} [redraw=true] Redraw the table or not\n         *  @returns {array} The row that was deleted\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Immediately remove the first row\n         *      oTable.fnDeleteRow( 0 );\n         *    } );\n         */\n        this.fnDeleteRow = function (target, callback, redraw) {\n          var api = this.api(true)\n          var rows = api.rows(target)\n          var settings = rows.settings()[0]\n          var data = settings.aoData[rows[0][0]]\n\n          rows.remove()\n\n          if (callback) {\n            callback.call(this, settings, data)\n          }\n\n          if (redraw === undefined || redraw) {\n            api.draw()\n          }\n\n          return data\n        }\n\n        /**\n         * Restore the table to it's original state in the DOM by removing all of DataTables\n         * enhancements, alterations to the DOM structure of the table and event listeners.\n         *  @param {boolean} [remove=false] Completely remove the table from the DOM\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\n         *      var oTable = $('#example').dataTable();\n         *      oTable.fnDestroy();\n         *    } );\n         */\n        this.fnDestroy = function (remove) {\n          this.api(true).destroy(remove)\n        }\n\n        /**\n         * Redraw the table\n         *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\n         *      oTable.fnDraw();\n         *    } );\n         */\n        this.fnDraw = function (complete) {\n          // Note that this isn't an exact match to the old call to _fnDraw - it takes\n          // into account the new data, but can old position.\n          this.api(true).draw(!complete)\n        }\n\n        /**\n         * Filter the input based on data\n         *  @param {string} sInput String to filter the table on\n         *  @param {int|null} [iColumn] Column to limit filtering to\n         *  @param {bool} [bRegex=false] Treat as regular expression or not\n         *  @param {bool} [bSmart=true] Perform smart filtering or not\n         *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\n         *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Sometime later - filter...\n         *      oTable.fnFilter( 'test string' );\n         *    } );\n         */\n        this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {\n          var api = this.api(true)\n\n          if (iColumn === null || iColumn === undefined) {\n            api.search(sInput, bRegex, bSmart, bCaseInsensitive)\n          } else {\n            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive)\n          }\n\n          api.draw()\n        }\n\n        /**\n         * Get the data for the whole table, an individual row or an individual cell based on the\n         * provided parameters.\n         *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\n         *    a TR node then the data source for the whole row will be returned. If given as a\n         *    TD/TH cell node then iCol will be automatically calculated and the data for the\n         *    cell returned. If given as an integer, then this is treated as the aoData internal\n         *    data index for the row (see fnGetPosition) and the data for that row used.\n         *  @param {int} [col] Optional column index that you want the data of.\n         *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\n         *    returned. If mRow is defined, just data for that row, and is iCol is\n         *    defined, only data for the designated cell is returned.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    // Row data\n         *    $(document).ready(function() {\n         *      oTable = $('#example').dataTable();\n         *\n         *      oTable.$('tr').click( function () {\n         *        var data = oTable.fnGetData( this );\n         *        // ... do something with the array / object of data for the row\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Individual cell data\n         *    $(document).ready(function() {\n         *      oTable = $('#example').dataTable();\n         *\n         *      oTable.$('td').click( function () {\n         *        var sData = oTable.fnGetData( this );\n         *        alert( 'The cell clicked on had the value of '+sData );\n         *      } );\n         *    } );\n         */\n        this.fnGetData = function (src, col) {\n          var api = this.api(true)\n\n          if (src !== undefined) {\n            var type = src.nodeName ? src.nodeName.toLowerCase() : ''\n\n            return col !== undefined || type == 'td' || type == 'th'\n              ? api.cell(src, col).data()\n              : api.row(src).data() || null\n          }\n\n          return api.data().toArray()\n        }\n\n        /**\n         * Get an array of the TR nodes that are used in the table's body. Note that you will\n         * typically want to use the '$' API method in preference to this as it is more\n         * flexible.\n         *  @param {int} [iRow] Optional row index for the TR element you want\n         *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\n         *    in the table's body, or iRow is defined, just the TR element requested.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Get the nodes from the table\n         *      var nNodes = oTable.fnGetNodes( );\n         *    } );\n         */\n        this.fnGetNodes = function (iRow) {\n          var api = this.api(true)\n\n          return iRow !== undefined\n            ? api.row(iRow).node()\n            : api\n                .rows()\n                .nodes()\n                .flatten()\n                .toArray()\n        }\n\n        /**\n         * Get the array indexes of a particular cell from it's DOM element\n         * and column index including hidden columns\n         *  @param {node} node this can either be a TR, TD or TH in the table's body\n         *  @returns {int} If nNode is given as a TR, then a single index is returned, or\n         *    if given as a cell, an array of [row index, column index (visible),\n         *    column index (all)] is given.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      $('#example tbody td').click( function () {\n         *        // Get the position of the current data from the node\n         *        var aPos = oTable.fnGetPosition( this );\n         *\n         *        // Get the data array for this row\n         *        var aData = oTable.fnGetData( aPos[0] );\n         *\n         *        // Update the data array and return the value\n         *        aData[ aPos[1] ] = 'clicked';\n         *        this.innerHTML = 'clicked';\n         *      } );\n         *\n         *      // Init DataTables\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnGetPosition = function (node) {\n          var api = this.api(true)\n          var nodeName = node.nodeName.toUpperCase()\n\n          if (nodeName == 'TR') {\n            return api.row(node).index()\n          } else if (nodeName == 'TD' || nodeName == 'TH') {\n            var cell = api.cell(node).index()\n\n            return [cell.row, cell.columnVisible, cell.column]\n          }\n          return null\n        }\n\n        /**\n         * Check to see if a row is 'open' or not.\n         *  @param {node} nTr the table row to check\n         *  @returns {boolean} true if the row is currently open, false otherwise\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable;\n         *\n         *      // 'open' an information row when a row is clicked on\n         *      $('#example tbody tr').click( function () {\n         *        if ( oTable.fnIsOpen(this) ) {\n         *          oTable.fnClose( this );\n         *        } else {\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n         *        }\n         *      } );\n         *\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnIsOpen = function (nTr) {\n          return this.api(true)\n            .row(nTr)\n            .child.isShown()\n        }\n\n        /**\n         * This function will place a new row directly after a row which is currently\n         * on display on the page, with the HTML contents that is passed into the\n         * function. This can be used, for example, to ask for confirmation that a\n         * particular record should be deleted.\n         *  @param {node} nTr The table row to 'open'\n         *  @param {string|node|jQuery} mHtml The HTML to put into the row\n         *  @param {string} sClass Class to give the new TD cell\n         *  @returns {node} The row opened. Note that if the table row passed in as the\n         *    first parameter, is not found in the table, this method will silently\n         *    return.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable;\n         *\n         *      // 'open' an information row when a row is clicked on\n         *      $('#example tbody tr').click( function () {\n         *        if ( oTable.fnIsOpen(this) ) {\n         *          oTable.fnClose( this );\n         *        } else {\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n         *        }\n         *      } );\n         *\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnOpen = function (nTr, mHtml, sClass) {\n          return this.api(true)\n            .row(nTr)\n            .child(mHtml, sClass)\n            .show()\n            .child()[0]\n        }\n\n        /**\n         * Change the pagination - provides the internal logic for pagination in a simple API\n         * function. With this function you can have a DataTables table go to the next,\n         * previous, first or last pages.\n         *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\n         *    or page number to jump to (integer), note that page 0 is the first page.\n         *  @param {bool} [bRedraw=true] Redraw the table or not\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      oTable.fnPageChange( 'next' );\n         *    } );\n         */\n        this.fnPageChange = function (mAction, bRedraw) {\n          var api = this.api(true).page(mAction)\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw(false)\n          }\n        }\n\n        /**\n         * Show a particular column\n         *  @param {int} iCol The column whose display should be changed\n         *  @param {bool} bShow Show (true) or hide (false) the column\n         *  @param {bool} [bRedraw=true] Redraw the table or not\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Hide the second column after initialisation\n         *      oTable.fnSetColumnVis( 1, false );\n         *    } );\n         */\n        this.fnSetColumnVis = function (iCol, bShow, bRedraw) {\n          var api = this.api(true)\n            .column(iCol)\n            .visible(bShow)\n\n          if (bRedraw === undefined || bRedraw) {\n            api.columns.adjust().draw()\n          }\n        }\n\n        /**\n         * Get the settings for a particular table for external manipulation\n         *  @returns {object} DataTables settings object. See\n         *    {@link DataTable.models.oSettings}\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      var oSettings = oTable.fnSettings();\n         *\n         *      // Show an example parameter from the settings\n         *      alert( oSettings._iDisplayStart );\n         *    } );\n         */\n        this.fnSettings = function () {\n          return _fnSettingsFromNode(this[_ext.iApiIndex])\n        }\n\n        /**\n         * Sort the table by a particular column\n         *  @param {int} iCol the data index to sort on. Note that this will not match the\n         *    'display index' if you have hidden data entries\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Sort immediately with columns 0 and 1\n         *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\n         *    } );\n         */\n        this.fnSort = function (aaSort) {\n          this.api(true)\n            .order(aaSort)\n            .draw()\n        }\n\n        /**\n         * Attach a sort listener to an element for a given column\n         *  @param {node} nNode the element to attach the sort listener to\n         *  @param {int} iColumn the column that a click on this node will sort on\n         *  @param {function} [fnCallback] callback function when sort is run\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Sort on column 1, when 'sorter' is clicked on\n         *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\n         *    } );\n         */\n        this.fnSortListener = function (nNode, iColumn, fnCallback) {\n          this.api(true).order.listener(nNode, iColumn, fnCallback)\n        }\n\n        /**\n         * Update a table cell or row - this method will accept either a single value to\n         * update the cell with, an array of values with one element for each column or\n         * an object in the same format as the original data source. The function is\n         * self-referencing in order to make the multi column updates easier.\n         *  @param {object|array|string} mData Data to update the cell/row with\n         *  @param {node|int} mRow TR element you want to update or the aoData index\n         *  @param {int} [iColumn] The column to update, give as null or undefined to\n         *    update a whole row.\n         *  @param {bool} [bRedraw=true] Redraw the table or not\n         *  @param {bool} [bAction=true] Perform pre-draw actions or not\n         *  @returns {int} 0 on success, 1 on error\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\n         *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\n         *    } );\n         */\n        this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {\n          var api = this.api(true)\n\n          if (iColumn === undefined || iColumn === null) {\n            api.row(mRow).data(mData)\n          } else {\n            api.cell(mRow, iColumn).data(mData)\n          }\n\n          if (bAction === undefined || bAction) {\n            api.columns.adjust()\n          }\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw()\n          }\n          return 0\n        }\n\n        /**\n         * Provide a common method for plug-ins to check the version of DataTables being used, in order\n         * to ensure compatibility.\n         *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\n         *    formats \"X\" and \"X.Y\" are also acceptable.\n         *  @returns {boolean} true if this version of DataTables is greater or equal to the required\n         *    version, or false if this version of DataTales is not suitable\n         *  @method\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      alert( oTable.fnVersionCheck( '1.9.0' ) );\n         *    } );\n         */\n        this.fnVersionCheck = _ext.fnVersionCheck\n\n        var _that = this\n        var emptyInit = options === undefined\n        var len = this.length\n\n        if (emptyInit) {\n          options = {}\n        }\n\n        this.oApi = this.internal = _ext.internal\n\n        // Extend with old style plug-in API methods\n        for (var fn in DataTable.ext.internal) {\n          if (fn) {\n            this[fn] = _fnExternApiFunc(fn)\n          }\n        }\n\n        this.each(function () {\n          // For each initialisation we want to give it a clean initialisation\n          // object that can be bashed around\n          var o = {}\n          var oInit =\n            len > 1 // optimisation for single table case\n              ? _fnExtend(o, options, true)\n              : options\n\n          /*global oInit,_that,emptyInit*/\n          var i = 0,\n            iLen,\n            j,\n            jLen,\n            k,\n            kLen\n          var sId = this.getAttribute('id')\n          var bInitHandedOff = false\n          var defaults = DataTable.defaults\n\n          /* Sanity check */\n          if (this.nodeName.toLowerCase() != 'table') {\n            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2)\n            return\n          }\n\n          /* Backwards compatibility for the defaults */\n          _fnCompatOpts(defaults)\n          _fnCompatCols(defaults.column)\n\n          /* Convert the camel-case defaults to Hungarian */\n          _fnCamelToHungarian(defaults, defaults, true)\n          _fnCamelToHungarian(defaults.column, defaults.column, true)\n\n          /* Setting up the initialisation object */\n          _fnCamelToHungarian(defaults, oInit)\n\n          /* Check to see if we are re-initialising a table */\n          var allSettings = DataTable.settings\n          for (i = 0, iLen = allSettings.length; i < iLen; i++) {\n            /* Base check on table node */\n            if (allSettings[i].nTable == this) {\n              var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve\n              var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy\n\n              if (emptyInit || bRetrieve) {\n                return allSettings[i].oInstance\n              } else if (bDestroy) {\n                allSettings[i].oInstance.fnDestroy()\n                break\n              } else {\n                _fnLog(allSettings[i], 0, 'Cannot reinitialise DataTable', 3)\n                return\n              }\n            }\n\n            /* If the element we are initialising has the same ID as a table which was previously\n             * initialised, but the table nodes don't match (from before) then we destroy the old\n             * instance by simply deleting it. This is under the assumption that the table has been\n             * destroyed by other methods. Anyone using non-id selectors will need to do this manually\n             */\n            if (allSettings[i].sTableId == this.id) {\n              allSettings.splice(i, 1)\n              break\n            }\n          }\n\n          /* Ensure the table has an ID - required for accessibility */\n          if (sId === null || sId === '') {\n            sId = 'DataTables_Table_' + DataTable.ext._unique++\n            this.id = sId\n          }\n\n          /* Create the settings object for this table and set some of the default parameters */\n          var oSettings = $.extend(true, {}, DataTable.models.oSettings, {\n            nTable: this,\n            oApi: _that.internal,\n            oInit: oInit,\n            sDestroyWidth: $(this)[0].style.width,\n            sInstance: sId,\n            sTableId: sId\n          })\n          allSettings.push(oSettings)\n\n          // Need to add the instance after the instance after the settings object has been added\n          // to the settings array, so we can self reference the table instance if more than one\n          oSettings.oInstance = _that.length === 1 ? _that : $(this).dataTable()\n\n          // Backwards compatibility, before we apply all the defaults\n          _fnCompatOpts(oInit)\n\n          if (oInit.oLanguage) {\n            _fnLanguageCompat(oInit.oLanguage)\n          }\n\n          // If the length menu is given, but the init display length is not, use the length menu\n          if (oInit.aLengthMenu && !oInit.iDisplayLength) {\n            oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0]\n          }\n\n          // Apply the defaults and init options to make a single init object will all\n          // options defined from defaults and instance options.\n          oInit = _fnExtend($.extend(true, {}, defaults), oInit)\n\n          // Map the initialisation options onto the settings object\n          _fnMap(oSettings.oFeatures, oInit, [\n            'bPaginate',\n            'bLengthChange',\n            'bFilter',\n            'bSort',\n            'bSortMulti',\n            'bInfo',\n            'bProcessing',\n            'bAutoWidth',\n            'bSortClasses',\n            'bServerSide',\n            'bDeferRender'\n          ])\n          _fnMap(oSettings, oInit, [\n            'asStripeClasses',\n            'ajax',\n            'fnServerData',\n            'fnFormatNumber',\n            'sServerMethod',\n            'aaSorting',\n            'aaSortingFixed',\n            'aLengthMenu',\n            'sPaginationType',\n            'sAjaxSource',\n            'sAjaxDataProp',\n            'iStateDuration',\n            'sDom',\n            'bSortCellsTop',\n            'iTabIndex',\n            'fnStateLoadCallback',\n            'fnStateSaveCallback',\n            'renderer',\n            ['iCookieDuration', 'iStateDuration'], // backwards compat\n            ['oSearch', 'oPreviousSearch'],\n            ['aoSearchCols', 'aoPreSearchCols'],\n            ['iDisplayLength', '_iDisplayLength'],\n            ['bJQueryUI', 'bJUI']\n          ])\n          _fnMap(oSettings.oScroll, oInit, [\n            ['sScrollX', 'sX'],\n            ['sScrollXInner', 'sXInner'],\n            ['sScrollY', 'sY'],\n            ['bScrollCollapse', 'bCollapse']\n          ])\n          _fnMap(oSettings.oLanguage, oInit, 'fnInfoCallback')\n\n          /* Callback functions which are array driven */\n          _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user')\n          _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user')\n          _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user')\n          _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user')\n          _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user')\n          _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user')\n          _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user')\n\n          var oClasses = oSettings.oClasses\n\n          // @todo Remove in 1.11\n          if (oInit.bJQueryUI) {\n            /* Use the JUI classes object for display. You could clone the oStdClasses object if\n             * you want to have multiple tables with multiple independent classes\n             */\n            $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses)\n\n            if (oInit.sDom === defaults.sDom && defaults.sDom === 'lfrtip') {\n              /* Set the DOM to use a layout suitable for jQuery UI's theming */\n              oSettings.sDom = '<\"H\"lfr>t<\"F\"ip>'\n            }\n\n            if (!oSettings.renderer) {\n              oSettings.renderer = 'jqueryui'\n            } else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {\n              oSettings.renderer.header = 'jqueryui'\n            }\n          } else {\n            $.extend(oClasses, DataTable.ext.classes, oInit.oClasses)\n          }\n          $(this).addClass(oClasses.sTable)\n\n          /* Calculate the scroll bar width and cache it for use later on */\n          if (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '') {\n            oSettings.oScroll.iBarWidth = _fnScrollBarWidth()\n          }\n          if (oSettings.oScroll.sX === true) {\n            // Easy initialisation of x-scrolling\n            oSettings.oScroll.sX = '100%'\n          }\n\n          if (oSettings.iInitDisplayStart === undefined) {\n            /* Display start point, taking into account the save saving */\n            oSettings.iInitDisplayStart = oInit.iDisplayStart\n            oSettings._iDisplayStart = oInit.iDisplayStart\n          }\n\n          if (oInit.iDeferLoading !== null) {\n            oSettings.bDeferLoading = true\n            var tmp = $.isArray(oInit.iDeferLoading)\n            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading\n            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading\n          }\n\n          /* Language definitions */\n          if (oInit.oLanguage.sUrl !== '') {\n            /* Get the language definitions from a file - because this Ajax call makes the language\n             * get async to the remainder of this function we use bInitHandedOff to indicate that\n             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\n             */\n            oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl\n            $.getJSON(oSettings.oLanguage.sUrl, null, function (json) {\n              _fnLanguageCompat(json)\n              _fnCamelToHungarian(defaults.oLanguage, json)\n              $.extend(true, oSettings.oLanguage, oInit.oLanguage, json)\n              _fnInitialise(oSettings)\n            })\n            bInitHandedOff = true\n          } else {\n            $.extend(true, oSettings.oLanguage, oInit.oLanguage)\n          }\n\n          /*\n           * Stripes\n           */\n          if (oInit.asStripeClasses === null) {\n            oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven]\n          }\n\n          /* Remove row stripe classes if they are already on the table row */\n          var stripeClasses = oSettings.asStripeClasses\n          var rowOne = $('tbody tr:eq(0)', this)\n          if (\n            $.inArray(\n              true,\n              $.map(stripeClasses, function (el, i) {\n                return rowOne.hasClass(el)\n              })\n            ) !== -1\n          ) {\n            $('tbody tr', this).removeClass(stripeClasses.join(' '))\n            oSettings.asDestroyStripes = stripeClasses.slice()\n          }\n\n          /*\n           * Columns\n           * See if we should load columns automatically or use defined ones\n           */\n          var anThs = []\n          var aoColumnsInit\n          var nThead = this.getElementsByTagName('thead')\n          if (nThead.length !== 0) {\n            _fnDetectHeader(oSettings.aoHeader, nThead[0])\n            anThs = _fnGetUniqueThs(oSettings)\n          }\n\n          /* If not given a column array, generate one with nulls */\n          if (oInit.aoColumns === null) {\n            aoColumnsInit = []\n            for (i = 0, iLen = anThs.length; i < iLen; i++) {\n              aoColumnsInit.push(null)\n            }\n          } else {\n            aoColumnsInit = oInit.aoColumns\n          }\n\n          /* Add the columns */\n          for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {\n            _fnAddColumn(oSettings, anThs ? anThs[i] : null)\n          }\n\n          /* Apply the column definitions */\n          _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\n            _fnColumnOptions(oSettings, iCol, oDef)\n          })\n\n          /* HTML5 attribute detection - build an mData object automatically if the\n           * attributes are found\n           */\n          if (rowOne.length) {\n            var a = function (cell, name) {\n              return cell.getAttribute('data-' + name) ? name : null\n            }\n\n            $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {\n              var col = oSettings.aoColumns[i]\n\n              if (col.mData === i) {\n                var sort = a(cell, 'sort') || a(cell, 'order')\n                var filter = a(cell, 'filter') || a(cell, 'search')\n\n                if (sort !== null || filter !== null) {\n                  col.mData = {\n                    _: i + '.display',\n                    sort: sort !== null ? i + '.@data-' + sort : undefined,\n                    type: sort !== null ? i + '.@data-' + sort : undefined,\n                    filter: filter !== null ? i + '.@data-' + filter : undefined\n                  }\n\n                  _fnColumnOptions(oSettings, i)\n                }\n              }\n            })\n          }\n\n          var features = oSettings.oFeatures\n\n          /* Must be done after everything which can be overridden by the state saving! */\n          if (oInit.bStateSave) {\n            features.bStateSave = true\n            _fnLoadState(oSettings, oInit)\n            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save')\n          }\n\n          /*\n           * Sorting\n           * @todo For modularisation (1.11) this needs to do into a sort start up handler\n           */\n\n          // If aaSorting is not defined, then we use the first indicator in asSorting\n          // in case that has been altered, so the default sort reflects that option\n          if (oInit.aaSorting === undefined) {\n            var sorting = oSettings.aaSorting\n            for (i = 0, iLen = sorting.length; i < iLen; i++) {\n              sorting[i][1] = oSettings.aoColumns[i].asSorting[0]\n            }\n          }\n\n          /* Do a first pass on the sorting classes (allows any size changes to be taken into\n           * account, and also will apply sorting disabled classes if disabled\n           */\n          _fnSortingClasses(oSettings)\n\n          if (features.bSort) {\n            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {\n              if (oSettings.bSorted) {\n                var aSort = _fnSortFlatten(oSettings)\n                var sortedColumns = {}\n\n                $.each(aSort, function (i, val) {\n                  sortedColumns[val.src] = val.dir\n                })\n\n                _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns])\n                _fnSortAria(oSettings)\n              }\n            })\n          }\n\n          _fnCallbackReg(\n            oSettings,\n            'aoDrawCallback',\n            function () {\n              if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {\n                _fnSortingClasses(oSettings)\n              }\n            },\n            'sc'\n          )\n\n          /*\n           * Final init\n           * Cache the header, body and footer as required, creating them if needed\n           */\n\n          /* Browser support detection */\n          _fnBrowserDetect(oSettings)\n\n          // Work around for Webkit bug 83867 - store the caption-side before removing from doc\n          var captions = $(this)\n            .children('caption')\n            .each(function () {\n              this._captionSide = $(this).css('caption-side')\n            })\n\n          var thead = $(this).children('thead')\n          if (thead.length === 0) {\n            thead = $('<thead/>').appendTo(this)\n          }\n          oSettings.nTHead = thead[0]\n\n          var tbody = $(this).children('tbody')\n          if (tbody.length === 0) {\n            tbody = $('<tbody/>').appendTo(this)\n          }\n          oSettings.nTBody = tbody[0]\n\n          var tfoot = $(this).children('tfoot')\n          if (\n            tfoot.length === 0 &&\n            captions.length > 0 &&\n            (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '')\n          ) {\n            // If we are a scrolling table, and no footer has been given, then we need to create\n            // a tfoot element for the caption element to be appended to\n            tfoot = $('<tfoot/>').appendTo(this)\n          }\n\n          if (tfoot.length === 0 || tfoot.children().length === 0) {\n            $(this).addClass(oClasses.sNoFooter)\n          } else if (tfoot.length > 0) {\n            oSettings.nTFoot = tfoot[0]\n            _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot)\n          }\n\n          /* Check if there is data passing into the constructor */\n          if (oInit.aaData) {\n            for (i = 0; i < oInit.aaData.length; i++) {\n              _fnAddData(oSettings, oInit.aaData[i])\n            }\n          } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {\n            /* Grab the data from the page - only do this when deferred loading or no Ajax\n             * source since there is no point in reading the DOM data if we are then going\n             * to replace it with Ajax data\n             */\n            _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'))\n          }\n\n          /* Copy the data index array */\n          oSettings.aiDisplay = oSettings.aiDisplayMaster.slice()\n\n          /* Initialisation complete - table can be drawn */\n          oSettings.bInitialised = true\n\n          /* Check if we need to initialise the table (it might not have been handed off to the\n           * language processor)\n           */\n          if (bInitHandedOff === false) {\n            _fnInitialise(oSettings)\n          }\n        })\n        _that = null\n        return this\n      }\n\n      /**\n       * Computed structure of the DataTables API, defined by the options passed to\n       * `DataTable.Api.register()` when building the API.\n       *\n       * The structure is built in order to speed creation and extension of the Api\n       * objects since the extensions are effectively pre-parsed.\n       *\n       * The array is an array of objects with the following structure, where this\n       * base array represents the Api prototype base:\n       *\n       *     [\n       *       {\n       *         name:      'data'                -- string   - Property name\n       *         val:       function () {},       -- function - Api method (or undefined if just an object\n       *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n       *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n       *       },\n       *       {\n       *         name:     'row'\n       *         val:       {},\n       *         methodExt: [ ... ],\n       *         propExt:   [\n       *           {\n       *             name:      'data'\n       *             val:       function () {},\n       *             methodExt: [ ... ],\n       *             propExt:   [ ... ]\n       *           },\n       *           ...\n       *         ]\n       *       }\n       *     ]\n       *\n       * @type {Array}\n       * @ignore\n       */\n      var __apiStruct = []\n\n      /**\n       * `Array.prototype` reference.\n       *\n       * @type object\n       * @ignore\n       */\n      var __arrayProto = Array.prototype\n\n      /**\n       * Abstraction for `context` parameter of the `Api` constructor to allow it to\n       * take several different forms for ease of use.\n       *\n       * Each of the input parameter types will be converted to a DataTables settings\n       * object where possible.\n       *\n       * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\n       *   of:\n       *\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\n       *     with be found and used.\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\n       *   * `object` - DataTables settings object\n       *   * `DataTables.Api` - API instance\n       * @return {array|null} Matching DataTables settings objects. `null` or\n       *   `undefined` is returned if no matching DataTable is found.\n       * @ignore\n       */\n      var _toSettings = function (mixed) {\n        var idx, jq\n        var settings = DataTable.settings\n        var tables = $.map(settings, function (el, i) {\n          return el.nTable\n        })\n\n        if (!mixed) {\n          return []\n        } else if (mixed.nTable && mixed.oApi) {\n          // DataTables settings object\n          return [mixed]\n        } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {\n          // Table node\n          idx = $.inArray(mixed, tables)\n          return idx !== -1 ? [settings[idx]] : null\n        } else if (mixed && typeof mixed.settings === 'function') {\n          return mixed.settings().toArray()\n        } else if (typeof mixed === 'string') {\n          // jQuery selector\n          jq = $(mixed)\n        } else if (mixed instanceof $) {\n          // jQuery object (also DataTables instance)\n          jq = mixed\n        }\n\n        if (jq) {\n          return jq\n            .map(function (i) {\n              idx = $.inArray(this, tables)\n              return idx !== -1 ? settings[idx] : null\n            })\n            .toArray()\n        }\n      }\n\n      /**\n       * DataTables API class - used to control and interface with  one or more\n       * DataTables enhanced tables.\n       *\n       * The API class is heavily based on jQuery, presenting a chainable interface\n       * that you can use to interact with tables. Each instance of the API class has\n       * a \"context\" - i.e. the tables that it will operate on. This could be a single\n       * table, all tables on a page or a sub-set thereof.\n       *\n       * Additionally the API is designed to allow you to easily work with the data in\n       * the tables, retrieving and manipulating it as required. This is done by\n       * presenting the API class as an array like interface. The contents of the\n       * array depend upon the actions requested by each method (for example\n       * `rows().nodes()` will return an array of nodes, while `rows().data()` will\n       * return an array of objects or arrays depending upon your table's\n       * configuration). The API object has a number of array like methods (`push`,\n       * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\n       * `unique` etc) to assist your working with the data held in a table.\n       *\n       * Most methods (those which return an Api instance) are chainable, which means\n       * the return from a method call also has all of the methods available that the\n       * top level object had. For example, these two calls are equivalent:\n       *\n       *     // Not chained\n       *     api.row.add( {...} );\n       *     api.draw();\n       *\n       *     // Chained\n       *     api.row.add( {...} ).draw();\n       *\n       * @class DataTable.Api\n       * @param {array|object|string|jQuery} context DataTable identifier. This is\n       *   used to define which DataTables enhanced tables this API will operate on.\n       *   Can be one of:\n       *\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\n       *     with be found and used.\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\n       *   * `object` - DataTables settings object\n       * @param {array} [data] Data to initialise the Api instance with.\n       *\n       * @example\n       *   // Direct initialisation during DataTables construction\n       *   var api = $('#example').DataTable();\n       *\n       * @example\n       *   // Initialisation using a DataTables jQuery object\n       *   var api = $('#example').dataTable().api();\n       *\n       * @example\n       *   // Initialisation as a constructor\n       *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\n       */\n      _Api = function (context, data) {\n        if (!this instanceof _Api) {\n          throw 'DT API must be constructed as a new object'\n          // or should it do the 'new' for the caller?\n          // return new _Api.apply( this, arguments );\n        }\n\n        var settings = []\n        var ctxSettings = function (o) {\n          var a = _toSettings(o)\n          if (a) {\n            settings.push.apply(settings, a)\n          }\n        }\n\n        if ($.isArray(context)) {\n          for (var i = 0, ien = context.length; i < ien; i++) {\n            ctxSettings(context[i])\n          }\n        } else {\n          ctxSettings(context)\n        }\n\n        // Remove duplicates\n        this.context = _unique(settings)\n\n        // Initial data\n        if (data) {\n          this.push.apply(this, data.toArray ? data.toArray() : data)\n        }\n\n        // selector\n        this.selector = {\n          rows: null,\n          cols: null,\n          opts: null\n        }\n\n        _Api.extend(this, this, __apiStruct)\n      }\n\n      DataTable.Api = _Api\n\n      _Api.prototype = /** @lends DataTables.Api */ {\n        /**\n         * Return a new Api instance, comprised of the data held in the current\n         * instance, join with the other array(s) and/or value(s).\n         *\n         * An alias for `Array.prototype.concat`.\n         *\n         * @type method\n         * @param {*} value1 Arrays and/or values to concatenate.\n         * @param {*} [...] Additional arrays and/or values to concatenate.\n         * @returns {DataTables.Api} New API instance, comprising of the combined\n         *   array.\n         */\n        concat: __arrayProto.concat,\n\n        context: [], // array of table settings objects\n\n        each: function (fn) {\n          for (var i = 0, ien = this.length; i < ien; i++) {\n            fn.call(this, this[i], i, this)\n          }\n\n          return this\n        },\n\n        eq: function (idx) {\n          var ctx = this.context\n\n          return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null\n        },\n\n        filter: function (fn) {\n          var a = []\n\n          if (__arrayProto.filter) {\n            a = __arrayProto.filter.call(this, fn, this)\n          } else {\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\n            for (var i = 0, ien = this.length; i < ien; i++) {\n              if (fn.call(this, this[i], i, this)) {\n                a.push(this[i])\n              }\n            }\n          }\n\n          return new _Api(this.context, a)\n        },\n\n        flatten: function () {\n          var a = []\n          return new _Api(this.context, a.concat.apply(a, this.toArray()))\n        },\n\n        join: __arrayProto.join,\n\n        indexOf:\n          __arrayProto.indexOf ||\n          function (obj, start) {\n            for (var i = start || 0, ien = this.length; i < ien; i++) {\n              if (this[i] === obj) {\n                return i\n              }\n            }\n            return -1\n          },\n\n        // Internal only at the moment - relax?\n        iterator: function (flatten, type, fn) {\n          var a = [],\n            ret,\n            i,\n            ien,\n            j,\n            jen,\n            context = this.context,\n            rows,\n            items,\n            item,\n            selector = this.selector\n\n          // Argument shifting\n          if (typeof flatten === 'string') {\n            fn = type\n            type = flatten\n            flatten = false\n          }\n\n          for (i = 0, ien = context.length; i < ien; i++) {\n            if (type === 'table') {\n              ret = fn(context[i], i)\n\n              if (ret !== undefined) {\n                a.push(ret)\n              }\n            } else if (type === 'columns' || type === 'rows') {\n              // this has same length as context - one entry for each table\n              ret = fn(context[i], this[i], i)\n\n              if (ret !== undefined) {\n                a.push(ret)\n              }\n            } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {\n              // columns and rows share the same structure.\n              // 'this' is an array of column indexes for each context\n              items = this[i]\n\n              if (type === 'column-rows') {\n                rows = _selector_row_indexes(context[i], selector.opts)\n              }\n\n              for (j = 0, jen = items.length; j < jen; j++) {\n                item = items[j]\n\n                if (type === 'cell') {\n                  ret = fn(context[i], item.row, item.column, i, j)\n                } else {\n                  ret = fn(context[i], item, i, j, rows)\n                }\n\n                if (ret !== undefined) {\n                  a.push(ret)\n                }\n              }\n            }\n          }\n\n          if (a.length) {\n            var api = new _Api(context, flatten ? a.concat.apply([], a) : a)\n            var apiSelector = api.selector\n            apiSelector.rows = selector.rows\n            apiSelector.cols = selector.cols\n            apiSelector.opts = selector.opts\n            return api\n          }\n          return this\n        },\n\n        lastIndexOf:\n          __arrayProto.lastIndexOf ||\n          function (obj, start) {\n            // Bit cheeky...\n            return this.indexOf.apply(this.toArray.reverse(), arguments)\n          },\n\n        length: 0,\n\n        map: function (fn) {\n          var a = []\n\n          if (__arrayProto.map) {\n            a = __arrayProto.map.call(this, fn, this)\n          } else {\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\n            for (var i = 0, ien = this.length; i < ien; i++) {\n              a.push(fn.call(this, this[i], i))\n            }\n          }\n\n          return new _Api(this.context, a)\n        },\n\n        pluck: function (prop) {\n          return this.map(function (el) {\n            return el[prop]\n          })\n        },\n\n        pop: __arrayProto.pop,\n\n        push: __arrayProto.push,\n\n        // Does not return an API instance\n        reduce:\n          __arrayProto.reduce ||\n          function (fn, init) {\n            return _fnReduce(this, fn, init, 0, this.length, 1)\n          },\n\n        reduceRight:\n          __arrayProto.reduceRight ||\n          function (fn, init) {\n            return _fnReduce(this, fn, init, this.length - 1, -1, -1)\n          },\n\n        reverse: __arrayProto.reverse,\n\n        // Object with rows, columns and opts\n        selector: null,\n\n        shift: __arrayProto.shift,\n\n        sort: __arrayProto.sort, // ? name - order?\n\n        splice: __arrayProto.splice,\n\n        toArray: function () {\n          return __arrayProto.slice.call(this)\n        },\n\n        to$: function () {\n          return $(this)\n        },\n\n        toJQuery: function () {\n          return $(this)\n        },\n\n        unique: function () {\n          return new _Api(this.context, _unique(this))\n        },\n\n        unshift: __arrayProto.unshift\n      }\n\n      _Api.extend = function (scope, obj, ext) {\n        // Only extend API instances and static properties of the API\n        if (!obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {\n          return\n        }\n\n        var i,\n          ien,\n          j,\n          jen,\n          struct,\n          inner,\n          methodScoping = function (scope, fn, struc) {\n            return function () {\n              var ret = fn.apply(scope, arguments)\n\n              // Method extension\n              _Api.extend(ret, ret, struc.methodExt)\n              return ret\n            }\n          }\n\n        for (i = 0, ien = ext.length; i < ien; i++) {\n          struct = ext[i]\n\n          // Value\n          obj[struct.name] =\n            typeof struct.val === 'function'\n              ? methodScoping(scope, struct.val, struct)\n              : $.isPlainObject(struct.val)\n              ? {}\n              : struct.val\n\n          obj[struct.name].__dt_wrapper = true\n\n          // Property extension\n          _Api.extend(scope, obj[struct.name], struct.propExt)\n        }\n      }\n\n      // @todo - Is there need for an augment function?\n      // _Api.augment = function ( inst, name )\n      // {\n      // \t// Find src object in the structure from the name\n      // \tvar parts = name.split('.');\n\n      // \t_Api.extend( inst, obj );\n      // };\n\n      //     [\n      //       {\n      //         name:      'data'                -- string   - Property name\n      //         val:       function () {},       -- function - Api method (or undefined if just an object\n      //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n      //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n      //       },\n      //       {\n      //         name:     'row'\n      //         val:       {},\n      //         methodExt: [ ... ],\n      //         propExt:   [\n      //           {\n      //             name:      'data'\n      //             val:       function () {},\n      //             methodExt: [ ... ],\n      //             propExt:   [ ... ]\n      //           },\n      //           ...\n      //         ]\n      //       }\n      //     ]\n\n      _Api.register = _api_register = function (name, val) {\n        if ($.isArray(name)) {\n          for (var j = 0, jen = name.length; j < jen; j++) {\n            _Api.register(name[j], val)\n          }\n          return\n        }\n\n        var i,\n          ien,\n          heir = name.split('.'),\n          struct = __apiStruct,\n          key,\n          method\n\n        var find = function (src, name) {\n          for (var i = 0, ien = src.length; i < ien; i++) {\n            if (src[i].name === name) {\n              return src[i]\n            }\n          }\n          return null\n        }\n\n        for (i = 0, ien = heir.length; i < ien; i++) {\n          method = heir[i].indexOf('()') !== -1\n          key = method ? heir[i].replace('()', '') : heir[i]\n\n          var src = find(struct, key)\n          if (!src) {\n            src = {\n              name: key,\n              val: {},\n              methodExt: [],\n              propExt: []\n            }\n            struct.push(src)\n          }\n\n          if (i === ien - 1) {\n            src.val = val\n          } else {\n            struct = method ? src.methodExt : src.propExt\n          }\n        }\n      }\n\n      _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {\n        _Api.register(pluralName, val)\n\n        _Api.register(singularName, function () {\n          var ret = val.apply(this, arguments)\n\n          if (ret === this) {\n            // Returned item is the API instance that was passed in, return it\n            return this\n          } else if (ret instanceof _Api) {\n            // New API instance returned, want the value from the first item\n            // in the returned array for the singular result.\n            return ret.length\n              ? $.isArray(ret[0])\n                ? new _Api(ret.context, ret[0]) // Array results are 'enhanced'\n                : ret[0]\n              : undefined\n          }\n\n          // Non-API return - just fire it back\n          return ret\n        })\n      }\n\n      /**\n       * Selector for HTML tables. Apply the given selector to the give array of\n       * DataTables settings objects.\n       *\n       * @param {string|integer} [selector] jQuery selector string or integer\n       * @param  {array} Array of DataTables settings objects to be filtered\n       * @return {array}\n       * @ignore\n       */\n      var __table_selector = function (selector, a) {\n        // Integer is used to pick out a table by index\n        if (typeof selector === 'number') {\n          return [a[selector]]\n        }\n\n        // Perform a jQuery selector on the table nodes\n        var nodes = $.map(a, function (el, i) {\n          return el.nTable\n        })\n\n        return $(nodes)\n          .filter(selector)\n          .map(function (i) {\n            // Need to translate back from the table node to the settings\n            var idx = $.inArray(this, nodes)\n            return a[idx]\n          })\n          .toArray()\n      }\n\n      /**\n       * Context selector for the API's context (i.e. the tables the API instance\n       * refers to.\n       *\n       * @name    DataTable.Api#tables\n       * @param {string|integer} [selector] Selector to pick which tables the iterator\n       *   should operate on. If not given, all tables in the current context are\n       *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\n       *   select multiple tables or as an integer to select a single table.\n       * @returns {DataTable.Api} Returns a new API instance if a selector is given.\n       */\n      _api_register('tables()', function (selector) {\n        // A new instance is created if there was a selector specified\n        return selector ? new _Api(__table_selector(selector, this.context)) : this\n      })\n\n      _api_register('table()', function (selector) {\n        var tables = this.tables(selector)\n        var ctx = tables.context\n\n        // Truncate to the first matched table\n        return ctx.length ? new _Api(ctx[0]) : tables\n      })\n\n      _api_registerPlural('tables().nodes()', 'table().node()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTable\n        })\n      })\n\n      _api_registerPlural('tables().body()', 'table().body()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTBody\n        })\n      })\n\n      _api_registerPlural('tables().header()', 'table().header()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTHead\n        })\n      })\n\n      _api_registerPlural('tables().footer()', 'table().footer()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTFoot\n        })\n      })\n\n      _api_registerPlural('tables().containers()', 'table().container()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTableWrapper\n        })\n      })\n\n      /**\n       * Redraw the tables in the current context.\n       *\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\n       *   position. A full re-sort and re-filter is performed when this method is\n       *   called, which is why the pagination reset is the default action.\n       * @returns {DataTables.Api} this\n       */\n      _api_register('draw()', function (resetPaging) {\n        return this.iterator('table', function (settings) {\n          _fnReDraw(settings, resetPaging === false)\n        })\n      })\n      /**\n       * Set the current page.\n       *\n       * Note that if you attempt to show a page which does not exist, DataTables will\n       * not throw an error, but rather reset the paging.\n       *\n       * @param {integer|string} action The paging action to take. This can be one of:\n       *  * `integer` - The page index to jump to\n       *  * `string` - An action to take:\n       *    * `first` - Jump to first page.\n       *    * `next` - Jump to the next page\n       *    * `previous` - Jump to previous page\n       *    * `last` - Jump to the last page.\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get the current page index.\n       *\n       * @return {integer} Current page index (zero based)\n       */ _api_register('page()', function (action) {\n        if (action === undefined) {\n          return this.page.info().page // not an expensive call\n        }\n\n        // else, have an action to take on all tables\n        return this.iterator('table', function (settings) {\n          _fnPageChange(settings, action)\n        })\n      })\n\n      /**\n       * Paging information for the first table in the current context.\n       *\n       * If you require paging information for another table, use the `table()` method\n       * with a suitable selector.\n       *\n       * @return {object} Object with the following properties set:\n       *  * `page` - Current page index (zero based - i.e. the first page is `0`)\n       *  * `pages` - Total number of pages\n       *  * `start` - Display index for the first record shown on the current page\n       *  * `end` - Display index for the last record shown on the current page\n       *  * `length` - Display length (number of records). Note that generally `start\n       *    + length = end`, but this is not always true, for example if there are\n       *    only 2 records to show on the final page, with a length of 10.\n       *  * `recordsTotal` - Full data set length\n       *  * `recordsDisplay` - Data set length once the current filtering criterion\n       *    are applied.\n       */\n      _api_register('page.info()', function (action) {\n        if (this.context.length === 0) {\n          return undefined\n        }\n\n        var settings = this.context[0],\n          start = settings._iDisplayStart,\n          len = settings._iDisplayLength,\n          visRecords = settings.fnRecordsDisplay(),\n          all = len === -1\n\n        return {\n          page: all ? 0 : Math.floor(start / len),\n          pages: all ? 1 : Math.ceil(visRecords / len),\n          start: start,\n          end: settings.fnDisplayEnd(),\n          length: len,\n          recordsTotal: settings.fnRecordsTotal(),\n          recordsDisplay: visRecords\n        }\n      })\n      /**\n       * Set the current page length.\n       *\n       * @param {integer} Page length to set. Use `-1` to show all records.\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get the current page length.\n       *\n       * @return {integer} Current page length. Note `-1` indicates that all records\n       *   are to be shown.\n       */ _api_register('page.len()', function (len) {\n        // Note that we can't call this function 'length()' because `length`\n        // is a Javascript property of functions which defines how many arguments\n        // the function expects.\n        if (len === undefined) {\n          return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined\n        }\n\n        // else, set the page length\n        return this.iterator('table', function (settings) {\n          _fnLengthChange(settings, len)\n        })\n      })\n\n      var __reload = function (settings, holdPosition, callback) {\n        if (_fnDataSource(settings) == 'ssp') {\n          _fnReDraw(settings, holdPosition)\n        } else {\n          // Trigger xhr\n          _fnProcessingDisplay(settings, true)\n\n          _fnBuildAjax(settings, [], function (json) {\n            _fnClearTable(settings)\n\n            var data = _fnAjaxDataSrc(settings, json)\n            for (var i = 0, ien = data.length; i < ien; i++) {\n              _fnAddData(settings, data[i])\n            }\n\n            _fnReDraw(settings, holdPosition)\n            _fnProcessingDisplay(settings, false)\n          })\n        }\n\n        // Use the draw event to trigger a callback, regardless of if it is an async\n        // or sync draw\n        if (callback) {\n          var api = new _Api(settings)\n\n          api.one('draw', function () {\n            callback(api.ajax.json())\n          })\n        }\n      }\n\n      /**\n       * Get the JSON response from the last Ajax request that DataTables made to the\n       * server. Note that this returns the JSON from the first table in the current\n       * context.\n       *\n       * @return {object} JSON received from the server.\n       */\n      _api_register('ajax.json()', function () {\n        var ctx = this.context\n\n        if (ctx.length > 0) {\n          return ctx[0].json\n        }\n\n        // else return undefined;\n      })\n\n      /**\n       * Get the data submitted in the last Ajax request\n       */\n      _api_register('ajax.params()', function () {\n        var ctx = this.context\n\n        if (ctx.length > 0) {\n          return ctx[0].oAjaxData\n        }\n\n        // else return undefined;\n      })\n\n      /**\n       * Reload tables from the Ajax data source. Note that this function will\n       * automatically re-draw the table when the remote data has been loaded.\n       *\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\n       *   position. A full re-sort and re-filter is performed when this method is\n       *   called, which is why the pagination reset is the default action.\n       * @returns {DataTables.Api} this\n       */\n      _api_register('ajax.reload()', function (callback, resetPaging) {\n        return this.iterator('table', function (settings) {\n          __reload(settings, resetPaging === false, callback)\n        })\n      })\n      /**\n       * Set the Ajax URL. Note that this will set the URL for all tables in the\n       * current context.\n       *\n       * @param {string} url URL to set.\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get the current Ajax URL. Note that this returns the URL from the first\n       * table in the current context.\n       *\n       * @return {string} Current Ajax source URL\n       */ _api_register('ajax.url()', function (url) {\n        var ctx = this.context\n\n        if (url === undefined) {\n          // get\n          if (ctx.length === 0) {\n            return undefined\n          }\n          ctx = ctx[0]\n\n          return ctx.ajax ? ($.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax) : ctx.sAjaxSource\n        }\n\n        // set\n        return this.iterator('table', function (settings) {\n          if ($.isPlainObject(settings.ajax)) {\n            settings.ajax.url = url\n          } else {\n            settings.ajax = url\n          }\n          // No need to consider sAjaxSource here since DataTables gives priority\n          // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\n          // value of `sAjaxSource` redundant.\n        })\n      })\n\n      /**\n       * Load data from the newly set Ajax URL. Note that this method is only\n       * available when `ajax.url()` is used to set a URL. Additionally, this method\n       * has the same effect as calling `ajax.reload()` but is provided for\n       * convenience when setting a new URL. Like `ajax.reload()` it will\n       * automatically redraw the table once the remote data has been loaded.\n       *\n       * @returns {DataTables.Api} this\n       */\n      _api_register('ajax.url().load()', function (callback, resetPaging) {\n        // Same as a reload, but makes sense to present it for easy access after a\n        // url change\n        return this.iterator('table', function (ctx) {\n          __reload(ctx, resetPaging === false, callback)\n        })\n      })\n\n      var _selector_run = function (selector, select) {\n        var out = [],\n          res,\n          a,\n          i,\n          ien,\n          j,\n          jen\n\n        // Can't just check for isArray here, as an API or jQuery instance might be\n        // given with their array like look\n        if (!selector || typeof selector === 'string' || selector.length === undefined) {\n          selector = [selector]\n        }\n\n        for (i = 0, ien = selector.length; i < ien; i++) {\n          a = selector[i] && selector[i].split ? selector[i].split(',') : [selector[i]]\n\n          for (j = 0, jen = a.length; j < jen; j++) {\n            res = select(typeof a[j] === 'string' ? $.trim(a[j]) : a[j])\n\n            if (res && res.length) {\n              out.push.apply(out, res)\n            }\n          }\n        }\n\n        return out\n      }\n\n      var _selector_opts = function (opts) {\n        if (!opts) {\n          opts = {}\n        }\n\n        // Backwards compatibility for 1.9- which used the terminology filter rather\n        // than search\n        if (opts.filter && !opts.search) {\n          opts.search = opts.filter\n        }\n\n        return {\n          search: opts.search || 'none',\n          order: opts.order || 'current',\n          page: opts.page || 'all'\n        }\n      }\n\n      var _selector_first = function (inst) {\n        // Reduce the API instance to the first item found\n        for (var i = 0, ien = inst.length; i < ien; i++) {\n          if (inst[i].length > 0) {\n            // Assign the first element to the first item in the instance\n            // and truncate the instance and context\n            inst[0] = inst[i]\n            inst.length = 1\n            inst.context = [inst.context[i]]\n\n            return inst\n          }\n        }\n\n        // Not found - return an empty instance\n        inst.length = 0\n        return inst\n      }\n\n      var _selector_row_indexes = function (settings, opts) {\n        var i,\n          ien,\n          tmp,\n          a = [],\n          displayFiltered = settings.aiDisplay,\n          displayMaster = settings.aiDisplayMaster\n\n        var search = opts.search, // none, applied, removed\n          order = opts.order, // applied, current, index (original - compatibility with 1.9)\n          page = opts.page // all, current\n\n        if (_fnDataSource(settings) == 'ssp') {\n          // In server-side processing mode, most options are irrelevant since\n          // rows not shown don't exist and the index order is the applied order\n          // Removed is a special case - for consistency just return an empty\n          // array\n          return search === 'removed' ? [] : _range(0, displayMaster.length)\n        } else if (page == 'current') {\n          // Current page implies that order=current and fitler=applied, since it is\n          // fairly senseless otherwise, regardless of what order and search actually\n          // are\n          for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {\n            a.push(displayFiltered[i])\n          }\n        } else if (order == 'current' || order == 'applied') {\n          a =\n            search == 'none'\n              ? displayMaster.slice() // no search\n              : search == 'applied'\n              ? displayFiltered.slice() // applied search\n              : $.map(displayMaster, function (el, i) {\n                  // removed search\n                  return $.inArray(el, displayFiltered) === -1 ? el : null\n                })\n        } else if (order == 'index' || order == 'original') {\n          for (i = 0, ien = settings.aoData.length; i < ien; i++) {\n            if (search == 'none') {\n              a.push(i)\n            } else {\n              // applied | removed\n              tmp = $.inArray(i, displayFiltered)\n\n              if ((tmp === -1 && search == 'removed') || (tmp >= 0 && search == 'applied')) {\n                a.push(i)\n              }\n            }\n          }\n        }\n\n        return a\n      }\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Rows\n       *\n       * {}          - no selector - use all available rows\n       * {integer}   - row aoData index\n       * {node}      - TR node\n       * {string}    - jQuery selector to apply to the TR elements\n       * {array}     - jQuery array of nodes, or simply an array of TR nodes\n       *\n       */\n\n      var __row_selector = function (settings, selector, opts) {\n        return _selector_run(selector, function (sel) {\n          var selInt = _intVal(sel)\n\n          // Short cut - selector is a number and no options provided (default is\n          // all records, so no need to check if the index is in there, since it\n          // must be - dev error if the index doesn't exist).\n          if (selInt !== null && !opts) {\n            return [selInt]\n          }\n\n          var rows = _selector_row_indexes(settings, opts)\n\n          if (selInt !== null && $.inArray(selInt, rows) !== -1) {\n            // Selector - integer\n            return [selInt]\n          } else if (!sel) {\n            // Selector - none\n            return rows\n          }\n\n          // Get nodes in the order from the `rows` array (can't use `pluck`) @todo - use pluck_order\n          var nodes = []\n          for (var i = 0, ien = rows.length; i < ien; i++) {\n            nodes.push(settings.aoData[rows[i]].nTr)\n          }\n\n          if (sel.nodeName) {\n            // Selector - node\n            if ($.inArray(sel, nodes) !== -1) {\n              return [sel._DT_RowIndex] // sel is a TR node that is in the table\n              // and DataTables adds a prop for fast lookup\n            }\n          }\n\n          // Selector - jQuery selector string, array of nodes or jQuery object/\n          // As jQuery's .filter() allows jQuery objects to be passed in filter,\n          // it also allows arrays, so this will cope with all three options\n          return $(nodes)\n            .filter(sel)\n            .map(function () {\n              return this._DT_RowIndex\n            })\n            .toArray()\n        })\n      }\n\n      /**\n       *\n       */\n      _api_register('rows()', function (selector, opts) {\n        // argument shifting\n        if (selector === undefined) {\n          selector = ''\n        } else if ($.isPlainObject(selector)) {\n          opts = selector\n          selector = ''\n        }\n\n        opts = _selector_opts(opts)\n\n        var inst = this.iterator('table', function (settings) {\n          return __row_selector(settings, selector, opts)\n        })\n\n        // Want argument shifting here and in __row_selector?\n        inst.selector.rows = selector\n        inst.selector.opts = opts\n\n        return inst\n      })\n\n      _api_register('rows().nodes()', function () {\n        return this.iterator('row', function (settings, row) {\n          return settings.aoData[row].nTr || undefined\n        })\n      })\n\n      _api_register('rows().data()', function () {\n        return this.iterator(true, 'rows', function (settings, rows) {\n          return _pluck_order(settings.aoData, rows, '_aData')\n        })\n      })\n\n      _api_registerPlural('rows().cache()', 'row().cache()', function (type) {\n        return this.iterator('row', function (settings, row) {\n          var r = settings.aoData[row]\n          return type === 'search' ? r._aFilterData : r._aSortData\n        })\n      })\n\n      _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {\n        return this.iterator('row', function (settings, row) {\n          _fnInvalidateRow(settings, row, src)\n        })\n      })\n\n      _api_registerPlural('rows().indexes()', 'row().index()', function () {\n        return this.iterator('row', function (settings, row) {\n          return row\n        })\n      })\n\n      _api_registerPlural('rows().remove()', 'row().remove()', function () {\n        var that = this\n\n        return this.iterator('row', function (settings, row, thatIdx) {\n          var data = settings.aoData\n\n          data.splice(row, 1)\n\n          // Update the _DT_RowIndex parameter on all rows in the table\n          for (var i = 0, ien = data.length; i < ien; i++) {\n            if (data[i].nTr !== null) {\n              data[i].nTr._DT_RowIndex = i\n            }\n          }\n\n          // Remove the target row from the search array\n          var displayIndex = $.inArray(row, settings.aiDisplay)\n\n          // Delete from the display arrays\n          _fnDeleteIndex(settings.aiDisplayMaster, row)\n          _fnDeleteIndex(settings.aiDisplay, row)\n          _fnDeleteIndex(that[thatIdx], row, false) // maintain local indexes\n\n          // Check for an 'overflow' they case for displaying the table\n          _fnLengthOverflow(settings)\n        })\n      })\n\n      _api_register('rows.add()', function (rows) {\n        var newRows = this.iterator('table', function (settings) {\n          var row, i, ien\n          var out = []\n\n          for (i = 0, ien = rows.length; i < ien; i++) {\n            row = rows[i]\n\n            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\n              out.push(_fnAddTr(settings, row)[0])\n            } else {\n              out.push(_fnAddData(settings, row))\n            }\n          }\n\n          return out\n        })\n\n        // Return an Api.rows() extended instance, so rows().nodes() etc can be used\n        var modRows = this.rows(-1)\n        modRows.pop()\n        modRows.push.apply(modRows, newRows.toArray())\n\n        return modRows\n      })\n\n      /**\n       *\n       */\n      _api_register('row()', function (selector, opts) {\n        return _selector_first(this.rows(selector, opts))\n      })\n\n      _api_register('row().data()', function (data) {\n        var ctx = this.context\n\n        if (data === undefined) {\n          // Get\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined\n        }\n\n        // Set\n        ctx[0].aoData[this[0]]._aData = data\n\n        // Automatically invalidate\n        _fnInvalidateRow(ctx[0], this[0], 'data')\n\n        return this\n      })\n\n      _api_register('row().node()', function () {\n        var ctx = this.context\n\n        return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null\n      })\n\n      _api_register('row.add()', function (row) {\n        // Allow a jQuery object to be passed in - only a single row is added from\n        // it though - the first element in the set\n        if (row instanceof $ && row.length) {\n          row = row[0]\n        }\n\n        var rows = this.iterator('table', function (settings) {\n          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\n            return _fnAddTr(settings, row)[0]\n          }\n          return _fnAddData(settings, row)\n        })\n\n        // Return an Api.rows() extended instance, with the newly added row selected\n        return this.row(rows[0])\n      })\n\n      var __details_add = function (ctx, row, data, klass) {\n        // Convert to array of TR elements\n        var rows = []\n        var addRow = function (r, k) {\n          // If we get a TR element, then just add it directly - up to the dev\n          // to add the correct number of columns etc\n          if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {\n            rows.push(r)\n          } else {\n            // Otherwise create a row with a wrapper\n            var created = $('<tr><td/></tr>').addClass(k)\n            $('td', created)\n              .addClass(k)\n              .html(r)[0].colSpan = _fnVisbleColumns(ctx)\n\n            rows.push(created[0])\n          }\n        }\n\n        if ($.isArray(data) || data instanceof $) {\n          for (var i = 0, ien = data.length; i < ien; i++) {\n            addRow(data[i], klass)\n          }\n        } else {\n          addRow(data, klass)\n        }\n\n        if (row._details) {\n          row._details.remove()\n        }\n\n        row._details = $(rows)\n\n        // If the children were already shown, that state should be retained\n        if (row._detailsShow) {\n          row._details.insertAfter(row.nTr)\n        }\n      }\n\n      var __details_remove = function (api) {\n        var ctx = api.context\n\n        if (ctx.length && api.length) {\n          var row = ctx[0].aoData[api[0]]\n\n          if (row._details) {\n            row._details.remove()\n\n            row._detailsShow = undefined\n            row._details = undefined\n          }\n        }\n      }\n\n      var __details_display = function (api, show) {\n        var ctx = api.context\n\n        if (ctx.length && api.length) {\n          var row = ctx[0].aoData[api[0]]\n\n          if (row._details) {\n            row._detailsShow = show\n\n            if (show) {\n              row._details.insertAfter(row.nTr)\n            } else {\n              row._details.detach()\n            }\n\n            __details_events(ctx[0])\n          }\n        }\n      }\n\n      var __details_events = function (settings) {\n        var api = new _Api(settings)\n        var namespace = '.dt.DT_details'\n        var drawEvent = 'draw' + namespace\n        var colvisEvent = 'column-visibility' + namespace\n        var destroyEvent = 'destroy' + namespace\n        var data = settings.aoData\n\n        api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent)\n\n        if (_pluck(data, '_details').length > 0) {\n          // On each draw, insert the required elements into the document\n          api.on(drawEvent, function (e, ctx) {\n            if (settings !== ctx) {\n              return\n            }\n\n            api\n              .rows({ page: 'current' })\n              .eq(0)\n              .each(function (idx) {\n                // Internal data grab\n                var row = data[idx]\n\n                if (row._detailsShow) {\n                  row._details.insertAfter(row.nTr)\n                }\n              })\n          })\n\n          // Column visibility change - update the colspan\n          api.on(colvisEvent, function (e, ctx, idx, vis) {\n            if (settings !== ctx) {\n              return\n            }\n\n            // Update the colspan for the details rows (note, only if it already has\n            // a colspan)\n            var row,\n              visible = _fnVisbleColumns(ctx)\n\n            for (var i = 0, ien = data.length; i < ien; i++) {\n              row = data[i]\n\n              if (row._details) {\n                row._details.children('td[colspan]').attr('colspan', visible)\n              }\n            }\n          })\n\n          // Table destroyed - nuke any child rows\n          api.on(destroyEvent, function (e, ctx) {\n            if (settings !== ctx) {\n              return\n            }\n\n            for (var i = 0, ien = data.length; i < ien; i++) {\n              if (data[i]._details) {\n                __details_remove(data[i])\n              }\n            }\n          })\n        }\n      }\n\n      // Strings for the method names to help minification\n      var _emp = ''\n      var _child_obj = _emp + 'row().child'\n      var _child_mth = _child_obj + '()'\n\n      // data can be:\n      //  tr\n      //  string\n      //  jQuery or array of any of the above\n      _api_register(_child_mth, function (data, klass) {\n        var ctx = this.context\n\n        if (data === undefined) {\n          // get\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined\n        } else if (data === true) {\n          // show\n          this.child.show()\n        } else if (data === false) {\n          // remove\n          __details_remove(this)\n        } else if (ctx.length && this.length) {\n          // set\n          __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass)\n        }\n\n        return this\n      })\n\n      _api_register(\n        [\n          _child_obj + '.show()',\n          _child_mth + '.show()' // only when `child()` was called with parameters (without\n        ],\n        function (show) {\n          // it returns an object and this method is not executed)\n          __details_display(this, true)\n          return this\n        }\n      )\n\n      _api_register(\n        [\n          _child_obj + '.hide()',\n          _child_mth + '.hide()' // only when `child()` was called with parameters (without\n        ],\n        function () {\n          // it returns an object and this method is not executed)\n          __details_display(this, false)\n          return this\n        }\n      )\n\n      _api_register(\n        [\n          _child_obj + '.remove()',\n          _child_mth + '.remove()' // only when `child()` was called with parameters (without\n        ],\n        function () {\n          // it returns an object and this method is not executed)\n          __details_remove(this)\n          return this\n        }\n      )\n\n      _api_register(_child_obj + '.isShown()', function () {\n        var ctx = this.context\n\n        if (ctx.length && this.length) {\n          // _detailsShown as false or undefined will fall through to return false\n          return ctx[0].aoData[this[0]]._detailsShow || false\n        }\n        return false\n      })\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Columns\n       *\n       * {integer}           - column index (>=0 count from left, <0 count from right)\n       * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\n       * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\n       * \"{string}:name\"     - column name\n       * \"{string}\"          - jQuery selector on column header nodes\n       *\n       */\n\n      // can be an array of these items, comma separated list, or an array of comma\n      // separated lists\n\n      var __re_column_selector = /^(.+):(name|visIdx|visible)$/\n\n      var __column_selector = function (settings, selector, opts) {\n        var columns = settings.aoColumns,\n          names = _pluck(columns, 'sName'),\n          nodes = _pluck(columns, 'nTh')\n\n        return _selector_run(selector, function (s) {\n          var selInt = _intVal(s)\n\n          if (s === '') {\n            // All columns\n            return _range(columns.length)\n          } else if (selInt !== null) {\n            // Integer selector\n            return [\n              selInt >= 0\n                ? selInt // Count from left\n                : columns.length + selInt // Count from right (+ because its a negative value)\n            ]\n          } else {\n            var match = typeof s === 'string' ? s.match(__re_column_selector) : ''\n\n            if (match) {\n              switch (match[2]) {\n                case 'visIdx':\n                case 'visible':\n                  var idx = parseInt(match[1], 10)\n                  // Visible index given, convert to column index\n                  if (idx < 0) {\n                    // Counting from the right\n                    var visColumns = $.map(columns, function (col, i) {\n                      return col.bVisible ? i : null\n                    })\n                    return [visColumns[visColumns.length + idx]]\n                  }\n                  // Counting from the left\n                  return [_fnVisibleToColumnIndex(settings, idx)]\n\n                case 'name':\n                  // match by name. `names` is column index complete and in order\n                  return $.map(names, function (name, i) {\n                    return name === match[1] ? i : null\n                  })\n              }\n            } else {\n              // jQuery selector on the TH elements for the columns\n              return $(nodes)\n                .filter(s)\n                .map(function () {\n                  return $.inArray(this, nodes) // `nodes` is column index complete and in order\n                })\n                .toArray()\n            }\n          }\n        })\n      }\n\n      var __setColumnVis = function (settings, column, vis, recalc) {\n        var cols = settings.aoColumns,\n          col = cols[column],\n          data = settings.aoData,\n          row,\n          cells,\n          i,\n          ien,\n          tr\n\n        // Get\n        if (vis === undefined) {\n          return col.bVisible\n        }\n\n        // Set\n        // No change\n        if (col.bVisible === vis) {\n          return\n        }\n\n        if (vis) {\n          // Insert column\n          // Need to decide if we should use appendChild or insertBefore\n          var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1)\n\n          for (i = 0, ien = data.length; i < ien; i++) {\n            tr = data[i].nTr\n            cells = data[i].anCells\n\n            if (tr) {\n              // insertBefore can act like appendChild if 2nd arg is null\n              tr.insertBefore(cells[column], cells[insertBefore] || null)\n            }\n          }\n        } else {\n          // Remove column\n          $(_pluck(settings.aoData, 'anCells', column)).detach()\n        }\n\n        // Common actions\n        col.bVisible = vis\n        _fnDrawHead(settings, settings.aoHeader)\n        _fnDrawHead(settings, settings.aoFooter)\n\n        if (recalc === undefined || recalc) {\n          // Automatically adjust column sizing\n          _fnAdjustColumnSizing(settings)\n\n          // Realign columns for scrolling\n          if (settings.oScroll.sX || settings.oScroll.sY) {\n            _fnScrollDraw(settings)\n          }\n        }\n\n        _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis])\n\n        _fnSaveState(settings)\n      }\n\n      /**\n       *\n       */\n      _api_register('columns()', function (selector, opts) {\n        // argument shifting\n        if (selector === undefined) {\n          selector = ''\n        } else if ($.isPlainObject(selector)) {\n          opts = selector\n          selector = ''\n        }\n\n        opts = _selector_opts(opts)\n\n        var inst = this.iterator('table', function (settings) {\n          return __column_selector(settings, selector, opts)\n        })\n\n        // Want argument shifting here and in _row_selector?\n        inst.selector.cols = selector\n        inst.selector.opts = opts\n\n        return inst\n      })\n\n      /**\n       *\n       */\n      _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {\n        return this.iterator('column', function (settings, column) {\n          return settings.aoColumns[column].nTh\n        })\n      })\n\n      /**\n       *\n       */\n      _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {\n        return this.iterator('column', function (settings, column) {\n          return settings.aoColumns[column].nTf\n        })\n      })\n\n      /**\n       *\n       */\n      _api_registerPlural('columns().data()', 'column().data()', function () {\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\n          var a = []\n          for (var row = 0, ien = rows.length; row < ien; row++) {\n            a.push(_fnGetCellData(settings, rows[row], column, ''))\n          }\n          return a\n        })\n      })\n\n      _api_registerPlural('columns().cache()', 'column().cache()', function (type) {\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\n          return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column)\n        })\n      })\n\n      _api_registerPlural('columns().nodes()', 'column().nodes()', function () {\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\n          return _pluck_order(settings.aoData, rows, 'anCells', column)\n        })\n      })\n\n      _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {\n        return this.iterator('column', function (settings, column) {\n          return vis === undefined ? settings.aoColumns[column].bVisible : __setColumnVis(settings, column, vis, calc)\n        })\n      })\n\n      _api_registerPlural('columns().indexes()', 'column().index()', function (type) {\n        return this.iterator('column', function (settings, column) {\n          return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column\n        })\n      })\n\n      // _api_register( 'columns().show()', function () {\n      // \tvar selector = this.selector;\n      // \treturn this.columns( selector.cols, selector.opts ).visible( true );\n      // } );\n\n      // _api_register( 'columns().hide()', function () {\n      // \tvar selector = this.selector;\n      // \treturn this.columns( selector.cols, selector.opts ).visible( false );\n      // } );\n\n      _api_register('columns.adjust()', function () {\n        return this.iterator('table', function (settings) {\n          _fnAdjustColumnSizing(settings)\n        })\n      })\n\n      // Convert from one column index type, to another type\n      _api_register('column.index()', function (type, idx) {\n        if (this.context.length !== 0) {\n          var ctx = this.context[0]\n\n          if (type === 'fromVisible' || type === 'toData') {\n            return _fnVisibleToColumnIndex(ctx, idx)\n          } else if (type === 'fromData' || type === 'toVisible') {\n            return _fnColumnIndexToVisible(ctx, idx)\n          }\n        }\n      })\n\n      _api_register('column()', function (selector, opts) {\n        return _selector_first(this.columns(selector, opts))\n      })\n\n      var __cell_selector = function (settings, selector, opts) {\n        var data = settings.aoData\n        var rows = _selector_row_indexes(settings, opts)\n        var cells = _pluck_order(data, rows, 'anCells')\n        var allCells = $([].concat.apply([], cells))\n        var row\n        var columns = settings.aoColumns.length\n        var a, i, ien, j\n\n        return _selector_run(selector, function (s) {\n          if (s === null || s === undefined) {\n            // All cells\n            a = []\n\n            for (i = 0, ien = rows.length; i < ien; i++) {\n              row = rows[i]\n\n              for (j = 0; j < columns; j++) {\n                a.push({\n                  row: row,\n                  column: j\n                })\n              }\n            }\n\n            return a\n          } else if ($.isPlainObject(s)) {\n            return [s]\n          }\n\n          // jQuery filtered cells\n          return allCells\n            .filter(s)\n            .map(function (i, el) {\n              row = el.parentNode._DT_RowIndex\n\n              return {\n                row: row,\n                column: $.inArray(el, data[row].anCells)\n              }\n            })\n            .toArray()\n        })\n      }\n\n      _api_register('cells()', function (rowSelector, columnSelector, opts) {\n        // Argument shifting\n        if ($.isPlainObject(rowSelector)) {\n          // Indexes\n          if (typeof rowSelector.row !== undefined) {\n            opts = columnSelector\n            columnSelector = null\n          } else {\n            opts = rowSelector\n            rowSelector = null\n          }\n        }\n        if ($.isPlainObject(columnSelector)) {\n          opts = columnSelector\n          columnSelector = null\n        }\n\n        // Cell selector\n        if (columnSelector === null || columnSelector === undefined) {\n          return this.iterator('table', function (settings) {\n            return __cell_selector(settings, rowSelector, _selector_opts(opts))\n          })\n        }\n\n        // Row + column selector\n        var columns = this.columns(columnSelector, opts)\n        var rows = this.rows(rowSelector, opts)\n        var a, i, ien, j, jen\n\n        var cells = this.iterator('table', function (settings, idx) {\n          a = []\n\n          for (i = 0, ien = rows[idx].length; i < ien; i++) {\n            for (j = 0, jen = columns[idx].length; j < jen; j++) {\n              a.push({\n                row: rows[idx][i],\n                column: columns[idx][j]\n              })\n            }\n          }\n\n          return a\n        })\n\n        $.extend(cells.selector, {\n          cols: columnSelector,\n          rows: rowSelector,\n          opts: opts\n        })\n\n        return cells\n      })\n\n      _api_registerPlural('cells().nodes()', 'cell().node()', function () {\n        return this.iterator('cell', function (settings, row, column) {\n          return settings.aoData[row].anCells[column]\n        })\n      })\n\n      _api_register('cells().data()', function () {\n        return this.iterator('cell', function (settings, row, column) {\n          return _fnGetCellData(settings, row, column)\n        })\n      })\n\n      _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {\n        type = type === 'search' ? '_aFilterData' : '_aSortData'\n\n        return this.iterator('cell', function (settings, row, column) {\n          return settings.aoData[row][type][column]\n        })\n      })\n\n      _api_registerPlural('cells().indexes()', 'cell().index()', function () {\n        return this.iterator('cell', function (settings, row, column) {\n          return {\n            row: row,\n            column: column,\n            columnVisible: _fnColumnIndexToVisible(settings, column)\n          }\n        })\n      })\n\n      _api_register(['cells().invalidate()', 'cell().invalidate()'], function (src) {\n        var selector = this.selector\n\n        // Use the rows method of the instance to perform the invalidation, rather\n        // than doing it here. This avoids needing to handle duplicate rows from\n        // the cells.\n        this.rows(selector.rows, selector.opts).invalidate(src)\n\n        return this\n      })\n\n      _api_register('cell()', function (rowSelector, columnSelector, opts) {\n        return _selector_first(this.cells(rowSelector, columnSelector, opts))\n      })\n\n      _api_register('cell().data()', function (data) {\n        var ctx = this.context\n        var cell = this[0]\n\n        if (data === undefined) {\n          // Get\n          return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined\n        }\n\n        // Set\n        _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data)\n        _fnInvalidateRow(ctx[0], cell[0].row, 'data', cell[0].column)\n\n        return this\n      })\n      /**\n       * Set the ordering for the table.\n       *\n       * @param {array} order 2D array of sorting information to be applied.\n       * @returns {DataTables.Api} this\n       */\n      /**\n       * Set the ordering for the table.\n       *\n       * @param {integer} order Column index to sort upon.\n       * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\n       * @returns {DataTables.Api} this\n       */\n      /**\n       * Set the ordering for the table.\n       *\n       * @param {array} order 1D array of sorting information to be applied.\n       * @param {array} [...] Optional additional sorting conditions\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get current ordering (sorting) that has been applied to the table.\n       *\n       * @returns {array} 2D array containing the sorting information for the first\n       *   table in the current context. Each element in the parent array represents\n       *   a column being sorted upon (i.e. multi-sorting with two columns would have\n       *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\n       *   the column index that the sorting condition applies to, the second is the\n       *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\n       *   index of the sorting order from the `column.sorting` initialisation array.\n       */ _api_register('order()', function (order, dir) {\n        var ctx = this.context\n\n        if (order === undefined) {\n          // get\n          return ctx.length !== 0 ? ctx[0].aaSorting : undefined\n        }\n\n        // set\n        if (typeof order === 'number') {\n          // Simple column / direction passed in\n          order = [[order, dir]]\n        } else if (!$.isArray(order[0])) {\n          // Arguments passed in (list of 1D arrays)\n          order = Array.prototype.slice.call(arguments)\n        }\n        // otherwise a 2D array was passed in\n\n        return this.iterator('table', function (settings) {\n          settings.aaSorting = order.slice()\n        })\n      })\n\n      /**\n       * Attach a sort listener to an element for a given column\n       *\n       * @param {node|jQuery|string} node Identifier for the element(s) to attach the\n       *   listener to. This can take the form of a single DOM node, a jQuery\n       *   collection of nodes or a jQuery selector which will identify the node(s).\n       * @param {integer} column the column that a click on this node will sort on\n       * @param {function} [callback] callback function when sort is run\n       * @returns {DataTables.Api} this\n       */\n      _api_register('order.listener()', function (node, column, callback) {\n        return this.iterator('table', function (settings) {\n          _fnSortAttachListener(settings, node, column, callback)\n        })\n      })\n\n      // Order by the selected column(s)\n      _api_register(['columns().order()', 'column().order()'], function (dir) {\n        var that = this\n\n        return this.iterator('table', function (settings, i) {\n          var sort = []\n\n          $.each(that[i], function (j, col) {\n            sort.push([col, dir])\n          })\n\n          settings.aaSorting = sort\n        })\n      })\n\n      _api_register('search()', function (input, regex, smart, caseInsen) {\n        var ctx = this.context\n\n        if (input === undefined) {\n          // get\n          return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined\n        }\n\n        // set\n        return this.iterator('table', function (settings) {\n          if (!settings.oFeatures.bFilter) {\n            return\n          }\n\n          _fnFilterComplete(\n            settings,\n            $.extend({}, settings.oPreviousSearch, {\n              sSearch: input + '',\n              bRegex: regex === null ? false : regex,\n              bSmart: smart === null ? true : smart,\n              bCaseInsensitive: caseInsen === null ? true : caseInsen\n            }),\n            1\n          )\n        })\n      })\n\n      _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {\n        return this.iterator('column', function (settings, column) {\n          var preSearch = settings.aoPreSearchCols\n\n          if (input === undefined) {\n            // get\n            return preSearch[column].sSearch\n          }\n\n          // set\n          if (!settings.oFeatures.bFilter) {\n            return\n          }\n\n          $.extend(preSearch[column], {\n            sSearch: input + '',\n            bRegex: regex === null ? false : regex,\n            bSmart: smart === null ? true : smart,\n            bCaseInsensitive: caseInsen === null ? true : caseInsen\n          })\n\n          _fnFilterComplete(settings, settings.oPreviousSearch, 1)\n        })\n      })\n\n      /*\n       * State API methods\n       */\n\n      _api_register('state()', function () {\n        return this.context.length ? this.context[0].oSavedState : null\n      })\n\n      _api_register('state.clear()', function () {\n        return this.iterator('table', function (settings) {\n          // Save an empty object\n          settings.fnStateSaveCallback.call(settings.oInstance, settings, {})\n        })\n      })\n\n      _api_register('state.loaded()', function () {\n        return this.context.length ? this.context[0].oLoadedState : null\n      })\n\n      _api_register('state.save()', function () {\n        return this.iterator('table', function (settings) {\n          _fnSaveState(settings)\n        })\n      })\n\n      /**\n       * Provide a common method for plug-ins to check the version of DataTables being\n       * used, in order to ensure compatibility.\n       *\n       *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\n       *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\n       *  @returns {boolean} true if this version of DataTables is greater or equal to\n       *    the required version, or false if this version of DataTales is not\n       *    suitable\n       *  @static\n       *  @dtopt API-Static\n       *\n       *  @example\n       *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\n       */\n      DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {\n        var aThis = DataTable.version.split('.')\n        var aThat = version.split('.')\n        var iThis, iThat\n\n        for (var i = 0, iLen = aThat.length; i < iLen; i++) {\n          iThis = parseInt(aThis[i], 10) || 0\n          iThat = parseInt(aThat[i], 10) || 0\n\n          // Parts are the same, keep comparing\n          if (iThis === iThat) {\n            continue\n          }\n\n          // Parts are different, return immediately\n          return iThis > iThat\n        }\n\n        return true\n      }\n\n      /**\n       * Check if a `<table>` node is a DataTable table already or not.\n       *\n       *  @param {node|jquery|string} table Table node, jQuery object or jQuery\n       *      selector for the table to test. Note that if more than more than one\n       *      table is passed on, only the first will be checked\n       *  @returns {boolean} true the table given is a DataTable, or false otherwise\n       *  @static\n       *  @dtopt API-Static\n       *\n       *  @example\n       *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\n       *      $('#example').dataTable();\n       *    }\n       */\n      DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {\n        var t = $(table).get(0)\n        var is = false\n\n        $.each(DataTable.settings, function (i, o) {\n          if (o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t) {\n            is = true\n          }\n        })\n\n        return is\n      }\n\n      /**\n       * Get all DataTable tables that have been initialised - optionally you can\n       * select to get only currently visible tables.\n       *\n       *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\n       *    or visible tables only.\n       *  @returns {array} Array of `table` nodes (not DataTable instances) which are\n       *    DataTables\n       *  @static\n       *  @dtopt API-Static\n       *\n       *  @example\n       *    $.each( $.fn.dataTable.tables(true), function () {\n       *      $(table).DataTable().columns.adjust();\n       *    } );\n       */\n      DataTable.tables = DataTable.fnTables = function (visible) {\n        return jQuery.map(DataTable.settings, function (o) {\n          if (!visible || (visible && $(o.nTable).is(':visible'))) {\n            return o.nTable\n          }\n        })\n      }\n\n      /**\n       * Convert from camel case parameters to Hungarian notation. This is made public\n       * for the extensions to provide the same ability as DataTables core to accept\n       * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\n       * parameters.\n       *\n       *  @param {object} src The model object which holds all parameters that can be\n       *    mapped.\n       *  @param {object} user The object to convert from camel case to Hungarian.\n       *  @param {boolean} force When set to `true`, properties which already have a\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\n       *    won't be.\n       */\n      DataTable.camelToHungarian = _fnCamelToHungarian\n\n      /**\n       *\n       */\n      _api_register('$()', function (selector, opts) {\n        var rows = this.rows(opts).nodes(), // Get all rows\n          jqRows = $(rows)\n\n        return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()))\n      })\n\n      // jQuery functions to operate on the tables\n      $.each(['on', 'one', 'off'], function (i, key) {\n        _api_register(key + '()', function (/* event, handler */) {\n          var args = Array.prototype.slice.call(arguments)\n\n          // Add the `dt` namespace automatically if it isn't already present\n          if (!args[0].match(/\\.dt\\b/)) {\n            args[0] += '.dt'\n          }\n\n          var inst = $(this.tables().nodes())\n          inst[key].apply(inst, args)\n          return this\n        })\n      })\n\n      _api_register('clear()', function () {\n        return this.iterator('table', function (settings) {\n          _fnClearTable(settings)\n        })\n      })\n\n      _api_register('settings()', function () {\n        return new _Api(this.context, this.context)\n      })\n\n      _api_register('data()', function () {\n        return this.iterator('table', function (settings) {\n          return _pluck(settings.aoData, '_aData')\n        }).flatten()\n      })\n\n      _api_register('destroy()', function (remove) {\n        remove = remove || false\n\n        return this.iterator('table', function (settings) {\n          var orig = settings.nTableWrapper.parentNode\n          var classes = settings.oClasses\n          var table = settings.nTable\n          var tbody = settings.nTBody\n          var thead = settings.nTHead\n          var tfoot = settings.nTFoot\n          var jqTable = $(table)\n          var jqTbody = $(tbody)\n          var jqWrapper = $(settings.nTableWrapper)\n          var rows = $.map(settings.aoData, function (r) {\n            return r.nTr\n          })\n          var i, ien\n\n          // Flag to note that the table is currently being destroyed - no action\n          // should be taken\n          settings.bDestroying = true\n\n          // Fire off the destroy callbacks for plug-ins etc\n          _fnCallbackFire(settings, 'aoDestroyCallback', 'destroy', [settings])\n\n          // If not being removed from the document, make all columns visible\n          if (!remove) {\n            new _Api(settings).columns().visible(true)\n          }\n\n          // Blitz all `DT` namespaced events (these are internal events, the\n          // lowercase, `dt` events are user subscribed and they are responsible\n          // for removing them\n          jqWrapper\n            .unbind('.DT')\n            .find(':not(tbody *)')\n            .unbind('.DT')\n          $(window).unbind('.DT-' + settings.sInstance)\n\n          // When scrolling we had to break the table up - restore it\n          if (table != thead.parentNode) {\n            jqTable.children('thead').detach()\n            jqTable.append(thead)\n          }\n\n          if (tfoot && table != tfoot.parentNode) {\n            jqTable.children('tfoot').detach()\n            jqTable.append(tfoot)\n          }\n\n          // Remove the DataTables generated nodes, events and classes\n          jqTable.detach()\n          jqWrapper.detach()\n\n          settings.aaSorting = []\n          settings.aaSortingFixed = []\n          _fnSortingClasses(settings)\n\n          $(rows).removeClass(settings.asStripeClasses.join(' '))\n\n          $('th, td', thead).removeClass(\n            classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone\n          )\n\n          if (settings.bJUI) {\n            $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach()\n            $('th, td', thead).each(function () {\n              var wrapper = $('div.' + classes.sSortJUIWrapper, this)\n              $(this).append(wrapper.contents())\n              wrapper.detach()\n            })\n          }\n\n          if (!remove && orig) {\n            // insertBefore acts like appendChild if !arg[1]\n            orig.insertBefore(table, settings.nTableReinsertBefore)\n          }\n\n          // Add the TR elements back into the table in their original order\n          jqTbody.children().detach()\n          jqTbody.append(rows)\n\n          // Restore the width of the original table - was read from the style property,\n          // so we can restore directly to that\n          jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable)\n\n          // If the were originally stripe classes - then we add them back here.\n          // Note this is not fool proof (for example if not all rows had stripe\n          // classes - but it's a good effort without getting carried away\n          ien = settings.asDestroyStripes.length\n\n          if (ien) {\n            jqTbody.children().each(function (i) {\n              $(this).addClass(settings.asDestroyStripes[i % ien])\n            })\n          }\n\n          /* Remove the settings object from the settings array */\n          var idx = $.inArray(settings, DataTable.settings)\n          if (idx !== -1) {\n            DataTable.settings.splice(idx, 1)\n          }\n        })\n      })\n\n      /**\n       * Version string for plug-ins to check compatibility. Allowed format is\n       * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\n       * only for non-release builds. See http://semver.org/ for more information.\n       *  @member\n       *  @type string\n       *  @default Version number\n       */\n      DataTable.version = '1.10.2'\n\n      /**\n       * Private data store, containing all of the settings objects that are\n       * created for the tables on a given page.\n       *\n       * Note that the `DataTable.settings` object is aliased to\n       * `jQuery.fn.dataTableExt` through which it may be accessed and\n       * manipulated, or `jQuery.fn.dataTable.settings`.\n       *  @member\n       *  @type array\n       *  @default []\n       *  @private\n       */\n      DataTable.settings = []\n\n      /**\n       * Object models container, for the various models that DataTables has\n       * available to it. These models define the objects that are used to hold\n       * the active state and configuration of the table.\n       *  @namespace\n       */\n      DataTable.models = {}\n\n      /**\n       * Template object for the way in which DataTables holds information about\n       * search information for the global filter and individual column filters.\n       *  @namespace\n       */\n      DataTable.models.oSearch = {\n        /**\n         * Flag to indicate if the filtering should be case insensitive or not\n         *  @type boolean\n         *  @default true\n         */\n        bCaseInsensitive: true,\n\n        /**\n         * Applied search term\n         *  @type string\n         *  @default <i>Empty string</i>\n         */\n        sSearch: '',\n\n        /**\n         * Flag to indicate if the search term should be interpreted as a\n         * regular expression (true) or not (false) and therefore and special\n         * regex characters escaped.\n         *  @type boolean\n         *  @default false\n         */\n        bRegex: false,\n\n        /**\n         * Flag to indicate if DataTables is to use its smart filtering or not.\n         *  @type boolean\n         *  @default true\n         */\n        bSmart: true\n      }\n\n      /**\n       * Template object for the way in which DataTables holds information about\n       * each individual row. This is the object format used for the settings\n       * aoData array.\n       *  @namespace\n       */\n      DataTable.models.oRow = {\n        /**\n         * TR element for the row\n         *  @type node\n         *  @default null\n         */\n        nTr: null,\n\n        /**\n         * Array of TD elements for each row. This is null until the row has been\n         * created.\n         *  @type array nodes\n         *  @default []\n         */\n        anCells: null,\n\n        /**\n         * Data object from the original data source for the row. This is either\n         * an array if using the traditional form of DataTables, or an object if\n         * using mData options. The exact type will depend on the passed in\n         * data from the data source, or will be an array if using DOM a data\n         * source.\n         *  @type array|object\n         *  @default []\n         */\n        _aData: [],\n\n        /**\n         * Sorting data cache - this array is ostensibly the same length as the\n         * number of columns (although each index is generated only as it is\n         * needed), and holds the data that is used for sorting each column in the\n         * row. We do this cache generation at the start of the sort in order that\n         * the formatting of the sort data need be done only once for each cell\n         * per sort. This array should not be read from or written to by anything\n         * other than the master sorting methods.\n         *  @type array\n         *  @default null\n         *  @private\n         */\n        _aSortData: null,\n\n        /**\n         * Per cell filtering data cache. As per the sort data cache, used to\n         * increase the performance of the filtering in DataTables\n         *  @type array\n         *  @default null\n         *  @private\n         */\n        _aFilterData: null,\n\n        /**\n         * Filtering data cache. This is the same as the cell filtering cache, but\n         * in this case a string rather than an array. This is easily computed with\n         * a join on `_aFilterData`, but is provided as a cache so the join isn't\n         * needed on every search (memory traded for performance)\n         *  @type array\n         *  @default null\n         *  @private\n         */\n        _sFilterRow: null,\n\n        /**\n         * Cache of the class name that DataTables has applied to the row, so we\n         * can quickly look at this variable rather than needing to do a DOM check\n         * on className for the nTr property.\n         *  @type string\n         *  @default <i>Empty string</i>\n         *  @private\n         */\n        _sRowStripe: '',\n\n        /**\n         * Denote if the original data source was from the DOM, or the data source\n         * object. This is used for invalidating data, so DataTables can\n         * automatically read data from the original source, unless uninstructed\n         * otherwise.\n         *  @type string\n         *  @default null\n         *  @private\n         */\n        src: null\n      }\n\n      /**\n       * Template object for the column information object in DataTables. This object\n       * is held in the settings aoColumns array and contains all the information that\n       * DataTables needs about each individual column.\n       *\n       * Note that this object is related to {@link DataTable.defaults.column}\n       * but this one is the internal data store for DataTables's cache of columns.\n       * It should NOT be manipulated outside of DataTables. Any configuration should\n       * be done through the initialisation options.\n       *  @namespace\n       */\n      DataTable.models.oColumn = {\n        /**\n         * Column index. This could be worked out on-the-fly with $.inArray, but it\n         * is faster to just hold it as a variable\n         *  @type integer\n         *  @default null\n         */\n        idx: null,\n\n        /**\n         * A list of the columns that sorting should occur on when this column\n         * is sorted. That this property is an array allows multi-column sorting\n         * to be defined for a column (for example first name / last name columns\n         * would benefit from this). The values are integers pointing to the\n         * columns to be sorted on (typically it will be a single integer pointing\n         * at itself, but that doesn't need to be the case).\n         *  @type array\n         */\n        aDataSort: null,\n\n        /**\n         * Define the sorting directions that are applied to the column, in sequence\n         * as the column is repeatedly sorted upon - i.e. the first value is used\n         * as the sorting direction when the column if first sorted (clicked on).\n         * Sort it again (click again) and it will move on to the next index.\n         * Repeat until loop.\n         *  @type array\n         */\n        asSorting: null,\n\n        /**\n         * Flag to indicate if the column is searchable, and thus should be included\n         * in the filtering or not.\n         *  @type boolean\n         */\n        bSearchable: null,\n\n        /**\n         * Flag to indicate if the column is sortable or not.\n         *  @type boolean\n         */\n        bSortable: null,\n\n        /**\n         * Flag to indicate if the column is currently visible in the table or not\n         *  @type boolean\n         */\n        bVisible: null,\n\n        /**\n         * Store for manual type assignment using the `column.type` option. This\n         * is held in store so we can manipulate the column's `sType` property.\n         *  @type string\n         *  @default null\n         *  @private\n         */\n        _sManualType: null,\n\n        /**\n         * Flag to indicate if HTML5 data attributes should be used as the data\n         * source for filtering or sorting. True is either are.\n         *  @type boolean\n         *  @default false\n         *  @private\n         */\n        _bAttrSrc: false,\n\n        /**\n         * Developer definable function that is called whenever a cell is created (Ajax source,\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n         * allowing you to modify the DOM element (add background colour for example) when the\n         * element is available.\n         *  @type function\n         *  @param {element} nTd The TD node that has been created\n         *  @param {*} sData The Data for the cell\n         *  @param {array|object} oData The data for the whole row\n         *  @param {int} iRow The row index for the aoData data store\n         *  @default null\n         */\n        fnCreatedCell: null,\n\n        /**\n         * Function to get data from a cell in a column. You should <b>never</b>\n         * access data directly through _aData internally in DataTables - always use\n         * the method attached to this property. It allows mData to function as\n         * required. This function is automatically assigned by the column\n         * initialisation method\n         *  @type function\n         *  @param {array|object} oData The data array/object for the array\n         *    (i.e. aoData[]._aData)\n         *  @param {string} sSpecific The specific data type you want to get -\n         *    'display', 'type' 'filter' 'sort'\n         *  @returns {*} The data for the cell from the given row's data\n         *  @default null\n         */\n        fnGetData: null,\n\n        /**\n         * Function to set data for a cell in the column. You should <b>never</b>\n         * set the data directly to _aData internally in DataTables - always use\n         * this method. It allows mData to function as required. This function\n         * is automatically assigned by the column initialisation method\n         *  @type function\n         *  @param {array|object} oData The data array/object for the array\n         *    (i.e. aoData[]._aData)\n         *  @param {*} sValue Value to set\n         *  @default null\n         */\n        fnSetData: null,\n\n        /**\n         * Property to read the value for the cells in the column from the data\n         * source array / object. If null, then the default content is used, if a\n         * function is given then the return from the function is used.\n         *  @type function|int|string|null\n         *  @default null\n         */\n        mData: null,\n\n        /**\n         * Partner property to mData which is used (only when defined) to get\n         * the data - i.e. it is basically the same as mData, but without the\n         * 'set' option, and also the data fed to it is the result from mData.\n         * This is the rendering method to match the data method of mData.\n         *  @type function|int|string|null\n         *  @default null\n         */\n        mRender: null,\n\n        /**\n         * Unique header TH/TD element for this column - this is what the sorting\n         * listener is attached to (if sorting is enabled.)\n         *  @type node\n         *  @default null\n         */\n        nTh: null,\n\n        /**\n         * Unique footer TH/TD element for this column (if there is one). Not used\n         * in DataTables as such, but can be used for plug-ins to reference the\n         * footer for each column.\n         *  @type node\n         *  @default null\n         */\n        nTf: null,\n\n        /**\n         * The class to apply to all TD elements in the table's TBODY for the column\n         *  @type string\n         *  @default null\n         */\n        sClass: null,\n\n        /**\n         * When DataTables calculates the column widths to assign to each column,\n         * it finds the longest string in each column and then constructs a\n         * temporary table and reads the widths from that. The problem with this\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n         * string - thus the calculation can go wrong (doing it properly and putting\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\n         * a \"work around\" we provide this option. It will append its value to the\n         * text that is found to be the longest string for the column - i.e. padding.\n         *  @type string\n         */\n        sContentPadding: null,\n\n        /**\n         * Allows a default value to be given for a column's data, and will be used\n         * whenever a null data source is encountered (this can be because mData\n         * is set to null, or because the data source itself is null).\n         *  @type string\n         *  @default null\n         */\n        sDefaultContent: null,\n\n        /**\n         * Name for the column, allowing reference to the column by name as well as\n         * by index (needs a lookup to work by name).\n         *  @type string\n         */\n        sName: null,\n\n        /**\n         * Custom sorting data type - defines which of the available plug-ins in\n         * afnSortData the custom sorting will use - if any is defined.\n         *  @type string\n         *  @default std\n         */\n        sSortDataType: 'std',\n\n        /**\n         * Class to be applied to the header element when sorting on this column\n         *  @type string\n         *  @default null\n         */\n        sSortingClass: null,\n\n        /**\n         * Class to be applied to the header element when sorting on this column -\n         * when jQuery UI theming is used.\n         *  @type string\n         *  @default null\n         */\n        sSortingClassJUI: null,\n\n        /**\n         * Title of the column - what is seen in the TH element (nTh).\n         *  @type string\n         */\n        sTitle: null,\n\n        /**\n         * Column sorting and filtering type\n         *  @type string\n         *  @default null\n         */\n        sType: null,\n\n        /**\n         * Width of the column\n         *  @type string\n         *  @default null\n         */\n        sWidth: null,\n\n        /**\n         * Width of the column when it was first \"encountered\"\n         *  @type string\n         *  @default null\n         */\n        sWidthOrig: null\n      }\n\n      /*\n       * Developer note: The properties of the object below are given in Hungarian\n       * notation, that was used as the interface for DataTables prior to v1.10, however\n       * from v1.10 onwards the primary interface is camel case. In order to avoid\n       * breaking backwards compatibility utterly with this change, the Hungarian\n       * version is still, internally the primary interface, but is is not documented\n       * - hence the @name tags in each doc comment. This allows a Javascript function\n       * to create a map from Hungarian notation to camel case (going the other direction\n       * would require each property to be listed, which would at around 3K to the size\n       * of DataTables, while this method is about a 0.5K hit.\n       *\n       * Ultimately this does pave the way for Hungarian notation to be dropped\n       * completely, but that is a massive amount of work and will break current\n       * installs (therefore is on-hold until v2).\n       */\n\n      /**\n       * Initialisation options that can be given to DataTables at initialisation\n       * time.\n       *  @namespace\n       */\n      DataTable.defaults = {\n        /**\n         * An array of data to use for the table, passed in at initialisation which\n         * will be used in preference to any data which is already in the DOM. This is\n         * particularly useful for constructing tables purely in Javascript, for\n         * example with a custom Ajax call.\n         *  @type array\n         *  @default null\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.data\n         *\n         *  @example\n         *    // Using a 2D array data source\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"data\": [\n         *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\n         *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\n         *        ],\n         *        \"columns\": [\n         *          { \"title\": \"Engine\" },\n         *          { \"title\": \"Browser\" },\n         *          { \"title\": \"Platform\" },\n         *          { \"title\": \"Version\" },\n         *          { \"title\": \"Grade\" }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using an array of objects as a data source (`data`)\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"data\": [\n         *          {\n         *            \"engine\":   \"Trident\",\n         *            \"browser\":  \"Internet Explorer 4.0\",\n         *            \"platform\": \"Win 95+\",\n         *            \"version\":  4,\n         *            \"grade\":    \"X\"\n         *          },\n         *          {\n         *            \"engine\":   \"Trident\",\n         *            \"browser\":  \"Internet Explorer 5.0\",\n         *            \"platform\": \"Win 95+\",\n         *            \"version\":  5,\n         *            \"grade\":    \"C\"\n         *          }\n         *        ],\n         *        \"columns\": [\n         *          { \"title\": \"Engine\",   \"data\": \"engine\" },\n         *          { \"title\": \"Browser\",  \"data\": \"browser\" },\n         *          { \"title\": \"Platform\", \"data\": \"platform\" },\n         *          { \"title\": \"Version\",  \"data\": \"version\" },\n         *          { \"title\": \"Grade\",    \"data\": \"grade\" }\n         *        ]\n         *      } );\n         *    } );\n         */\n        aaData: null,\n\n        /**\n         * If ordering is enabled, then DataTables will perform a first pass sort on\n         * initialisation. You can define which column(s) the sort is performed\n         * upon, and the sorting direction, with this variable. The `sorting` array\n         * should contain an array for each column to be sorted initially containing\n         * the column's index and a direction string ('asc' or 'desc').\n         *  @type array\n         *  @default [[0,'asc']]\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.order\n         *\n         *  @example\n         *    // Sort by 3rd column first, and then 4th column\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"order\": [[2,'asc'], [3,'desc']]\n         *      } );\n         *    } );\n         *\n         *    // No initial sorting\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"order\": []\n         *      } );\n         *    } );\n         */\n        aaSorting: [[0, 'asc']],\n\n        /**\n         * This parameter is basically identical to the `sorting` parameter, but\n         * cannot be overridden by user interaction with the table. What this means\n         * is that you could have a column (visible or hidden) which the sorting\n         * will always be forced on first - any sorting after that (from the user)\n         * will then be performed as required. This can be useful for grouping rows\n         * together.\n         *  @type array\n         *  @default null\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.orderFixed\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"orderFixed\": [[0,'asc']]\n         *      } );\n         *    } )\n         */\n        aaSortingFixed: [],\n\n        /**\n         * DataTables can be instructed to load data to display in the table from a\n         * Ajax source. This option defines how that Ajax call is made and where to.\n         *\n         * The `ajax` property has three different modes of operation, depending on\n         * how it is defined. These are:\n         *\n         * * `string` - Set the URL from where the data should be loaded from.\n         * * `object` - Define properties for `jQuery.ajax`.\n         * * `function` - Custom data get function\n         *\n         * `string`\n         * --------\n         *\n         * As a string, the `ajax` property simply defines the URL from which\n         * DataTables will load data.\n         *\n         * `object`\n         * --------\n         *\n         * As an object, the parameters in the object are passed to\n         * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\n         * of the Ajax request. DataTables has a number of default parameters which\n         * you can override using this option. Please refer to the jQuery\n         * documentation for a full description of the options available, although\n         * the following parameters provide additional options in DataTables or\n         * require special consideration:\n         *\n         * * `data` - As with jQuery, `data` can be provided as an object, but it\n         *   can also be used as a function to manipulate the data DataTables sends\n         *   to the server. The function takes a single parameter, an object of\n         *   parameters with the values that DataTables has readied for sending. An\n         *   object may be returned which will be merged into the DataTables\n         *   defaults, or you can add the items to the object that was passed in and\n         *   not return anything from the function. This supersedes `fnServerParams`\n         *   from DataTables 1.9-.\n         *\n         * * `dataSrc` - By default DataTables will look for the property `data` (or\n         *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\n         *   from an Ajax source or for server-side processing - this parameter\n         *   allows that property to be changed. You can use Javascript dotted\n         *   object notation to get a data source for multiple levels of nesting, or\n         *   it my be used as a function. As a function it takes a single parameter,\n         *   the JSON returned from the server, which can be manipulated as\n         *   required, with the returned value being that used by DataTables as the\n         *   data source for the table. This supersedes `sAjaxDataProp` from\n         *   DataTables 1.9-.\n         *\n         * * `success` - Should not be overridden it is used internally in\n         *   DataTables. To manipulate / transform the data returned by the server\n         *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\n         *\n         * `function`\n         * ----------\n         *\n         * As a function, making the Ajax call is left up to yourself allowing\n         * complete control of the Ajax request. Indeed, if desired, a method other\n         * than Ajax could be used to obtain the required data, such as Web storage\n         * or an AIR database.\n         *\n         * The function is given four parameters and no return is required. The\n         * parameters are:\n         *\n         * 1. _object_ - Data to send to the server\n         * 2. _function_ - Callback function that must be executed when the required\n         *    data has been obtained. That data should be passed into the callback\n         *    as the only parameter\n         * 3. _object_ - DataTables settings object for the table\n         *\n         * Note that this supersedes `fnServerData` from DataTables 1.9-.\n         *\n         *  @type string|object|function\n         *  @default null\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.ajax\n         *  @since 1.10.0\n         *\n         * @example\n         *   // Get JSON data from a file via Ajax.\n         *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\n         *   $('#example').dataTable( {\n         *     \"ajax\": \"data.json\"\n         *   } );\n         *\n         * @example\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to change\n         *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"dataSrc\": \"tableData\"\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\n         *   // from a plain array rather than an array in an object\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"dataSrc\": \"\"\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Manipulate the data returned from the server - add a link to data\n         *   // (note this can, should, be done using `render` for the column - this\n         *   // is just a simple example of how the data can be manipulated).\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"dataSrc\": function ( json ) {\n         *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\n         *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\n         *         }\n         *         return json;\n         *       }\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Add data to the request\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"data\": function ( d ) {\n         *         return {\n         *           \"extra_search\": $('#extra').val()\n         *         };\n         *       }\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Send request as POST\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"type\": \"POST\"\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Get the data from localStorage (could interface with a form for\n         *   // adding, editing and removing rows).\n         *   $('#example').dataTable( {\n         *     \"ajax\": function (data, callback, settings) {\n         *       callback(\n         *         JSON.parse( localStorage.getItem('dataTablesData') )\n         *       );\n         *     }\n         *   } );\n         */\n        ajax: null,\n\n        /**\n         * This parameter allows you to readily specify the entries in the length drop\n         * down menu that DataTables shows when pagination is enabled. It can be\n         * either a 1D array of options which will be used for both the displayed\n         * option and the value, or a 2D array which will use the array in the first\n         * position as the value, and the array in the second position as the\n         * displayed options (useful for language strings such as 'All').\n         *\n         * Note that the `pageLength` property will be automatically set to the\n         * first value given in this array, unless `pageLength` is also provided.\n         *  @type array\n         *  @default [ 10, 25, 50, 100 ]\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.lengthMenu\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\n         *      } );\n         *    } );\n         */\n        aLengthMenu: [10, 25, 50, 100],\n\n        /**\n         * The `columns` option in the initialisation parameter allows you to define\n         * details about the way individual columns behave. For a full list of\n         * column options that can be set, please see\n         * {@link DataTable.defaults.column}. Note that if you use `columns` to\n         * define your columns, you must have an entry in the array for every single\n         * column that you have in your table (these can be null if you don't which\n         * to specify any options).\n         *  @member\n         *\n         *  @name DataTable.defaults.column\n         */\n        aoColumns: null,\n\n        /**\n         * Very similar to `columns`, `columnDefs` allows you to target a specific\n         * column, multiple columns, or all columns, using the `targets` property of\n         * each object in the array. This allows great flexibility when creating\n         * tables, as the `columnDefs` arrays can be of any length, targeting the\n         * columns you specifically want. `columnDefs` may use any of the column\n         * options available: {@link DataTable.defaults.column}, but it _must_\n         * have `targets` defined in each object in the array. Values in the `targets`\n         * array may be:\n         *   <ul>\n         *     <li>a string - class name will be matched on the TH for the column</li>\n         *     <li>0 or a positive integer - column index counting from the left</li>\n         *     <li>a negative integer - column index counting from the right</li>\n         *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\n         *   </ul>\n         *  @member\n         *\n         *  @name DataTable.defaults.columnDefs\n         */\n        aoColumnDefs: null,\n\n        /**\n         * Basically the same as `search`, this parameter defines the individual column\n         * filtering state at initialisation time. The array must be of the same size\n         * as the number of columns, and each element be an object with the parameters\n         * `search` and `escapeRegex` (the latter is optional). 'null' is also\n         * accepted and the default will be used.\n         *  @type array\n         *  @default []\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.searchCols\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"searchCols\": [\n         *          null,\n         *          { \"search\": \"My filter\" },\n         *          null,\n         *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\n         *        ]\n         *      } );\n         *    } )\n         */\n        aoSearchCols: [],\n\n        /**\n         * An array of CSS classes that should be applied to displayed rows. This\n         * array may be of any length, and DataTables will apply each class\n         * sequentially, looping when required.\n         *  @type array\n         *  @default null <i>Will take the values determined by the `oClasses.stripe*`\n         *    options</i>\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.stripeClasses\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\n         *      } );\n         *    } )\n         */\n        asStripeClasses: null,\n\n        /**\n         * Enable or disable automatic column width calculation. This can be disabled\n         * as an optimisation (it takes some time to calculate the widths) if the\n         * tables widths are passed in using `columns`.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.autoWidth\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"autoWidth\": false\n         *      } );\n         *    } );\n         */\n        bAutoWidth: true,\n\n        /**\n         * Deferred rendering can provide DataTables with a huge speed boost when you\n         * are using an Ajax or JS data source for the table. This option, when set to\n         * true, will cause DataTables to defer the creation of the table elements for\n         * each row until they are needed for a draw - saving a significant amount of\n         * time.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.deferRender\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajax\": \"sources/arrays.txt\",\n         *        \"deferRender\": true\n         *      } );\n         *    } );\n         */\n        bDeferRender: false,\n\n        /**\n         * Replace a DataTable which matches the given selector and replace it with\n         * one which has the properties of the new initialisation object passed. If no\n         * table matches the selector, then the new DataTable will be constructed as\n         * per normal.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.destroy\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"srollY\": \"200px\",\n         *        \"paginate\": false\n         *      } );\n         *\n         *      // Some time later....\n         *      $('#example').dataTable( {\n         *        \"filter\": false,\n         *        \"destroy\": true\n         *      } );\n         *    } );\n         */\n        bDestroy: false,\n\n        /**\n         * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\n         * that it allows the end user to input multiple words (space separated) and\n         * will match a row containing those words, even if not in the order that was\n         * specified (this allow matching across multiple columns). Note that if you\n         * wish to use filtering in DataTables this must remain 'true' - to remove the\n         * default filtering input box and retain filtering abilities, please use\n         * {@link DataTable.defaults.dom}.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.searching\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"searching\": false\n         *      } );\n         *    } );\n         */\n        bFilter: true,\n\n        /**\n         * Enable or disable the table information display. This shows information\n         * about the data that is currently visible on the page, including information\n         * about filtered data if that action is being performed.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.info\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"info\": false\n         *      } );\n         *    } );\n         */\n        bInfo: true,\n\n        /**\n         * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some\n         * slightly different and additional mark-up from what DataTables has\n         * traditionally used).\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.jQueryUI\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"jQueryUI\": true\n         *      } );\n         *    } );\n         */\n        bJQueryUI: false,\n\n        /**\n         * Allows the end user to select the size of a formatted page from a select\n         * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.lengthChange\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"lengthChange\": false\n         *      } );\n         *    } );\n         */\n        bLengthChange: true,\n\n        /**\n         * Enable or disable pagination.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.paging\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"paging\": false\n         *      } );\n         *    } );\n         */\n        bPaginate: true,\n\n        /**\n         * Enable or disable the display of a 'processing' indicator when the table is\n         * being processed (e.g. a sort). This is particularly useful for tables with\n         * large amounts of data where it can take a noticeable amount of time to sort\n         * the entries.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.processing\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"processing\": true\n         *      } );\n         *    } );\n         */\n        bProcessing: false,\n\n        /**\n         * Retrieve the DataTables object for the given selector. Note that if the\n         * table has already been initialised, this parameter will cause DataTables\n         * to simply return the object that has already been set up - it will not take\n         * account of any changes you might have made to the initialisation object\n         * passed to DataTables (setting this parameter to true is an acknowledgement\n         * that you understand this). `destroy` can be used to reinitialise a table if\n         * you need.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.retrieve\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      initTable();\n         *      tableActions();\n         *    } );\n         *\n         *    function initTable ()\n         *    {\n         *      return $('#example').dataTable( {\n         *        \"scrollY\": \"200px\",\n         *        \"paginate\": false,\n         *        \"retrieve\": true\n         *      } );\n         *    }\n         *\n         *    function tableActions ()\n         *    {\n         *      var table = initTable();\n         *      // perform API operations with oTable\n         *    }\n         */\n        bRetrieve: false,\n\n        /**\n         * When vertical (y) scrolling is enabled, DataTables will force the height of\n         * the table's viewport to the given height at all times (useful for layout).\n         * However, this can look odd when filtering data down to a small data set,\n         * and the footer is left \"floating\" further down. This parameter (when\n         * enabled) will cause DataTables to collapse the table's viewport down when\n         * the result set will fit within the given Y height.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.scrollCollapse\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollY\": \"200\",\n         *        \"scrollCollapse\": true\n         *      } );\n         *    } );\n         */\n        bScrollCollapse: false,\n\n        /**\n         * Configure DataTables to use server-side processing. Note that the\n         * `ajax` parameter must also be given in order to give DataTables a\n         * source to obtain the required data for each draw.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverSide\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"serverSide\": true,\n         *        \"ajax\": \"xhr.php\"\n         *      } );\n         *    } );\n         */\n        bServerSide: false,\n\n        /**\n         * Enable or disable sorting of columns. Sorting of individual columns can be\n         * disabled by the `sortable` option for each column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.ordering\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"ordering\": false\n         *      } );\n         *    } );\n         */\n        bSort: true,\n\n        /**\n         * Enable or display DataTables' ability to sort multiple columns at the\n         * same time (activated by shift-click by the user).\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.orderMulti\n         *\n         *  @example\n         *    // Disable multiple column sorting ability\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"orderMulti\": false\n         *      } );\n         *    } );\n         */\n        bSortMulti: true,\n\n        /**\n         * Allows control over whether DataTables should use the top (true) unique\n         * cell that is found for a single column, or the bottom (false - default).\n         * This is useful when using complex headers.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.orderCellsTop\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"orderCellsTop\": true\n         *      } );\n         *    } );\n         */\n        bSortCellsTop: false,\n\n        /**\n         * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\n         * `sorting\\_3` to the columns which are currently being sorted on. This is\n         * presented as a feature switch as it can increase processing time (while\n         * classes are removed and added) so for large data sets you might want to\n         * turn this off.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.orderClasses\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"orderClasses\": false\n         *      } );\n         *    } );\n         */\n        bSortClasses: true,\n\n        /**\n         * Enable or disable state saving. When enabled HTML5 `localStorage` will be\n         * used to save table display information such as pagination information,\n         * display length, filtering and sorting. As such when the end user reloads\n         * the page the display display will match what thy had previously set up.\n         *\n         * Due to the use of `localStorage` the default state saving is not supported\n         * in IE6 or 7. If state saving is required in those browsers, use\n         * `stateSaveCallback` to provide a storage solution such as cookies.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.stateSave\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true\n         *      } );\n         *    } );\n         */\n        bStateSave: false,\n\n        /**\n         * This function is called when a TR element is created (and all TD child\n         * elements have been inserted), or registered if using a DOM source, allowing\n         * manipulation of the TR element (adding classes etc).\n         *  @type function\n         *  @param {node} row \"TR\" element for the current row\n         *  @param {array} data Raw data array for this row\n         *  @param {int} dataIndex The index of this row in the internal aoData array\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.createdRow\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"createdRow\": function( row, data, dataIndex ) {\n         *          // Bold the grade for all 'A' grade browsers\n         *          if ( data[4] == \"A\" )\n         *          {\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\n         *          }\n         *        }\n         *      } );\n         *    } );\n         */\n        fnCreatedRow: null,\n\n        /**\n         * This function is called on every 'draw' event, and allows you to\n         * dynamically modify any aspect you want about the created DOM.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.drawCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"drawCallback\": function( settings ) {\n         *          alert( 'DataTables has redrawn the table' );\n         *        }\n         *      } );\n         *    } );\n         */\n        fnDrawCallback: null,\n\n        /**\n         * Identical to fnHeaderCallback() but for the table footer this function\n         * allows you to modify the table footer on every 'draw' event.\n         *  @type function\n         *  @param {node} foot \"TR\" element for the footer\n         *  @param {array} data Full table data (as derived from the original HTML)\n         *  @param {int} start Index for the current display starting point in the\n         *    display array\n         *  @param {int} end Index for the current display ending point in the\n         *    display array\n         *  @param {array int} display Index array to translate the visual position\n         *    to the full data array\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.footerCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"footerCallback\": function( tfoot, data, start, end, display ) {\n         *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\n         *        }\n         *      } );\n         *    } )\n         */\n        fnFooterCallback: null,\n\n        /**\n         * When rendering large numbers in the information element for the table\n         * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\n         * to have a comma separator for the 'thousands' units (e.g. 1 million is\n         * rendered as \"1,000,000\") to help readability for the end user. This\n         * function will override the default method DataTables uses.\n         *  @type function\n         *  @member\n         *  @param {int} toFormat number to be formatted\n         *  @returns {string} formatted string for DataTables to show the number\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.formatNumber\n         *\n         *  @example\n         *    // Format a number using a single quote for the separator (note that\n         *    // this can also be done with the language.thousands option)\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"formatNumber\": function ( toFormat ) {\n         *          return toFormat.toString().replace(\n         *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\n         *          );\n         *        };\n         *      } );\n         *    } );\n         */\n        fnFormatNumber: function (toFormat) {\n          return toFormat.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.oLanguage.sThousands)\n        },\n\n        /**\n         * This function is called on every 'draw' event, and allows you to\n         * dynamically modify the header row. This can be used to calculate and\n         * display useful information about the table.\n         *  @type function\n         *  @param {node} head \"TR\" element for the header\n         *  @param {array} data Full table data (as derived from the original HTML)\n         *  @param {int} start Index for the current display starting point in the\n         *    display array\n         *  @param {int} end Index for the current display ending point in the\n         *    display array\n         *  @param {array int} display Index array to translate the visual position\n         *    to the full data array\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.headerCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"fheaderCallback\": function( head, data, start, end, display ) {\n         *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\n         *        }\n         *      } );\n         *    } )\n         */\n        fnHeaderCallback: null,\n\n        /**\n         * The information element can be used to convey information about the current\n         * state of the table. Although the internationalisation options presented by\n         * DataTables are quite capable of dealing with most customisations, there may\n         * be times where you wish to customise the string further. This callback\n         * allows you to do exactly that.\n         *  @type function\n         *  @param {object} oSettings DataTables settings object\n         *  @param {int} start Starting position in data for the draw\n         *  @param {int} end End position in data for the draw\n         *  @param {int} max Total number of rows in the table (regardless of\n         *    filtering)\n         *  @param {int} total Total number of rows in the data set, after filtering\n         *  @param {string} pre The string that DataTables has formatted using it's\n         *    own rules\n         *  @returns {string} The string to be displayed in the information element.\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.infoCallback\n         *\n         *  @example\n         *    $('#example').dataTable( {\n         *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\n         *        return start +\" to \"+ end;\n         *      }\n         *    } );\n         */\n        fnInfoCallback: null,\n\n        /**\n         * Called when the table has been initialised. Normally DataTables will\n         * initialise sequentially and there will be no need for this function,\n         * however, this does not hold true when using external language information\n         * since that is obtained using an async XHR call.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} json The JSON object request from the server - only\n         *    present if client-side Ajax sourced data is used\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.initComplete\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"initComplete\": function(settings, json) {\n         *          alert( 'DataTables has finished its initialisation.' );\n         *        }\n         *      } );\n         *    } )\n         */\n        fnInitComplete: null,\n\n        /**\n         * Called at the very start of each table draw and can be used to cancel the\n         * draw by returning false, any other return (including undefined) results in\n         * the full draw occurring).\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @returns {boolean} False will cancel the draw, anything else (including no\n         *    return) will allow it to complete.\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.preDrawCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"preDrawCallback\": function( settings ) {\n         *          if ( $('#test').val() == 1 ) {\n         *            return false;\n         *          }\n         *        }\n         *      } );\n         *    } );\n         */\n        fnPreDrawCallback: null,\n\n        /**\n         * This function allows you to 'post process' each row after it have been\n         * generated for each table draw, but before it is rendered on screen. This\n         * function might be used for setting the row class name etc.\n         *  @type function\n         *  @param {node} row \"TR\" element for the current row\n         *  @param {array} data Raw data array for this row\n         *  @param {int} displayIndex The display index for the current table draw\n         *  @param {int} displayIndexFull The index of the data in the full list of\n         *    rows (after filtering)\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.rowCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\n         *          // Bold the grade for all 'A' grade browsers\n         *          if ( data[4] == \"A\" ) {\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\n         *          }\n         *        }\n         *      } );\n         *    } );\n         */\n        fnRowCallback: null,\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * This parameter allows you to override the default function which obtains\n         * the data from the server so something more suitable for your application.\n         * For example you could use POST data, or pull information from a Gears or\n         * AIR database.\n         *  @type function\n         *  @member\n         *  @param {string} source HTTP source to obtain the data from (`ajax`)\n         *  @param {array} data A key/value pair object containing the data to send\n         *    to the server\n         *  @param {function} callback to be called on completion of the data get\n         *    process that will draw the data on the page.\n         *  @param {object} settings DataTables settings object\n         *\n         *  @dtopt Callbacks\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverData\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        fnServerData: null,\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         *  It is often useful to send extra data to the server when making an Ajax\n         * request - for example custom filtering information, and this callback\n         * function makes it trivial to send extra information to the server. The\n         * passed in parameter is the data set that has been constructed by\n         * DataTables, and you can add to this or modify it as you require.\n         *  @type function\n         *  @param {array} data Data array (array of objects which are name/value\n         *    pairs) that has been constructed by DataTables and will be sent to the\n         *    server. In the case of Ajax sourced data with server-side processing\n         *    this will be an empty array, for server-side processing there will be a\n         *    significant number of parameters!\n         *  @returns {undefined} Ensure that you modify the data array passed in,\n         *    as this is passed by reference.\n         *\n         *  @dtopt Callbacks\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverParams\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        fnServerParams: null,\n\n        /**\n         * Load the table state. With this function you can define from where, and how, the\n         * state of a table is loaded. By default DataTables will load from `localStorage`\n         * but you might wish to use a server-side database or cookies.\n         *  @type function\n         *  @member\n         *  @param {object} settings DataTables settings object\n         *  @return {object} The DataTables state object to be loaded\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateLoadCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoadCallback\": function (settings) {\n         *          var o;\n         *\n         *          // Send an Ajax request to the server to get the data. Note that\n         *          // this is a synchronous request.\n         *          $.ajax( {\n         *            \"url\": \"/state_load\",\n         *            \"async\": false,\n         *            \"dataType\": \"json\",\n         *            \"success\": function (json) {\n         *              o = json;\n         *            }\n         *          } );\n         *\n         *          return o;\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateLoadCallback: function (settings) {\n          try {\n            return JSON.parse(\n              (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\n                'DataTables_' + settings.sInstance + '_' + location.pathname\n              )\n            )\n          } catch (e) {}\n        },\n\n        /**\n         * Callback which allows modification of the saved state prior to loading that state.\n         * This callback is called when the table is loading state from the stored data, but\n         * prior to the settings object being modified by the saved state. Note that for\n         * plug-in authors, you should use the `stateLoadParams` event to load parameters for\n         * a plug-in.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object that is to be loaded\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateLoadParams\n         *\n         *  @example\n         *    // Remove a saved filter, so filtering is never loaded\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoadParams\": function (settings, data) {\n         *          data.oSearch.sSearch = \"\";\n         *        }\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Disallow state loading by returning false\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoadParams\": function (settings, data) {\n         *          return false;\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateLoadParams: null,\n\n        /**\n         * Callback that is called when the state has been loaded from the state saving method\n         * and the DataTables settings object has been modified as a result of the loaded state.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object that was loaded\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateLoaded\n         *\n         *  @example\n         *    // Show an alert with the filtering value that was saved\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoaded\": function (settings, data) {\n         *          alert( 'Saved filter was: '+data.oSearch.sSearch );\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateLoaded: null,\n\n        /**\n         * Save the table state. This function allows you to define where and how the state\n         * information for the table is stored By default DataTables will use `localStorage`\n         * but you might wish to use a server-side database or cookies.\n         *  @type function\n         *  @member\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object to be saved\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateSaveCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateSaveCallback\": function (settings, data) {\n         *          // Send an Ajax request to the server with the state object\n         *          $.ajax( {\n         *            \"url\": \"/state_save\",\n         *            \"data\": data,\n         *            \"dataType\": \"json\",\n         *            \"method\": \"POST\"\n         *            \"success\": function () {}\n         *          } );\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateSaveCallback: function (settings, data) {\n          try {\n            ;(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\n              'DataTables_' + settings.sInstance + '_' + location.pathname,\n              JSON.stringify(data)\n            )\n          } catch (e) {}\n        },\n\n        /**\n         * Callback which allows modification of the state to be saved. Called when the table\n         * has changed state a new state save is required. This method allows modification of\n         * the state saving object prior to actually doing the save, including addition or\n         * other state properties or modification. Note that for plug-in authors, you should\n         * use the `stateSaveParams` event to save parameters for a plug-in.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object to be saved\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateSaveParams\n         *\n         *  @example\n         *    // Remove a saved filter, so filtering is never saved\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateSaveParams\": function (settings, data) {\n         *          data.oSearch.sSearch = \"\";\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateSaveParams: null,\n\n        /**\n         * Duration for which the saved state information is considered valid. After this period\n         * has elapsed the state will be returned to the default.\n         * Value is given in seconds.\n         *  @type int\n         *  @default 7200 <i>(2 hours)</i>\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.stateDuration\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateDuration\": 60*60*24; // 1 day\n         *      } );\n         *    } )\n         */\n        iStateDuration: 7200,\n\n        /**\n         * When enabled DataTables will not make a request to the server for the first\n         * page draw - rather it will use the data already on the page (no sorting etc\n         * will be applied to it), thus saving on an XHR at load time. `deferLoading`\n         * is used to indicate that deferred loading is required, but it is also used\n         * to tell DataTables how many records there are in the full table (allowing\n         * the information element and pagination to be displayed correctly). In the case\n         * where a filtering is applied to the table on initial load, this can be\n         * indicated by giving the parameter as an array, where the first element is\n         * the number of records available after filtering and the second element is the\n         * number of records without filtering (allowing the table information element\n         * to be shown correctly).\n         *  @type int | array\n         *  @default null\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.deferLoading\n         *\n         *  @example\n         *    // 57 records available in the table, no filtering applied\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"serverSide\": true,\n         *        \"ajax\": \"scripts/server_processing.php\",\n         *        \"deferLoading\": 57\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // 57 records after filtering, 100 without filtering (an initial filter applied)\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"serverSide\": true,\n         *        \"ajax\": \"scripts/server_processing.php\",\n         *        \"deferLoading\": [ 57, 100 ],\n         *        \"search\": {\n         *          \"search\": \"my_filter\"\n         *        }\n         *      } );\n         *    } );\n         */\n        iDeferLoading: null,\n\n        /**\n         * Number of rows to display on a single page when using pagination. If\n         * feature enabled (`lengthChange`) then the end user will be able to override\n         * this to a custom setting using a pop-up menu.\n         *  @type int\n         *  @default 10\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.pageLength\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"pageLength\": 50\n         *      } );\n         *    } )\n         */\n        iDisplayLength: 10,\n\n        /**\n         * Define the starting point for data display when using DataTables with\n         * pagination. Note that this parameter is the number of records, rather than\n         * the page number, so if you have 10 records per page and want to start on\n         * the third page, it should be \"20\".\n         *  @type int\n         *  @default 0\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.displayStart\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"displayStart\": 20\n         *      } );\n         *    } )\n         */\n        iDisplayStart: 0,\n\n        /**\n         * By default DataTables allows keyboard navigation of the table (sorting, paging,\n         * and filtering) by adding a `tabindex` attribute to the required elements. This\n         * allows you to tab through the controls and press the enter key to activate them.\n         * The tabindex is default 0, meaning that the tab follows the flow of the document.\n         * You can overrule this using this parameter if you wish. Use a value of -1 to\n         * disable built-in keyboard navigation.\n         *  @type int\n         *  @default 0\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.tabIndex\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"tabIndex\": 1\n         *      } );\n         *    } );\n         */\n        iTabIndex: 0,\n\n        /**\n         * Classes that DataTables assigns to the various components and features\n         * that it adds to the HTML table. This allows classes to be configured\n         * during initialisation in addition to through the static\n         * {@link DataTable.ext.oStdClasses} object).\n         *  @namespace\n         *  @name DataTable.defaults.classes\n         */\n        oClasses: {},\n\n        /**\n         * All strings that DataTables uses in the user interface that it creates\n         * are defined in this object, allowing you to modified them individually or\n         * completely replace them all as required.\n         *  @namespace\n         *  @name DataTable.defaults.language\n         */\n        oLanguage: {\n          /**\n           * Strings that are used for WAI-ARIA labels and controls only (these are not\n           * actually visible on the page, but will be read by screenreaders, and thus\n           * must be internationalised as well).\n           *  @namespace\n           *  @name DataTable.defaults.language.aria\n           */\n          oAria: {\n            /**\n             * ARIA label that is added to the table headers when the column may be\n             * sorted ascending by activing the column (click or return when focused).\n             * Note that the column header is prefixed to this string.\n             *  @type string\n             *  @default : activate to sort column ascending\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.aria.sortAscending\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"aria\": {\n             *            \"sortAscending\": \" - click/return to sort ascending\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sSortAscending: ': activate to sort column ascending',\n\n            /**\n             * ARIA label that is added to the table headers when the column may be\n             * sorted descending by activing the column (click or return when focused).\n             * Note that the column header is prefixed to this string.\n             *  @type string\n             *  @default : activate to sort column ascending\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.aria.sortDescending\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"aria\": {\n             *            \"sortDescending\": \" - click/return to sort descending\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sSortDescending: ': activate to sort column descending'\n          },\n\n          /**\n           * Pagination string used by DataTables for the built-in pagination\n           * control types.\n           *  @namespace\n           *  @name DataTable.defaults.language.paginate\n           */\n          oPaginate: {\n            /**\n             * Text to use when using the 'full_numbers' type of pagination for the\n             * button to take the user to the first page.\n             *  @type string\n             *  @default First\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.first\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"first\": \"First page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sFirst: 'First',\n\n            /**\n             * Text to use when using the 'full_numbers' type of pagination for the\n             * button to take the user to the last page.\n             *  @type string\n             *  @default Last\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.last\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"last\": \"Last page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sLast: 'Last',\n\n            /**\n             * Text to use for the 'next' pagination button (to take the user to the\n             * next page).\n             *  @type string\n             *  @default Next\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.next\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"next\": \"Next page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sNext: 'Next',\n\n            /**\n             * Text to use for the 'previous' pagination button (to take the user to\n             * the previous page).\n             *  @type string\n             *  @default Previous\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.previous\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"previous\": \"Previous page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sPrevious: 'Previous'\n          },\n\n          /**\n           * This string is shown in preference to `zeroRecords` when the table is\n           * empty of data (regardless of filtering). Note that this is an optional\n           * parameter - if it is not given, the value of `zeroRecords` will be used\n           * instead (either the default or given value).\n           *  @type string\n           *  @default No data available in table\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.emptyTable\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"emptyTable\": \"No data available in table\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sEmptyTable: 'No data available in table',\n\n          /**\n           * This string gives information to the end user about the information\n           * that is current on display on the page. The following tokens can be\n           * used in the string and will be dynamically replaced as the table\n           * display updates. This tokens can be placed anywhere in the string, or\n           * removed as needed by the language requires:\n           *\n           * * `\\_START\\_` - Display index of the first record on the current page\n           * * `\\_END\\_` - Display index of the last record on the current page\n           * * `\\_TOTAL\\_` - Number of records in the table after filtering\n           * * `\\_MAX\\_` - Number of records in the table without filtering\n           * * `\\_PAGE\\_` - Current page number\n           * * `\\_PAGES\\_` - Total number of pages of data in the table\n           *\n           *  @type string\n           *  @default Showing _START_ to _END_ of _TOTAL_ entries\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.info\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfo: 'Showing _START_ to _END_ of _TOTAL_ entries',\n\n          /**\n           * Display information string for when the table is empty. Typically the\n           * format of this string should match `info`.\n           *  @type string\n           *  @default Showing 0 to 0 of 0 entries\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.infoEmpty\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"infoEmpty\": \"No entries to show\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfoEmpty: 'Showing 0 to 0 of 0 entries',\n\n          /**\n           * When a user filters the information in a table, this string is appended\n           * to the information (`info`) to give an idea of how strong the filtering\n           * is. The variable _MAX_ is dynamically updated.\n           *  @type string\n           *  @default (filtered from _MAX_ total entries)\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.infoFiltered\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"infoFiltered\": \" - filtering from _MAX_ records\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfoFiltered: '(filtered from _MAX_ total entries)',\n\n          /**\n           * If can be useful to append extra information to the info string at times,\n           * and this variable does exactly that. This information will be appended to\n           * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\n           * being used) at all times.\n           *  @type string\n           *  @default <i>Empty string</i>\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.infoPostFix\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"infoPostFix\": \"All records shown are derived from real information.\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfoPostFix: '',\n\n          /**\n           * This decimal place operator is a little different from the other\n           * language options since DataTables doesn't output floating point\n           * numbers, so it won't ever use this for display of a number. Rather,\n           * what this parameter does is modify the sort methods of the table so\n           * that numbers which are in a format which has a character other than\n           * a period (`.`) as a decimal place will be sorted numerically.\n           *\n           * Note that numbers with different decimal places cannot be shown in\n           * the same table and still be sortable, the table must be consistent.\n           * However, multiple different tables on the page can use different\n           * decimal place characters.\n           *  @type string\n           *  @default\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.decimal\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"decimal\": \",\"\n           *          \"thousands\": \".\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sDecimal: '',\n\n          /**\n           * DataTables has a build in number formatter (`formatNumber`) which is\n           * used to format large numbers that are used in the table information.\n           * By default a comma is used, but this can be trivially changed to any\n           * character you wish with this parameter.\n           *  @type string\n           *  @default ,\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.thousands\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"thousands\": \"'\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sThousands: ',',\n\n          /**\n           * Detail the action that will be taken when the drop down menu for the\n           * pagination length option is changed. The '_MENU_' variable is replaced\n           * with a default select list of 10, 25, 50 and 100, and can be replaced\n           * with a custom select box if required.\n           *  @type string\n           *  @default Show _MENU_ entries\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.lengthMenu\n           *\n           *  @example\n           *    // Language change only\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"lengthMenu\": \"Display _MENU_ records\"\n           *        }\n           *      } );\n           *    } );\n           *\n           *  @example\n           *    // Language and options change\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"lengthMenu\": 'Display <select>'+\n           *            '<option value=\"10\">10</option>'+\n           *            '<option value=\"20\">20</option>'+\n           *            '<option value=\"30\">30</option>'+\n           *            '<option value=\"40\">40</option>'+\n           *            '<option value=\"50\">50</option>'+\n           *            '<option value=\"-1\">All</option>'+\n           *            '</select> records'\n           *        }\n           *      } );\n           *    } );\n           */\n          sLengthMenu: 'Show _MENU_ entries',\n\n          /**\n           * When using Ajax sourced data and during the first draw when DataTables is\n           * gathering the data, this message is shown in an empty row in the table to\n           * indicate to the end user the the data is being loaded. Note that this\n           * parameter is not used when loading data by server-side processing, just\n           * Ajax sourced data with client-side processing.\n           *  @type string\n           *  @default Loading...\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.loadingRecords\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"loadingRecords\": \"Please wait - loading...\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sLoadingRecords: 'Loading...',\n\n          /**\n           * Text which is displayed when the table is processing a user action\n           * (usually a sort command or similar).\n           *  @type string\n           *  @default Processing...\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.processing\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"processing\": \"DataTables is currently busy\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sProcessing: 'Processing...',\n\n          /**\n           * Details the actions that will be taken when the user types into the\n           * filtering input text box. The variable \"_INPUT_\", if used in the string,\n           * is replaced with the HTML text box for the filtering input allowing\n           * control over where it appears in the string. If \"_INPUT_\" is not given\n           * then the input box is appended to the string automatically.\n           *  @type string\n           *  @default Search:\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.search\n           *\n           *  @example\n           *    // Input text box will be appended at the end automatically\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"search\": \"Filter records:\"\n           *        }\n           *      } );\n           *    } );\n           *\n           *  @example\n           *    // Specify where the filter should appear\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"search\": \"Apply filter _INPUT_ to table\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sSearch: 'Search:',\n\n          /**\n           * Assign a `placeholder` attribute to the search `input` element\n           *  @type string\n           *  @default\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.searchPlaceholder\n           */\n          sSearchPlaceholder: '',\n\n          /**\n           * All of the language information can be stored in a file on the\n           * server-side, which DataTables will look up if this parameter is passed.\n           * It must store the URL of the language file, which is in a JSON format,\n           * and the object has the same properties as the oLanguage object in the\n           * initialiser object (i.e. the above parameters). Please refer to one of\n           * the example language files to see how this works in action.\n           *  @type string\n           *  @default <i>Empty string - i.e. disabled</i>\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.url\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sUrl: '',\n\n          /**\n           * Text shown inside the table records when the is no information to be\n           * displayed after filtering. `emptyTable` is shown when there is simply no\n           * information in the table at all (regardless of filtering).\n           *  @type string\n           *  @default No matching records found\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.zeroRecords\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"zeroRecords\": \"No records to display\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sZeroRecords: 'No matching records found'\n        },\n\n        /**\n         * This parameter allows you to have define the global filtering state at\n         * initialisation time. As an object the `search` parameter must be\n         * defined, but all other parameters are optional. When `regex` is true,\n         * the search string will be treated as a regular expression, when false\n         * (default) it will be treated as a straight string. When `smart`\n         * DataTables will use it's smart filtering methods (to word match at\n         * any point in the data), when false this will not be done.\n         *  @namespace\n         *  @extends DataTable.models.oSearch\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.search\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"search\": {\"search\": \"Initial search\"}\n         *      } );\n         *    } )\n         */\n        oSearch: $.extend({}, DataTable.models.oSearch),\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * By default DataTables will look for the property `data` (or `aaData` for\n         * compatibility with DataTables 1.9-) when obtaining data from an Ajax\n         * source or for server-side processing - this parameter allows that\n         * property to be changed. You can use Javascript dotted object notation to\n         * get a data source for multiple levels of nesting.\n         *  @type string\n         *  @default data\n         *\n         *  @dtopt Options\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.ajaxDataProp\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        sAjaxDataProp: 'data',\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * You can instruct DataTables to load data from an external\n         * source using this parameter (use aData if you want to pass data in you\n         * already have). Simply provide a url a JSON object can be obtained from.\n         *  @type string\n         *  @default null\n         *\n         *  @dtopt Options\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.ajaxSource\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        sAjaxSource: null,\n\n        /**\n         * This initialisation variable allows you to specify exactly where in the\n         * DOM you want DataTables to inject the various controls it adds to the page\n         * (for example you might want the pagination controls at the top of the\n         * table). DIV elements (with or without a custom class) can also be added to\n         * aid styling. The follow syntax is used:\n         *   <ul>\n         *     <li>The following options are allowed:\n         *       <ul>\n         *         <li>'l' - Length changing</li>\n         *         <li>'f' - Filtering input</li>\n         *         <li>'t' - The table!</li>\n         *         <li>'i' - Information</li>\n         *         <li>'p' - Pagination</li>\n         *         <li>'r' - pRocessing</li>\n         *       </ul>\n         *     </li>\n         *     <li>The following constants are allowed:\n         *       <ul>\n         *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\n         *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\n         *       </ul>\n         *     </li>\n         *     <li>The following syntax is expected:\n         *       <ul>\n         *         <li>'&lt;' and '&gt;' - div elements</li>\n         *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\n         *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\n         *       </ul>\n         *     </li>\n         *     <li>Examples:\n         *       <ul>\n         *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\n         *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\n         *       </ul>\n         *     </li>\n         *   </ul>\n         *  @type string\n         *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\n         *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.dom\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\n         *      } );\n         *    } );\n         */\n        sDom: 'lfrtip',\n\n        /**\n         * DataTables features four different built-in options for the buttons to\n         * display for pagination control:\n         *\n         * * `simple` - 'Previous' and 'Next' buttons only\n         * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\n         * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\n         * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus\n         *   page numbers\n         *\n         * Further methods can be added using {@link DataTable.ext.oPagination}.\n         *  @type string\n         *  @default simple_numbers\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.pagingType\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"pagingType\": \"full_numbers\"\n         *      } );\n         *    } )\n         */\n        sPaginationType: 'simple_numbers',\n\n        /**\n         * Enable horizontal scrolling. When a table is too wide to fit into a\n         * certain layout, or you have a large number of columns in the table, you\n         * can enable x-scrolling to show the table in a viewport, which can be\n         * scrolled. This property can be `true` which will allow the table to\n         * scroll horizontally when needed, or any CSS unit, or a number (in which\n         * case it will be treated as a pixel measurement). Setting as simply `true`\n         * is recommended.\n         *  @type boolean|string\n         *  @default <i>blank string - i.e. disabled</i>\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.scrollX\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollX\": true,\n         *        \"scrollCollapse\": true\n         *      } );\n         *    } );\n         */\n        sScrollX: '',\n\n        /**\n         * This property can be used to force a DataTable to use more width than it\n         * might otherwise do when x-scrolling is enabled. For example if you have a\n         * table which requires to be well spaced, this parameter is useful for\n         * \"over-sizing\" the table, and thus forcing scrolling. This property can by\n         * any CSS unit, or a number (in which case it will be treated as a pixel\n         * measurement).\n         *  @type string\n         *  @default <i>blank string - i.e. disabled</i>\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.scrollXInner\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollX\": \"100%\",\n         *        \"scrollXInner\": \"110%\"\n         *      } );\n         *    } );\n         */\n        sScrollXInner: '',\n\n        /**\n         * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\n         * to the given height, and enable scrolling for any data which overflows the\n         * current viewport. This can be used as an alternative to paging to display\n         * a lot of data in a small area (although paging and scrolling can both be\n         * enabled at the same time). This property can be any CSS unit, or a number\n         * (in which case it will be treated as a pixel measurement).\n         *  @type string\n         *  @default <i>blank string - i.e. disabled</i>\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.scrollY\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollY\": \"200px\",\n         *        \"paginate\": false\n         *      } );\n         *    } );\n         */\n        sScrollY: '',\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * Set the HTTP method that is used to make the Ajax call for server-side\n         * processing or Ajax sourced data.\n         *  @type string\n         *  @default GET\n         *\n         *  @dtopt Options\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverMethod\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        sServerMethod: 'GET',\n\n        /**\n         * DataTables makes use of renderers when displaying HTML elements for\n         * a table. These renderers can be added or modified by plug-ins to\n         * generate suitable mark-up for a site. For example the Bootstrap\n         * integration plug-in for DataTables uses a paging button renderer to\n         * display pagination buttons in the mark-up required by Bootstrap.\n         *\n         * For further information about the renderers available see\n         * DataTable.ext.renderer\n         *  @type string|object\n         *  @default null\n         *\n         *  @name DataTable.defaults.renderer\n         *\n         */\n        renderer: null\n      }\n\n      _fnHungarianMap(DataTable.defaults)\n\n      /*\n       * Developer note - See note in model.defaults.js about the use of Hungarian\n       * notation and camel case.\n       */\n\n      /**\n       * Column options that can be given to DataTables at initialisation time.\n       *  @namespace\n       */\n      DataTable.defaults.column = {\n        /**\n         * Define which column(s) an order will occur on for this column. This\n         * allows a column's ordering to take multiple columns into account when\n         * doing a sort or use the data from a different column. For example first\n         * name / last name columns make sense to do a multi-column sort over the\n         * two columns.\n         *  @type array|int\n         *  @default null <i>Takes the value of the column index automatically</i>\n         *\n         *  @name DataTable.defaults.column.orderData\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\n         *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\n         *          { \"orderData\": 2, \"targets\": [ 2 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"orderData\": [ 0, 1 ] },\n         *          { \"orderData\": [ 1, 0 ] },\n         *          { \"orderData\": 2 },\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        aDataSort: null,\n        iDataSort: -1,\n\n        /**\n         * You can control the default ordering direction, and even alter the\n         * behaviour of the sort handler (i.e. only allow ascending ordering etc)\n         * using this parameter.\n         *  @type array\n         *  @default [ 'asc', 'desc' ]\n         *\n         *  @name DataTable.defaults.column.orderSequence\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\n         *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          { \"orderSequence\": [ \"asc\" ] },\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\n         *          { \"orderSequence\": [ \"desc\" ] },\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        asSorting: ['asc', 'desc'],\n\n        /**\n         * Enable or disable filtering on the data in this column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @name DataTable.defaults.column.searchable\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"searchable\": false, \"targets\": [ 0 ] }\n         *        ] } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"searchable\": false },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ] } );\n         *    } );\n         */\n        bSearchable: true,\n\n        /**\n         * Enable or disable ordering on this column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @name DataTable.defaults.column.orderable\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderable\": false, \"targets\": [ 0 ] }\n         *        ] } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"orderable\": false },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ] } );\n         *    } );\n         */\n        bSortable: true,\n\n        /**\n         * Enable or disable the display of this column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @name DataTable.defaults.column.visible\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"visible\": false, \"targets\": [ 0 ] }\n         *        ] } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"visible\": false },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ] } );\n         *    } );\n         */\n        bVisible: true,\n\n        /**\n         * Developer definable function that is called whenever a cell is created (Ajax source,\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n         * allowing you to modify the DOM element (add background colour for example) when the\n         * element is available.\n         *  @type function\n         *  @param {element} td The TD node that has been created\n         *  @param {*} cellData The Data for the cell\n         *  @param {array|object} rowData The data for the whole row\n         *  @param {int} row The row index for the aoData data store\n         *  @param {int} col The column index for aoColumns\n         *\n         *  @name DataTable.defaults.column.createdCell\n         *  @dtopt Columns\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [3],\n         *          \"createdCell\": function (td, cellData, rowData, row, col) {\n         *            if ( cellData == \"1.7\" ) {\n         *              $(td).css('color', 'blue')\n         *            }\n         *          }\n         *        } ]\n         *      });\n         *    } );\n         */\n        fnCreatedCell: null,\n\n        /**\n         * This parameter has been replaced by `data` in DataTables to ensure naming\n         * consistency. `dataProp` can still be used, as there is backwards\n         * compatibility in DataTables for this option, but it is strongly\n         * recommended that you use `data` in preference to `dataProp`.\n         *  @name DataTable.defaults.column.dataProp\n         */\n\n        /**\n         * This property can be used to read data from any data source property,\n         * including deeply nested objects / properties. `data` can be given in a\n         * number of different ways which effect its behaviour:\n         *\n         * * `integer` - treated as an array index for the data source. This is the\n         *   default that DataTables uses (incrementally increased for each column).\n         * * `string` - read an object property from the data source. There are\n         *   three 'special' options that can be used in the string to alter how\n         *   DataTables reads the data from the source object:\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n         *      Javascript to read from nested objects, so to can the options\n         *      specified in `data`. For example: `browser.version` or\n         *      `browser.name`. If your object parameter name contains a period, use\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\n         *    * `[]` - Array notation. DataTables can automatically combine data\n         *      from and array source, joining the data with the characters provided\n         *      between the two brackets. For example: `name[, ]` would provide a\n         *      comma-space separated list from the source array. If no characters\n         *      are provided between the brackets, the original array source is\n         *      returned.\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\n         *      execute a function of the name given. For example: `browser()` for a\n         *      simple function on the data source, `browser.version()` for a\n         *      function in a nested property or even `browser().version` to get an\n         *      object property if the function called returns an object. Note that\n         *      function notation is recommended for use in `render` rather than\n         *      `data` as it is much simpler to use as a renderer.\n         * * `null` - use the original data source for the row rather than plucking\n         *   data directly from it. This action has effects on two other\n         *   initialisation options:\n         *    * `defaultContent` - When null is given as the `data` option and\n         *      `defaultContent` is specified for the column, the value defined by\n         *      `defaultContent` will be used for the cell.\n         *    * `render` - When null is used for the `data` option and the `render`\n         *      option is specified for the column, the whole data source for the\n         *      row is used for the renderer.\n         * * `function` - the function given will be executed whenever DataTables\n         *   needs to set or get the data for a cell in the column. The function\n         *   takes three parameters:\n         *    * Parameters:\n         *      * `{array|object}` The data source for the row\n         *      * `{string}` The type call data requested - this will be 'set' when\n         *        setting data or 'filter', 'display', 'type', 'sort' or undefined\n         *        when gathering data. Note that when `undefined` is given for the\n         *        type DataTables expects to get the raw data for the object back<\n         *      * `{*}` Data to set when the second parameter is 'set'.\n         *    * Return:\n         *      * The return value from the function is not required when 'set' is\n         *        the type of call, but otherwise the return is what will be used\n         *        for the data requested.\n         *\n         * Note that `data` is a getter and setter option. If you just require\n         * formatting of data for output, you will likely want to use `render` which\n         * is simply a getter and thus simpler to use.\n         *\n         * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\n         * name change reflects the flexibility of this property and is consistent\n         * with the naming of mRender. If 'mDataProp' is given, then it will still\n         * be used by DataTables, as it automatically maps the old name to the new\n         * if required.\n         *\n         *  @type string|int|function|null\n         *  @default null <i>Use automatically calculated column index</i>\n         *\n         *  @name DataTable.defaults.column.data\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Read table data from objects\n         *    // JSON structure for each row:\n         *    //   {\n         *    //      \"engine\": {value},\n         *    //      \"browser\": {value},\n         *    //      \"platform\": {value},\n         *    //      \"version\": {value},\n         *    //      \"grade\": {value}\n         *    //   }\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajaxSource\": \"sources/objects.txt\",\n         *        \"columns\": [\n         *          { \"data\": \"engine\" },\n         *          { \"data\": \"browser\" },\n         *          { \"data\": \"platform\" },\n         *          { \"data\": \"version\" },\n         *          { \"data\": \"grade\" }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Read information from deeply nested objects\n         *    // JSON structure for each row:\n         *    //   {\n         *    //      \"engine\": {value},\n         *    //      \"browser\": {value},\n         *    //      \"platform\": {\n         *    //         \"inner\": {value}\n         *    //      },\n         *    //      \"details\": [\n         *    //         {value}, {value}\n         *    //      ]\n         *    //   }\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajaxSource\": \"sources/deep.txt\",\n         *        \"columns\": [\n         *          { \"data\": \"engine\" },\n         *          { \"data\": \"browser\" },\n         *          { \"data\": \"platform.inner\" },\n         *          { \"data\": \"platform.details.0\" },\n         *          { \"data\": \"platform.details.1\" }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `data` as a function to provide different information for\n         *    // sorting, filtering and display. In this case, currency (price)\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": function ( source, type, val ) {\n         *            if (type === 'set') {\n         *              source.price = val;\n         *              // Store the computed dislay and filter values for efficiency\n         *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\n         *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\n         *              return;\n         *            }\n         *            else if (type === 'display') {\n         *              return source.price_display;\n         *            }\n         *            else if (type === 'filter') {\n         *              return source.price_filter;\n         *            }\n         *            // 'sort', 'type' and undefined all just use the integer\n         *            return source.price;\n         *          }\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using default content\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": null,\n         *          \"defaultContent\": \"Click to edit\"\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using array notation - outputting a list from an array\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": \"name[, ]\"\n         *        } ]\n         *      } );\n         *    } );\n         *\n         */\n        mData: null,\n\n        /**\n         * This property is the rendering partner to `data` and it is suggested that\n         * when you want to manipulate data for display (including filtering,\n         * sorting etc) without altering the underlying data for the table, use this\n         * property. `render` can be considered to be the the read only companion to\n         * `data` which is read / write (then as such more complex). Like `data`\n         * this option can be given in a number of different ways to effect its\n         * behaviour:\n         *\n         * * `integer` - treated as an array index for the data source. This is the\n         *   default that DataTables uses (incrementally increased for each column).\n         * * `string` - read an object property from the data source. There are\n         *   three 'special' options that can be used in the string to alter how\n         *   DataTables reads the data from the source object:\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n         *      Javascript to read from nested objects, so to can the options\n         *      specified in `data`. For example: `browser.version` or\n         *      `browser.name`. If your object parameter name contains a period, use\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\n         *    * `[]` - Array notation. DataTables can automatically combine data\n         *      from and array source, joining the data with the characters provided\n         *      between the two brackets. For example: `name[, ]` would provide a\n         *      comma-space separated list from the source array. If no characters\n         *      are provided between the brackets, the original array source is\n         *      returned.\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\n         *      execute a function of the name given. For example: `browser()` for a\n         *      simple function on the data source, `browser.version()` for a\n         *      function in a nested property or even `browser().version` to get an\n         *      object property if the function called returns an object.\n         * * `object` - use different data for the different data types requested by\n         *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\n         *   of the object is the data type the property refers to and the value can\n         *   defined using an integer, string or function using the same rules as\n         *   `render` normally does. Note that an `_` option _must_ be specified.\n         *   This is the default value to use if you haven't specified a value for\n         *   the data type requested by DataTables.\n         * * `function` - the function given will be executed whenever DataTables\n         *   needs to set or get the data for a cell in the column. The function\n         *   takes three parameters:\n         *    * Parameters:\n         *      * {array|object} The data source for the row (based on `data`)\n         *      * {string} The type call data requested - this will be 'filter',\n         *        'display', 'type' or 'sort'.\n         *      * {array|object} The full data source for the row (not based on\n         *        `data`)\n         *    * Return:\n         *      * The return value from the function is what will be used for the\n         *        data requested.\n         *\n         *  @type string|int|function|object|null\n         *  @default null Use the data source value.\n         *\n         *  @name DataTable.defaults.column.render\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Create a comma separated list from an array of objects\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajaxSource\": \"sources/deep.txt\",\n         *        \"columns\": [\n         *          { \"data\": \"engine\" },\n         *          { \"data\": \"browser\" },\n         *          {\n         *            \"data\": \"platform\",\n         *            \"render\": \"[, ].name\"\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Execute a function to obtain data\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": null, // Use the full data source object for the renderer's source\n         *          \"render\": \"browserName()\"\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // As an object, extracting different data for the different types\n         *    // This would be used with a data source such as:\n         *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\n         *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\n         *    // (which has both forms) is used for filtering for if a user inputs either format, while\n         *    // the formatted phone number is the one that is shown in the table.\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": null, // Use the full data source object for the renderer's source\n         *          \"render\": {\n         *            \"_\": \"phone\",\n         *            \"filter\": \"phone_filter\",\n         *            \"display\": \"phone_display\"\n         *          }\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Use as a function to create a link from the data source\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": \"download_link\",\n         *          \"render\": function ( data, type, full ) {\n         *            return '<a href=\"'+data+'\">Download</a>';\n         *          }\n         *        } ]\n         *      } );\n         *    } );\n         */\n        mRender: null,\n\n        /**\n         * Change the cell type created for the column - either TD cells or TH cells. This\n         * can be useful as TH cells have semantic meaning in the table body, allowing them\n         * to act as a header for a row (you may wish to add scope='row' to the TH elements).\n         *  @type string\n         *  @default td\n         *\n         *  @name DataTable.defaults.column.cellType\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Make the first column use TH cells\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"cellType\": \"th\"\n         *        } ]\n         *      } );\n         *    } );\n         */\n        sCellType: 'td',\n\n        /**\n         * Class to give to each cell in this column.\n         *  @type string\n         *  @default <i>Empty string</i>\n         *\n         *  @name DataTable.defaults.column.class\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"class\": \"my_class\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sClass: '',\n\n        /**\n         * When DataTables calculates the column widths to assign to each column,\n         * it finds the longest string in each column and then constructs a\n         * temporary table and reads the widths from that. The problem with this\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n         * string - thus the calculation can go wrong (doing it properly and putting\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\n         * a \"work around\" we provide this option. It will append its value to the\n         * text that is found to be the longest string for the column - i.e. padding.\n         * Generally you shouldn't need this!\n         *  @type string\n         *  @default <i>Empty string<i>\n         *\n         *  @name DataTable.defaults.column.contentPadding\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          null,\n         *          null,\n         *          {\n         *            \"contentPadding\": \"mmm\"\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sContentPadding: '',\n\n        /**\n         * Allows a default value to be given for a column's data, and will be used\n         * whenever a null data source is encountered (this can be because `data`\n         * is set to null, or because the data source itself is null).\n         *  @type string\n         *  @default null\n         *\n         *  @name DataTable.defaults.column.defaultContent\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          {\n         *            \"data\": null,\n         *            \"defaultContent\": \"Edit\",\n         *            \"targets\": [ -1 ]\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          null,\n         *          null,\n         *          {\n         *            \"data\": null,\n         *            \"defaultContent\": \"Edit\"\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sDefaultContent: null,\n\n        /**\n         * This parameter is only used in DataTables' server-side processing. It can\n         * be exceptionally useful to know what columns are being displayed on the\n         * client side, and to map these to database fields. When defined, the names\n         * also allow DataTables to reorder information from the server if it comes\n         * back in an unexpected order (i.e. if you switch your columns around on the\n         * client-side, your server-side code does not also need updating).\n         *  @type string\n         *  @default <i>Empty string</i>\n         *\n         *  @name DataTable.defaults.column.name\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"name\": \"engine\", \"targets\": [ 0 ] },\n         *          { \"name\": \"browser\", \"targets\": [ 1 ] },\n         *          { \"name\": \"platform\", \"targets\": [ 2 ] },\n         *          { \"name\": \"version\", \"targets\": [ 3 ] },\n         *          { \"name\": \"grade\", \"targets\": [ 4 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"name\": \"engine\" },\n         *          { \"name\": \"browser\" },\n         *          { \"name\": \"platform\" },\n         *          { \"name\": \"version\" },\n         *          { \"name\": \"grade\" }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sName: '',\n\n        /**\n         * Defines a data source type for the ordering which can be used to read\n         * real-time information from the table (updating the internally cached\n         * version) prior to ordering. This allows ordering to occur on user\n         * editable elements such as form inputs.\n         *  @type string\n         *  @default std\n         *\n         *  @name DataTable.defaults.column.orderDataType\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\n         *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\n         *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\n         *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          null,\n         *          { \"orderDataType\": \"dom-text\" },\n         *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\n         *          { \"orderDataType\": \"dom-select\" },\n         *          { \"orderDataType\": \"dom-checkbox\" }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sSortDataType: 'std',\n\n        /**\n         * The title of this column.\n         *  @type string\n         *  @default null <i>Derived from the 'TH' value for this column in the\n         *    original HTML table.</i>\n         *\n         *  @name DataTable.defaults.column.title\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"title\": \"My column title\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sTitle: null,\n\n        /**\n         * The type allows you to specify how the data for this column will be\n         * ordered. Four types (string, numeric, date and html (which will strip\n         * HTML tags before ordering)) are currently available. Note that only date\n         * formats understood by Javascript's Date() object will be accepted as type\n         * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\n         * 'numeric', 'date' or 'html' (by default). Further types can be adding\n         * through plug-ins.\n         *  @type string\n         *  @default null <i>Auto-detected from raw data</i>\n         *\n         *  @name DataTable.defaults.column.type\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"type\": \"html\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"type\": \"html\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sType: null,\n\n        /**\n         * Defining the width of the column, this parameter may take any CSS value\n         * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\n         * been given a specific width through this interface ensuring that the table\n         * remains readable.\n         *  @type string\n         *  @default null <i>Automatic</i>\n         *\n         *  @name DataTable.defaults.column.width\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"width\": \"20%\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"width\": \"20%\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sWidth: null\n      }\n\n      _fnHungarianMap(DataTable.defaults.column)\n\n      /**\n       * DataTables settings object - this holds all the information needed for a\n       * given table, including configuration, data and current application of the\n       * table options. DataTables does not have a single instance for each DataTable\n       * with the settings attached to that instance, but rather instances of the\n       * DataTable \"class\" are created on-the-fly as needed (typically by a\n       * $().dataTable() call) and the settings object is then applied to that\n       * instance.\n       *\n       * Note that this object is related to {@link DataTable.defaults} but this\n       * one is the internal data store for DataTables's cache of columns. It should\n       * NOT be manipulated outside of DataTables. Any configuration should be done\n       * through the initialisation options.\n       *  @namespace\n       *  @todo Really should attach the settings object to individual instances so we\n       *    don't need to create new instances on each $().dataTable() call (if the\n       *    table already exists). It would also save passing oSettings around and\n       *    into every single function. However, this is a very significant\n       *    architecture change for DataTables and will almost certainly break\n       *    backwards compatibility with older installations. This is something that\n       *    will be done in 2.0.\n       */\n      DataTable.models.oSettings = {\n        /**\n         * Primary features of DataTables and their enablement state.\n         *  @namespace\n         */\n        oFeatures: {\n          /**\n           * Flag to say if DataTables should automatically try to calculate the\n           * optimum table and columns widths (true) or not (false).\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bAutoWidth: null,\n\n          /**\n           * Delay the creation of TR and TD elements until they are actually\n           * needed by a driven page draw. This can give a significant speed\n           * increase for Ajax source and Javascript source data, but makes no\n           * difference at all fro DOM and server-side processing tables.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bDeferRender: null,\n\n          /**\n           * Enable filtering on the table or not. Note that if this is disabled\n           * then there is no filtering at all on the table, including fnFilter.\n           * To just remove the filtering input use sDom and remove the 'f' option.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bFilter: null,\n\n          /**\n           * Table information element (the 'Showing x of y records' div) enable\n           * flag.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bInfo: null,\n\n          /**\n           * Present a user control allowing the end user to change the page size\n           * when pagination is enabled.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bLengthChange: null,\n\n          /**\n           * Pagination enabled or not. Note that if this is disabled then length\n           * changing must also be disabled.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bPaginate: null,\n\n          /**\n           * Processing indicator enable flag whenever DataTables is enacting a\n           * user request - typically an Ajax request for server-side processing.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bProcessing: null,\n\n          /**\n           * Server-side processing enabled flag - when enabled DataTables will\n           * get all data from the server for every draw - there is no filtering,\n           * sorting or paging done on the client-side.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bServerSide: null,\n\n          /**\n           * Sorting enablement flag.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bSort: null,\n\n          /**\n           * Multi-column sorting\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bSortMulti: null,\n\n          /**\n           * Apply a class to the columns which are being sorted to provide a\n           * visual highlight or not. This can slow things down when enabled since\n           * there is a lot of DOM interaction.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bSortClasses: null,\n\n          /**\n           * State saving enablement flag.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bStateSave: null\n        },\n\n        /**\n         * Scrolling settings for a table.\n         *  @namespace\n         */\n        oScroll: {\n          /**\n           * When the table is shorter in height than sScrollY, collapse the\n           * table container down to the height of the table (when true).\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bCollapse: null,\n\n          /**\n           * Width of the scrollbar for the web-browser's platform. Calculated\n           * during table initialisation.\n           *  @type int\n           *  @default 0\n           */\n          iBarWidth: 0,\n\n          /**\n           * Viewport width for horizontal scrolling. Horizontal scrolling is\n           * disabled if an empty string.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type string\n           */\n          sX: null,\n\n          /**\n           * Width to expand the table to when using x-scrolling. Typically you\n           * should not need to use this.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type string\n           *  @deprecated\n           */\n          sXInner: null,\n\n          /**\n           * Viewport height for vertical scrolling. Vertical scrolling is disabled\n           * if an empty string.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type string\n           */\n          sY: null\n        },\n\n        /**\n         * Language information for the table.\n         *  @namespace\n         *  @extends DataTable.defaults.oLanguage\n         */\n        oLanguage: {\n          /**\n           * Information callback function. See\n           * {@link DataTable.defaults.fnInfoCallback}\n           *  @type function\n           *  @default null\n           */\n          fnInfoCallback: null\n        },\n\n        /**\n         * Browser support parameters\n         *  @namespace\n         */\n        oBrowser: {\n          /**\n           * Indicate if the browser incorrectly calculates width:100% inside a\n           * scrolling element (IE6/7)\n           *  @type boolean\n           *  @default false\n           */\n          bScrollOversize: false,\n\n          /**\n           * Determine if the vertical scrollbar is on the right or left of the\n           * scrolling container - needed for rtl language layout, although not\n           * all browsers move the scrollbar (Safari).\n           *  @type boolean\n           *  @default false\n           */\n          bScrollbarLeft: false\n        },\n\n        ajax: null,\n\n        /**\n         * Array referencing the nodes which are used for the features. The\n         * parameters of this object match what is allowed by sDom - i.e.\n         *   <ul>\n         *     <li>'l' - Length changing</li>\n         *     <li>'f' - Filtering input</li>\n         *     <li>'t' - The table!</li>\n         *     <li>'i' - Information</li>\n         *     <li>'p' - Pagination</li>\n         *     <li>'r' - pRocessing</li>\n         *   </ul>\n         *  @type array\n         *  @default []\n         */\n        aanFeatures: [],\n\n        /**\n         * Store data information - see {@link DataTable.models.oRow} for detailed\n         * information.\n         *  @type array\n         *  @default []\n         */\n        aoData: [],\n\n        /**\n         * Array of indexes which are in the current display (after filtering etc)\n         *  @type array\n         *  @default []\n         */\n        aiDisplay: [],\n\n        /**\n         * Array of indexes for display - no filtering\n         *  @type array\n         *  @default []\n         */\n        aiDisplayMaster: [],\n\n        /**\n         * Store information about each column that is in use\n         *  @type array\n         *  @default []\n         */\n        aoColumns: [],\n\n        /**\n         * Store information about the table's header\n         *  @type array\n         *  @default []\n         */\n        aoHeader: [],\n\n        /**\n         * Store information about the table's footer\n         *  @type array\n         *  @default []\n         */\n        aoFooter: [],\n\n        /**\n         * Store the applied global search information in case we want to force a\n         * research or compare the old search to a new one.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @namespace\n         *  @extends DataTable.models.oSearch\n         */\n        oPreviousSearch: {},\n\n        /**\n         * Store the applied search for each column - see\n         * {@link DataTable.models.oSearch} for the format that is used for the\n         * filtering information for each column.\n         *  @type array\n         *  @default []\n         */\n        aoPreSearchCols: [],\n\n        /**\n         * Sorting that is applied to the table. Note that the inner arrays are\n         * used in the following manner:\n         * <ul>\n         *   <li>Index 0 - column number</li>\n         *   <li>Index 1 - current sorting direction</li>\n         * </ul>\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @todo These inner arrays should really be objects\n         */\n        aaSorting: null,\n\n        /**\n         * Sorting that is always applied to the table (i.e. prefixed in front of\n         * aaSorting).\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @default []\n         */\n        aaSortingFixed: [],\n\n        /**\n         * Classes to use for the striping of a table.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @default []\n         */\n        asStripeClasses: null,\n\n        /**\n         * If restoring a table - we should restore its striping classes as well\n         *  @type array\n         *  @default []\n         */\n        asDestroyStripes: [],\n\n        /**\n         * If restoring a table - we should restore its width\n         *  @type int\n         *  @default 0\n         */\n        sDestroyWidth: 0,\n\n        /**\n         * Callback functions array for every time a row is inserted (i.e. on a draw).\n         *  @type array\n         *  @default []\n         */\n        aoRowCallback: [],\n\n        /**\n         * Callback functions for the header on each draw.\n         *  @type array\n         *  @default []\n         */\n        aoHeaderCallback: [],\n\n        /**\n         * Callback function for the footer on each draw.\n         *  @type array\n         *  @default []\n         */\n        aoFooterCallback: [],\n\n        /**\n         * Array of callback functions for draw callback functions\n         *  @type array\n         *  @default []\n         */\n        aoDrawCallback: [],\n\n        /**\n         * Array of callback functions for row created function\n         *  @type array\n         *  @default []\n         */\n        aoRowCreatedCallback: [],\n\n        /**\n         * Callback functions for just before the table is redrawn. A return of\n         * false will be used to cancel the draw.\n         *  @type array\n         *  @default []\n         */\n        aoPreDrawCallback: [],\n\n        /**\n         * Callback functions for when the table has been initialised.\n         *  @type array\n         *  @default []\n         */\n        aoInitComplete: [],\n\n        /**\n         * Callbacks for modifying the settings to be stored for state saving, prior to\n         * saving state.\n         *  @type array\n         *  @default []\n         */\n        aoStateSaveParams: [],\n\n        /**\n         * Callbacks for modifying the settings that have been stored for state saving\n         * prior to using the stored values to restore the state.\n         *  @type array\n         *  @default []\n         */\n        aoStateLoadParams: [],\n\n        /**\n         * Callbacks for operating on the settings object once the saved state has been\n         * loaded\n         *  @type array\n         *  @default []\n         */\n        aoStateLoaded: [],\n\n        /**\n         * Cache the table ID for quick access\n         *  @type string\n         *  @default <i>Empty string</i>\n         */\n        sTableId: '',\n\n        /**\n         * The TABLE node for the main table\n         *  @type node\n         *  @default null\n         */\n        nTable: null,\n\n        /**\n         * Permanent ref to the thead element\n         *  @type node\n         *  @default null\n         */\n        nTHead: null,\n\n        /**\n         * Permanent ref to the tfoot element - if it exists\n         *  @type node\n         *  @default null\n         */\n        nTFoot: null,\n\n        /**\n         * Permanent ref to the tbody element\n         *  @type node\n         *  @default null\n         */\n        nTBody: null,\n\n        /**\n         * Cache the wrapper node (contains all DataTables controlled elements)\n         *  @type node\n         *  @default null\n         */\n        nTableWrapper: null,\n\n        /**\n         * Indicate if when using server-side processing the loading of data\n         * should be deferred until the second draw.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type boolean\n         *  @default false\n         */\n        bDeferLoading: false,\n\n        /**\n         * Indicate if all required information has been read in\n         *  @type boolean\n         *  @default false\n         */\n        bInitialised: false,\n\n        /**\n         * Information about open rows. Each object in the array has the parameters\n         * 'nTr' and 'nParent'\n         *  @type array\n         *  @default []\n         */\n        aoOpenRows: [],\n\n        /**\n         * Dictate the positioning of DataTables' control elements - see\n         * {@link DataTable.model.oInit.sDom}.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         *  @default null\n         */\n        sDom: null,\n\n        /**\n         * Which type of pagination should be used.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         *  @default two_button\n         */\n        sPaginationType: 'two_button',\n\n        /**\n         * The state duration (for `stateSave`) in seconds.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type int\n         *  @default 0\n         */\n        iStateDuration: 0,\n\n        /**\n         * Array of callback functions for state saving. Each array element is an\n         * object with the following parameters:\n         *   <ul>\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\n         *       and the JSON string to save that has been thus far created. Returns\n         *       a JSON string to be inserted into a json object\n         *       (i.e. '\"param\": [ 0, 1, 2]')</li>\n         *     <li>string:sName - name of callback</li>\n         *   </ul>\n         *  @type array\n         *  @default []\n         */\n        aoStateSave: [],\n\n        /**\n         * Array of callback functions for state loading. Each array element is an\n         * object with the following parameters:\n         *   <ul>\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\n         *       and the object stored. May return false to cancel state loading</li>\n         *     <li>string:sName - name of callback</li>\n         *   </ul>\n         *  @type array\n         *  @default []\n         */\n        aoStateLoad: [],\n\n        /**\n         * State that was saved. Useful for back reference\n         *  @type object\n         *  @default null\n         */\n        oSavedState: null,\n\n        /**\n         * State that was loaded. Useful for back reference\n         *  @type object\n         *  @default null\n         */\n        oLoadedState: null,\n\n        /**\n         * Source url for AJAX data for the table.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         *  @default null\n         */\n        sAjaxSource: null,\n\n        /**\n         * Property from a given object from which to read the table data from. This\n         * can be an empty string (when not server-side processing), in which case\n         * it is  assumed an an array is given directly.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         */\n        sAjaxDataProp: null,\n\n        /**\n         * Note if draw should be blocked while getting data\n         *  @type boolean\n         *  @default true\n         */\n        bAjaxDataGet: true,\n\n        /**\n         * The last jQuery XHR object that was used for server-side data gathering.\n         * This can be used for working with the XHR information in one of the\n         * callbacks\n         *  @type object\n         *  @default null\n         */\n        jqXHR: null,\n\n        /**\n         * JSON returned from the server in the last Ajax request\n         *  @type object\n         *  @default undefined\n         */\n        json: undefined,\n\n        /**\n         * Data submitted as part of the last Ajax request\n         *  @type object\n         *  @default undefined\n         */\n        oAjaxData: undefined,\n\n        /**\n         * Function to get the server-side data.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type function\n         */\n        fnServerData: null,\n\n        /**\n         * Functions which are called prior to sending an Ajax request so extra\n         * parameters can easily be sent to the server\n         *  @type array\n         *  @default []\n         */\n        aoServerParams: [],\n\n        /**\n         * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\n         * required).\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         */\n        sServerMethod: null,\n\n        /**\n         * Format numbers for display.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type function\n         */\n        fnFormatNumber: null,\n\n        /**\n         * List of options that can be used for the user selectable length menu.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @default []\n         */\n        aLengthMenu: null,\n\n        /**\n         * Counter for the draws that the table does. Also used as a tracker for\n         * server-side processing\n         *  @type int\n         *  @default 0\n         */\n        iDraw: 0,\n\n        /**\n         * Indicate if a redraw is being done - useful for Ajax\n         *  @type boolean\n         *  @default false\n         */\n        bDrawing: false,\n\n        /**\n         * Draw index (iDraw) of the last error when parsing the returned data\n         *  @type int\n         *  @default -1\n         */\n        iDrawError: -1,\n\n        /**\n         * Paging display length\n         *  @type int\n         *  @default 10\n         */\n        _iDisplayLength: 10,\n\n        /**\n         * Paging start point - aiDisplay index\n         *  @type int\n         *  @default 0\n         */\n        _iDisplayStart: 0,\n\n        /**\n         * Server-side processing - number of records in the result set\n         * (i.e. before filtering), Use fnRecordsTotal rather than\n         * this property to get the value of the number of records, regardless of\n         * the server-side processing setting.\n         *  @type int\n         *  @default 0\n         *  @private\n         */\n        _iRecordsTotal: 0,\n\n        /**\n         * Server-side processing - number of records in the current display set\n         * (i.e. after filtering). Use fnRecordsDisplay rather than\n         * this property to get the value of the number of records, regardless of\n         * the server-side processing setting.\n         *  @type boolean\n         *  @default 0\n         *  @private\n         */\n        _iRecordsDisplay: 0,\n\n        /**\n         * Flag to indicate if jQuery UI marking and classes should be used.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type boolean\n         */\n        bJUI: null,\n\n        /**\n         * The classes to use for the table\n         *  @type object\n         *  @default {}\n         */\n        oClasses: {},\n\n        /**\n         * Flag attached to the settings object so you can check in the draw\n         * callback if filtering has been done in the draw. Deprecated in favour of\n         * events.\n         *  @type boolean\n         *  @default false\n         *  @deprecated\n         */\n        bFiltered: false,\n\n        /**\n         * Flag attached to the settings object so you can check in the draw\n         * callback if sorting has been done in the draw. Deprecated in favour of\n         * events.\n         *  @type boolean\n         *  @default false\n         *  @deprecated\n         */\n        bSorted: false,\n\n        /**\n         * Indicate that if multiple rows are in the header and there is more than\n         * one unique cell per column, if the top one (true) or bottom one (false)\n         * should be used for sorting / title by DataTables.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type boolean\n         */\n        bSortCellsTop: null,\n\n        /**\n         * Initialisation object that is used for the table\n         *  @type object\n         *  @default null\n         */\n        oInit: null,\n\n        /**\n         * Destroy callback functions - for plug-ins to attach themselves to the\n         * destroy so they can clean up markup and events.\n         *  @type array\n         *  @default []\n         */\n        aoDestroyCallback: [],\n\n        /**\n         * Get the number of records in the current record set, before filtering\n         *  @type function\n         */\n        fnRecordsTotal: function () {\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length\n        },\n\n        /**\n         * Get the number of records in the current record set, after filtering\n         *  @type function\n         */\n        fnRecordsDisplay: function () {\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length\n        },\n\n        /**\n         * Get the display end point - aiDisplay index\n         *  @type function\n         */\n        fnDisplayEnd: function () {\n          var len = this._iDisplayLength,\n            start = this._iDisplayStart,\n            calc = start + len,\n            records = this.aiDisplay.length,\n            features = this.oFeatures,\n            paginate = features.bPaginate\n\n          if (features.bServerSide) {\n            return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay)\n          } else {\n            return !paginate || calc > records || len === -1 ? records : calc\n          }\n        },\n\n        /**\n         * The DataTables object for this table\n         *  @type object\n         *  @default null\n         */\n        oInstance: null,\n\n        /**\n         * Unique identifier for each instance of the DataTables object. If there\n         * is an ID on the table node, then it takes that value, otherwise an\n         * incrementing internal counter is used.\n         *  @type string\n         *  @default null\n         */\n        sInstance: null,\n\n        /**\n         * tabindex attribute value that is added to DataTables control elements, allowing\n         * keyboard navigation of the table and its controls.\n         */\n        iTabIndex: 0,\n\n        /**\n         * DIV container for the footer scrolling table if scrolling\n         */\n        nScrollHead: null,\n\n        /**\n         * DIV container for the footer scrolling table if scrolling\n         */\n        nScrollFoot: null,\n\n        /**\n         * Last applied sort\n         *  @type array\n         *  @default []\n         */\n        aLastSort: [],\n\n        /**\n         * Stored plug-in instances\n         *  @type object\n         *  @default {}\n         */\n        oPlugins: {}\n      }\n\n      /**\n       * Extension object for DataTables that is used to provide all extension\n       * options.\n       *\n       * Note that the `DataTable.ext` object is available through\n       * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\n       * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\n       *  @namespace\n       *  @extends DataTable.models.ext\n       */\n\n      /**\n       * DataTables extensions\n       *\n       * This namespace acts as a collection area for plug-ins that can be used to\n       * extend DataTables capabilities. Indeed many of the build in methods\n       * use this method to provide their own capabilities (sorting methods for\n       * example).\n       *\n       * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\n       * reasons\n       *\n       *  @namespace\n       */\n      DataTable.ext = _ext = {\n        /**\n         * Element class names\n         *\n         *  @type object\n         *  @default {}\n         */\n        classes: {},\n\n        /**\n         * Error reporting.\n         *\n         * How should DataTables report an error. Can take the value 'alert' or\n         * 'throw'\n         *\n         *  @type string\n         *  @default alert\n         */\n        errMode: 'alert',\n\n        /**\n         * Feature plug-ins.\n         *\n         * This is an array of objects which describe the feature plug-ins that are\n         * available to DataTables. These feature plug-ins are then available for\n         * use through the `dom` initialisation option.\n         *\n         * Each feature plug-in is described by an object which must have the\n         * following properties:\n         *\n         * * `fnInit` - function that is used to initialise the plug-in,\n         * * `cFeature` - a character so the feature can be enabled by the `dom`\n         *   instillation option. This is case sensitive.\n         *\n         * The `fnInit` function has the following input parameters:\n         *\n         * 1. `{object}` DataTables settings object: see\n         *    {@link DataTable.models.oSettings}\n         *\n         * And the following return is expected:\n         *\n         * * {node|null} The element which contains your feature. Note that the\n         *   return may also be void if your plug-in does not require to inject any\n         *   DOM elements into DataTables control (`dom`) - for example this might\n         *   be useful when developing a plug-in which allows table control via\n         *   keyboard entry\n         *\n         *  @type array\n         *\n         *  @example\n         *    $.fn.dataTable.ext.features.push( {\n         *      \"fnInit\": function( oSettings ) {\n         *        return new TableTools( { \"oDTSettings\": oSettings } );\n         *      },\n         *      \"cFeature\": \"T\"\n         *    } );\n         */\n        feature: [],\n\n        /**\n         * Row searching.\n         *\n         * This method of searching is complimentary to the default type based\n         * searching, and a lot more comprehensive as it allows you complete control\n         * over the searching logic. Each element in this array is a function\n         * (parameters described below) that is called for every row in the table,\n         * and your logic decides if it should be included in the searching data set\n         * or not.\n         *\n         * Searching functions have the following input parameters:\n         *\n         * 1. `{object}` DataTables settings object: see\n         *    {@link DataTable.models.oSettings}\n         * 2. `{array|object}` Data for the row to be processed (same as the\n         *    original format that was passed in as the data source, or an array\n         *    from a DOM data source\n         * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\n         *    can be useful to retrieve the `TR` element if you need DOM interaction.\n         *\n         * And the following return is expected:\n         *\n         * * {boolean} Include the row in the searched result set (true) or not\n         *   (false)\n         *\n         * Note that as with the main search ability in DataTables, technically this\n         * is \"filtering\", since it is subtractive. However, for consistency in\n         * naming we call it searching here.\n         *\n         *  @type array\n         *  @default []\n         *\n         *  @example\n         *    // The following example shows custom search being applied to the\n         *    // fourth column (i.e. the data[3] index) based on two input values\n         *    // from the end-user, matching the data in a certain range.\n         *    $.fn.dataTable.ext.search.push(\n         *      function( settings, data, dataIndex ) {\n         *        var min = document.getElementById('min').value * 1;\n         *        var max = document.getElementById('max').value * 1;\n         *        var version = data[3] == \"-\" ? 0 : data[3]*1;\n         *\n         *        if ( min == \"\" && max == \"\" ) {\n         *          return true;\n         *        }\n         *        else if ( min == \"\" && version < max ) {\n         *          return true;\n         *        }\n         *        else if ( min < version && \"\" == max ) {\n         *          return true;\n         *        }\n         *        else if ( min < version && version < max ) {\n         *          return true;\n         *        }\n         *        return false;\n         *      }\n         *    );\n         */\n        search: [],\n\n        /**\n         * Internal functions, exposed for used in plug-ins.\n         *\n         * Please note that you should not need to use the internal methods for\n         * anything other than a plug-in (and even then, try to avoid if possible).\n         * The internal function may change between releases.\n         *\n         *  @type object\n         *  @default {}\n         */\n        internal: {},\n\n        /**\n         * Legacy configuration options. Enable and disable legacy options that\n         * are available in DataTables.\n         *\n         *  @type object\n         */\n        legacy: {\n          /**\n           * Enable / disable DataTables 1.9 compatible server-side processing\n           * requests\n           *\n           *  @type boolean\n           *  @default null\n           */\n          ajax: null\n        },\n\n        /**\n         * Pagination plug-in methods.\n         *\n         * Each entry in this object is a function and defines which buttons should\n         * be shown by the pagination rendering method that is used for the table:\n         * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\n         * buttons are displayed in the document, while the functions here tell it\n         * what buttons to display. This is done by returning an array of button\n         * descriptions (what each button will do).\n         *\n         * Pagination types (the four built in options and any additional plug-in\n         * options defined here) can be used through the `paginationType`\n         * initialisation parameter.\n         *\n         * The functions defined take two parameters:\n         *\n         * 1. `{int} page` The current page index\n         * 2. `{int} pages` The number of pages in the table\n         *\n         * Each function is expected to return an array where each element of the\n         * array can be one of:\n         *\n         * * `first` - Jump to first page when activated\n         * * `last` - Jump to last page when activated\n         * * `previous` - Show previous page when activated\n         * * `next` - Show next page when activated\n         * * `{int}` - Show page of the index given\n         * * `{array}` - A nested array containing the above elements to add a\n         *   containing 'DIV' element (might be useful for styling).\n         *\n         * Note that DataTables v1.9- used this object slightly differently whereby\n         * an object with two functions would be defined for each plug-in. That\n         * ability is still supported by DataTables 1.10+ to provide backwards\n         * compatibility, but this option of use is now decremented and no longer\n         * documented in DataTables 1.10+.\n         *\n         *  @type object\n         *  @default {}\n         *\n         *  @example\n         *    // Show previous, next and current page buttons only\n         *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\n         *      return [ 'previous', page, 'next' ];\n         *    };\n         */\n        pager: {},\n\n        renderer: {\n          pageButton: {},\n          header: {}\n        },\n\n        /**\n         * Ordering plug-ins - custom data source\n         *\n         * The extension options for ordering of data available here is complimentary\n         * to the default type based ordering that DataTables typically uses. It\n         * allows much greater control over the the data that is being used to\n         * order a column, but is necessarily therefore more complex.\n         *\n         * This type of ordering is useful if you want to do ordering based on data\n         * live from the DOM (for example the contents of an 'input' element) rather\n         * than just the static string that DataTables knows of.\n         *\n         * The way these plug-ins work is that you create an array of the values you\n         * wish to be ordering for the column in question and then return that\n         * array. The data in the array much be in the index order of the rows in\n         * the table (not the currently ordering order!). Which order data gathering\n         * function is run here depends on the `dt-init columns.orderDataType`\n         * parameter that is used for the column (if any).\n         *\n         * The functions defined take two parameters:\n         *\n         * 1. `{object}` DataTables settings object: see\n         *    {@link DataTable.models.oSettings}\n         * 2. `{int}` Target column index\n         *\n         * Each function is expected to return an array:\n         *\n         * * `{array}` Data for the column to be ordering upon\n         *\n         *  @type array\n         *\n         *  @example\n         *    // Ordering using `input` node values\n         *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\n         *    {\n         *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\n         *        return $('input', td).val();\n         *      } );\n         *    }\n         */\n        order: {},\n\n        /**\n         * Type based plug-ins.\n         *\n         * Each column in DataTables has a type assigned to it, either by automatic\n         * detection or by direct assignment using the `type` option for the column.\n         * The type of a column will effect how it is ordering and search (plug-ins\n         * can also make use of the column type if required).\n         *\n         * @namespace\n         */\n        type: {\n          /**\n           * Type detection functions.\n           *\n           * The functions defined in this object are used to automatically detect\n           * a column's type, making initialisation of DataTables super easy, even\n           * when complex data is in the table.\n           *\n           * The functions defined take two parameters:\n           *\n           *  1. `{*}` Data from the column cell to be analysed\n           *  2. `{settings}` DataTables settings object. This can be used to\n           *     perform context specific type detection - for example detection\n           *     based on language settings such as using a comma for a decimal\n           *     place. Generally speaking the options from the settings will not\n           *     be required\n           *\n           * Each function is expected to return:\n           *\n           * * `{string|null}` Data type detected, or null if unknown (and thus\n           *   pass it on to the other type detection functions.\n           *\n           *  @type array\n           *\n           *  @example\n           *    // Currency type detection plug-in:\n           *    $.fn.dataTable.ext.type.detect.push(\n           *      function ( data, settings ) {\n           *        // Check the numeric part\n           *        if ( ! $.isNumeric( data.substring(1) ) ) {\n           *          return null;\n           *        }\n           *\n           *        // Check prefixed by currency\n           *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\n           *          return 'currency';\n           *        }\n           *        return null;\n           *      }\n           *    );\n           */\n          detect: [],\n\n          /**\n           * Type based search formatting.\n           *\n           * The type based searching functions can be used to pre-format the\n           * data to be search on. For example, it can be used to strip HTML\n           * tags or to de-format telephone numbers for numeric only searching.\n           *\n           * Note that is a search is not defined for a column of a given type,\n           * no search formatting will be performed.\n           *\n           * Pre-processing of searching data plug-ins - When you assign the sType\n           * for a column (or have it automatically detected for you by DataTables\n           * or a type detection plug-in), you will typically be using this for\n           * custom sorting, but it can also be used to provide custom searching\n           * by allowing you to pre-processing the data and returning the data in\n           * the format that should be searched upon. This is done by adding\n           * functions this object with a parameter name which matches the sType\n           * for that target column. This is the corollary of <i>afnSortData</i>\n           * for searching data.\n           *\n           * The functions defined take a single parameter:\n           *\n           *  1. `{*}` Data from the column cell to be prepared for searching\n           *\n           * Each function is expected to return:\n           *\n           * * `{string|null}` Formatted string that will be used for the searching.\n           *\n           *  @type object\n           *  @default {}\n           *\n           *  @example\n           *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\n           *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\n           *    }\n           */\n          search: {},\n\n          /**\n           * Type based ordering.\n           *\n           * The column type tells DataTables what ordering to apply to the table\n           * when a column is sorted upon. The order for each type that is defined,\n           * is defined by the functions available in this object.\n           *\n           * Each ordering option can be described by three properties added to\n           * this object:\n           *\n           * * `{type}-pre` - Pre-formatting function\n           * * `{type}-asc` - Ascending order function\n           * * `{type}-desc` - Descending order function\n           *\n           * All three can be used together, only `{type}-pre` or only\n           * `{type}-asc` and `{type}-desc` together. It is generally recommended\n           * that only `{type}-pre` is used, as this provides the optimal\n           * implementation in terms of speed, although the others are provided\n           * for compatibility with existing Javascript sort functions.\n           *\n           * `{type}-pre`: Functions defined take a single parameter:\n           *\n           *  1. `{*}` Data from the column cell to be prepared for ordering\n           *\n           * And return:\n           *\n           * * `{*}` Data to be sorted upon\n           *\n           * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\n           * functions, taking two parameters:\n           *\n           *  1. `{*}` Data to compare to the second parameter\n           *  2. `{*}` Data to compare to the first parameter\n           *\n           * And returning:\n           *\n           * * `{*}` Ordering match: <0 if first parameter should be sorted lower\n           *   than the second parameter, ===0 if the two parameters are equal and\n           *   >0 if the first parameter should be sorted height than the second\n           *   parameter.\n           *\n           *  @type object\n           *  @default {}\n           *\n           *  @example\n           *    // Numeric ordering of formatted numbers with a pre-formatter\n           *    $.extend( $.fn.dataTable.ext.type.order, {\n           *      \"string-pre\": function(x) {\n           *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\n           *        return parseFloat( a );\n           *      }\n           *    } );\n           *\n           *  @example\n           *    // Case-sensitive string ordering, with no pre-formatting method\n           *    $.extend( $.fn.dataTable.ext.order, {\n           *      \"string-case-asc\": function(x,y) {\n           *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n           *      },\n           *      \"string-case-desc\": function(x,y) {\n           *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n           *      }\n           *    } );\n           */\n          order: {}\n        },\n\n        /**\n         * Unique DataTables instance counter\n         *\n         * @type int\n         * @private\n         */\n        _unique: 0,\n\n        //\n        // Depreciated\n        // The following properties are retained for backwards compatiblity only.\n        // The should not be used in new projects and will be removed in a future\n        // version\n        //\n\n        /**\n         * Version check function.\n         *  @type function\n         *  @depreciated Since 1.10\n         */\n        fnVersionCheck: DataTable.fnVersionCheck,\n\n        /**\n         * Index for what 'this' index API functions should use\n         *  @type int\n         *  @deprecated Since v1.10\n         */\n        iApiIndex: 0,\n\n        /**\n         * jQuery UI class container\n         *  @type object\n         *  @deprecated Since v1.10\n         */\n        oJUIClasses: {},\n\n        /**\n         * Software version\n         *  @type string\n         *  @deprecated Since v1.10\n         */\n        sVersion: DataTable.version\n      }\n\n      //\n      // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\n      //\n      $.extend(_ext, {\n        afnFiltering: _ext.search,\n        aTypes: _ext.type.detect,\n        ofnSearch: _ext.type.search,\n        oSort: _ext.type.order,\n        afnSortData: _ext.order,\n        aoFeatures: _ext.feature,\n        oApi: _ext.internal,\n        oStdClasses: _ext.classes,\n        oPagination: _ext.pager\n      })\n\n      $.extend(DataTable.ext.classes, {\n        sTable: 'dataTable',\n        sNoFooter: 'no-footer',\n\n        /* Paging buttons */\n        sPageButton: 'paginate_button',\n        sPageButtonActive: 'current',\n        sPageButtonDisabled: 'disabled',\n\n        /* Striping classes */\n        sStripeOdd: 'odd',\n        sStripeEven: 'even',\n\n        /* Empty row */\n        sRowEmpty: 'dataTables_empty',\n\n        /* Features */\n        sWrapper: 'dataTables_wrapper',\n        sFilter: 'dataTables_filter',\n        sInfo: 'dataTables_info',\n        sPaging: 'dataTables_paginate paging_' /* Note that the type is postfixed */,\n        sLength: 'dataTables_length',\n        sProcessing: 'dataTables_processing',\n\n        /* Sorting */\n        sSortAsc: 'sorting_asc',\n        sSortDesc: 'sorting_desc',\n        sSortable: 'sorting' /* Sortable in both directions */,\n        sSortableAsc: 'sorting_asc_disabled',\n        sSortableDesc: 'sorting_desc_disabled',\n        sSortableNone: 'sorting_disabled',\n        sSortColumn: 'sorting_' /* Note that an int is postfixed for the sorting order */,\n\n        /* Filtering */\n        sFilterInput: '',\n\n        /* Page length */\n        sLengthSelect: '',\n\n        /* Scrolling */\n        sScrollWrapper: 'dataTables_scroll',\n        sScrollHead: 'dataTables_scrollHead',\n        sScrollHeadInner: 'dataTables_scrollHeadInner',\n        sScrollBody: 'dataTables_scrollBody',\n        sScrollFoot: 'dataTables_scrollFoot',\n        sScrollFootInner: 'dataTables_scrollFootInner',\n\n        /* Misc */\n        sHeaderTH: '',\n        sFooterTH: '',\n\n        // Deprecated\n        sSortJUIAsc: '',\n        sSortJUIDesc: '',\n        sSortJUI: '',\n        sSortJUIAscAllowed: '',\n        sSortJUIDescAllowed: '',\n        sSortJUIWrapper: '',\n        sSortIcon: '',\n        sJUIHeader: '',\n        sJUIFooter: ''\n      })\n      ;(function () {\n        // Reused strings for better compression. Closure compiler appears to have a\n        // weird edge case where it is trying to expand strings rather than use the\n        // variable version. This results in about 200 bytes being added, for very\n        // little preference benefit since it this run on script load only.\n        var _empty = ''\n        _empty = ''\n\n        var _stateDefault = _empty + 'ui-state-default'\n        var _sortIcon = _empty + 'css_right ui-icon ui-icon-'\n        var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix'\n\n        $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {\n          /* Full numbers paging buttons */\n          sPageButton: 'fg-button ui-button ' + _stateDefault,\n          sPageButtonActive: 'ui-state-disabled',\n          sPageButtonDisabled: 'ui-state-disabled',\n\n          /* Features */\n          sPaging:\n            'dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ' +\n            'ui-buttonset-multi paging_' /* Note that the type is postfixed */,\n\n          /* Sorting */\n          sSortAsc: _stateDefault + ' sorting_asc',\n          sSortDesc: _stateDefault + ' sorting_desc',\n          sSortable: _stateDefault + ' sorting',\n          sSortableAsc: _stateDefault + ' sorting_asc_disabled',\n          sSortableDesc: _stateDefault + ' sorting_desc_disabled',\n          sSortableNone: _stateDefault + ' sorting_disabled',\n          sSortJUIAsc: _sortIcon + 'triangle-1-n',\n          sSortJUIDesc: _sortIcon + 'triangle-1-s',\n          sSortJUI: _sortIcon + 'carat-2-n-s',\n          sSortJUIAscAllowed: _sortIcon + 'carat-1-n',\n          sSortJUIDescAllowed: _sortIcon + 'carat-1-s',\n          sSortJUIWrapper: 'DataTables_sort_wrapper',\n          sSortIcon: 'DataTables_sort_icon',\n\n          /* Scrolling */\n          sScrollHead: 'dataTables_scrollHead ' + _stateDefault,\n          sScrollFoot: 'dataTables_scrollFoot ' + _stateDefault,\n\n          /* Misc */\n          sHeaderTH: _stateDefault,\n          sFooterTH: _stateDefault,\n          sJUIHeader: _headerFooter + ' ui-corner-tl ui-corner-tr',\n          sJUIFooter: _headerFooter + ' ui-corner-bl ui-corner-br'\n        })\n      })()\n\n      var extPagination = DataTable.ext.pager\n\n      function _numbers (page, pages) {\n        var numbers = [],\n          buttons = extPagination.numbers_length,\n          half = Math.floor(buttons / 2),\n          i = 1\n\n        if (pages <= buttons) {\n          numbers = _range(0, pages)\n        } else if (page <= half) {\n          numbers = _range(0, buttons - 2)\n          numbers.push('ellipsis')\n          numbers.push(pages - 1)\n        } else if (page >= pages - 1 - half) {\n          numbers = _range(pages - (buttons - 2), pages)\n          numbers.splice(0, 0, 'ellipsis') // no unshift in ie6\n          numbers.splice(0, 0, 0)\n        } else {\n          numbers = _range(page - 1, page + 2)\n          numbers.push('ellipsis')\n          numbers.push(pages - 1)\n          numbers.splice(0, 0, 'ellipsis')\n          numbers.splice(0, 0, 0)\n        }\n\n        numbers.DT_el = 'span'\n        return numbers\n      }\n\n      $.extend(extPagination, {\n        simple: function (page, pages) {\n          return ['previous', 'next']\n        },\n\n        full: function (page, pages) {\n          return ['first', 'previous', 'next', 'last']\n        },\n\n        simple_numbers: function (page, pages) {\n          return ['previous', _numbers(page, pages), 'next']\n        },\n\n        full_numbers: function (page, pages) {\n          return ['first', 'previous', _numbers(page, pages), 'next', 'last']\n        },\n\n        // For testing and plug-ins to use\n        _numbers: _numbers,\n        numbers_length: 7\n      })\n\n      $.extend(true, DataTable.ext.renderer, {\n        pageButton: {\n          _: function (settings, host, idx, buttons, page, pages) {\n            var classes = settings.oClasses\n            var lang = settings.oLanguage.oPaginate\n            var btnDisplay,\n              btnClass,\n              counter = 0\n\n            var attach = function (container, buttons) {\n              var i, ien, node, button\n              var clickHandler = function (e) {\n                _fnPageChange(settings, e.data.action, true)\n              }\n\n              for (i = 0, ien = buttons.length; i < ien; i++) {\n                button = buttons[i]\n\n                if ($.isArray(button)) {\n                  var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container)\n                  attach(inner, button)\n                } else {\n                  btnDisplay = ''\n                  btnClass = ''\n\n                  switch (button) {\n                    case 'ellipsis':\n                      container.append('<span>&hellip;</span>')\n                      break\n\n                    case 'first':\n                      btnDisplay = lang.sFirst\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    case 'previous':\n                      btnDisplay = lang.sPrevious\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    case 'next':\n                      btnDisplay = lang.sNext\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    case 'last':\n                      btnDisplay = lang.sLast\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    default:\n                      btnDisplay = button + 1\n                      btnClass = page === button ? classes.sPageButtonActive : ''\n                      break\n                  }\n\n                  if (btnDisplay) {\n                    node = $('<a>', {\n                      class: classes.sPageButton + ' ' + btnClass,\n                      'aria-controls': settings.sTableId,\n                      'data-dt-idx': counter,\n                      tabindex: settings.iTabIndex,\n                      id: idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null\n                    })\n                      .html(btnDisplay)\n                      .appendTo(container)\n\n                    _fnBindAction(node, { action: button }, clickHandler)\n\n                    counter++\n                  }\n                }\n              }\n            }\n\n            // IE9 throws an 'unknown error' if document.activeElement is used\n            // inside an iframe or frame. Try / catch the error. Not good for\n            // accessibility, but neither are frames.\n            try {\n              // Because this approach is destroying and recreating the paging\n              // elements, focus is lost on the select button which is bad for\n              // accessibility. So we want to restore focus once the draw has\n              // completed\n              var activeEl = $(document.activeElement).data('dt-idx')\n\n              attach($(host).empty(), buttons)\n\n              if (activeEl !== null) {\n                $(host)\n                  .find('[data-dt-idx=' + activeEl + ']')\n                  .focus()\n              }\n            } catch (e) {}\n          }\n        }\n      })\n\n      var __numericReplace = function (d, decimalPlace, re1, re2) {\n        if (!d || d === '-') {\n          return -Infinity\n        }\n\n        // If a decimal place other than `.` is used, it needs to be given to the\n        // function so we can detect it and replace with a `.` which is the only\n        // decimal place Javascript recognises - it is not locale aware.\n        if (decimalPlace) {\n          d = _numToDecimal(d, decimalPlace)\n        }\n\n        if (d.replace) {\n          if (re1) {\n            d = d.replace(re1, '')\n          }\n\n          if (re2) {\n            d = d.replace(re2, '')\n          }\n        }\n\n        return d * 1\n      }\n\n      // Add the numeric 'deformatting' functions for sorting. This is done in a\n      // function to provide an easy ability for the language options to add\n      // additional methods if a non-period decimal place is used.\n      function _addNumericSort (decimalPlace) {\n        $.each(\n          {\n            // Plain numbers\n            num: function (d) {\n              return __numericReplace(d, decimalPlace)\n            },\n\n            // Formatted numbers\n            'num-fmt': function (d) {\n              return __numericReplace(d, decimalPlace, _re_formatted_numeric)\n            },\n\n            // HTML numeric\n            'html-num': function (d) {\n              return __numericReplace(d, decimalPlace, _re_html)\n            },\n\n            // HTML numeric, formatted\n            'html-num-fmt': function (d) {\n              return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric)\n            }\n          },\n          function (key, fn) {\n            _ext.type.order[key + decimalPlace + '-pre'] = fn\n          }\n        )\n      }\n\n      // Default sort methods\n      $.extend(_ext.type.order, {\n        // Dates\n        'date-pre': function (d) {\n          return Date.parse(d) || 0\n        },\n\n        // html\n        'html-pre': function (a) {\n          return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, '').toLowerCase() : a + ''\n        },\n\n        // string\n        'string-pre': function (a) {\n          // This is a little complex, but faster than always calling toString,\n          // http://jsperf.com/tostring-v-check\n          return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString()\n        },\n\n        // string-asc and -desc are retained only for compatibility with the old\n        // sort methods\n        'string-asc': function (x, y) {\n          return x < y ? -1 : x > y ? 1 : 0\n        },\n\n        'string-desc': function (x, y) {\n          return x < y ? 1 : x > y ? -1 : 0\n        }\n      })\n\n      // Numeric sorting types - order doesn't matter here\n      _addNumericSort('')\n\n      // Built in type detection. See model.ext.aTypes for information about\n      // what is required from this methods.\n      $.extend(DataTable.ext.type.detect, [\n        // Plain numbers - first since V8 detects some plain numbers as dates\n        // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _isNumber(d, decimal) ? 'num' + decimal : null\n        },\n\n        // Dates (only those recognised by the browser's Date.parse)\n        function (d, settings) {\n          // V8 will remove any unknown characters at the start and end of the\n          // expression, leading to false matches such as `$245.12` or `10%` being\n          // a valid date. See forum thread 18941 for detail.\n          if (d && (!_re_date_start.test(d) || !_re_date_end.test(d))) {\n            return null\n          }\n          var parsed = Date.parse(d)\n          return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null\n        },\n\n        // Formatted numbers\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null\n        },\n\n        // HTML numeric\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null\n        },\n\n        // HTML numeric, formatted\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null\n        },\n\n        // HTML (this is strict checking - there must be html)\n        function (d, settings) {\n          return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ? 'html' : null\n        }\n      ])\n\n      // Filter formatting functions. See model.ext.ofnSearch for information about\n      // what is required from these methods.\n\n      $.extend(DataTable.ext.type.search, {\n        html: function (data) {\n          return _empty(data)\n            ? data\n            : typeof data === 'string'\n            ? data.replace(_re_new_lines, ' ').replace(_re_html, '')\n            : ''\n        },\n\n        string: function (data) {\n          return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, ' ') : data\n        }\n      })\n\n      $.extend(true, DataTable.ext.renderer, {\n        header: {\n          _: function (settings, cell, column, classes) {\n            // No additional mark-up required\n            // Attach a sort listener to update on sort - note that using the\n            // `DT` namespace will allow the event to be removed automatically\n            // on destroy, while the `dt` namespaced event is the one we are\n            // listening for\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\n              if (settings !== ctx) {\n                // need to check this this is the host\n                return // table, not a nested one\n              }\n\n              var colIdx = column.idx\n\n              cell\n                .removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc)\n                .addClass(\n                  columns[colIdx] == 'asc'\n                    ? classes.sSortAsc\n                    : columns[colIdx] == 'desc'\n                    ? classes.sSortDesc\n                    : column.sSortingClass\n                )\n            })\n          },\n\n          jqueryui: function (settings, cell, column, classes) {\n            var colIdx = column.idx\n\n            $('<div/>')\n              .addClass(classes.sSortJUIWrapper)\n              .append(cell.contents())\n              .append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI))\n              .appendTo(cell)\n\n            // Attach a sort listener to update on sort\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\n              if (settings !== ctx) {\n                return\n              }\n\n              cell\n                .removeClass(classes.sSortAsc + ' ' + classes.sSortDesc)\n                .addClass(\n                  columns[colIdx] == 'asc'\n                    ? classes.sSortAsc\n                    : columns[colIdx] == 'desc'\n                    ? classes.sSortDesc\n                    : column.sSortingClass\n                )\n\n              cell\n                .find('span.' + classes.sSortIcon)\n                .removeClass(\n                  classes.sSortJUIAsc +\n                    ' ' +\n                    classes.sSortJUIDesc +\n                    ' ' +\n                    classes.sSortJUI +\n                    ' ' +\n                    classes.sSortJUIAscAllowed +\n                    ' ' +\n                    classes.sSortJUIDescAllowed\n                )\n                .addClass(\n                  columns[colIdx] == 'asc'\n                    ? classes.sSortJUIAsc\n                    : columns[colIdx] == 'desc'\n                    ? classes.sSortJUIDesc\n                    : column.sSortingClassJUI\n                )\n            })\n          }\n        }\n      })\n\n      /*\n       * Public helper functions. These aren't used internally by DataTables, or\n       * called by any of the options passed into DataTables, but they can be used\n       * externally by developers working with DataTables. They are helper functions\n       * to make working with DataTables a little bit easier.\n       */\n\n      /**\n       * Helpers for `columns.render`.\n       *\n       * The options defined here can be used with the `columns.render` initialisation\n       * option to provide a display renderer. The following functions are defined:\n       *\n       * * `number` - Will format numeric data (defined by `columns.data`) for\n       *   display, retaining the original unformatted data for sorting and filtering.\n       *   It takes 4 parameters:\n       *   * `string` - Thousands grouping separator\n       *   * `string` - Decimal point indicator\n       *   * `integer` - Number of decimal points to show\n       *   * `string` (optional) - Prefix.\n       *\n       * @example\n       *   // Column definition using the number renderer\n       *   {\n       *     data: \"salary\",\n       *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\n       *   }\n       *\n       * @namespace\n       */\n      DataTable.render = {\n        number: function (thousands, decimal, precision, prefix) {\n          return {\n            display: function (d) {\n              var negative = d < 0 ? '-' : ''\n              d = Math.abs(parseFloat(d))\n\n              var intPart = parseInt(d, 10)\n              var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : ''\n\n              return (\n                negative + (prefix || '') + intPart.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands) + floatPart\n              )\n            }\n          }\n        }\n      }\n\n      /*\n       * This is really a good bit rubbish this method of exposing the internal methods\n       * publicly... - To be fixed in 2.0 using methods on the prototype\n       */\n\n      /**\n       * Create a wrapper function for exporting an internal functions to an external API.\n       *  @param {string} fn API function name\n       *  @returns {function} wrapped function\n       *  @memberof DataTable#internal\n       */\n      function _fnExternApiFunc (fn) {\n        return function () {\n          var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments))\n          return DataTable.ext.internal[fn].apply(this, args)\n        }\n      }\n\n      /**\n       * Reference to internal functions for use by plug-in developers. Note that\n       * these methods are references to internal functions and are considered to be\n       * private. If you use these methods, be aware that they are liable to change\n       * between versions.\n       *  @namespace\n       */\n      $.extend(DataTable.ext.internal, {\n        _fnExternApiFunc: _fnExternApiFunc,\n        _fnBuildAjax: _fnBuildAjax,\n        _fnAjaxUpdate: _fnAjaxUpdate,\n        _fnAjaxParameters: _fnAjaxParameters,\n        _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\n        _fnAjaxDataSrc: _fnAjaxDataSrc,\n        _fnAddColumn: _fnAddColumn,\n        _fnColumnOptions: _fnColumnOptions,\n        _fnAdjustColumnSizing: _fnAdjustColumnSizing,\n        _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\n        _fnColumnIndexToVisible: _fnColumnIndexToVisible,\n        _fnVisbleColumns: _fnVisbleColumns,\n        _fnGetColumns: _fnGetColumns,\n        _fnColumnTypes: _fnColumnTypes,\n        _fnApplyColumnDefs: _fnApplyColumnDefs,\n        _fnHungarianMap: _fnHungarianMap,\n        _fnCamelToHungarian: _fnCamelToHungarian,\n        _fnLanguageCompat: _fnLanguageCompat,\n        _fnBrowserDetect: _fnBrowserDetect,\n        _fnAddData: _fnAddData,\n        _fnAddTr: _fnAddTr,\n        _fnNodeToDataIndex: _fnNodeToDataIndex,\n        _fnNodeToColumnIndex: _fnNodeToColumnIndex,\n        _fnGetCellData: _fnGetCellData,\n        _fnSetCellData: _fnSetCellData,\n        _fnSplitObjNotation: _fnSplitObjNotation,\n        _fnGetObjectDataFn: _fnGetObjectDataFn,\n        _fnSetObjectDataFn: _fnSetObjectDataFn,\n        _fnGetDataMaster: _fnGetDataMaster,\n        _fnClearTable: _fnClearTable,\n        _fnDeleteIndex: _fnDeleteIndex,\n        _fnInvalidateRow: _fnInvalidateRow,\n        _fnGetRowElements: _fnGetRowElements,\n        _fnCreateTr: _fnCreateTr,\n        _fnBuildHead: _fnBuildHead,\n        _fnDrawHead: _fnDrawHead,\n        _fnDraw: _fnDraw,\n        _fnReDraw: _fnReDraw,\n        _fnAddOptionsHtml: _fnAddOptionsHtml,\n        _fnDetectHeader: _fnDetectHeader,\n        _fnGetUniqueThs: _fnGetUniqueThs,\n        _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\n        _fnFilterComplete: _fnFilterComplete,\n        _fnFilterCustom: _fnFilterCustom,\n        _fnFilterColumn: _fnFilterColumn,\n        _fnFilter: _fnFilter,\n        _fnFilterCreateSearch: _fnFilterCreateSearch,\n        _fnEscapeRegex: _fnEscapeRegex,\n        _fnFilterData: _fnFilterData,\n        _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\n        _fnUpdateInfo: _fnUpdateInfo,\n        _fnInfoMacros: _fnInfoMacros,\n        _fnInitialise: _fnInitialise,\n        _fnInitComplete: _fnInitComplete,\n        _fnLengthChange: _fnLengthChange,\n        _fnFeatureHtmlLength: _fnFeatureHtmlLength,\n        _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\n        _fnPageChange: _fnPageChange,\n        _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\n        _fnProcessingDisplay: _fnProcessingDisplay,\n        _fnFeatureHtmlTable: _fnFeatureHtmlTable,\n        _fnScrollDraw: _fnScrollDraw,\n        _fnApplyToChildren: _fnApplyToChildren,\n        _fnCalculateColumnWidths: _fnCalculateColumnWidths,\n        _fnThrottle: _fnThrottle,\n        _fnConvertToWidth: _fnConvertToWidth,\n        _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,\n        _fnGetWidestNode: _fnGetWidestNode,\n        _fnGetMaxLenString: _fnGetMaxLenString,\n        _fnStringToCss: _fnStringToCss,\n        _fnScrollBarWidth: _fnScrollBarWidth,\n        _fnSortFlatten: _fnSortFlatten,\n        _fnSort: _fnSort,\n        _fnSortAria: _fnSortAria,\n        _fnSortListener: _fnSortListener,\n        _fnSortAttachListener: _fnSortAttachListener,\n        _fnSortingClasses: _fnSortingClasses,\n        _fnSortData: _fnSortData,\n        _fnSaveState: _fnSaveState,\n        _fnLoadState: _fnLoadState,\n        _fnSettingsFromNode: _fnSettingsFromNode,\n        _fnLog: _fnLog,\n        _fnMap: _fnMap,\n        _fnBindAction: _fnBindAction,\n        _fnCallbackReg: _fnCallbackReg,\n        _fnCallbackFire: _fnCallbackFire,\n        _fnLengthOverflow: _fnLengthOverflow,\n        _fnRenderer: _fnRenderer,\n        _fnDataSource: _fnDataSource,\n        _fnRowAttributes: _fnRowAttributes,\n        _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant\n        // in 1.10, so this dead-end function is\n        // added to prevent errors\n      })\n\n      // jQuery access\n      $.fn.dataTable = DataTable\n\n      // Legacy aliases\n      $.fn.dataTableSettings = DataTable.settings\n      $.fn.dataTableExt = DataTable.ext\n\n      // With a capital `D` we return a DataTables API instance rather than a\n      // jQuery object\n      $.fn.DataTable = function (opts) {\n        return $(this)\n          .dataTable(opts)\n          .api()\n      }\n\n      // All properties that are available to $.fn.dataTable should also be\n      // available on $.fn.DataTable\n      $.each(DataTable, function (prop, val) {\n        $.fn.DataTable[prop] = val\n      })\n\n      // Information about events fired by DataTables - for documentation.\n      /**\n       * Draw event, fired whenever the table is redrawn on the page, at the same\n       * point as fnDrawCallback. This may be useful for binding events or\n       * performing calculations when the table is altered at all.\n       *  @name DataTable#draw.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Search event, fired when the searching applied to the table (using the\n       * built-in global search, or column filters) is altered.\n       *  @name DataTable#search.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Page change event, fired when the paging of the table is altered.\n       *  @name DataTable#page.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Order event, fired when the ordering applied to the table is altered.\n       *  @name DataTable#order.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * DataTables initialisation complete event, fired when the table is fully\n       * drawn, including Ajax data loaded, if Ajax data is required.\n       *  @name DataTable#init.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The JSON object request from the server - only\n       *    present if client-side Ajax sourced data is used</li></ol>\n       */\n\n      /**\n       * State save event, fired when the table has changed state a new state save\n       * is required. This event allows modification of the state saving object\n       * prior to actually doing the save, including addition or other state\n       * properties (for plug-ins) or modification of a DataTables core property.\n       *  @name DataTable#stateSaveParams.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The state information to be saved\n       */\n\n      /**\n       * State load event, fired when the table is loading state from the stored\n       * data, but prior to the settings object being modified by the saved state\n       * - allowing modification of the saved state is required or loading of\n       * state for a plug-in.\n       *  @name DataTable#stateLoadParams.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The saved state information\n       */\n\n      /**\n       * State loaded event, fired when state has been loaded from stored data and\n       * the settings object has been modified by the loaded data.\n       *  @name DataTable#stateLoaded.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The saved state information\n       */\n\n      /**\n       * Processing event, fired when DataTables is doing some kind of processing\n       * (be it, order, searcg or anything else). It can be used to indicate to\n       * the end user that there is something happening, or that something has\n       * finished.\n       *  @name DataTable#processing.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {boolean} bShow Flag for if DataTables is doing processing or not\n       */\n\n      /**\n       * Ajax (XHR) event, fired whenever an Ajax request is completed from a\n       * request to made to the server for new data. This event is called before\n       * DataTables processed the returned data, so it can also be used to pre-\n       * process the data returned from the server, if needed.\n       *\n       * Note that this trigger is called in `fnServerData`, if you override\n       * `fnServerData` and which to use this event, you need to trigger it in you\n       * success function.\n       *  @name DataTable#xhr.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       *  @param {object} json JSON returned from the server\n       *\n       *  @example\n       *     // Use a custom property returned from the server in another DOM element\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n       *       $('#status').html( json.status );\n       *     } );\n       *\n       *  @example\n       *     // Pre-process the data returned from the server\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n       *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {\n       *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;\n       *       }\n       *       // Note no return - manipulate the data directly in the JSON object.\n       *     } );\n       */\n\n      /**\n       * Destroy event, fired when the DataTable is destroyed by calling fnDestroy\n       * or passing the bDestroy:true parameter in the initialisation object. This\n       * can be used to remove bound events, added DOM nodes, etc.\n       *  @name DataTable#destroy.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Page length change event, fired when number of records to show on each\n       * page (the length) is changed.\n       *  @name DataTable#length.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       *  @param {integer} len New length\n       */\n\n      /**\n       * Column sizing has changed.\n       *  @name DataTable#column-sizing.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Column visibility has changed.\n       *  @name DataTable#column-visibility.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       *  @param {int} column Column index\n       *  @param {bool} vis `false` if column now hidden, or `true` if visible\n       */\n\n      return $.fn.dataTable\n    }\n  )\n})(window, document)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/jquery.dataTables.js?");

/***/ }),

/***/ "./src/public/js/vendor/jquery/jquery.js":
/*!***********************************************!*\
  !*** ./src/public/js/vendor/jquery/jquery.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v2.2.4\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-05-20T17:23Z\n */\n\n;(function (global, factory) {\n  if ( true && typeof module.exports === 'object') {\n    // For CommonJS and CommonJS-like environments where a proper `window`\n    // is present, execute the factory and get jQuery.\n    // For environments that do not have a `window` with a `document`\n    // (such as Node.js), expose a factory as module.exports.\n    // This accentuates the need for the creation of a real `window`.\n    // e.g. var jQuery = require(\"jquery\")(window);\n    // See ticket #14549 for more info.\n    module.exports = global.document\n      ? factory(global, true)\n      : function (w) {\n          if (!w.document) {\n            throw new Error('jQuery requires a window with a document')\n          }\n          return factory(w)\n        }\n  } else {\n    factory(global)\n  }\n\n  // Pass this if window is not defined yet\n})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {\n  // Support: Firefox 18+\n  // Can't be in strict mode, several libs including ASP.NET trace\n  // the stack via arguments.caller.callee and Firefox dies if\n  // you try to trace through \"use strict\" call chains. (#13335)\n  //\"use strict\";\n  var arr = []\n\n  var document = window.document\n\n  var slice = arr.slice\n\n  var concat = arr.concat\n\n  var push = arr.push\n\n  var indexOf = arr.indexOf\n\n  var class2type = {}\n\n  var toString = class2type.toString\n\n  var hasOwn = class2type.hasOwnProperty\n\n  var support = {}\n\n  var version = '2.2.4',\n    // Define a local copy of jQuery\n    jQuery = function (selector, context) {\n      // The jQuery object is actually just the init constructor 'enhanced'\n      // Need init if jQuery is called (just allow error to be thrown if not included)\n      return new jQuery.fn.init(selector, context)\n    },\n    // Support: Android<4.1\n    // Make sure we trim BOM and NBSP\n    rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n    // Matches dashed string for camelizing\n    rmsPrefix = /^-ms-/,\n    rdashAlpha = /-([\\da-z])/gi,\n    // Used by jQuery.camelCase as callback to replace()\n    fcamelCase = function (all, letter) {\n      return letter.toUpperCase()\n    }\n\n  jQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: version,\n\n    constructor: jQuery,\n\n    // Start with an empty selector\n    selector: '',\n\n    // The default length of a jQuery object is 0\n    length: 0,\n\n    toArray: function () {\n      return slice.call(this)\n    },\n\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function (num) {\n      return num != null\n        ? // Return just the one element from the set\n          num < 0\n          ? this[num + this.length]\n          : this[num]\n        : // Return all the elements in a clean array\n          slice.call(this)\n    },\n\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function (elems) {\n      // Build a new jQuery matched element set\n      var ret = jQuery.merge(this.constructor(), elems)\n\n      // Add the old object onto the stack (as a reference)\n      ret.prevObject = this\n      ret.context = this.context\n\n      // Return the newly-formed element set\n      return ret\n    },\n\n    // Execute a callback for every element in the matched set.\n    each: function (callback) {\n      return jQuery.each(this, callback)\n    },\n\n    map: function (callback) {\n      return this.pushStack(\n        jQuery.map(this, function (elem, i) {\n          return callback.call(elem, i, elem)\n        })\n      )\n    },\n\n    slice: function () {\n      return this.pushStack(slice.apply(this, arguments))\n    },\n\n    first: function () {\n      return this.eq(0)\n    },\n\n    last: function () {\n      return this.eq(-1)\n    },\n\n    eq: function (i) {\n      var len = this.length,\n        j = +i + (i < 0 ? len : 0)\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : [])\n    },\n\n    end: function () {\n      return this.prevObject || this.constructor()\n    },\n\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: push,\n    sort: arr.sort,\n    splice: arr.splice\n  }\n\n  jQuery.extend = jQuery.fn.extend = function () {\n    var options,\n      name,\n      src,\n      copy,\n      copyIsArray,\n      clone,\n      target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false\n\n    // Handle a deep copy situation\n    if (typeof target === 'boolean') {\n      deep = target\n\n      // Skip the boolean and the target\n      target = arguments[i] || {}\n      i++\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if (typeof target !== 'object' && !jQuery.isFunction(target)) {\n      target = {}\n    }\n\n    // Extend jQuery itself if only one argument is passed\n    if (i === length) {\n      target = this\n      i--\n    }\n\n    for (; i < length; i++) {\n      // Only deal with non-null/undefined values\n      if ((options = arguments[i]) != null) {\n        // Extend the base object\n        for (name in options) {\n          src = target[name]\n          copy = options[name]\n\n          // Prevent never-ending loop\n          if (target === copy) {\n            continue\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false\n              clone = src && jQuery.isArray(src) ? src : []\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {}\n            }\n\n            // Never move original objects, clone them\n            target[name] = jQuery.extend(deep, clone, copy)\n\n            // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            target[name] = copy\n          }\n        }\n      }\n    }\n\n    // Return the modified object\n    return target\n  }\n\n  jQuery.extend({\n    // Unique for each copy of jQuery on the page\n    expando: 'jQuery' + (version + Math.random()).replace(/\\D/g, ''),\n\n    // Assume jQuery is ready without the ready module\n    isReady: true,\n\n    error: function (msg) {\n      throw new Error(msg)\n    },\n\n    noop: function () {},\n\n    isFunction: function (obj) {\n      return jQuery.type(obj) === 'function'\n    },\n\n    isArray: Array.isArray,\n\n    isWindow: function (obj) {\n      return obj != null && obj === obj.window\n    },\n\n    isNumeric: function (obj) {\n      // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\n      // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n      // subtraction forces infinities to NaN\n      // adding 1 corrects loss of precision from parseFloat (#15100)\n      var realStringObj = obj && obj.toString()\n      return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0\n    },\n\n    isPlainObject: function (obj) {\n      var key\n\n      // Not plain objects:\n      // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n      // - DOM nodes\n      // - window\n      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {\n        return false\n      }\n\n      // Not own constructor property must be Object\n      if (\n        obj.constructor &&\n        !hasOwn.call(obj, 'constructor') &&\n        !hasOwn.call(obj.constructor.prototype || {}, 'isPrototypeOf')\n      ) {\n        return false\n      }\n\n      // Own properties are enumerated firstly, so to speed up,\n      // if last one is own, then all properties are own\n      for (key in obj) {\n      }\n\n      return key === undefined || hasOwn.call(obj, key)\n    },\n\n    isEmptyObject: function (obj) {\n      var name\n      for (name in obj) {\n        return false\n      }\n      return true\n    },\n\n    type: function (obj) {\n      if (obj == null) {\n        return obj + ''\n      }\n\n      // Support: Android<4.0, iOS<6 (functionish RegExp)\n      return typeof obj === 'object' || typeof obj === 'function'\n        ? class2type[toString.call(obj)] || 'object'\n        : typeof obj\n    },\n\n    // Evaluates a script in a global context\n    globalEval: function (code) {\n      var script,\n        indirect = eval\n\n      code = jQuery.trim(code)\n\n      if (code) {\n        // If the code includes a valid, prologue position\n        // strict mode pragma, execute code by injecting a\n        // script tag into the document.\n        if (code.indexOf('use strict') === 1) {\n          script = document.createElement('script')\n          script.text = code\n          document.head.appendChild(script).parentNode.removeChild(script)\n        } else {\n          // Otherwise, avoid the DOM node creation, insertion\n          // and removal by using an indirect global eval\n\n          indirect(code)\n        }\n      }\n    },\n\n    // Convert dashed to camelCase; used by the css and data modules\n    // Support: IE9-11+\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function (string) {\n      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase)\n    },\n\n    nodeName: function (elem, name) {\n      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()\n    },\n\n    each: function (obj, callback) {\n      var length,\n        i = 0\n\n      if (isArrayLike(obj)) {\n        length = obj.length\n        for (; i < length; i++) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break\n          }\n        }\n      } else {\n        for (i in obj) {\n          if (callback.call(obj[i], i, obj[i]) === false) {\n            break\n          }\n        }\n      }\n\n      return obj\n    },\n\n    // Support: Android<4.1\n    trim: function (text) {\n      return text == null ? '' : (text + '').replace(rtrim, '')\n    },\n\n    // results is for internal usage only\n    makeArray: function (arr, results) {\n      var ret = results || []\n\n      if (arr != null) {\n        if (isArrayLike(Object(arr))) {\n          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr)\n        } else {\n          push.call(ret, arr)\n        }\n      }\n\n      return ret\n    },\n\n    inArray: function (elem, arr, i) {\n      return arr == null ? -1 : indexOf.call(arr, elem, i)\n    },\n\n    merge: function (first, second) {\n      var len = +second.length,\n        j = 0,\n        i = first.length\n\n      for (; j < len; j++) {\n        first[i++] = second[j]\n      }\n\n      first.length = i\n\n      return first\n    },\n\n    grep: function (elems, callback, invert) {\n      var callbackInverse,\n        matches = [],\n        i = 0,\n        length = elems.length,\n        callbackExpect = !invert\n\n      // Go through the array, only saving the items\n      // that pass the validator function\n      for (; i < length; i++) {\n        callbackInverse = !callback(elems[i], i)\n        if (callbackInverse !== callbackExpect) {\n          matches.push(elems[i])\n        }\n      }\n\n      return matches\n    },\n\n    // arg is for internal usage only\n    map: function (elems, callback, arg) {\n      var length,\n        value,\n        i = 0,\n        ret = []\n\n      // Go through the array, translating each of the items to their new values\n      if (isArrayLike(elems)) {\n        length = elems.length\n        for (; i < length; i++) {\n          value = callback(elems[i], i, arg)\n\n          if (value != null) {\n            ret.push(value)\n          }\n        }\n\n        // Go through every key on the object,\n      } else {\n        for (i in elems) {\n          value = callback(elems[i], i, arg)\n\n          if (value != null) {\n            ret.push(value)\n          }\n        }\n      }\n\n      // Flatten any nested arrays\n      return concat.apply([], ret)\n    },\n\n    // A global GUID counter for objects\n    guid: 1,\n\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function (fn, context) {\n      var tmp, args, proxy\n\n      if (typeof context === 'string') {\n        tmp = fn[context]\n        context = fn\n        fn = tmp\n      }\n\n      // Quick check to determine if target is callable, in the spec\n      // this throws a TypeError, but we will just return undefined.\n      if (!jQuery.isFunction(fn)) {\n        return undefined\n      }\n\n      // Simulated bind\n      args = slice.call(arguments, 2)\n      proxy = function () {\n        return fn.apply(context || this, args.concat(slice.call(arguments)))\n      }\n\n      // Set the guid of unique handler to the same of original handler, so it can be removed\n      proxy.guid = fn.guid = fn.guid || jQuery.guid++\n\n      return proxy\n    },\n\n    now: Date.now,\n\n    // jQuery.support is not used in Core but other projects attach their\n    // properties to it so it needs to exist.\n    support: support\n  })\n\n  // JSHint would error on this code due to the Symbol not being defined in ES5.\n  // Defining this global in .jshintrc would create a danger of using the global\n  // unguarded in another place, it seems safer to just disable JSHint for these\n  // three lines.\n  /* jshint ignore: start */\n  if (typeof Symbol === 'function') {\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]\n  }\n  /* jshint ignore: end */\n\n  // Populate the class2type map\n  jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {\n    class2type['[object ' + name + ']'] = name.toLowerCase()\n  })\n\n  function isArrayLike (obj) {\n    // Support: iOS 8.2 (not reproducible in simulator)\n    // `in` check used to prevent JIT error (gh-2145)\n    // hasOwn isn't used here due to false negatives\n    // regarding Nodelist length in IE\n    var length = !!obj && 'length' in obj && obj.length,\n      type = jQuery.type(obj)\n\n    if (type === 'function' || jQuery.isWindow(obj)) {\n      return false\n    }\n\n    return type === 'array' || length === 0 || (typeof length === 'number' && length > 0 && length - 1 in obj)\n  }\n  var Sizzle =\n    /*!\n     * Sizzle CSS Selector Engine v2.2.1\n     * http://sizzlejs.com/\n     *\n     * Copyright jQuery Foundation and other contributors\n     * Released under the MIT license\n     * http://jquery.org/license\n     *\n     * Date: 2015-10-17\n     */\n    (function (window) {\n      var i,\n        support,\n        Expr,\n        getText,\n        isXML,\n        tokenize,\n        compile,\n        select,\n        outermostContext,\n        sortInput,\n        hasDuplicate,\n        // Local document vars\n        setDocument,\n        document,\n        docElem,\n        documentIsHTML,\n        rbuggyQSA,\n        rbuggyMatches,\n        matches,\n        contains,\n        // Instance-specific data\n        expando = 'sizzle' + 1 * new Date(),\n        preferredDoc = window.document,\n        dirruns = 0,\n        done = 0,\n        classCache = createCache(),\n        tokenCache = createCache(),\n        compilerCache = createCache(),\n        sortOrder = function (a, b) {\n          if (a === b) {\n            hasDuplicate = true\n          }\n          return 0\n        },\n        // General-purpose constants\n        MAX_NEGATIVE = 1 << 31,\n        // Instance methods\n        hasOwn = {}.hasOwnProperty,\n        arr = [],\n        pop = arr.pop,\n        push_native = arr.push,\n        push = arr.push,\n        slice = arr.slice,\n        // Use a stripped-down indexOf as it's faster than native\n        // http://jsperf.com/thor-indexof-vs-for/5\n        indexOf = function (list, elem) {\n          var i = 0,\n            len = list.length\n          for (; i < len; i++) {\n            if (list[i] === elem) {\n              return i\n            }\n          }\n          return -1\n        },\n        booleans =\n          'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',\n        // Regular expressions\n\n        // http://www.w3.org/TR/css3-selectors/#whitespace\n        whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]',\n        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n        identifier = '(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+',\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n        attributes =\n          '\\\\[' +\n          whitespace +\n          '*(' +\n          identifier +\n          ')(?:' +\n          whitespace +\n          // Operator (capture 2)\n          '*([*^$|!~]?=)' +\n          whitespace +\n          // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n          '*(?:\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\"|(' +\n          identifier +\n          '))|)' +\n          whitespace +\n          '*\\\\]',\n        pseudos =\n          ':(' +\n          identifier +\n          ')(?:\\\\((' +\n          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n          // 1. quoted (capture 3; capture 4 or capture 5)\n          '(\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\")|' +\n          // 2. simple (capture 6)\n          '((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|' +\n          attributes +\n          ')*)|' +\n          // 3. anything else (capture 2)\n          '.*' +\n          ')\\\\)|)',\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n        rwhitespace = new RegExp(whitespace + '+', 'g'),\n        rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$', 'g'),\n        rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),\n        rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'),\n        rattributeQuotes = new RegExp('=' + whitespace + '*([^\\\\]\\'\"]*?)' + whitespace + '*\\\\]', 'g'),\n        rpseudo = new RegExp(pseudos),\n        ridentifier = new RegExp('^' + identifier + '$'),\n        matchExpr = {\n          ID: new RegExp('^#(' + identifier + ')'),\n          CLASS: new RegExp('^\\\\.(' + identifier + ')'),\n          TAG: new RegExp('^(' + identifier + '|[*])'),\n          ATTR: new RegExp('^' + attributes),\n          PSEUDO: new RegExp('^' + pseudos),\n          CHILD: new RegExp(\n            '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(' +\n              whitespace +\n              '*(even|odd|(([+-]|)(\\\\d*)n|)' +\n              whitespace +\n              '*(?:([+-]|)' +\n              whitespace +\n              '*(\\\\d+)|))' +\n              whitespace +\n              '*\\\\)|)',\n            'i'\n          ),\n          bool: new RegExp('^(?:' + booleans + ')$', 'i'),\n          // For use in libraries implementing .is()\n          // We use this for POS matching in `select`\n          needsContext: new RegExp(\n            '^' +\n              whitespace +\n              '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(' +\n              whitespace +\n              '*((?:-\\\\d)?\\\\d*)' +\n              whitespace +\n              '*\\\\)|)(?=[^-]|$)',\n            'i'\n          )\n        },\n        rinputs = /^(?:input|select|textarea|button)$/i,\n        rheader = /^h\\d$/i,\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\n        rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        rsibling = /[+~]/,\n        rescape = /'|\\\\/g,\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n        runescape = new RegExp('\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'),\n        funescape = function (_, escaped, escapedWhitespace) {\n          var high = '0x' + escaped - 0x10000\n          // NaN means non-codepoint\n          // Support: Firefox<24\n          // Workaround erroneous numeric interpretation of +\"0x\"\n          return high !== high || escapedWhitespace\n            ? escaped\n            : high < 0\n            ? // BMP codepoint\n              String.fromCharCode(high + 0x10000)\n            : // Supplemental Plane codepoint (surrogate pair)\n              String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00)\n        },\n        // Used for iframes\n        // See setDocument()\n        // Removing the function wrapper causes a \"Permission Denied\"\n        // error in IE\n        unloadHandler = function () {\n          setDocument()\n        }\n\n      // Optimize for push.apply( _, NodeList )\n      try {\n        push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes)\n        // Support: Android<4.0\n        // Detect silently failing push.apply\n        arr[preferredDoc.childNodes.length].nodeType\n      } catch (e) {\n        push = {\n          apply: arr.length\n            ? // Leverage slice if possible\n              function (target, els) {\n                push_native.apply(target, slice.call(els))\n              }\n            : // Support: IE<9\n              // Otherwise append directly\n              function (target, els) {\n                var j = target.length,\n                  i = 0\n                // Can't trust NodeList.length\n                while ((target[j++] = els[i++])) {}\n                target.length = j - 1\n              }\n        }\n      }\n\n      function Sizzle (selector, context, results, seed) {\n        var m,\n          i,\n          elem,\n          nid,\n          nidselect,\n          match,\n          groups,\n          newSelector,\n          newContext = context && context.ownerDocument,\n          // nodeType defaults to 9, since context defaults to document\n          nodeType = context ? context.nodeType : 9\n\n        results = results || []\n\n        // Return early from calls with invalid selector or context\n        if (typeof selector !== 'string' || !selector || (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)) {\n          return results\n        }\n\n        // Try to shortcut find operations (as opposed to filters) in HTML documents\n        if (!seed) {\n          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n            setDocument(context)\n          }\n          context = context || document\n\n          if (documentIsHTML) {\n            // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n            // (excepting DocumentFragment context, where the methods don't exist)\n            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n              // ID selector\n              if ((m = match[1])) {\n                // Document context\n                if (nodeType === 9) {\n                  if ((elem = context.getElementById(m))) {\n                    // Support: IE, Opera, Webkit\n                    // TODO: identify versions\n                    // getElementById can match elements by name instead of ID\n                    if (elem.id === m) {\n                      results.push(elem)\n                      return results\n                    }\n                  } else {\n                    return results\n                  }\n\n                  // Element context\n                } else {\n                  // Support: IE, Opera, Webkit\n                  // TODO: identify versions\n                  // getElementById can match elements by name instead of ID\n                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n                    results.push(elem)\n                    return results\n                  }\n                }\n\n                // Type selector\n              } else if (match[2]) {\n                push.apply(results, context.getElementsByTagName(selector))\n                return results\n\n                // Class selector\n              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n                push.apply(results, context.getElementsByClassName(m))\n                return results\n              }\n            }\n\n            // Take advantage of querySelectorAll\n            if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n              if (nodeType !== 1) {\n                newContext = context\n                newSelector = selector\n\n                // qSA looks outside Element context, which is not what we want\n                // Thanks to Andrew Dupont for this workaround technique\n                // Support: IE <=8\n                // Exclude object elements\n              } else if (context.nodeName.toLowerCase() !== 'object') {\n                // Capture the context ID, setting it first if necessary\n                if ((nid = context.getAttribute('id'))) {\n                  nid = nid.replace(rescape, '\\\\$&')\n                } else {\n                  context.setAttribute('id', (nid = expando))\n                }\n\n                // Prefix every selector in the list\n                groups = tokenize(selector)\n                i = groups.length\n                nidselect = ridentifier.test(nid) ? '#' + nid : \"[id='\" + nid + \"']\"\n                while (i--) {\n                  groups[i] = nidselect + ' ' + toSelector(groups[i])\n                }\n                newSelector = groups.join(',')\n\n                // Expand context for sibling selectors\n                newContext = (rsibling.test(selector) && testContext(context.parentNode)) || context\n              }\n\n              if (newSelector) {\n                try {\n                  push.apply(results, newContext.querySelectorAll(newSelector))\n                  return results\n                } catch (qsaError) {\n                } finally {\n                  if (nid === expando) {\n                    context.removeAttribute('id')\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // All others\n        return select(selector.replace(rtrim, '$1'), context, results, seed)\n      }\n\n      /**\n       * Create key-value caches of limited size\n       * @returns {function(string, object)} Returns the Object data after storing it on itself with\n       *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n       *\tdeleting the oldest entry\n       */\n      function createCache () {\n        var keys = []\n\n        function cache (key, value) {\n          // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n          if (keys.push(key + ' ') > Expr.cacheLength) {\n            // Only keep the most recent entries\n            delete cache[keys.shift()]\n          }\n          return (cache[key + ' '] = value)\n        }\n        return cache\n      }\n\n      /**\n       * Mark a function for special use by Sizzle\n       * @param {Function} fn The function to mark\n       */\n      function markFunction (fn) {\n        fn[expando] = true\n        return fn\n      }\n\n      /**\n       * Support testing using an element\n       * @param {Function} fn Passed the created div and expects a boolean result\n       */\n      function assert (fn) {\n        var div = document.createElement('div')\n\n        try {\n          return !!fn(div)\n        } catch (e) {\n          return false\n        } finally {\n          // Remove from its parent by default\n          if (div.parentNode) {\n            div.parentNode.removeChild(div)\n          }\n          // release memory in IE\n          div = null\n        }\n      }\n\n      /**\n       * Adds the same handler for all of the specified attrs\n       * @param {String} attrs Pipe-separated list of attributes\n       * @param {Function} handler The method that will be applied\n       */\n      function addHandle (attrs, handler) {\n        var arr = attrs.split('|'),\n          i = arr.length\n\n        while (i--) {\n          Expr.attrHandle[arr[i]] = handler\n        }\n      }\n\n      /**\n       * Checks document order of two siblings\n       * @param {Element} a\n       * @param {Element} b\n       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n       */\n      function siblingCheck (a, b) {\n        var cur = b && a,\n          diff =\n            cur &&\n            a.nodeType === 1 &&\n            b.nodeType === 1 &&\n            (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE)\n\n        // Use IE sourceIndex if available on both nodes\n        if (diff) {\n          return diff\n        }\n\n        // Check if b follows a\n        if (cur) {\n          while ((cur = cur.nextSibling)) {\n            if (cur === b) {\n              return -1\n            }\n          }\n        }\n\n        return a ? 1 : -1\n      }\n\n      /**\n       * Returns a function to use in pseudos for input types\n       * @param {String} type\n       */\n      function createInputPseudo (type) {\n        return function (elem) {\n          var name = elem.nodeName.toLowerCase()\n          return name === 'input' && elem.type === type\n        }\n      }\n\n      /**\n       * Returns a function to use in pseudos for buttons\n       * @param {String} type\n       */\n      function createButtonPseudo (type) {\n        return function (elem) {\n          var name = elem.nodeName.toLowerCase()\n          return (name === 'input' || name === 'button') && elem.type === type\n        }\n      }\n\n      /**\n       * Returns a function to use in pseudos for positionals\n       * @param {Function} fn\n       */\n      function createPositionalPseudo (fn) {\n        return markFunction(function (argument) {\n          argument = +argument\n          return markFunction(function (seed, matches) {\n            var j,\n              matchIndexes = fn([], seed.length, argument),\n              i = matchIndexes.length\n\n            // Match elements found at the specified indexes\n            while (i--) {\n              if (seed[(j = matchIndexes[i])]) {\n                seed[j] = !(matches[j] = seed[j])\n              }\n            }\n          })\n        })\n      }\n\n      /**\n       * Checks a node for validity as a Sizzle context\n       * @param {Element|Object=} context\n       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n       */\n      function testContext (context) {\n        return context && typeof context.getElementsByTagName !== 'undefined' && context\n      }\n\n      // Expose support vars for convenience\n      support = Sizzle.support = {}\n\n      /**\n       * Detects XML nodes\n       * @param {Element|Object} elem An element or a document\n       * @returns {Boolean} True iff elem is a non-HTML XML node\n       */\n      isXML = Sizzle.isXML = function (elem) {\n        // documentElement is verified for cases where it doesn't yet exist\n        // (such as loading iframes in IE - #4833)\n        var documentElement = elem && (elem.ownerDocument || elem).documentElement\n        return documentElement ? documentElement.nodeName !== 'HTML' : false\n      }\n\n      /**\n       * Sets document-related variables once based on the current document\n       * @param {Element|Object} [doc] An element or document object to use to set the document\n       * @returns {Object} Returns the current document\n       */\n      setDocument = Sizzle.setDocument = function (node) {\n        var hasCompare,\n          parent,\n          doc = node ? node.ownerDocument || node : preferredDoc\n\n        // Return early if doc is invalid or already selected\n        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n          return document\n        }\n\n        // Update global variables\n        document = doc\n        docElem = document.documentElement\n        documentIsHTML = !isXML(document)\n\n        // Support: IE 9-11, Edge\n        // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n        if ((parent = document.defaultView) && parent.top !== parent) {\n          // Support: IE 11\n          if (parent.addEventListener) {\n            parent.addEventListener('unload', unloadHandler, false)\n\n            // Support: IE 9 - 10 only\n          } else if (parent.attachEvent) {\n            parent.attachEvent('onunload', unloadHandler)\n          }\n        }\n\n        /* Attributes\n\t---------------------------------------------------------------------- */\n\n        // Support: IE<8\n        // Verify that getAttribute really returns attributes and not properties\n        // (excepting IE8 booleans)\n        support.attributes = assert(function (div) {\n          div.className = 'i'\n          return !div.getAttribute('className')\n        })\n\n        /* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n        // Check if getElementsByTagName(\"*\") returns only elements\n        support.getElementsByTagName = assert(function (div) {\n          div.appendChild(document.createComment(''))\n          return !div.getElementsByTagName('*').length\n        })\n\n        // Support: IE<9\n        support.getElementsByClassName = rnative.test(document.getElementsByClassName)\n\n        // Support: IE<10\n        // Check if getElementById returns elements by name\n        // The broken getElementById methods don't pick up programatically-set names,\n        // so use a roundabout getElementsByName test\n        support.getById = assert(function (div) {\n          docElem.appendChild(div).id = expando\n          return !document.getElementsByName || !document.getElementsByName(expando).length\n        })\n\n        // ID find and filter\n        if (support.getById) {\n          Expr.find['ID'] = function (id, context) {\n            if (typeof context.getElementById !== 'undefined' && documentIsHTML) {\n              var m = context.getElementById(id)\n              return m ? [m] : []\n            }\n          }\n          Expr.filter['ID'] = function (id) {\n            var attrId = id.replace(runescape, funescape)\n            return function (elem) {\n              return elem.getAttribute('id') === attrId\n            }\n          }\n        } else {\n          // Support: IE6/7\n          // getElementById is not reliable as a find shortcut\n          delete Expr.find['ID']\n\n          Expr.filter['ID'] = function (id) {\n            var attrId = id.replace(runescape, funescape)\n            return function (elem) {\n              var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id')\n              return node && node.value === attrId\n            }\n          }\n        }\n\n        // Tag\n        Expr.find['TAG'] = support.getElementsByTagName\n          ? function (tag, context) {\n              if (typeof context.getElementsByTagName !== 'undefined') {\n                return context.getElementsByTagName(tag)\n\n                // DocumentFragment nodes don't have gEBTN\n              } else if (support.qsa) {\n                return context.querySelectorAll(tag)\n              }\n            }\n          : function (tag, context) {\n              var elem,\n                tmp = [],\n                i = 0,\n                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n                results = context.getElementsByTagName(tag)\n\n              // Filter out possible comments\n              if (tag === '*') {\n                while ((elem = results[i++])) {\n                  if (elem.nodeType === 1) {\n                    tmp.push(elem)\n                  }\n                }\n\n                return tmp\n              }\n              return results\n            }\n\n        // Class\n        Expr.find['CLASS'] =\n          support.getElementsByClassName &&\n          function (className, context) {\n            if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {\n              return context.getElementsByClassName(className)\n            }\n          }\n\n        /* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n        // QSA and matchesSelector support\n\n        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n        rbuggyMatches = []\n\n        // qSa(:focus) reports false when true (Chrome 21)\n        // We allow this because of a bug in IE8/9 that throws an error\n        // whenever `document.activeElement` is accessed on an iframe\n        // So, we allow :focus to pass through QSA all the time to avoid the IE error\n        // See http://bugs.jquery.com/ticket/13378\n        rbuggyQSA = []\n\n        if ((support.qsa = rnative.test(document.querySelectorAll))) {\n          // Build QSA regex\n          // Regex strategy adopted from Diego Perini\n          assert(function (div) {\n            // Select is set to empty string on purpose\n            // This is to test IE's treatment of not explicitly\n            // setting a boolean content attribute,\n            // since its presence should be enough\n            // http://bugs.jquery.com/ticket/12359\n            docElem.appendChild(div).innerHTML =\n              \"<a id='\" +\n              expando +\n              \"'></a>\" +\n              \"<select id='\" +\n              expando +\n              \"-\\r\\\\' msallowcapture=''>\" +\n              \"<option selected=''></option></select>\"\n\n            // Support: IE8, Opera 11-12.16\n            // Nothing should be selected when empty strings follow ^= or $= or *=\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\n            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n            if (div.querySelectorAll(\"[msallowcapture^='']\").length) {\n              rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\\'\\'|\"\")')\n            }\n\n            // Support: IE8\n            // Boolean attributes and \"value\" are not treated correctly\n            if (!div.querySelectorAll('[selected]').length) {\n              rbuggyQSA.push('\\\\[' + whitespace + '*(?:value|' + booleans + ')')\n            }\n\n            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n            if (!div.querySelectorAll('[id~=' + expando + '-]').length) {\n              rbuggyQSA.push('~=')\n            }\n\n            // Webkit/Opera - :checked should return selected option elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            // IE8 throws error here and will not see later tests\n            if (!div.querySelectorAll(':checked').length) {\n              rbuggyQSA.push(':checked')\n            }\n\n            // Support: Safari 8+, iOS 8+\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\n            // In-page `selector#id sibing-combinator selector` fails\n            if (!div.querySelectorAll('a#' + expando + '+*').length) {\n              rbuggyQSA.push('.#.+[+~]')\n            }\n          })\n\n          assert(function (div) {\n            // Support: Windows 8 Native Apps\n            // The type and name attributes are restricted during .innerHTML assignment\n            var input = document.createElement('input')\n            input.setAttribute('type', 'hidden')\n            div.appendChild(input).setAttribute('name', 'D')\n\n            // Support: IE8\n            // Enforce case-sensitivity of name attribute\n            if (div.querySelectorAll('[name=d]').length) {\n              rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=')\n            }\n\n            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n            // IE8 throws error here and will not see later tests\n            if (!div.querySelectorAll(':enabled').length) {\n              rbuggyQSA.push(':enabled', ':disabled')\n            }\n\n            // Opera 10-11 does not throw on post-comma invalid pseudos\n            div.querySelectorAll('*,:x')\n            rbuggyQSA.push(',.*:')\n          })\n        }\n\n        if (\n          (support.matchesSelector = rnative.test(\n            (matches =\n              docElem.matches ||\n              docElem.webkitMatchesSelector ||\n              docElem.mozMatchesSelector ||\n              docElem.oMatchesSelector ||\n              docElem.msMatchesSelector)\n          ))\n        ) {\n          assert(function (div) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9)\n            support.disconnectedMatch = matches.call(div, 'div')\n\n            // This should fail with an exception\n            // Gecko does not error, returns false instead\n            matches.call(div, \"[s!='']:x\")\n            rbuggyMatches.push('!=', pseudos)\n          })\n        }\n\n        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'))\n        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'))\n\n        /* Contains\n\t---------------------------------------------------------------------- */\n        hasCompare = rnative.test(docElem.compareDocumentPosition)\n\n        // Element contains another\n        // Purposefully self-exclusive\n        // As in, an element does not contain itself\n        contains =\n          hasCompare || rnative.test(docElem.contains)\n            ? function (a, b) {\n                var adown = a.nodeType === 9 ? a.documentElement : a,\n                  bup = b && b.parentNode\n                return (\n                  a === bup ||\n                  !!(\n                    bup &&\n                    bup.nodeType === 1 &&\n                    (adown.contains\n                      ? adown.contains(bup)\n                      : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)\n                  )\n                )\n              }\n            : function (a, b) {\n                if (b) {\n                  while ((b = b.parentNode)) {\n                    if (b === a) {\n                      return true\n                    }\n                  }\n                }\n                return false\n              }\n\n        /* Sorting\n\t---------------------------------------------------------------------- */\n\n        // Document order sorting\n        sortOrder = hasCompare\n          ? function (a, b) {\n              // Flag for duplicate removal\n              if (a === b) {\n                hasDuplicate = true\n                return 0\n              }\n\n              // Sort on method existence if only one input has compareDocumentPosition\n              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition\n              if (compare) {\n                return compare\n              }\n\n              // Calculate position if both inputs belong to the same document\n              compare =\n                (a.ownerDocument || a) === (b.ownerDocument || b)\n                  ? a.compareDocumentPosition(b)\n                  : // Otherwise we know they are disconnected\n                    1\n\n              // Disconnected nodes\n              if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {\n                // Choose the first element that is related to our preferred document\n                if (a === document || (a.ownerDocument === preferredDoc && contains(preferredDoc, a))) {\n                  return -1\n                }\n                if (b === document || (b.ownerDocument === preferredDoc && contains(preferredDoc, b))) {\n                  return 1\n                }\n\n                // Maintain original order\n                return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0\n              }\n\n              return compare & 4 ? -1 : 1\n            }\n          : function (a, b) {\n              // Exit early if the nodes are identical\n              if (a === b) {\n                hasDuplicate = true\n                return 0\n              }\n\n              var cur,\n                i = 0,\n                aup = a.parentNode,\n                bup = b.parentNode,\n                ap = [a],\n                bp = [b]\n\n              // Parentless nodes are either documents or disconnected\n              if (!aup || !bup) {\n                return a === document\n                  ? -1\n                  : b === document\n                  ? 1\n                  : aup\n                  ? -1\n                  : bup\n                  ? 1\n                  : sortInput\n                  ? indexOf(sortInput, a) - indexOf(sortInput, b)\n                  : 0\n\n                // If the nodes are siblings, we can do a quick check\n              } else if (aup === bup) {\n                return siblingCheck(a, b)\n              }\n\n              // Otherwise we need full lists of their ancestors for comparison\n              cur = a\n              while ((cur = cur.parentNode)) {\n                ap.unshift(cur)\n              }\n              cur = b\n              while ((cur = cur.parentNode)) {\n                bp.unshift(cur)\n              }\n\n              // Walk down the tree looking for a discrepancy\n              while (ap[i] === bp[i]) {\n                i++\n              }\n\n              return i\n                ? // Do a sibling check if the nodes have a common ancestor\n                  siblingCheck(ap[i], bp[i])\n                : // Otherwise nodes in our document sort first\n                ap[i] === preferredDoc\n                ? -1\n                : bp[i] === preferredDoc\n                ? 1\n                : 0\n            }\n\n        return document\n      }\n\n      Sizzle.matches = function (expr, elements) {\n        return Sizzle(expr, null, null, elements)\n      }\n\n      Sizzle.matchesSelector = function (elem, expr) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem)\n        }\n\n        // Make sure that attribute selectors are quoted\n        expr = expr.replace(rattributeQuotes, \"='$1']\")\n\n        if (\n          support.matchesSelector &&\n          documentIsHTML &&\n          !compilerCache[expr + ' '] &&\n          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&\n          (!rbuggyQSA || !rbuggyQSA.test(expr))\n        ) {\n          try {\n            var ret = matches.call(elem, expr)\n\n            // IE 9's matchesSelector returns false on disconnected nodes\n            if (\n              ret ||\n              support.disconnectedMatch ||\n              // As well, disconnected nodes are said to be in a document\n              // fragment in IE 9\n              (elem.document && elem.document.nodeType !== 11)\n            ) {\n              return ret\n            }\n          } catch (e) {}\n        }\n\n        return Sizzle(expr, document, null, [elem]).length > 0\n      }\n\n      Sizzle.contains = function (context, elem) {\n        // Set document vars if needed\n        if ((context.ownerDocument || context) !== document) {\n          setDocument(context)\n        }\n        return contains(context, elem)\n      }\n\n      Sizzle.attr = function (elem, name) {\n        // Set document vars if needed\n        if ((elem.ownerDocument || elem) !== document) {\n          setDocument(elem)\n        }\n\n        var fn = Expr.attrHandle[name.toLowerCase()],\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\n          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined\n\n        return val !== undefined\n          ? val\n          : support.attributes || !documentIsHTML\n          ? elem.getAttribute(name)\n          : (val = elem.getAttributeNode(name)) && val.specified\n          ? val.value\n          : null\n      }\n\n      Sizzle.error = function (msg) {\n        throw new Error('Syntax error, unrecognized expression: ' + msg)\n      }\n\n      /**\n       * Document sorting and removing duplicates\n       * @param {ArrayLike} results\n       */\n      Sizzle.uniqueSort = function (results) {\n        var elem,\n          duplicates = [],\n          j = 0,\n          i = 0\n\n        // Unless we *know* we can detect duplicates, assume their presence\n        hasDuplicate = !support.detectDuplicates\n        sortInput = !support.sortStable && results.slice(0)\n        results.sort(sortOrder)\n\n        if (hasDuplicate) {\n          while ((elem = results[i++])) {\n            if (elem === results[i]) {\n              j = duplicates.push(i)\n            }\n          }\n          while (j--) {\n            results.splice(duplicates[j], 1)\n          }\n        }\n\n        // Clear input after sorting to release objects\n        // See https://github.com/jquery/sizzle/pull/225\n        sortInput = null\n\n        return results\n      }\n\n      /**\n       * Utility function for retrieving the text value of an array of DOM nodes\n       * @param {Array|Element} elem\n       */\n      getText = Sizzle.getText = function (elem) {\n        var node,\n          ret = '',\n          i = 0,\n          nodeType = elem.nodeType\n\n        if (!nodeType) {\n          // If no nodeType, this is expected to be an array\n          while ((node = elem[i++])) {\n            // Do not traverse comment nodes\n            ret += getText(node)\n          }\n        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n          // Use textContent for elements\n          // innerText usage removed for consistency of new lines (jQuery #11153)\n          if (typeof elem.textContent === 'string') {\n            return elem.textContent\n          } else {\n            // Traverse its children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              ret += getText(elem)\n            }\n          }\n        } else if (nodeType === 3 || nodeType === 4) {\n          return elem.nodeValue\n        }\n        // Do not include comment or processing instruction nodes\n\n        return ret\n      }\n\n      Expr = Sizzle.selectors = {\n        // Can be adjusted by the user\n        cacheLength: 50,\n\n        createPseudo: markFunction,\n\n        match: matchExpr,\n\n        attrHandle: {},\n\n        find: {},\n\n        relative: {\n          '>': { dir: 'parentNode', first: true },\n          ' ': { dir: 'parentNode' },\n          '+': { dir: 'previousSibling', first: true },\n          '~': { dir: 'previousSibling' }\n        },\n\n        preFilter: {\n          ATTR: function (match) {\n            match[1] = match[1].replace(runescape, funescape)\n\n            // Move the given value to match[3] whether quoted or unquoted\n            match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape)\n\n            if (match[2] === '~=') {\n              match[3] = ' ' + match[3] + ' '\n            }\n\n            return match.slice(0, 4)\n          },\n\n          CHILD: function (match) {\n            /* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n            match[1] = match[1].toLowerCase()\n\n            if (match[1].slice(0, 3) === 'nth') {\n              // nth-* requires argument\n              if (!match[3]) {\n                Sizzle.error(match[0])\n              }\n\n              // numeric x and y parameters for Expr.filter.CHILD\n              // remember that false/true cast respectively to 0/1\n              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'))\n              match[5] = +(match[7] + match[8] || match[3] === 'odd')\n\n              // other types prohibit arguments\n            } else if (match[3]) {\n              Sizzle.error(match[0])\n            }\n\n            return match\n          },\n\n          PSEUDO: function (match) {\n            var excess,\n              unquoted = !match[6] && match[2]\n\n            if (matchExpr['CHILD'].test(match[0])) {\n              return null\n            }\n\n            // Accept quoted arguments as-is\n            if (match[3]) {\n              match[2] = match[4] || match[5] || ''\n\n              // Strip excess characters from unquoted arguments\n            } else if (\n              unquoted &&\n              rpseudo.test(unquoted) &&\n              // Get excess from tokenize (recursively)\n              (excess = tokenize(unquoted, true)) &&\n              // advance to the next closing parenthesis\n              (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)\n            ) {\n              // excess is a negative index\n              match[0] = match[0].slice(0, excess)\n              match[2] = unquoted.slice(0, excess)\n            }\n\n            // Return only captures needed by the pseudo filter method (type and argument)\n            return match.slice(0, 3)\n          }\n        },\n\n        filter: {\n          TAG: function (nodeNameSelector) {\n            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase()\n            return nodeNameSelector === '*'\n              ? function () {\n                  return true\n                }\n              : function (elem) {\n                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName\n                }\n          },\n\n          CLASS: function (className) {\n            var pattern = classCache[className + ' ']\n\n            return (\n              pattern ||\n              ((pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) &&\n                classCache(className, function (elem) {\n                  return pattern.test(\n                    (typeof elem.className === 'string' && elem.className) ||\n                      (typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class')) ||\n                      ''\n                  )\n                }))\n            )\n          },\n\n          ATTR: function (name, operator, check) {\n            return function (elem) {\n              var result = Sizzle.attr(elem, name)\n\n              if (result == null) {\n                return operator === '!='\n              }\n              if (!operator) {\n                return true\n              }\n\n              result += ''\n\n              return operator === '='\n                ? result === check\n                : operator === '!='\n                ? result !== check\n                : operator === '^='\n                ? check && result.indexOf(check) === 0\n                : operator === '*='\n                ? check && result.indexOf(check) > -1\n                : operator === '$='\n                ? check && result.slice(-check.length) === check\n                : operator === '~='\n                ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1\n                : operator === '|='\n                ? result === check || result.slice(0, check.length + 1) === check + '-'\n                : false\n            }\n          },\n\n          CHILD: function (type, what, argument, first, last) {\n            var simple = type.slice(0, 3) !== 'nth',\n              forward = type.slice(-4) !== 'last',\n              ofType = what === 'of-type'\n\n            return first === 1 && last === 0\n              ? // Shortcut for :nth-*(n)\n                function (elem) {\n                  return !!elem.parentNode\n                }\n              : function (elem, context, xml) {\n                  var cache,\n                    uniqueCache,\n                    outerCache,\n                    node,\n                    nodeIndex,\n                    start,\n                    dir = simple !== forward ? 'nextSibling' : 'previousSibling',\n                    parent = elem.parentNode,\n                    name = ofType && elem.nodeName.toLowerCase(),\n                    useCache = !xml && !ofType,\n                    diff = false\n\n                  if (parent) {\n                    // :(first|last|only)-(child|of-type)\n                    if (simple) {\n                      while (dir) {\n                        node = elem\n                        while ((node = node[dir])) {\n                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n                            return false\n                          }\n                        }\n                        // Reverse direction for :only-* (if we haven't yet done so)\n                        start = dir = type === 'only' && !start && 'nextSibling'\n                      }\n                      return true\n                    }\n\n                    start = [forward ? parent.firstChild : parent.lastChild]\n\n                    // non-xml :nth-child(...) stores cache data on `parent`\n                    if (forward && useCache) {\n                      // Seek `elem` from a previously-cached index\n\n                      // ...in a gzip-friendly way\n                      node = parent\n                      outerCache = node[expando] || (node[expando] = {})\n\n                      // Support: IE <9 only\n                      // Defend against cloned attroperties (jQuery gh-1709)\n                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {})\n\n                      cache = uniqueCache[type] || []\n                      nodeIndex = cache[0] === dirruns && cache[1]\n                      diff = nodeIndex && cache[2]\n                      node = nodeIndex && parent.childNodes[nodeIndex]\n\n                      while (\n                        (node =\n                          (++nodeIndex && node && node[dir]) ||\n                          // Fallback to seeking `elem` from the start\n                          (diff = nodeIndex = 0) ||\n                          start.pop())\n                      ) {\n                        // When found, cache indexes on `parent` and break\n                        if (node.nodeType === 1 && ++diff && node === elem) {\n                          uniqueCache[type] = [dirruns, nodeIndex, diff]\n                          break\n                        }\n                      }\n                    } else {\n                      // Use previously-cached element index if available\n                      if (useCache) {\n                        // ...in a gzip-friendly way\n                        node = elem\n                        outerCache = node[expando] || (node[expando] = {})\n\n                        // Support: IE <9 only\n                        // Defend against cloned attroperties (jQuery gh-1709)\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {})\n\n                        cache = uniqueCache[type] || []\n                        nodeIndex = cache[0] === dirruns && cache[1]\n                        diff = nodeIndex\n                      }\n\n                      // xml :nth-child(...)\n                      // or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                      if (diff === false) {\n                        // Use the same loop as above to seek `elem` from the start\n                        while ((node = (++nodeIndex && node && node[dir]) || (diff = nodeIndex = 0) || start.pop())) {\n                          if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n                            // Cache the index of each encountered element\n                            if (useCache) {\n                              outerCache = node[expando] || (node[expando] = {})\n\n                              // Support: IE <9 only\n                              // Defend against cloned attroperties (jQuery gh-1709)\n                              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {})\n\n                              uniqueCache[type] = [dirruns, diff]\n                            }\n\n                            if (node === elem) {\n                              break\n                            }\n                          }\n                        }\n                      }\n                    }\n\n                    // Incorporate the offset, then check against cycle size\n                    diff -= last\n                    return diff === first || (diff % first === 0 && diff / first >= 0)\n                  }\n                }\n          },\n\n          PSEUDO: function (pseudo, argument) {\n            // pseudo-class names are case-insensitive\n            // http://www.w3.org/TR/selectors/#pseudo-classes\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n            // Remember that setFilters inherits from pseudos\n            var args,\n              fn =\n                Expr.pseudos[pseudo] ||\n                Expr.setFilters[pseudo.toLowerCase()] ||\n                Sizzle.error('unsupported pseudo: ' + pseudo)\n\n            // The user may use createPseudo to indicate that\n            // arguments are needed to create the filter function\n            // just as Sizzle does\n            if (fn[expando]) {\n              return fn(argument)\n            }\n\n            // But maintain support for old signatures\n            if (fn.length > 1) {\n              args = [pseudo, pseudo, '', argument]\n              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())\n                ? markFunction(function (seed, matches) {\n                    var idx,\n                      matched = fn(seed, argument),\n                      i = matched.length\n                    while (i--) {\n                      idx = indexOf(seed, matched[i])\n                      seed[idx] = !(matches[idx] = matched[i])\n                    }\n                  })\n                : function (elem) {\n                    return fn(elem, 0, args)\n                  }\n            }\n\n            return fn\n          }\n        },\n\n        pseudos: {\n          // Potentially complex pseudos\n          not: markFunction(function (selector) {\n            // Trim the selector passed to compile\n            // to avoid treating leading and trailing\n            // spaces as combinators\n            var input = [],\n              results = [],\n              matcher = compile(selector.replace(rtrim, '$1'))\n\n            return matcher[expando]\n              ? markFunction(function (seed, matches, context, xml) {\n                  var elem,\n                    unmatched = matcher(seed, null, xml, []),\n                    i = seed.length\n\n                  // Match elements unmatched by `matcher`\n                  while (i--) {\n                    if ((elem = unmatched[i])) {\n                      seed[i] = !(matches[i] = elem)\n                    }\n                  }\n                })\n              : function (elem, context, xml) {\n                  input[0] = elem\n                  matcher(input, null, xml, results)\n                  // Don't keep the element (issue #299)\n                  input[0] = null\n                  return !results.pop()\n                }\n          }),\n\n          has: markFunction(function (selector) {\n            return function (elem) {\n              return Sizzle(selector, elem).length > 0\n            }\n          }),\n\n          contains: markFunction(function (text) {\n            text = text.replace(runescape, funescape)\n            return function (elem) {\n              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1\n            }\n          }),\n\n          // \"Whether an element is represented by a :lang() selector\n          // is based solely on the element's language value\n          // being equal to the identifier C,\n          // or beginning with the identifier C immediately followed by \"-\".\n          // The matching of C against the element's language value is performed case-insensitively.\n          // The identifier C does not have to be a valid language name.\"\n          // http://www.w3.org/TR/selectors/#lang-pseudo\n          lang: markFunction(function (lang) {\n            // lang value must be a valid identifier\n            if (!ridentifier.test(lang || '')) {\n              Sizzle.error('unsupported lang: ' + lang)\n            }\n            lang = lang.replace(runescape, funescape).toLowerCase()\n            return function (elem) {\n              var elemLang\n              do {\n                if (\n                  (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang'))\n                ) {\n                  elemLang = elemLang.toLowerCase()\n                  return elemLang === lang || elemLang.indexOf(lang + '-') === 0\n                }\n              } while ((elem = elem.parentNode) && elem.nodeType === 1)\n              return false\n            }\n          }),\n\n          // Miscellaneous\n          target: function (elem) {\n            var hash = window.location && window.location.hash\n            return hash && hash.slice(1) === elem.id\n          },\n\n          root: function (elem) {\n            return elem === docElem\n          },\n\n          focus: function (elem) {\n            return (\n              elem === document.activeElement &&\n              (!document.hasFocus || document.hasFocus()) &&\n              !!(elem.type || elem.href || ~elem.tabIndex)\n            )\n          },\n\n          // Boolean properties\n          enabled: function (elem) {\n            return elem.disabled === false\n          },\n\n          disabled: function (elem) {\n            return elem.disabled === true\n          },\n\n          checked: function (elem) {\n            // In CSS3, :checked should return both checked and selected elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            var nodeName = elem.nodeName.toLowerCase()\n            return (nodeName === 'input' && !!elem.checked) || (nodeName === 'option' && !!elem.selected)\n          },\n\n          selected: function (elem) {\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            if (elem.parentNode) {\n              elem.parentNode.selectedIndex\n            }\n\n            return elem.selected === true\n          },\n\n          // Contents\n          empty: function (elem) {\n            // http://www.w3.org/TR/selectors/#empty-pseudo\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\n            // nodeType < 6 works because attributes (2) do not appear as children\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n              if (elem.nodeType < 6) {\n                return false\n              }\n            }\n            return true\n          },\n\n          parent: function (elem) {\n            return !Expr.pseudos['empty'](elem)\n          },\n\n          // Element/input types\n          header: function (elem) {\n            return rheader.test(elem.nodeName)\n          },\n\n          input: function (elem) {\n            return rinputs.test(elem.nodeName)\n          },\n\n          button: function (elem) {\n            var name = elem.nodeName.toLowerCase()\n            return (name === 'input' && elem.type === 'button') || name === 'button'\n          },\n\n          text: function (elem) {\n            var attr\n            return (\n              elem.nodeName.toLowerCase() === 'input' &&\n              elem.type === 'text' &&\n              // Support: IE<8\n              // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n              ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text')\n            )\n          },\n\n          // Position-in-collection\n          first: createPositionalPseudo(function () {\n            return [0]\n          }),\n\n          last: createPositionalPseudo(function (matchIndexes, length) {\n            return [length - 1]\n          }),\n\n          eq: createPositionalPseudo(function (matchIndexes, length, argument) {\n            return [argument < 0 ? argument + length : argument]\n          }),\n\n          even: createPositionalPseudo(function (matchIndexes, length) {\n            var i = 0\n            for (; i < length; i += 2) {\n              matchIndexes.push(i)\n            }\n            return matchIndexes\n          }),\n\n          odd: createPositionalPseudo(function (matchIndexes, length) {\n            var i = 1\n            for (; i < length; i += 2) {\n              matchIndexes.push(i)\n            }\n            return matchIndexes\n          }),\n\n          lt: createPositionalPseudo(function (matchIndexes, length, argument) {\n            var i = argument < 0 ? argument + length : argument\n            for (; --i >= 0; ) {\n              matchIndexes.push(i)\n            }\n            return matchIndexes\n          }),\n\n          gt: createPositionalPseudo(function (matchIndexes, length, argument) {\n            var i = argument < 0 ? argument + length : argument\n            for (; ++i < length; ) {\n              matchIndexes.push(i)\n            }\n            return matchIndexes\n          })\n        }\n      }\n\n      Expr.pseudos['nth'] = Expr.pseudos['eq']\n\n      // Add button/input type pseudos\n      for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\n        Expr.pseudos[i] = createInputPseudo(i)\n      }\n      for (i in { submit: true, reset: true }) {\n        Expr.pseudos[i] = createButtonPseudo(i)\n      }\n\n      // Easy API for creating new setFilters\n      function setFilters () {}\n      setFilters.prototype = Expr.filters = Expr.pseudos\n      Expr.setFilters = new setFilters()\n\n      tokenize = Sizzle.tokenize = function (selector, parseOnly) {\n        var matched,\n          match,\n          tokens,\n          type,\n          soFar,\n          groups,\n          preFilters,\n          cached = tokenCache[selector + ' ']\n\n        if (cached) {\n          return parseOnly ? 0 : cached.slice(0)\n        }\n\n        soFar = selector\n        groups = []\n        preFilters = Expr.preFilter\n\n        while (soFar) {\n          // Comma and first run\n          if (!matched || (match = rcomma.exec(soFar))) {\n            if (match) {\n              // Don't consume trailing commas as valid\n              soFar = soFar.slice(match[0].length) || soFar\n            }\n            groups.push((tokens = []))\n          }\n\n          matched = false\n\n          // Combinators\n          if ((match = rcombinators.exec(soFar))) {\n            matched = match.shift()\n            tokens.push({\n              value: matched,\n              // Cast descendant combinators to space\n              type: match[0].replace(rtrim, ' ')\n            })\n            soFar = soFar.slice(matched.length)\n          }\n\n          // Filters\n          for (type in Expr.filter) {\n            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n              matched = match.shift()\n              tokens.push({\n                value: matched,\n                type: type,\n                matches: match\n              })\n              soFar = soFar.slice(matched.length)\n            }\n          }\n\n          if (!matched) {\n            break\n          }\n        }\n\n        // Return the length of the invalid excess\n        // if we're just parsing\n        // Otherwise, throw an error or return tokens\n        return parseOnly\n          ? soFar.length\n          : soFar\n          ? Sizzle.error(selector)\n          : // Cache the tokens\n            tokenCache(selector, groups).slice(0)\n      }\n\n      function toSelector (tokens) {\n        var i = 0,\n          len = tokens.length,\n          selector = ''\n        for (; i < len; i++) {\n          selector += tokens[i].value\n        }\n        return selector\n      }\n\n      function addCombinator (matcher, combinator, base) {\n        var dir = combinator.dir,\n          checkNonElements = base && dir === 'parentNode',\n          doneName = done++\n\n        return combinator.first\n          ? // Check against closest ancestor/preceding element\n            function (elem, context, xml) {\n              while ((elem = elem[dir])) {\n                if (elem.nodeType === 1 || checkNonElements) {\n                  return matcher(elem, context, xml)\n                }\n              }\n            }\n          : // Check against all ancestor/preceding elements\n            function (elem, context, xml) {\n              var oldCache,\n                uniqueCache,\n                outerCache,\n                newCache = [dirruns, doneName]\n\n              // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n              if (xml) {\n                while ((elem = elem[dir])) {\n                  if (elem.nodeType === 1 || checkNonElements) {\n                    if (matcher(elem, context, xml)) {\n                      return true\n                    }\n                  }\n                }\n              } else {\n                while ((elem = elem[dir])) {\n                  if (elem.nodeType === 1 || checkNonElements) {\n                    outerCache = elem[expando] || (elem[expando] = {})\n\n                    // Support: IE <9 only\n                    // Defend against cloned attroperties (jQuery gh-1709)\n                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {})\n\n                    if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n                      // Assign to newCache so results back-propagate to previous elements\n                      return (newCache[2] = oldCache[2])\n                    } else {\n                      // Reuse newcache so results back-propagate to previous elements\n                      uniqueCache[dir] = newCache\n\n                      // A match means we're done; a fail means we have to keep checking\n                      if ((newCache[2] = matcher(elem, context, xml))) {\n                        return true\n                      }\n                    }\n                  }\n                }\n              }\n            }\n      }\n\n      function elementMatcher (matchers) {\n        return matchers.length > 1\n          ? function (elem, context, xml) {\n              var i = matchers.length\n              while (i--) {\n                if (!matchers[i](elem, context, xml)) {\n                  return false\n                }\n              }\n              return true\n            }\n          : matchers[0]\n      }\n\n      function multipleContexts (selector, contexts, results) {\n        var i = 0,\n          len = contexts.length\n        for (; i < len; i++) {\n          Sizzle(selector, contexts[i], results)\n        }\n        return results\n      }\n\n      function condense (unmatched, map, filter, context, xml) {\n        var elem,\n          newUnmatched = [],\n          i = 0,\n          len = unmatched.length,\n          mapped = map != null\n\n        for (; i < len; i++) {\n          if ((elem = unmatched[i])) {\n            if (!filter || filter(elem, context, xml)) {\n              newUnmatched.push(elem)\n              if (mapped) {\n                map.push(i)\n              }\n            }\n          }\n        }\n\n        return newUnmatched\n      }\n\n      function setMatcher (preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n        if (postFilter && !postFilter[expando]) {\n          postFilter = setMatcher(postFilter)\n        }\n        if (postFinder && !postFinder[expando]) {\n          postFinder = setMatcher(postFinder, postSelector)\n        }\n        return markFunction(function (seed, results, context, xml) {\n          var temp,\n            i,\n            elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n            // Get initial elements from seed or context\n            elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n            matcherOut = matcher\n              ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n                postFinder || (seed ? preFilter : preexisting || postFilter)\n                ? // ...intermediate processing is necessary\n                  []\n                : // ...otherwise use results directly\n                  results\n              : matcherIn\n\n          // Find primary matches\n          if (matcher) {\n            matcher(matcherIn, matcherOut, context, xml)\n          }\n\n          // Apply postFilter\n          if (postFilter) {\n            temp = condense(matcherOut, postMap)\n            postFilter(temp, [], context, xml)\n\n            // Un-match failing elements by moving them back to matcherIn\n            i = temp.length\n            while (i--) {\n              if ((elem = temp[i])) {\n                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)\n              }\n            }\n          }\n\n          if (seed) {\n            if (postFinder || preFilter) {\n              if (postFinder) {\n                // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                temp = []\n                i = matcherOut.length\n                while (i--) {\n                  if ((elem = matcherOut[i])) {\n                    // Restore matcherIn since elem is not yet a final match\n                    temp.push((matcherIn[i] = elem))\n                  }\n                }\n                postFinder(null, (matcherOut = []), temp, xml)\n              }\n\n              // Move matched elements from seed to results to keep them synchronized\n              i = matcherOut.length\n              while (i--) {\n                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n                  seed[temp] = !(results[temp] = elem)\n                }\n              }\n            }\n\n            // Add elements to results, through postFinder if defined\n          } else {\n            matcherOut = condense(\n              matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut\n            )\n            if (postFinder) {\n              postFinder(null, results, matcherOut, xml)\n            } else {\n              push.apply(results, matcherOut)\n            }\n          }\n        })\n      }\n\n      function matcherFromTokens (tokens) {\n        var checkContext,\n          matcher,\n          j,\n          len = tokens.length,\n          leadingRelative = Expr.relative[tokens[0].type],\n          implicitRelative = leadingRelative || Expr.relative[' '],\n          i = leadingRelative ? 1 : 0,\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\n          matchContext = addCombinator(\n            function (elem) {\n              return elem === checkContext\n            },\n            implicitRelative,\n            true\n          ),\n          matchAnyContext = addCombinator(\n            function (elem) {\n              return indexOf(checkContext, elem) > -1\n            },\n            implicitRelative,\n            true\n          ),\n          matchers = [\n            function (elem, context, xml) {\n              var ret =\n                (!leadingRelative && (xml || context !== outermostContext)) ||\n                ((checkContext = context).nodeType\n                  ? matchContext(elem, context, xml)\n                  : matchAnyContext(elem, context, xml))\n              // Avoid hanging onto element (issue #299)\n              checkContext = null\n              return ret\n            }\n          ]\n\n        for (; i < len; i++) {\n          if ((matcher = Expr.relative[tokens[i].type])) {\n            matchers = [addCombinator(elementMatcher(matchers), matcher)]\n          } else {\n            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches)\n\n            // Return special upon seeing a positional matcher\n            if (matcher[expando]) {\n              // Find the next relative operator (if any) for proper handling\n              j = ++i\n              for (; j < len; j++) {\n                if (Expr.relative[tokens[j].type]) {\n                  break\n                }\n              }\n              return setMatcher(\n                i > 1 && elementMatcher(matchers),\n                i > 1 &&\n                  toSelector(\n                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                    tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })\n                  ).replace(rtrim, '$1'),\n                matcher,\n                i < j && matcherFromTokens(tokens.slice(i, j)),\n                j < len && matcherFromTokens((tokens = tokens.slice(j))),\n                j < len && toSelector(tokens)\n              )\n            }\n            matchers.push(matcher)\n          }\n        }\n\n        return elementMatcher(matchers)\n      }\n\n      function matcherFromGroupMatchers (elementMatchers, setMatchers) {\n        var bySet = setMatchers.length > 0,\n          byElement = elementMatchers.length > 0,\n          superMatcher = function (seed, context, xml, results, outermost) {\n            var elem,\n              j,\n              matcher,\n              matchedCount = 0,\n              i = '0',\n              unmatched = seed && [],\n              setMatched = [],\n              contextBackup = outermostContext,\n              // We must always have either seed elements or outermost context\n              elems = seed || (byElement && Expr.find['TAG']('*', outermost)),\n              // Use integer dirruns iff this is the outermost matcher\n              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n              len = elems.length\n\n            if (outermost) {\n              outermostContext = context === document || context || outermost\n            }\n\n            // Add elements passing elementMatchers directly to results\n            // Support: IE<9, Safari\n            // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n            for (; i !== len && (elem = elems[i]) != null; i++) {\n              if (byElement && elem) {\n                j = 0\n                if (!context && elem.ownerDocument !== document) {\n                  setDocument(elem)\n                  xml = !documentIsHTML\n                }\n                while ((matcher = elementMatchers[j++])) {\n                  if (matcher(elem, context || document, xml)) {\n                    results.push(elem)\n                    break\n                  }\n                }\n                if (outermost) {\n                  dirruns = dirrunsUnique\n                }\n              }\n\n              // Track unmatched elements for set filters\n              if (bySet) {\n                // They will have gone through all possible matchers\n                if ((elem = !matcher && elem)) {\n                  matchedCount--\n                }\n\n                // Lengthen the array for every element, matched or not\n                if (seed) {\n                  unmatched.push(elem)\n                }\n              }\n            }\n\n            // `i` is now the count of elements visited above, and adding it to `matchedCount`\n            // makes the latter nonnegative.\n            matchedCount += i\n\n            // Apply set filters to unmatched elements\n            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n            // no element matchers and no seed.\n            // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n            // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n            // numerically zero.\n            if (bySet && i !== matchedCount) {\n              j = 0\n              while ((matcher = setMatchers[j++])) {\n                matcher(unmatched, setMatched, context, xml)\n              }\n\n              if (seed) {\n                // Reintegrate element matches to eliminate the need for sorting\n                if (matchedCount > 0) {\n                  while (i--) {\n                    if (!(unmatched[i] || setMatched[i])) {\n                      setMatched[i] = pop.call(results)\n                    }\n                  }\n                }\n\n                // Discard index placeholder values to get only actual matches\n                setMatched = condense(setMatched)\n              }\n\n              // Add matches to results\n              push.apply(results, setMatched)\n\n              // Seedless set matches succeeding multiple successful matchers stipulate sorting\n              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n                Sizzle.uniqueSort(results)\n              }\n            }\n\n            // Override manipulation of globals by nested matchers\n            if (outermost) {\n              dirruns = dirrunsUnique\n              outermostContext = contextBackup\n            }\n\n            return unmatched\n          }\n\n        return bySet ? markFunction(superMatcher) : superMatcher\n      }\n\n      compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n        var i,\n          setMatchers = [],\n          elementMatchers = [],\n          cached = compilerCache[selector + ' ']\n\n        if (!cached) {\n          // Generate a function of recursive functions that can be used to check each element\n          if (!match) {\n            match = tokenize(selector)\n          }\n          i = match.length\n          while (i--) {\n            cached = matcherFromTokens(match[i])\n            if (cached[expando]) {\n              setMatchers.push(cached)\n            } else {\n              elementMatchers.push(cached)\n            }\n          }\n\n          // Cache the compiled function\n          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers))\n\n          // Save selector and tokenization\n          cached.selector = selector\n        }\n        return cached\n      }\n\n      /**\n       * A low-level selection function that works with Sizzle's compiled\n       *  selector functions\n       * @param {String|Function} selector A selector or a pre-compiled\n       *  selector function built with Sizzle.compile\n       * @param {Element} context\n       * @param {Array} [results]\n       * @param {Array} [seed] A set of elements to match against\n       */\n      select = Sizzle.select = function (selector, context, results, seed) {\n        var i,\n          tokens,\n          token,\n          type,\n          find,\n          compiled = typeof selector === 'function' && selector,\n          match = !seed && tokenize((selector = compiled.selector || selector))\n\n        results = results || []\n\n        // Try to minimize operations if there is only one selector in the list and no seed\n        // (the latter of which guarantees us context)\n        if (match.length === 1) {\n          // Reduce context if the leading compound selector is an ID\n          tokens = match[0] = match[0].slice(0)\n          if (\n            tokens.length > 2 &&\n            (token = tokens[0]).type === 'ID' &&\n            support.getById &&\n            context.nodeType === 9 &&\n            documentIsHTML &&\n            Expr.relative[tokens[1].type]\n          ) {\n            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0]\n            if (!context) {\n              return results\n\n              // Precompiled matchers will still verify ancestry, so step up a level\n            } else if (compiled) {\n              context = context.parentNode\n            }\n\n            selector = selector.slice(tokens.shift().value.length)\n          }\n\n          // Fetch a seed set for right-to-left matching\n          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length\n          while (i--) {\n            token = tokens[i]\n\n            // Abort if we hit a combinator\n            if (Expr.relative[(type = token.type)]) {\n              break\n            }\n            if ((find = Expr.find[type])) {\n              // Search, expanding context for leading sibling combinators\n              if (\n                (seed = find(\n                  token.matches[0].replace(runescape, funescape),\n                  (rsibling.test(tokens[0].type) && testContext(context.parentNode)) || context\n                ))\n              ) {\n                // If seed is empty or no tokens remain, we can return early\n                tokens.splice(i, 1)\n                selector = seed.length && toSelector(tokens)\n                if (!selector) {\n                  push.apply(results, seed)\n                  return results\n                }\n\n                break\n              }\n            }\n          }\n        }\n\n        // Compile and execute a filtering function if one is not provided\n        // Provide `match` to avoid retokenization if we modified the selector above\n        ;(compiled || compile(selector, match))(\n          seed,\n          context,\n          !documentIsHTML,\n          results,\n          !context || (rsibling.test(selector) && testContext(context.parentNode)) || context\n        )\n        return results\n      }\n\n      // One-time assignments\n\n      // Sort stability\n      support.sortStable =\n        expando\n          .split('')\n          .sort(sortOrder)\n          .join('') === expando\n\n      // Support: Chrome 14-35+\n      // Always assume duplicates if they aren't passed to the comparison function\n      support.detectDuplicates = !!hasDuplicate\n\n      // Initialize against the default document\n      setDocument()\n\n      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n      // Detached nodes confoundingly follow *each other*\n      support.sortDetached = assert(function (div1) {\n        // Should return 1, but returns 4 (following)\n        return div1.compareDocumentPosition(document.createElement('div')) & 1\n      })\n\n      // Support: IE<8\n      // Prevent attribute/property \"interpolation\"\n      // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n      if (\n        !assert(function (div) {\n          div.innerHTML = \"<a href='#'></a>\"\n          return div.firstChild.getAttribute('href') === '#'\n        })\n      ) {\n        addHandle('type|href|height|width', function (elem, name, isXML) {\n          if (!isXML) {\n            return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2)\n          }\n        })\n      }\n\n      // Support: IE<9\n      // Use defaultValue in place of getAttribute(\"value\")\n      if (\n        !support.attributes ||\n        !assert(function (div) {\n          div.innerHTML = '<input/>'\n          div.firstChild.setAttribute('value', '')\n          return div.firstChild.getAttribute('value') === ''\n        })\n      ) {\n        addHandle('value', function (elem, name, isXML) {\n          if (!isXML && elem.nodeName.toLowerCase() === 'input') {\n            return elem.defaultValue\n          }\n        })\n      }\n\n      // Support: IE<9\n      // Use getAttributeNode to fetch booleans when getAttribute lies\n      if (\n        !assert(function (div) {\n          return div.getAttribute('disabled') == null\n        })\n      ) {\n        addHandle(booleans, function (elem, name, isXML) {\n          var val\n          if (!isXML) {\n            return elem[name] === true\n              ? name.toLowerCase()\n              : (val = elem.getAttributeNode(name)) && val.specified\n              ? val.value\n              : null\n          }\n        })\n      }\n\n      return Sizzle\n    })(window)\n\n  jQuery.find = Sizzle\n  jQuery.expr = Sizzle.selectors\n  jQuery.expr[':'] = jQuery.expr.pseudos\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort\n  jQuery.text = Sizzle.getText\n  jQuery.isXMLDoc = Sizzle.isXML\n  jQuery.contains = Sizzle.contains\n\n  var dir = function (elem, dir, until) {\n    var matched = [],\n      truncate = until !== undefined\n\n    while ((elem = elem[dir]) && elem.nodeType !== 9) {\n      if (elem.nodeType === 1) {\n        if (truncate && jQuery(elem).is(until)) {\n          break\n        }\n        matched.push(elem)\n      }\n    }\n    return matched\n  }\n\n  var siblings = function (n, elem) {\n    var matched = []\n\n    for (; n; n = n.nextSibling) {\n      if (n.nodeType === 1 && n !== elem) {\n        matched.push(n)\n      }\n    }\n\n    return matched\n  }\n\n  var rneedsContext = jQuery.expr.match.needsContext\n\n  var rsingleTag = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/\n\n  var risSimple = /^.[^:#\\[\\.,]*$/\n\n  // Implement the identical functionality for filter and not\n  function winnow (elements, qualifier, not) {\n    if (jQuery.isFunction(qualifier)) {\n      return jQuery.grep(elements, function (elem, i) {\n        /* jshint -W018 */\n        return !!qualifier.call(elem, i, elem) !== not\n      })\n    }\n\n    if (qualifier.nodeType) {\n      return jQuery.grep(elements, function (elem) {\n        return (elem === qualifier) !== not\n      })\n    }\n\n    if (typeof qualifier === 'string') {\n      if (risSimple.test(qualifier)) {\n        return jQuery.filter(qualifier, elements, not)\n      }\n\n      qualifier = jQuery.filter(qualifier, elements)\n    }\n\n    return jQuery.grep(elements, function (elem) {\n      return indexOf.call(qualifier, elem) > -1 !== not\n    })\n  }\n\n  jQuery.filter = function (expr, elems, not) {\n    var elem = elems[0]\n\n    if (not) {\n      expr = ':not(' + expr + ')'\n    }\n\n    return elems.length === 1 && elem.nodeType === 1\n      ? jQuery.find.matchesSelector(elem, expr)\n        ? [elem]\n        : []\n      : jQuery.find.matches(\n          expr,\n          jQuery.grep(elems, function (elem) {\n            return elem.nodeType === 1\n          })\n        )\n  }\n\n  jQuery.fn.extend({\n    find: function (selector) {\n      var i,\n        len = this.length,\n        ret = [],\n        self = this\n\n      if (typeof selector !== 'string') {\n        return this.pushStack(\n          jQuery(selector).filter(function () {\n            for (i = 0; i < len; i++) {\n              if (jQuery.contains(self[i], this)) {\n                return true\n              }\n            }\n          })\n        )\n      }\n\n      for (i = 0; i < len; i++) {\n        jQuery.find(selector, self[i], ret)\n      }\n\n      // Needed because $( selector, context ) becomes $( context ).find( selector )\n      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret)\n      ret.selector = this.selector ? this.selector + ' ' + selector : selector\n      return ret\n    },\n    filter: function (selector) {\n      return this.pushStack(winnow(this, selector || [], false))\n    },\n    not: function (selector) {\n      return this.pushStack(winnow(this, selector || [], true))\n    },\n    is: function (selector) {\n      return !!winnow(\n        this,\n\n        // If this is a positional/relative selector, check membership in the returned set\n        // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n        typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [],\n        false\n      ).length\n    }\n  })\n\n  // Initialize a jQuery object\n\n  // A central reference to the root jQuery(document)\n  var rootjQuery,\n    // A simple way to check for HTML strings\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n    // Strict HTML recognition (#11290: must start with <)\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n    init = (jQuery.fn.init = function (selector, context, root) {\n      var match, elem\n\n      // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n      if (!selector) {\n        return this\n      }\n\n      // Method init() accepts an alternate rootjQuery\n      // so migrate can support jQuery.sub (gh-2101)\n      root = root || rootjQuery\n\n      // Handle HTML strings\n      if (typeof selector === 'string') {\n        if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {\n          // Assume that strings that start and end with <> are HTML and skip the regex check\n          match = [null, selector, null]\n        } else {\n          match = rquickExpr.exec(selector)\n        }\n\n        // Match html or make sure no context is specified for #id\n        if (match && (match[1] || !context)) {\n          // HANDLE: $(html) -> $(array)\n          if (match[1]) {\n            context = context instanceof jQuery ? context[0] : context\n\n            // Option to run scripts is true for back-compat\n            // Intentionally let the error be thrown if parseHTML is not present\n            jQuery.merge(\n              this,\n              jQuery.parseHTML(\n                match[1],\n                context && context.nodeType ? context.ownerDocument || context : document,\n                true\n              )\n            )\n\n            // HANDLE: $(html, props)\n            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\n              for (match in context) {\n                // Properties of context are called as methods if possible\n                if (jQuery.isFunction(this[match])) {\n                  this[match](context[match])\n\n                  // ...and otherwise set as attributes\n                } else {\n                  this.attr(match, context[match])\n                }\n              }\n            }\n\n            return this\n\n            // HANDLE: $(#id)\n          } else {\n            elem = document.getElementById(match[2])\n\n            // Support: Blackberry 4.6\n            // gEBID returns nodes no longer in the document (#6963)\n            if (elem && elem.parentNode) {\n              // Inject the element directly into the jQuery object\n              this.length = 1\n              this[0] = elem\n            }\n\n            this.context = document\n            this.selector = selector\n            return this\n          }\n\n          // HANDLE: $(expr, $(...))\n        } else if (!context || context.jquery) {\n          return (context || root).find(selector)\n\n          // HANDLE: $(expr, context)\n          // (which is just equivalent to: $(context).find(expr)\n        } else {\n          return this.constructor(context).find(selector)\n        }\n\n        // HANDLE: $(DOMElement)\n      } else if (selector.nodeType) {\n        this.context = this[0] = selector\n        this.length = 1\n        return this\n\n        // HANDLE: $(function)\n        // Shortcut for document ready\n      } else if (jQuery.isFunction(selector)) {\n        return root.ready !== undefined\n          ? root.ready(selector)\n          : // Execute immediately if ready is not present\n            selector(jQuery)\n      }\n\n      if (selector.selector !== undefined) {\n        this.selector = selector.selector\n        this.context = selector.context\n      }\n\n      return jQuery.makeArray(selector, this)\n    })\n\n  // Give the init function the jQuery prototype for later instantiation\n  init.prototype = jQuery.fn\n\n  // Initialize central reference\n  rootjQuery = jQuery(document)\n\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\n    // Methods guaranteed to produce a unique set when starting from a unique set\n    guaranteedUnique = {\n      children: true,\n      contents: true,\n      next: true,\n      prev: true\n    }\n\n  jQuery.fn.extend({\n    has: function (target) {\n      var targets = jQuery(target, this),\n        l = targets.length\n\n      return this.filter(function () {\n        var i = 0\n        for (; i < l; i++) {\n          if (jQuery.contains(this, targets[i])) {\n            return true\n          }\n        }\n      })\n    },\n\n    closest: function (selectors, context) {\n      var cur,\n        i = 0,\n        l = this.length,\n        matched = [],\n        pos =\n          rneedsContext.test(selectors) || typeof selectors !== 'string'\n            ? jQuery(selectors, context || this.context)\n            : 0\n\n      for (; i < l; i++) {\n        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\n          // Always skip document fragments\n          if (\n            cur.nodeType < 11 &&\n            (pos\n              ? pos.index(cur) > -1\n              : // Don't pass non-elements to Sizzle\n                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))\n          ) {\n            matched.push(cur)\n            break\n          }\n        }\n      }\n\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)\n    },\n\n    // Determine the position of an element within the set\n    index: function (elem) {\n      // No argument, return index in parent\n      if (!elem) {\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1\n      }\n\n      // Index in selector\n      if (typeof elem === 'string') {\n        return indexOf.call(jQuery(elem), this[0])\n      }\n\n      // Locate the position of the desired element\n      return indexOf.call(\n        this,\n\n        // If it receives a jQuery object, the first element is used\n        elem.jquery ? elem[0] : elem\n      )\n    },\n\n    add: function (selector, context) {\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))\n    },\n\n    addBack: function (selector) {\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))\n    }\n  })\n\n  function sibling (cur, dir) {\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\n    return cur\n  }\n\n  jQuery.each(\n    {\n      parent: function (elem) {\n        var parent = elem.parentNode\n        return parent && parent.nodeType !== 11 ? parent : null\n      },\n      parents: function (elem) {\n        return dir(elem, 'parentNode')\n      },\n      parentsUntil: function (elem, i, until) {\n        return dir(elem, 'parentNode', until)\n      },\n      next: function (elem) {\n        return sibling(elem, 'nextSibling')\n      },\n      prev: function (elem) {\n        return sibling(elem, 'previousSibling')\n      },\n      nextAll: function (elem) {\n        return dir(elem, 'nextSibling')\n      },\n      prevAll: function (elem) {\n        return dir(elem, 'previousSibling')\n      },\n      nextUntil: function (elem, i, until) {\n        return dir(elem, 'nextSibling', until)\n      },\n      prevUntil: function (elem, i, until) {\n        return dir(elem, 'previousSibling', until)\n      },\n      siblings: function (elem) {\n        return siblings((elem.parentNode || {}).firstChild, elem)\n      },\n      children: function (elem) {\n        return siblings(elem.firstChild)\n      },\n      contents: function (elem) {\n        return elem.contentDocument || jQuery.merge([], elem.childNodes)\n      }\n    },\n    function (name, fn) {\n      jQuery.fn[name] = function (until, selector) {\n        var matched = jQuery.map(this, fn, until)\n\n        if (name.slice(-5) !== 'Until') {\n          selector = until\n        }\n\n        if (selector && typeof selector === 'string') {\n          matched = jQuery.filter(selector, matched)\n        }\n\n        if (this.length > 1) {\n          // Remove duplicates\n          if (!guaranteedUnique[name]) {\n            jQuery.uniqueSort(matched)\n          }\n\n          // Reverse order for parents* and prev-derivatives\n          if (rparentsprev.test(name)) {\n            matched.reverse()\n          }\n        }\n\n        return this.pushStack(matched)\n      }\n    }\n  )\n  var rnotwhite = /\\S+/g\n\n  // Convert String-formatted options into Object-formatted ones\n  function createOptions (options) {\n    var object = {}\n    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n      object[flag] = true\n    })\n    return object\n  }\n\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options)\n\n    var // Flag to know if list is currently firing\n      firing,\n      // Last fire value for non-forgettable lists\n      memory,\n      // Flag to know if list was already fired\n      fired,\n      // Flag to prevent firing\n      locked,\n      // Actual callback list\n      list = [],\n      // Queue of execution data for repeatable lists\n      queue = [],\n      // Index of currently firing callback (modified by add/remove as needed)\n      firingIndex = -1,\n      // Fire callbacks\n      fire = function () {\n        // Enforce single-firing\n        locked = options.once\n\n        // Execute callbacks for all pending executions,\n        // respecting firingIndex overrides and runtime changes\n        fired = firing = true\n        for (; queue.length; firingIndex = -1) {\n          memory = queue.shift()\n          while (++firingIndex < list.length) {\n            // Run callback and check for early termination\n            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n              // Jump to end and forget the data so .add doesn't re-fire\n              firingIndex = list.length\n              memory = false\n            }\n          }\n        }\n\n        // Forget the data if we're done with it\n        if (!options.memory) {\n          memory = false\n        }\n\n        firing = false\n\n        // Clean up if we're done firing for good\n        if (locked) {\n          // Keep an empty list if we have data for future add calls\n          if (memory) {\n            list = []\n\n            // Otherwise, this object is spent\n          } else {\n            list = ''\n          }\n        }\n      },\n      // Actual Callbacks object\n      self = {\n        // Add a callback or a collection of callbacks to the list\n        add: function () {\n          if (list) {\n            // If we have memory from a past run, we should fire after adding\n            if (memory && !firing) {\n              firingIndex = list.length - 1\n              queue.push(memory)\n            }\n\n            ;(function add (args) {\n              jQuery.each(args, function (_, arg) {\n                if (jQuery.isFunction(arg)) {\n                  if (!options.unique || !self.has(arg)) {\n                    list.push(arg)\n                  }\n                } else if (arg && arg.length && jQuery.type(arg) !== 'string') {\n                  // Inspect recursively\n                  add(arg)\n                }\n              })\n            })(arguments)\n\n            if (memory && !firing) {\n              fire()\n            }\n          }\n          return this\n        },\n\n        // Remove a callback from the list\n        remove: function () {\n          jQuery.each(arguments, function (_, arg) {\n            var index\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1)\n\n              // Handle firing indexes\n              if (index <= firingIndex) {\n                firingIndex--\n              }\n            }\n          })\n          return this\n        },\n\n        // Check if a given callback is in the list.\n        // If no argument is given, return whether or not list has callbacks attached.\n        has: function (fn) {\n          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0\n        },\n\n        // Remove all callbacks from the list\n        empty: function () {\n          if (list) {\n            list = []\n          }\n          return this\n        },\n\n        // Disable .fire and .add\n        // Abort any current/pending executions\n        // Clear all callbacks and values\n        disable: function () {\n          locked = queue = []\n          list = memory = ''\n          return this\n        },\n        disabled: function () {\n          return !list\n        },\n\n        // Disable .fire\n        // Also disable .add unless we have memory (since it would have no effect)\n        // Abort any pending executions\n        lock: function () {\n          locked = queue = []\n          if (!memory) {\n            list = memory = ''\n          }\n          return this\n        },\n        locked: function () {\n          return !!locked\n        },\n\n        // Call all callbacks with the given context and arguments\n        fireWith: function (context, args) {\n          if (!locked) {\n            args = args || []\n            args = [context, args.slice ? args.slice() : args]\n            queue.push(args)\n            if (!firing) {\n              fire()\n            }\n          }\n          return this\n        },\n\n        // Call all the callbacks with the given arguments\n        fire: function () {\n          self.fireWith(this, arguments)\n          return this\n        },\n\n        // To know if the callbacks have already been called at least once\n        fired: function () {\n          return !!fired\n        }\n      }\n\n    return self\n  }\n\n  jQuery.extend({\n    Deferred: function (func) {\n      var tuples = [\n          // action, add listener, listener list, final state\n          ['resolve', 'done', jQuery.Callbacks('once memory'), 'resolved'],\n          ['reject', 'fail', jQuery.Callbacks('once memory'), 'rejected'],\n          ['notify', 'progress', jQuery.Callbacks('memory')]\n        ],\n        state = 'pending',\n        promise = {\n          state: function () {\n            return state\n          },\n          always: function () {\n            deferred.done(arguments).fail(arguments)\n            return this\n          },\n          then: function (/* fnDone, fnFail, fnProgress */) {\n            var fns = arguments\n            return jQuery\n              .Deferred(function (newDefer) {\n                jQuery.each(tuples, function (i, tuple) {\n                  var fn = jQuery.isFunction(fns[i]) && fns[i]\n\n                  // deferred[ done | fail | progress ] for forwarding actions to newDefer\n                  deferred[tuple[1]](function () {\n                    var returned = fn && fn.apply(this, arguments)\n                    if (returned && jQuery.isFunction(returned.promise)) {\n                      returned\n                        .promise()\n                        .progress(newDefer.notify)\n                        .done(newDefer.resolve)\n                        .fail(newDefer.reject)\n                    } else {\n                      newDefer[tuple[0] + 'With'](\n                        this === promise ? newDefer.promise() : this,\n                        fn ? [returned] : arguments\n                      )\n                    }\n                  })\n                })\n                fns = null\n              })\n              .promise()\n          },\n\n          // Get a promise for this deferred\n          // If obj is provided, the promise aspect is added to the object\n          promise: function (obj) {\n            return obj != null ? jQuery.extend(obj, promise) : promise\n          }\n        },\n        deferred = {}\n\n      // Keep pipe for back-compat\n      promise.pipe = promise.then\n\n      // Add list-specific methods\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n          stateString = tuple[3]\n\n        // promise[ done | fail | progress ] = list.add\n        promise[tuple[1]] = list.add\n\n        // Handle state\n        if (stateString) {\n          list.add(\n            function () {\n              // state = [ resolved | rejected ]\n              state = stateString\n\n              // [ reject_list | resolve_list ].disable; progress_list.lock\n            },\n            tuples[i ^ 1][2].disable,\n            tuples[2][2].lock\n          )\n        }\n\n        // deferred[ resolve | reject | notify ]\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments)\n          return this\n        }\n        deferred[tuple[0] + 'With'] = list.fireWith\n      })\n\n      // Make the deferred a promise\n      promise.promise(deferred)\n\n      // Call given func if any\n      if (func) {\n        func.call(deferred, deferred)\n      }\n\n      // All done!\n      return deferred\n    },\n\n    // Deferred helper\n    when: function (subordinate /* , ..., subordinateN */) {\n      var i = 0,\n        resolveValues = slice.call(arguments),\n        length = resolveValues.length,\n        // the count of uncompleted subordinates\n        remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,\n        // the master Deferred.\n        // If resolveValues consist of only a single Deferred, just use that.\n        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n        // Update function for both resolve and progress values\n        updateFunc = function (i, contexts, values) {\n          return function (value) {\n            contexts[i] = this\n            values[i] = arguments.length > 1 ? slice.call(arguments) : value\n            if (values === progressValues) {\n              deferred.notifyWith(contexts, values)\n            } else if (!--remaining) {\n              deferred.resolveWith(contexts, values)\n            }\n          }\n        },\n        progressValues,\n        progressContexts,\n        resolveContexts\n\n      // Add listeners to Deferred subordinates; treat others as resolved\n      if (length > 1) {\n        progressValues = new Array(length)\n        progressContexts = new Array(length)\n        resolveContexts = new Array(length)\n        for (; i < length; i++) {\n          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n            resolveValues[i]\n              .promise()\n              .progress(updateFunc(i, progressContexts, progressValues))\n              .done(updateFunc(i, resolveContexts, resolveValues))\n              .fail(deferred.reject)\n          } else {\n            --remaining\n          }\n        }\n      }\n\n      // If we're not waiting on anything, resolve the master\n      if (!remaining) {\n        deferred.resolveWith(resolveContexts, resolveValues)\n      }\n\n      return deferred.promise()\n    }\n  })\n\n  // The deferred used on DOM ready\n  var readyList\n\n  jQuery.fn.ready = function (fn) {\n    // Add the callback\n    jQuery.ready.promise().done(fn)\n\n    return this\n  }\n\n  jQuery.extend({\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n\n    // Hold (or release) the ready event\n    holdReady: function (hold) {\n      if (hold) {\n        jQuery.readyWait++\n      } else {\n        jQuery.ready(true)\n      }\n    },\n\n    // Handle when the DOM is ready\n    ready: function (wait) {\n      // Abort if there are pending holds or we're already ready\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\n        return\n      }\n\n      // Remember that the DOM is ready\n      jQuery.isReady = true\n\n      // If a normal DOM Ready event fired, decrement, and wait if need be\n      if (wait !== true && --jQuery.readyWait > 0) {\n        return\n      }\n\n      // If there are functions bound, to execute\n      readyList.resolveWith(document, [jQuery])\n\n      // Trigger any bound ready events\n      if (jQuery.fn.triggerHandler) {\n        jQuery(document).triggerHandler('ready')\n        jQuery(document).off('ready')\n      }\n    }\n  })\n\n  /**\n   * The ready event handler and self cleanup method\n   */\n  function completed () {\n    document.removeEventListener('DOMContentLoaded', completed)\n    window.removeEventListener('load', completed)\n    jQuery.ready()\n  }\n\n  jQuery.ready.promise = function (obj) {\n    if (!readyList) {\n      readyList = jQuery.Deferred()\n\n      // Catch cases where $(document).ready() is called\n      // after the browser event has already occurred.\n      // Support: IE9-10 only\n      // Older IE sometimes signals \"interactive\" too soon\n      if (\n        document.readyState === 'complete' ||\n        (document.readyState !== 'loading' && !document.documentElement.doScroll)\n      ) {\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\n        window.setTimeout(jQuery.ready)\n      } else {\n        // Use the handy event callback\n        document.addEventListener('DOMContentLoaded', completed)\n\n        // A fallback to window.onload, that will always work\n        window.addEventListener('load', completed)\n      }\n    }\n    return readyList.promise(obj)\n  }\n\n  // Kick off the DOM ready check even if the user does not\n  jQuery.ready.promise()\n\n  // Multifunctional method to get and set values of a collection\n  // The value/s can optionally be executed if it's a function\n  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {\n    var i = 0,\n      len = elems.length,\n      bulk = key == null\n\n    // Sets many values\n    if (jQuery.type(key) === 'object') {\n      chainable = true\n      for (i in key) {\n        access(elems, fn, i, key[i], true, emptyGet, raw)\n      }\n\n      // Sets one value\n    } else if (value !== undefined) {\n      chainable = true\n\n      if (!jQuery.isFunction(value)) {\n        raw = true\n      }\n\n      if (bulk) {\n        // Bulk operations run against the entire set\n        if (raw) {\n          fn.call(elems, value)\n          fn = null\n\n          // ...except when executing function values\n        } else {\n          bulk = fn\n          fn = function (elem, key, value) {\n            return bulk.call(jQuery(elem), value)\n          }\n        }\n      }\n\n      if (fn) {\n        for (; i < len; i++) {\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)))\n        }\n      }\n    }\n\n    return chainable\n      ? elems\n      : // Gets\n      bulk\n      ? fn.call(elems)\n      : len\n      ? fn(elems[0], key)\n      : emptyGet\n  }\n  var acceptData = function (owner) {\n    // Accepts only:\n    //  - Node\n    //    - Node.ELEMENT_NODE\n    //    - Node.DOCUMENT_NODE\n    //  - Object\n    //    - Any\n    /* jshint -W018 */\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType\n  }\n\n  function Data () {\n    this.expando = jQuery.expando + Data.uid++\n  }\n\n  Data.uid = 1\n\n  Data.prototype = {\n    register: function (owner, initial) {\n      var value = initial || {}\n\n      // If it is a node unlikely to be stringify-ed or looped over\n      // use plain assignment\n      if (owner.nodeType) {\n        owner[this.expando] = value\n\n        // Otherwise secure it in a non-enumerable, non-writable property\n        // configurability must be true to allow the property to be\n        // deleted with the delete operator\n      } else {\n        Object.defineProperty(owner, this.expando, {\n          value: value,\n          writable: true,\n          configurable: true\n        })\n      }\n      return owner[this.expando]\n    },\n    cache: function (owner) {\n      // We can accept data for non-element nodes in modern browsers,\n      // but we should not, see #8335.\n      // Always return an empty object.\n      if (!acceptData(owner)) {\n        return {}\n      }\n\n      // Check if the owner object already has a cache\n      var value = owner[this.expando]\n\n      // If not, create one\n      if (!value) {\n        value = {}\n\n        // We can accept data for non-element nodes in modern browsers,\n        // but we should not, see #8335.\n        // Always return an empty object.\n        if (acceptData(owner)) {\n          // If it is a node unlikely to be stringify-ed or looped over\n          // use plain assignment\n          if (owner.nodeType) {\n            owner[this.expando] = value\n\n            // Otherwise secure it in a non-enumerable property\n            // configurable must be true to allow the property to be\n            // deleted when data is removed\n          } else {\n            Object.defineProperty(owner, this.expando, {\n              value: value,\n              configurable: true\n            })\n          }\n        }\n      }\n\n      return value\n    },\n    set: function (owner, data, value) {\n      var prop,\n        cache = this.cache(owner)\n\n      // Handle: [ owner, key, value ] args\n      if (typeof data === 'string') {\n        cache[data] = value\n\n        // Handle: [ owner, { properties } ] args\n      } else {\n        // Copy the properties one-by-one to the cache object\n        for (prop in data) {\n          cache[prop] = data[prop]\n        }\n      }\n      return cache\n    },\n    get: function (owner, key) {\n      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key]\n    },\n    access: function (owner, key, value) {\n      var stored\n\n      // In cases where either:\n      //\n      //   1. No key was specified\n      //   2. A string key was specified, but no value provided\n      //\n      // Take the \"read\" path and allow the get method to determine\n      // which value to return, respectively either:\n      //\n      //   1. The entire cache object\n      //   2. The data stored at the key\n      //\n      if (key === undefined || (key && typeof key === 'string' && value === undefined)) {\n        stored = this.get(owner, key)\n\n        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key))\n      }\n\n      // When the key is not a string, or both a key and value\n      // are specified, set or extend (existing objects) with either:\n      //\n      //   1. An object of properties\n      //   2. A key and value\n      //\n      this.set(owner, key, value)\n\n      // Since the \"set\" path can have two possible entry points\n      // return the expected data based on which path was taken[*]\n      return value !== undefined ? value : key\n    },\n    remove: function (owner, key) {\n      var i,\n        name,\n        camel,\n        cache = owner[this.expando]\n\n      if (cache === undefined) {\n        return\n      }\n\n      if (key === undefined) {\n        this.register(owner)\n      } else {\n        // Support array or space separated string of keys\n        if (jQuery.isArray(key)) {\n          // If \"name\" is an array of keys...\n          // When data is initially created, via (\"key\", \"val\") signature,\n          // keys will be converted to camelCase.\n          // Since there is no way to tell _how_ a key was added, remove\n          // both plain key and camelCase key. #12786\n          // This will only penalize the array argument path.\n          name = key.concat(key.map(jQuery.camelCase))\n        } else {\n          camel = jQuery.camelCase(key)\n\n          // Try the string as a key before any manipulation\n          if (key in cache) {\n            name = [key, camel]\n          } else {\n            // If a key with the spaces exists, use it.\n            // Otherwise, create an array by matching non-whitespace\n            name = camel\n            name = name in cache ? [name] : name.match(rnotwhite) || []\n          }\n        }\n\n        i = name.length\n\n        while (i--) {\n          delete cache[name[i]]\n        }\n      }\n\n      // Remove the expando if there's no more data\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\n        // Support: Chrome <= 35-45+\n        // Webkit & Blink performance suffers when deleting properties\n        // from DOM nodes, so set to undefined instead\n        // https://code.google.com/p/chromium/issues/detail?id=378607\n        if (owner.nodeType) {\n          owner[this.expando] = undefined\n        } else {\n          delete owner[this.expando]\n        }\n      }\n    },\n    hasData: function (owner) {\n      var cache = owner[this.expando]\n      return cache !== undefined && !jQuery.isEmptyObject(cache)\n    }\n  }\n  var dataPriv = new Data()\n\n  var dataUser = new Data()\n\n  //\tImplementation Summary\n  //\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n  //\t2. Improve the module's maintainability by reducing the storage\n  //\t\tpaths to a single mechanism.\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n    rmultiDash = /[A-Z]/g\n\n  function dataAttr (elem, key, data) {\n    var name\n\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if (data === undefined && elem.nodeType === 1) {\n      name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase()\n      data = elem.getAttribute(name)\n\n      if (typeof data === 'string') {\n        try {\n          data =\n            data === 'true'\n              ? true\n              : data === 'false'\n              ? false\n              : data === 'null'\n              ? null\n              : // Only convert to a number if it doesn't change the string\n              +data + '' === data\n              ? +data\n              : rbrace.test(data)\n              ? jQuery.parseJSON(data)\n              : data\n        } catch (e) {}\n\n        // Make sure we set the data so it isn't changed later\n        dataUser.set(elem, key, data)\n      } else {\n        data = undefined\n      }\n    }\n    return data\n  }\n\n  jQuery.extend({\n    hasData: function (elem) {\n      return dataUser.hasData(elem) || dataPriv.hasData(elem)\n    },\n\n    data: function (elem, name, data) {\n      return dataUser.access(elem, name, data)\n    },\n\n    removeData: function (elem, name) {\n      dataUser.remove(elem, name)\n    },\n\n    // TODO: Now that all calls to _data and _removeData have been replaced\n    // with direct calls to dataPriv methods, these can be deprecated.\n    _data: function (elem, name, data) {\n      return dataPriv.access(elem, name, data)\n    },\n\n    _removeData: function (elem, name) {\n      dataPriv.remove(elem, name)\n    }\n  })\n\n  jQuery.fn.extend({\n    data: function (key, value) {\n      var i,\n        name,\n        data,\n        elem = this[0],\n        attrs = elem && elem.attributes\n\n      // Gets all values\n      if (key === undefined) {\n        if (this.length) {\n          data = dataUser.get(elem)\n\n          if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {\n            i = attrs.length\n            while (i--) {\n              // Support: IE11+\n              // The attrs elements can be null (#14894)\n              if (attrs[i]) {\n                name = attrs[i].name\n                if (name.indexOf('data-') === 0) {\n                  name = jQuery.camelCase(name.slice(5))\n                  dataAttr(elem, name, data[name])\n                }\n              }\n            }\n            dataPriv.set(elem, 'hasDataAttrs', true)\n          }\n        }\n\n        return data\n      }\n\n      // Sets multiple values\n      if (typeof key === 'object') {\n        return this.each(function () {\n          dataUser.set(this, key)\n        })\n      }\n\n      return access(\n        this,\n        function (value) {\n          var data, camelKey\n\n          // The calling jQuery object (element matches) is not empty\n          // (and therefore has an element appears at this[ 0 ]) and the\n          // `value` parameter was not undefined. An empty jQuery object\n          // will result in `undefined` for elem = this[ 0 ] which will\n          // throw an exception if an attempt to read a data cache is made.\n          if (elem && value === undefined) {\n            // Attempt to get data from the cache\n            // with the key as-is\n            data =\n              dataUser.get(elem, key) ||\n              // Try to find dashed key if it exists (gh-2779)\n              // This is for 2.2.x only\n              dataUser.get(elem, key.replace(rmultiDash, '-$&').toLowerCase())\n\n            if (data !== undefined) {\n              return data\n            }\n\n            camelKey = jQuery.camelCase(key)\n\n            // Attempt to get data from the cache\n            // with the key camelized\n            data = dataUser.get(elem, camelKey)\n            if (data !== undefined) {\n              return data\n            }\n\n            // Attempt to \"discover\" the data in\n            // HTML5 custom data-* attrs\n            data = dataAttr(elem, camelKey, undefined)\n            if (data !== undefined) {\n              return data\n            }\n\n            // We tried really hard, but the data doesn't exist.\n            return\n          }\n\n          // Set the data...\n          camelKey = jQuery.camelCase(key)\n          this.each(function () {\n            // First, attempt to store a copy or reference of any\n            // data that might've been store with a camelCased key.\n            var data = dataUser.get(this, camelKey)\n\n            // For HTML5 data-* attribute interop, we have to\n            // store property names with dashes in a camelCase form.\n            // This might not apply to all properties...*\n            dataUser.set(this, camelKey, value)\n\n            // *... In the case of properties that might _actually_\n            // have dashes, we need to also store a copy of that\n            // unchanged property.\n            if (key.indexOf('-') > -1 && data !== undefined) {\n              dataUser.set(this, key, value)\n            }\n          })\n        },\n        null,\n        value,\n        arguments.length > 1,\n        null,\n        true\n      )\n    },\n\n    removeData: function (key) {\n      return this.each(function () {\n        dataUser.remove(this, key)\n      })\n    }\n  })\n\n  jQuery.extend({\n    queue: function (elem, type, data) {\n      var queue\n\n      if (elem) {\n        type = (type || 'fx') + 'queue'\n        queue = dataPriv.get(elem, type)\n\n        // Speed up dequeue by getting out quickly if this is just a lookup\n        if (data) {\n          if (!queue || jQuery.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data))\n          } else {\n            queue.push(data)\n          }\n        }\n        return queue || []\n      }\n    },\n\n    dequeue: function (elem, type) {\n      type = type || 'fx'\n\n      var queue = jQuery.queue(elem, type),\n        startLength = queue.length,\n        fn = queue.shift(),\n        hooks = jQuery._queueHooks(elem, type),\n        next = function () {\n          jQuery.dequeue(elem, type)\n        }\n\n      // If the fx queue is dequeued, always remove the progress sentinel\n      if (fn === 'inprogress') {\n        fn = queue.shift()\n        startLength--\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === 'fx') {\n          queue.unshift('inprogress')\n        }\n\n        // Clear up the last queue stop function\n        delete hooks.stop\n        fn.call(elem, next, hooks)\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire()\n      }\n    },\n\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function (elem, type) {\n      var key = type + 'queueHooks'\n      return (\n        dataPriv.get(elem, key) ||\n        dataPriv.access(elem, key, {\n          empty: jQuery.Callbacks('once memory').add(function () {\n            dataPriv.remove(elem, [type + 'queue', key])\n          })\n        })\n      )\n    }\n  })\n\n  jQuery.fn.extend({\n    queue: function (type, data) {\n      var setter = 2\n\n      if (typeof type !== 'string') {\n        data = type\n        type = 'fx'\n        setter--\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type)\n      }\n\n      return data === undefined\n        ? this\n        : this.each(function () {\n            var queue = jQuery.queue(this, type, data)\n\n            // Ensure a hooks for this queue\n            jQuery._queueHooks(this, type)\n\n            if (type === 'fx' && queue[0] !== 'inprogress') {\n              jQuery.dequeue(this, type)\n            }\n          })\n    },\n    dequeue: function (type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type)\n      })\n    },\n    clearQueue: function (type) {\n      return this.queue(type || 'fx', [])\n    },\n\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function (type, obj) {\n      var tmp,\n        count = 1,\n        defer = jQuery.Deferred(),\n        elements = this,\n        i = this.length,\n        resolve = function () {\n          if (!--count) {\n            defer.resolveWith(elements, [elements])\n          }\n        }\n\n      if (typeof type !== 'string') {\n        obj = type\n        type = undefined\n      }\n      type = type || 'fx'\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + 'queueHooks')\n        if (tmp && tmp.empty) {\n          count++\n          tmp.empty.add(resolve)\n        }\n      }\n      resolve()\n      return defer.promise(obj)\n    }\n  })\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source\n\n  var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i')\n\n  var cssExpand = ['Top', 'Right', 'Bottom', 'Left']\n\n  var isHidden = function (elem, el) {\n    // isHidden might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem\n    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem)\n  }\n\n  function adjustCSS (elem, prop, valueParts, tween) {\n    var adjusted,\n      scale = 1,\n      maxIterations = 20,\n      currentValue = tween\n        ? function () {\n            return tween.cur()\n          }\n        : function () {\n            return jQuery.css(elem, prop, '')\n          },\n      initial = currentValue(),\n      unit = (valueParts && valueParts[3]) || (jQuery.cssNumber[prop] ? '' : 'px'),\n      // Starting value computation is required for potential unit mismatches\n      initialInUnit = (jQuery.cssNumber[prop] || (unit !== 'px' && +initial)) && rcssNum.exec(jQuery.css(elem, prop))\n\n    if (initialInUnit && initialInUnit[3] !== unit) {\n      // Trust units reported by jQuery.css\n      unit = unit || initialInUnit[3]\n\n      // Make sure we update the tween properties later on\n      valueParts = valueParts || []\n\n      // Iteratively approximate from a nonzero starting point\n      initialInUnit = +initial || 1\n\n      do {\n        // If previous iteration zeroed out, double until we get *something*.\n        // Use string for doubling so we don't accidentally see scale as unchanged below\n        scale = scale || '.5'\n\n        // Adjust and apply\n        initialInUnit = initialInUnit / scale\n        jQuery.style(elem, prop, initialInUnit + unit)\n\n        // Update scale, tolerating zero or NaN from tween.cur()\n        // Break the loop if scale is unchanged or perfect, or if we've just had enough.\n      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations)\n    }\n\n    if (valueParts) {\n      initialInUnit = +initialInUnit || +initial || 0\n\n      // Apply relative offset (+=/-=) if specified\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2]\n      if (tween) {\n        tween.unit = unit\n        tween.start = initialInUnit\n        tween.end = adjusted\n      }\n    }\n    return adjusted\n  }\n  var rcheckableType = /^(?:checkbox|radio)$/i\n\n  var rtagName = /<([\\w:-]+)/\n\n  var rscriptType = /^$|\\/(?:java|ecma)script/i\n\n  // We have to close these tags to support XHTML (#13200)\n  var wrapMap = {\n    // Support: IE9\n    option: [1, \"<select multiple='multiple'>\", '</select>'],\n\n    // XHTML parsers do not magically insert elements in the\n    // same way that tag soup parsers do. So we cannot shorten\n    // this by omitting <tbody> or other required elements.\n    thead: [1, '<table>', '</table>'],\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n\n    _default: [0, '', '']\n  }\n\n  // Support: IE9\n  wrapMap.optgroup = wrapMap.option\n\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead\n  wrapMap.th = wrapMap.td\n\n  function getAll (context, tag) {\n    // Support: IE9-11+\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\n    var ret =\n      typeof context.getElementsByTagName !== 'undefined'\n        ? context.getElementsByTagName(tag || '*')\n        : typeof context.querySelectorAll !== 'undefined'\n        ? context.querySelectorAll(tag || '*')\n        : []\n\n    return tag === undefined || (tag && jQuery.nodeName(context, tag)) ? jQuery.merge([context], ret) : ret\n  }\n\n  // Mark scripts as having already been evaluated\n  function setGlobalEval (elems, refElements) {\n    var i = 0,\n      l = elems.length\n\n    for (; i < l; i++) {\n      dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'))\n    }\n  }\n\n  var rhtml = /<|&#?\\w+;/\n\n  function buildFragment (elems, context, scripts, selection, ignored) {\n    var elem,\n      tmp,\n      tag,\n      wrap,\n      contains,\n      j,\n      fragment = context.createDocumentFragment(),\n      nodes = [],\n      i = 0,\n      l = elems.length\n\n    for (; i < l; i++) {\n      elem = elems[i]\n\n      if (elem || elem === 0) {\n        // Add nodes directly\n        if (jQuery.type(elem) === 'object') {\n          // Support: Android<4.1, PhantomJS<2\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem)\n\n          // Convert non-html into a text node\n        } else if (!rhtml.test(elem)) {\n          nodes.push(context.createTextNode(elem))\n\n          // Convert html into DOM nodes\n        } else {\n          tmp = tmp || fragment.appendChild(context.createElement('div'))\n\n          // Deserialize a standard representation\n          tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase()\n          wrap = wrapMap[tag] || wrapMap._default\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]\n\n          // Descend through wrappers to the right content\n          j = wrap[0]\n          while (j--) {\n            tmp = tmp.lastChild\n          }\n\n          // Support: Android<4.1, PhantomJS<2\n          // push.apply(_, arraylike) throws on ancient WebKit\n          jQuery.merge(nodes, tmp.childNodes)\n\n          // Remember the top-level container\n          tmp = fragment.firstChild\n\n          // Ensure the created nodes are orphaned (#12392)\n          tmp.textContent = ''\n        }\n      }\n    }\n\n    // Remove wrapper from fragment\n    fragment.textContent = ''\n\n    i = 0\n    while ((elem = nodes[i++])) {\n      // Skip elements already in the context collection (trac-4087)\n      if (selection && jQuery.inArray(elem, selection) > -1) {\n        if (ignored) {\n          ignored.push(elem)\n        }\n        continue\n      }\n\n      contains = jQuery.contains(elem.ownerDocument, elem)\n\n      // Append to fragment\n      tmp = getAll(fragment.appendChild(elem), 'script')\n\n      // Preserve script evaluation history\n      if (contains) {\n        setGlobalEval(tmp)\n      }\n\n      // Capture executables\n      if (scripts) {\n        j = 0\n        while ((elem = tmp[j++])) {\n          if (rscriptType.test(elem.type || '')) {\n            scripts.push(elem)\n          }\n        }\n      }\n    }\n\n    return fragment\n  }\n\n  ;(function () {\n    var fragment = document.createDocumentFragment(),\n      div = fragment.appendChild(document.createElement('div')),\n      input = document.createElement('input')\n\n    // Support: Android 4.0-4.3, Safari<=5.1\n    // Check state lost if the name is set (#11217)\n    // Support: Windows Web Apps (WWA)\n    // `name` and `type` must use .setAttribute for WWA (#14901)\n    input.setAttribute('type', 'radio')\n    input.setAttribute('checked', 'checked')\n    input.setAttribute('name', 't')\n\n    div.appendChild(input)\n\n    // Support: Safari<=5.1, Android<4.2\n    // Older WebKit doesn't clone checked state correctly in fragments\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked\n\n    // Support: IE<=11+\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\n    div.innerHTML = '<textarea>x</textarea>'\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue\n  })()\n\n  var rkeyEvent = /^key/,\n    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n    rtypenamespace = /^([^.]*)(?:\\.(.+)|)/\n\n  function returnTrue () {\n    return true\n  }\n\n  function returnFalse () {\n    return false\n  }\n\n  // Support: IE9\n  // See #13393 for more info\n  function safeActiveElement () {\n    try {\n      return document.activeElement\n    } catch (err) {}\n  }\n\n  function on (elem, types, selector, data, fn, one) {\n    var origFn, type\n\n    // Types can be a map of types/handlers\n    if (typeof types === 'object') {\n      // ( types-Object, selector, data )\n      if (typeof selector !== 'string') {\n        // ( types-Object, data )\n        data = data || selector\n        selector = undefined\n      }\n      for (type in types) {\n        on(elem, type, selector, data, types[type], one)\n      }\n      return elem\n    }\n\n    if (data == null && fn == null) {\n      // ( types, fn )\n      fn = selector\n      data = selector = undefined\n    } else if (fn == null) {\n      if (typeof selector === 'string') {\n        // ( types, selector, fn )\n        fn = data\n        data = undefined\n      } else {\n        // ( types, data, fn )\n        fn = data\n        data = selector\n        selector = undefined\n      }\n    }\n    if (fn === false) {\n      fn = returnFalse\n    } else if (!fn) {\n      return elem\n    }\n\n    if (one === 1) {\n      origFn = fn\n      fn = function (event) {\n        // Can use an empty set, since event contains the info\n        jQuery().off(event)\n        return origFn.apply(this, arguments)\n      }\n\n      // Use same guid so caller can remove using origFn\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)\n    }\n    return elem.each(function () {\n      jQuery.event.add(this, types, fn, data, selector)\n    })\n  }\n\n  /*\n   * Helper functions for managing events -- not part of the public interface.\n   * Props to Dean Edwards' addEvent library for many of the ideas.\n   */\n  jQuery.event = {\n    global: {},\n\n    add: function (elem, types, handler, data, selector) {\n      var handleObjIn,\n        eventHandle,\n        tmp,\n        events,\n        t,\n        handleObj,\n        special,\n        handlers,\n        type,\n        namespaces,\n        origType,\n        elemData = dataPriv.get(elem)\n\n      // Don't attach events to noData or text/comment nodes (but allow plain objects)\n      if (!elemData) {\n        return\n      }\n\n      // Caller can pass in an object of custom data in lieu of the handler\n      if (handler.handler) {\n        handleObjIn = handler\n        handler = handleObjIn.handler\n        selector = handleObjIn.selector\n      }\n\n      // Make sure that the handler has a unique ID, used to find/remove it later\n      if (!handler.guid) {\n        handler.guid = jQuery.guid++\n      }\n\n      // Init the element's event structure and main handler, if this is the first\n      if (!(events = elemData.events)) {\n        events = elemData.events = {}\n      }\n      if (!(eventHandle = elemData.handle)) {\n        eventHandle = elemData.handle = function (e) {\n          // Discard the second event of a jQuery.event.trigger() and\n          // when an event is called after a page has unloaded\n          return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type\n            ? jQuery.event.dispatch.apply(elem, arguments)\n            : undefined\n        }\n      }\n\n      // Handle multiple events separated by a space\n      types = (types || '').match(rnotwhite) || ['']\n      t = types.length\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || []\n        type = origType = tmp[1]\n        namespaces = (tmp[2] || '').split('.').sort()\n\n        // There *must* be a type, no attaching namespace-only handlers\n        if (!type) {\n          continue\n        }\n\n        // If event changes its type, use the special event handlers for the changed type\n        special = jQuery.event.special[type] || {}\n\n        // If selector defined, determine special event api type, otherwise given type\n        type = (selector ? special.delegateType : special.bindType) || type\n\n        // Update special based on newly reset type\n        special = jQuery.event.special[type] || {}\n\n        // handleObj is passed to all event handlers\n        handleObj = jQuery.extend(\n          {\n            type: type,\n            origType: origType,\n            data: data,\n            handler: handler,\n            guid: handler.guid,\n            selector: selector,\n            needsContext: selector && jQuery.expr.match.needsContext.test(selector),\n            namespace: namespaces.join('.')\n          },\n          handleObjIn\n        )\n\n        // Init the event handler queue if we're the first\n        if (!(handlers = events[type])) {\n          handlers = events[type] = []\n          handlers.delegateCount = 0\n\n          // Only use addEventListener if the special events handler returns false\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\n            if (elem.addEventListener) {\n              elem.addEventListener(type, eventHandle)\n            }\n          }\n        }\n\n        if (special.add) {\n          special.add.call(elem, handleObj)\n\n          if (!handleObj.handler.guid) {\n            handleObj.handler.guid = handler.guid\n          }\n        }\n\n        // Add to the element's handler list, delegates in front\n        if (selector) {\n          handlers.splice(handlers.delegateCount++, 0, handleObj)\n        } else {\n          handlers.push(handleObj)\n        }\n\n        // Keep track of which events have ever been used, for event optimization\n        jQuery.event.global[type] = true\n      }\n    },\n\n    // Detach an event or set of events from an element\n    remove: function (elem, types, handler, selector, mappedTypes) {\n      var j,\n        origCount,\n        tmp,\n        events,\n        t,\n        handleObj,\n        special,\n        handlers,\n        type,\n        namespaces,\n        origType,\n        elemData = dataPriv.hasData(elem) && dataPriv.get(elem)\n\n      if (!elemData || !(events = elemData.events)) {\n        return\n      }\n\n      // Once for each type.namespace in types; type may be omitted\n      types = (types || '').match(rnotwhite) || ['']\n      t = types.length\n      while (t--) {\n        tmp = rtypenamespace.exec(types[t]) || []\n        type = origType = tmp[1]\n        namespaces = (tmp[2] || '').split('.').sort()\n\n        // Unbind all events (on this namespace, if provided) for the element\n        if (!type) {\n          for (type in events) {\n            jQuery.event.remove(elem, type + types[t], handler, selector, true)\n          }\n          continue\n        }\n\n        special = jQuery.event.special[type] || {}\n        type = (selector ? special.delegateType : special.bindType) || type\n        handlers = events[type] || []\n        tmp = tmp[2] && new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\n\n        // Remove matching events\n        origCount = j = handlers.length\n        while (j--) {\n          handleObj = handlers[j]\n\n          if (\n            (mappedTypes || origType === handleObj.origType) &&\n            (!handler || handler.guid === handleObj.guid) &&\n            (!tmp || tmp.test(handleObj.namespace)) &&\n            (!selector || selector === handleObj.selector || (selector === '**' && handleObj.selector))\n          ) {\n            handlers.splice(j, 1)\n\n            if (handleObj.selector) {\n              handlers.delegateCount--\n            }\n            if (special.remove) {\n              special.remove.call(elem, handleObj)\n            }\n          }\n        }\n\n        // Remove generic event handler if we removed something and no more handlers exist\n        // (avoids potential for endless recursion during removal of special event handlers)\n        if (origCount && !handlers.length) {\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\n            jQuery.removeEvent(elem, type, elemData.handle)\n          }\n\n          delete events[type]\n        }\n      }\n\n      // Remove data and the expando if it's no longer used\n      if (jQuery.isEmptyObject(events)) {\n        dataPriv.remove(elem, 'handle events')\n      }\n    },\n\n    dispatch: function (event) {\n      // Make a writable jQuery.Event from the native event object\n      event = jQuery.event.fix(event)\n\n      var i,\n        j,\n        ret,\n        matched,\n        handleObj,\n        handlerQueue = [],\n        args = slice.call(arguments),\n        handlers = (dataPriv.get(this, 'events') || {})[event.type] || [],\n        special = jQuery.event.special[event.type] || {}\n\n      // Use the fix-ed jQuery.Event rather than the (read-only) native event\n      args[0] = event\n      event.delegateTarget = this\n\n      // Call the preDispatch hook for the mapped type, and let it bail if desired\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\n        return\n      }\n\n      // Determine handlers\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers)\n\n      // Run delegates first; they may want to stop propagation beneath us\n      i = 0\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\n        event.currentTarget = matched.elem\n\n        j = 0\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\n          // Triggered event must either 1) have no namespace, or 2) have namespace(s)\n          // a subset or equal to those in the bound event (both can have no namespace).\n          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\n            event.handleObj = handleObj\n            event.data = handleObj.data\n\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(\n              matched.elem,\n              args\n            )\n\n            if (ret !== undefined) {\n              if ((event.result = ret) === false) {\n                event.preventDefault()\n                event.stopPropagation()\n              }\n            }\n          }\n        }\n      }\n\n      // Call the postDispatch hook for the mapped type\n      if (special.postDispatch) {\n        special.postDispatch.call(this, event)\n      }\n\n      return event.result\n    },\n\n    handlers: function (event, handlers) {\n      var i,\n        matches,\n        sel,\n        handleObj,\n        handlerQueue = [],\n        delegateCount = handlers.delegateCount,\n        cur = event.target\n\n      // Support (at least): Chrome, IE9\n      // Find delegate handlers\n      // Black-hole SVG <use> instance trees (#13180)\n      //\n      // Support: Firefox<=42+\n      // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)\n      if (delegateCount && cur.nodeType && (event.type !== 'click' || isNaN(event.button) || event.button < 1)) {\n        for (; cur !== this; cur = cur.parentNode || this) {\n          // Don't check non-elements (#13208)\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {\n            matches = []\n            for (i = 0; i < delegateCount; i++) {\n              handleObj = handlers[i]\n\n              // Don't conflict with Object.prototype properties (#13203)\n              sel = handleObj.selector + ' '\n\n              if (matches[sel] === undefined) {\n                matches[sel] = handleObj.needsContext\n                  ? jQuery(sel, this).index(cur) > -1\n                  : jQuery.find(sel, this, null, [cur]).length\n              }\n              if (matches[sel]) {\n                matches.push(handleObj)\n              }\n            }\n            if (matches.length) {\n              handlerQueue.push({ elem: cur, handlers: matches })\n            }\n          }\n        }\n      }\n\n      // Add the remaining (directly-bound) handlers\n      if (delegateCount < handlers.length) {\n        handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) })\n      }\n\n      return handlerQueue\n    },\n\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: (\n      'altKey bubbles cancelable ctrlKey currentTarget detail eventPhase ' +\n      'metaKey relatedTarget shiftKey target timeStamp view which'\n    ).split(' '),\n\n    fixHooks: {},\n\n    keyHooks: {\n      props: 'char charCode key keyCode'.split(' '),\n      filter: function (event, original) {\n        // Add which for key events\n        if (event.which == null) {\n          event.which = original.charCode != null ? original.charCode : original.keyCode\n        }\n\n        return event\n      }\n    },\n\n    mouseHooks: {\n      props: ('button buttons clientX clientY offsetX offsetY pageX pageY ' + 'screenX screenY toElement').split(' '),\n      filter: function (event, original) {\n        var eventDoc,\n          doc,\n          body,\n          button = original.button\n\n        // Calculate pageX/Y if missing and clientX/Y available\n        if (event.pageX == null && original.clientX != null) {\n          eventDoc = event.target.ownerDocument || document\n          doc = eventDoc.documentElement\n          body = eventDoc.body\n\n          event.pageX =\n            original.clientX +\n            ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -\n            ((doc && doc.clientLeft) || (body && body.clientLeft) || 0)\n          event.pageY =\n            original.clientY +\n            ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) -\n            ((doc && doc.clientTop) || (body && body.clientTop) || 0)\n        }\n\n        // Add which for click: 1 === left; 2 === middle; 3 === right\n        // Note: button is not normalized, so don't use it\n        if (!event.which && button !== undefined) {\n          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0\n        }\n\n        return event\n      }\n    },\n\n    fix: function (event) {\n      if (event[jQuery.expando]) {\n        return event\n      }\n\n      // Create a writable copy of the event object and normalize some properties\n      var i,\n        prop,\n        copy,\n        type = event.type,\n        originalEvent = event,\n        fixHook = this.fixHooks[type]\n\n      if (!fixHook) {\n        this.fixHooks[type] = fixHook = rmouseEvent.test(type)\n          ? this.mouseHooks\n          : rkeyEvent.test(type)\n          ? this.keyHooks\n          : {}\n      }\n      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props\n\n      event = new jQuery.Event(originalEvent)\n\n      i = copy.length\n      while (i--) {\n        prop = copy[i]\n        event[prop] = originalEvent[prop]\n      }\n\n      // Support: Cordova 2.5 (WebKit) (#13255)\n      // All events should have a target; Cordova deviceready doesn't\n      if (!event.target) {\n        event.target = document\n      }\n\n      // Support: Safari 6.0+, Chrome<28\n      // Target should not be a text node (#504, #13143)\n      if (event.target.nodeType === 3) {\n        event.target = event.target.parentNode\n      }\n\n      return fixHook.filter ? fixHook.filter(event, originalEvent) : event\n    },\n\n    special: {\n      load: {\n        // Prevent triggered image.load events from bubbling to window.load\n        noBubble: true\n      },\n      focus: {\n        // Fire native event if possible so blur/focus sequence is correct\n        trigger: function () {\n          if (this !== safeActiveElement() && this.focus) {\n            this.focus()\n            return false\n          }\n        },\n        delegateType: 'focusin'\n      },\n      blur: {\n        trigger: function () {\n          if (this === safeActiveElement() && this.blur) {\n            this.blur()\n            return false\n          }\n        },\n        delegateType: 'focusout'\n      },\n      click: {\n        // For checkbox, fire native event so checked state will be right\n        trigger: function () {\n          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {\n            this.click()\n            return false\n          }\n        },\n\n        // For cross-browser consistency, don't fire native .click() on links\n        _default: function (event) {\n          return jQuery.nodeName(event.target, 'a')\n        }\n      },\n\n      beforeunload: {\n        postDispatch: function (event) {\n          // Support: Firefox 20+\n          // Firefox doesn't alert if the returnValue field is not set.\n          if (event.result !== undefined && event.originalEvent) {\n            event.originalEvent.returnValue = event.result\n          }\n        }\n      }\n    }\n  }\n\n  jQuery.removeEvent = function (elem, type, handle) {\n    // This \"if\" is needed for plain objects\n    if (elem.removeEventListener) {\n      elem.removeEventListener(type, handle)\n    }\n  }\n\n  jQuery.Event = function (src, props) {\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof jQuery.Event)) {\n      return new jQuery.Event(src, props)\n    }\n\n    // Event object\n    if (src && src.type) {\n      this.originalEvent = src\n      this.type = src.type\n\n      // Events bubbling up the document may have been marked as prevented\n      // by a handler lower down the tree; reflect the correct value.\n      this.isDefaultPrevented =\n        src.defaultPrevented ||\n        (src.defaultPrevented === undefined &&\n          // Support: Android<4.0\n          src.returnValue === false)\n          ? returnTrue\n          : returnFalse\n\n      // Event type\n    } else {\n      this.type = src\n    }\n\n    // Put explicitly provided properties onto the event object\n    if (props) {\n      jQuery.extend(this, props)\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = (src && src.timeStamp) || jQuery.now()\n\n    // Mark it as fixed\n    this[jQuery.expando] = true\n  }\n\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\n  jQuery.Event.prototype = {\n    constructor: jQuery.Event,\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n    isSimulated: false,\n\n    preventDefault: function () {\n      var e = this.originalEvent\n\n      this.isDefaultPrevented = returnTrue\n\n      if (e && !this.isSimulated) {\n        e.preventDefault()\n      }\n    },\n    stopPropagation: function () {\n      var e = this.originalEvent\n\n      this.isPropagationStopped = returnTrue\n\n      if (e && !this.isSimulated) {\n        e.stopPropagation()\n      }\n    },\n    stopImmediatePropagation: function () {\n      var e = this.originalEvent\n\n      this.isImmediatePropagationStopped = returnTrue\n\n      if (e && !this.isSimulated) {\n        e.stopImmediatePropagation()\n      }\n\n      this.stopPropagation()\n    }\n  }\n\n  // Create mouseenter/leave events using mouseover/out and event-time checks\n  // so that event delegation works in jQuery.\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\n  //\n  // Support: Safari 7 only\n  // Safari sends mouseenter too often; see:\n  // https://code.google.com/p/chromium/issues/detail?id=470258\n  // for the description of the bug (it existed in older Chrome versions as well).\n  jQuery.each(\n    {\n      mouseenter: 'mouseover',\n      mouseleave: 'mouseout',\n      pointerenter: 'pointerover',\n      pointerleave: 'pointerout'\n    },\n    function (orig, fix) {\n      jQuery.event.special[orig] = {\n        delegateType: fix,\n        bindType: fix,\n\n        handle: function (event) {\n          var ret,\n            target = this,\n            related = event.relatedTarget,\n            handleObj = event.handleObj\n\n          // For mouseenter/leave call the handler if related is outside the target.\n          // NB: No relatedTarget if the mouse left/entered the browser window\n          if (!related || (related !== target && !jQuery.contains(target, related))) {\n            event.type = handleObj.origType\n            ret = handleObj.handler.apply(this, arguments)\n            event.type = fix\n          }\n          return ret\n        }\n      }\n    }\n  )\n\n  jQuery.fn.extend({\n    on: function (types, selector, data, fn) {\n      return on(this, types, selector, data, fn)\n    },\n    one: function (types, selector, data, fn) {\n      return on(this, types, selector, data, fn, 1)\n    },\n    off: function (types, selector, fn) {\n      var handleObj, type\n      if (types && types.preventDefault && types.handleObj) {\n        // ( event )  dispatched jQuery.Event\n        handleObj = types.handleObj\n        jQuery(types.delegateTarget).off(\n          handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType,\n          handleObj.selector,\n          handleObj.handler\n        )\n        return this\n      }\n      if (typeof types === 'object') {\n        // ( types-object [, selector] )\n        for (type in types) {\n          this.off(type, selector, types[type])\n        }\n        return this\n      }\n      if (selector === false || typeof selector === 'function') {\n        // ( types [, fn] )\n        fn = selector\n        selector = undefined\n      }\n      if (fn === false) {\n        fn = returnFalse\n      }\n      return this.each(function () {\n        jQuery.event.remove(this, types, fn, selector)\n      })\n    }\n  })\n\n  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n    // Support: IE 10-11, Edge 10240+\n    // In IE/Edge using regex groups here causes severe slowdowns.\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\n    rnoInnerhtml = /<script|<style|<link/i,\n    // checked=\"checked\" or checked\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n    rscriptTypeMasked = /^true\\/(.*)/,\n    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g\n\n  // Manipulating tables requires a tbody\n  function manipulationTarget (elem, content) {\n    return jQuery.nodeName(elem, 'table') &&\n      jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')\n      ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody'))\n      : elem\n  }\n\n  // Replace/restore the type attribute of script elements for safe DOM manipulation\n  function disableScript (elem) {\n    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type\n    return elem\n  }\n  function restoreScript (elem) {\n    var match = rscriptTypeMasked.exec(elem.type)\n\n    if (match) {\n      elem.type = match[1]\n    } else {\n      elem.removeAttribute('type')\n    }\n\n    return elem\n  }\n\n  function cloneCopyEvent (src, dest) {\n    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events\n\n    if (dest.nodeType !== 1) {\n      return\n    }\n\n    // 1. Copy private data: events, handlers, etc.\n    if (dataPriv.hasData(src)) {\n      pdataOld = dataPriv.access(src)\n      pdataCur = dataPriv.set(dest, pdataOld)\n      events = pdataOld.events\n\n      if (events) {\n        delete pdataCur.handle\n        pdataCur.events = {}\n\n        for (type in events) {\n          for (i = 0, l = events[type].length; i < l; i++) {\n            jQuery.event.add(dest, type, events[type][i])\n          }\n        }\n      }\n    }\n\n    // 2. Copy user data\n    if (dataUser.hasData(src)) {\n      udataOld = dataUser.access(src)\n      udataCur = jQuery.extend({}, udataOld)\n\n      dataUser.set(dest, udataCur)\n    }\n  }\n\n  // Fix IE bugs, see support tests\n  function fixInput (src, dest) {\n    var nodeName = dest.nodeName.toLowerCase()\n\n    // Fails to persist the checked state of a cloned checkbox or radio button.\n    if (nodeName === 'input' && rcheckableType.test(src.type)) {\n      dest.checked = src.checked\n\n      // Fails to return the selected option to the default selected state when cloning options\n    } else if (nodeName === 'input' || nodeName === 'textarea') {\n      dest.defaultValue = src.defaultValue\n    }\n  }\n\n  function domManip (collection, args, callback, ignored) {\n    // Flatten any nested arrays\n    args = concat.apply([], args)\n\n    var fragment,\n      first,\n      scripts,\n      hasScripts,\n      node,\n      doc,\n      i = 0,\n      l = collection.length,\n      iNoClone = l - 1,\n      value = args[0],\n      isFunction = jQuery.isFunction(value)\n\n    // We can't cloneNode fragments that contain checked, in WebKit\n    if (isFunction || (l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value))) {\n      return collection.each(function (index) {\n        var self = collection.eq(index)\n        if (isFunction) {\n          args[0] = value.call(this, index, self.html())\n        }\n        domManip(self, args, callback, ignored)\n      })\n    }\n\n    if (l) {\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored)\n      first = fragment.firstChild\n\n      if (fragment.childNodes.length === 1) {\n        fragment = first\n      }\n\n      // Require either new content or an interest in ignored elements to invoke the callback\n      if (first || ignored) {\n        scripts = jQuery.map(getAll(fragment, 'script'), disableScript)\n        hasScripts = scripts.length\n\n        // Use the original fragment for the last item\n        // instead of the first because it can end up\n        // being emptied incorrectly in certain situations (#8070).\n        for (; i < l; i++) {\n          node = fragment\n\n          if (i !== iNoClone) {\n            node = jQuery.clone(node, true, true)\n\n            // Keep references to cloned scripts for later restoration\n            if (hasScripts) {\n              // Support: Android<4.1, PhantomJS<2\n              // push.apply(_, arraylike) throws on ancient WebKit\n              jQuery.merge(scripts, getAll(node, 'script'))\n            }\n          }\n\n          callback.call(collection[i], node, i)\n        }\n\n        if (hasScripts) {\n          doc = scripts[scripts.length - 1].ownerDocument\n\n          // Reenable scripts\n          jQuery.map(scripts, restoreScript)\n\n          // Evaluate executable scripts on first document insertion\n          for (i = 0; i < hasScripts; i++) {\n            node = scripts[i]\n            if (\n              rscriptType.test(node.type || '') &&\n              !dataPriv.access(node, 'globalEval') &&\n              jQuery.contains(doc, node)\n            ) {\n              if (node.src) {\n                // Optional AJAX dependency, but won't run scripts if not present\n                if (jQuery._evalUrl) {\n                  jQuery._evalUrl(node.src)\n                }\n              } else {\n                jQuery.globalEval(node.textContent.replace(rcleanScript, ''))\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return collection\n  }\n\n  function remove (elem, selector, keepData) {\n    var node,\n      nodes = selector ? jQuery.filter(selector, elem) : elem,\n      i = 0\n\n    for (; (node = nodes[i]) != null; i++) {\n      if (!keepData && node.nodeType === 1) {\n        jQuery.cleanData(getAll(node))\n      }\n\n      if (node.parentNode) {\n        if (keepData && jQuery.contains(node.ownerDocument, node)) {\n          setGlobalEval(getAll(node, 'script'))\n        }\n        node.parentNode.removeChild(node)\n      }\n    }\n\n    return elem\n  }\n\n  jQuery.extend({\n    htmlPrefilter: function (html) {\n      return html.replace(rxhtmlTag, '<$1></$2>')\n    },\n\n    clone: function (elem, dataAndEvents, deepDataAndEvents) {\n      var i,\n        l,\n        srcElements,\n        destElements,\n        clone = elem.cloneNode(true),\n        inPage = jQuery.contains(elem.ownerDocument, elem)\n\n      // Fix IE cloning issues\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\n        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n        destElements = getAll(clone)\n        srcElements = getAll(elem)\n\n        for (i = 0, l = srcElements.length; i < l; i++) {\n          fixInput(srcElements[i], destElements[i])\n        }\n      }\n\n      // Copy the events from the original to the clone\n      if (dataAndEvents) {\n        if (deepDataAndEvents) {\n          srcElements = srcElements || getAll(elem)\n          destElements = destElements || getAll(clone)\n\n          for (i = 0, l = srcElements.length; i < l; i++) {\n            cloneCopyEvent(srcElements[i], destElements[i])\n          }\n        } else {\n          cloneCopyEvent(elem, clone)\n        }\n      }\n\n      // Preserve script evaluation history\n      destElements = getAll(clone, 'script')\n      if (destElements.length > 0) {\n        setGlobalEval(destElements, !inPage && getAll(elem, 'script'))\n      }\n\n      // Return the cloned set\n      return clone\n    },\n\n    cleanData: function (elems) {\n      var data,\n        elem,\n        type,\n        special = jQuery.event.special,\n        i = 0\n\n      for (; (elem = elems[i]) !== undefined; i++) {\n        if (acceptData(elem)) {\n          if ((data = elem[dataPriv.expando])) {\n            if (data.events) {\n              for (type in data.events) {\n                if (special[type]) {\n                  jQuery.event.remove(elem, type)\n\n                  // This is a shortcut to avoid jQuery.event.remove's overhead\n                } else {\n                  jQuery.removeEvent(elem, type, data.handle)\n                }\n              }\n            }\n\n            // Support: Chrome <= 35-45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataPriv.expando] = undefined\n          }\n          if (elem[dataUser.expando]) {\n            // Support: Chrome <= 35-45+\n            // Assign undefined instead of using delete, see Data#remove\n            elem[dataUser.expando] = undefined\n          }\n        }\n      }\n    }\n  })\n\n  jQuery.fn.extend({\n    // Keep domManip exposed until 3.0 (gh-2225)\n    domManip: domManip,\n\n    detach: function (selector) {\n      return remove(this, selector, true)\n    },\n\n    remove: function (selector) {\n      return remove(this, selector)\n    },\n\n    text: function (value) {\n      return access(\n        this,\n        function (value) {\n          return value === undefined\n            ? jQuery.text(this)\n            : this.empty().each(function () {\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n                  this.textContent = value\n                }\n              })\n        },\n        null,\n        value,\n        arguments.length\n      )\n    },\n\n    append: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem)\n          target.appendChild(elem)\n        }\n      })\n    },\n\n    prepend: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\n          var target = manipulationTarget(this, elem)\n          target.insertBefore(elem, target.firstChild)\n        }\n      })\n    },\n\n    before: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this)\n        }\n      })\n    },\n\n    after: function () {\n      return domManip(this, arguments, function (elem) {\n        if (this.parentNode) {\n          this.parentNode.insertBefore(elem, this.nextSibling)\n        }\n      })\n    },\n\n    empty: function () {\n      var elem,\n        i = 0\n\n      for (; (elem = this[i]) != null; i++) {\n        if (elem.nodeType === 1) {\n          // Prevent memory leaks\n          jQuery.cleanData(getAll(elem, false))\n\n          // Remove any remaining nodes\n          elem.textContent = ''\n        }\n      }\n\n      return this\n    },\n\n    clone: function (dataAndEvents, deepDataAndEvents) {\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents\n\n      return this.map(function () {\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents)\n      })\n    },\n\n    html: function (value) {\n      return access(\n        this,\n        function (value) {\n          var elem = this[0] || {},\n            i = 0,\n            l = this.length\n\n          if (value === undefined && elem.nodeType === 1) {\n            return elem.innerHTML\n          }\n\n          // See if we can take a shortcut and just use innerHTML\n          if (\n            typeof value === 'string' &&\n            !rnoInnerhtml.test(value) &&\n            !wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]\n          ) {\n            value = jQuery.htmlPrefilter(value)\n\n            try {\n              for (; i < l; i++) {\n                elem = this[i] || {}\n\n                // Remove element nodes and prevent memory leaks\n                if (elem.nodeType === 1) {\n                  jQuery.cleanData(getAll(elem, false))\n                  elem.innerHTML = value\n                }\n              }\n\n              elem = 0\n\n              // If using innerHTML throws an exception, use the fallback method\n            } catch (e) {}\n          }\n\n          if (elem) {\n            this.empty().append(value)\n          }\n        },\n        null,\n        value,\n        arguments.length\n      )\n    },\n\n    replaceWith: function () {\n      var ignored = []\n\n      // Make the changes, replacing each non-ignored context element with the new content\n      return domManip(\n        this,\n        arguments,\n        function (elem) {\n          var parent = this.parentNode\n\n          if (jQuery.inArray(this, ignored) < 0) {\n            jQuery.cleanData(getAll(this))\n            if (parent) {\n              parent.replaceChild(elem, this)\n            }\n          }\n\n          // Force callback invocation\n        },\n        ignored\n      )\n    }\n  })\n\n  jQuery.each(\n    {\n      appendTo: 'append',\n      prependTo: 'prepend',\n      insertBefore: 'before',\n      insertAfter: 'after',\n      replaceAll: 'replaceWith'\n    },\n    function (name, original) {\n      jQuery.fn[name] = function (selector) {\n        var elems,\n          ret = [],\n          insert = jQuery(selector),\n          last = insert.length - 1,\n          i = 0\n\n        for (; i <= last; i++) {\n          elems = i === last ? this : this.clone(true)\n          jQuery(insert[i])[original](elems)\n\n          // Support: QtWebKit\n          // .get() because push.apply(_, arraylike) throws\n          push.apply(ret, elems.get())\n        }\n\n        return this.pushStack(ret)\n      }\n    }\n  )\n\n  var iframe,\n    elemdisplay = {\n      // Support: Firefox\n      // We have to pre-define these values for FF (#10227)\n      HTML: 'block',\n      BODY: 'block'\n    }\n\n  /**\n   * Retrieve the actual display of a element\n   * @param {String} name nodeName of the element\n   * @param {Object} doc Document object\n   */\n\n  // Called only from within defaultDisplay\n  function actualDisplay (name, doc) {\n    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),\n      display = jQuery.css(elem[0], 'display')\n\n    // We don't have any data stored on the element,\n    // so use \"detach\" method as fast way to get rid of the element\n    elem.detach()\n\n    return display\n  }\n\n  /**\n   * Try to determine the default display value of an element\n   * @param {String} nodeName\n   */\n  function defaultDisplay (nodeName) {\n    var doc = document,\n      display = elemdisplay[nodeName]\n\n    if (!display) {\n      display = actualDisplay(nodeName, doc)\n\n      // If the simple way fails, read from inside an iframe\n      if (display === 'none' || !display) {\n        // Use the already-created iframe if possible\n        iframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(doc.documentElement)\n\n        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n        doc = iframe[0].contentDocument\n\n        // Support: IE\n        doc.write()\n        doc.close()\n\n        display = actualDisplay(nodeName, doc)\n        iframe.detach()\n      }\n\n      // Store the correct default display\n      elemdisplay[nodeName] = display\n    }\n\n    return display\n  }\n  var rmargin = /^margin/\n\n  var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i')\n\n  var getStyles = function (elem) {\n    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\n    // IE throws on elements created in popups\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n    var view = elem.ownerDocument.defaultView\n\n    if (!view || !view.opener) {\n      view = window\n    }\n\n    return view.getComputedStyle(elem)\n  }\n\n  var swap = function (elem, options, callback, args) {\n    var ret,\n      name,\n      old = {}\n\n    // Remember the old values, and insert the new ones\n    for (name in options) {\n      old[name] = elem.style[name]\n      elem.style[name] = options[name]\n    }\n\n    ret = callback.apply(elem, args || [])\n\n    // Revert the old values\n    for (name in options) {\n      elem.style[name] = old[name]\n    }\n\n    return ret\n  }\n\n  var documentElement = document.documentElement\n\n  ;(function () {\n    var pixelPositionVal,\n      boxSizingReliableVal,\n      pixelMarginRightVal,\n      reliableMarginLeftVal,\n      container = document.createElement('div'),\n      div = document.createElement('div')\n\n    // Finish early in limited (non-browser) environments\n    if (!div.style) {\n      return\n    }\n\n    // Support: IE9-11+\n    // Style of cloned element affects source element cloned (#8908)\n    div.style.backgroundClip = 'content-box'\n    div.cloneNode(true).style.backgroundClip = ''\n    support.clearCloneStyle = div.style.backgroundClip === 'content-box'\n\n    container.style.cssText =\n      'border:0;width:8px;height:0;top:0;left:-9999px;' + 'padding:0;margin-top:1px;position:absolute'\n    container.appendChild(div)\n\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\n    // so they're executed at the same time to save the second computation.\n    function computeStyleTests () {\n      div.style.cssText =\n        // Support: Firefox<29, Android 2.3\n        // Vendor-prefix box-sizing\n        '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' +\n        'position:relative;display:block;' +\n        'margin:auto;border:1px;padding:1px;' +\n        'top:1%;width:50%'\n      div.innerHTML = ''\n      documentElement.appendChild(container)\n\n      var divStyle = window.getComputedStyle(div)\n      pixelPositionVal = divStyle.top !== '1%'\n      reliableMarginLeftVal = divStyle.marginLeft === '2px'\n      boxSizingReliableVal = divStyle.width === '4px'\n\n      // Support: Android 4.0 - 4.3 only\n      // Some styles come back with percentage values, even though they shouldn't\n      div.style.marginRight = '50%'\n      pixelMarginRightVal = divStyle.marginRight === '4px'\n\n      documentElement.removeChild(container)\n    }\n\n    jQuery.extend(support, {\n      pixelPosition: function () {\n        // This test is executed only once but we still do memoizing\n        // since we can use the boxSizingReliable pre-computing.\n        // No need to check if the test was already performed, though.\n        computeStyleTests()\n        return pixelPositionVal\n      },\n      boxSizingReliable: function () {\n        if (boxSizingReliableVal == null) {\n          computeStyleTests()\n        }\n        return boxSizingReliableVal\n      },\n      pixelMarginRight: function () {\n        // Support: Android 4.0-4.3\n        // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal\n        // since that compresses better and they're computed together anyway.\n        if (boxSizingReliableVal == null) {\n          computeStyleTests()\n        }\n        return pixelMarginRightVal\n      },\n      reliableMarginLeft: function () {\n        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\n        if (boxSizingReliableVal == null) {\n          computeStyleTests()\n        }\n        return reliableMarginLeftVal\n      },\n      reliableMarginRight: function () {\n        // Support: Android 2.3\n        // Check if div with explicit width and no margin-right incorrectly\n        // gets computed margin-right based on width of container. (#3333)\n        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n        // This support function is only executed once so no memoizing is needed.\n        var ret,\n          marginDiv = div.appendChild(document.createElement('div'))\n\n        // Reset CSS: box-sizing; display; margin; border; padding\n        marginDiv.style.cssText = div.style.cssText =\n          // Support: Android 2.3\n          // Vendor-prefix box-sizing\n          '-webkit-box-sizing:content-box;box-sizing:content-box;' + 'display:block;margin:0;border:0;padding:0'\n        marginDiv.style.marginRight = marginDiv.style.width = '0'\n        div.style.width = '1px'\n        documentElement.appendChild(container)\n\n        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight)\n\n        documentElement.removeChild(container)\n        div.removeChild(marginDiv)\n\n        return ret\n      }\n    })\n  })()\n\n  function curCSS (elem, name, computed) {\n    var width,\n      minWidth,\n      maxWidth,\n      ret,\n      style = elem.style\n\n    computed = computed || getStyles(elem)\n    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined\n\n    // Support: Opera 12.1x only\n    // Fall back to style even without computed\n    // computed is undefined for elems on document fragments\n    if ((ret === '' || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {\n      ret = jQuery.style(elem, name)\n    }\n\n    // Support: IE9\n    // getPropertyValue is only needed for .css('filter') (#12537)\n    if (computed) {\n      // A tribute to the \"awesome hack by Dean Edwards\"\n      // Android Browser returns percentage for some values,\n      // but width seems to be reliably pixels.\n      // This is against the CSSOM draft spec:\n      // http://dev.w3.org/csswg/cssom/#resolved-values\n      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {\n        // Remember the original values\n        width = style.width\n        minWidth = style.minWidth\n        maxWidth = style.maxWidth\n\n        // Put in the new values to get a computed value out\n        style.minWidth = style.maxWidth = style.width = ret\n        ret = computed.width\n\n        // Revert the changed values\n        style.width = width\n        style.minWidth = minWidth\n        style.maxWidth = maxWidth\n      }\n    }\n\n    return ret !== undefined\n      ? // Support: IE9-11+\n        // IE returns zIndex value as an integer.\n        ret + ''\n      : ret\n  }\n\n  function addGetHookIf (conditionFn, hookFn) {\n    // Define the hook, we'll check on the first run if it's really needed.\n    return {\n      get: function () {\n        if (conditionFn()) {\n          // Hook not needed (or it's not possible to use it due\n          // to missing dependency), remove it.\n          delete this.get\n          return\n        }\n\n        // Hook needed; redefine it so that the support test is not executed again.\n        return (this.get = hookFn).apply(this, arguments)\n      }\n    }\n  }\n\n  var // Swappable if display is none or starts with table\n    // except \"table\", \"table-cell\", or \"table-caption\"\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n    cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' },\n    cssNormalTransform = {\n      letterSpacing: '0',\n      fontWeight: '400'\n    },\n    cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'],\n    emptyStyle = document.createElement('div').style\n\n  // Return a css property mapped to a potentially vendor prefixed property\n  function vendorPropName (name) {\n    // Shortcut for names that are not vendor prefixed\n    if (name in emptyStyle) {\n      return name\n    }\n\n    // Check for vendor prefixed names\n    var capName = name[0].toUpperCase() + name.slice(1),\n      i = cssPrefixes.length\n\n    while (i--) {\n      name = cssPrefixes[i] + capName\n      if (name in emptyStyle) {\n        return name\n      }\n    }\n  }\n\n  function setPositiveNumber (elem, value, subtract) {\n    // Any relative (+/-) values have already been\n    // normalized at this point\n    var matches = rcssNum.exec(value)\n    return matches\n      ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px')\n      : value\n  }\n\n  function augmentWidthOrHeight (elem, name, extra, isBorderBox, styles) {\n    var i =\n        extra === (isBorderBox ? 'border' : 'content')\n          ? // If we already have the right measurement, avoid augmentation\n            4\n          : // Otherwise initialize for horizontal or vertical properties\n          name === 'width'\n          ? 1\n          : 0,\n      val = 0\n\n    for (; i < 4; i += 2) {\n      // Both box models exclude margin, so add it if we want it\n      if (extra === 'margin') {\n        val += jQuery.css(elem, extra + cssExpand[i], true, styles)\n      }\n\n      if (isBorderBox) {\n        // border-box includes padding, so remove it if we want content\n        if (extra === 'content') {\n          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles)\n        }\n\n        // At this point, extra isn't border nor margin, so remove border\n        if (extra !== 'margin') {\n          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles)\n        }\n      } else {\n        // At this point, extra isn't content, so add padding\n        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles)\n\n        // At this point, extra isn't content nor padding, so add border\n        if (extra !== 'padding') {\n          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles)\n        }\n      }\n    }\n\n    return val\n  }\n\n  function getWidthOrHeight (elem, name, extra) {\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n      val = name === 'width' ? elem.offsetWidth : elem.offsetHeight,\n      styles = getStyles(elem),\n      isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box'\n\n    // Some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n    if (val <= 0 || val == null) {\n      // Fall back to computed then uncomputed css if necessary\n      val = curCSS(elem, name, styles)\n      if (val < 0 || val == null) {\n        val = elem.style[name]\n      }\n\n      // Computed unit is not pixels. Stop here and return.\n      if (rnumnonpx.test(val)) {\n        return val\n      }\n\n      // Check for style in case a browser which returns unreliable values\n      // for getComputedStyle silently falls back to the reliable elem.style\n      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name])\n\n      // Normalize \"\", auto, and prepare for extra\n      val = parseFloat(val) || 0\n    }\n\n    // Use the active box-sizing model to add/subtract irrelevant styles\n    return (\n      val +\n      augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) +\n      'px'\n    )\n  }\n\n  function showHide (elements, show) {\n    var display,\n      elem,\n      hidden,\n      values = [],\n      index = 0,\n      length = elements.length\n\n    for (; index < length; index++) {\n      elem = elements[index]\n      if (!elem.style) {\n        continue\n      }\n\n      values[index] = dataPriv.get(elem, 'olddisplay')\n      display = elem.style.display\n      if (show) {\n        // Reset the inline display of this element to learn if it is\n        // being hidden by cascaded rules or not\n        if (!values[index] && display === 'none') {\n          elem.style.display = ''\n        }\n\n        // Set elements which have been overridden with display: none\n        // in a stylesheet to whatever the default browser style is\n        // for such an element\n        if (elem.style.display === '' && isHidden(elem)) {\n          values[index] = dataPriv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName))\n        }\n      } else {\n        hidden = isHidden(elem)\n\n        if (display !== 'none' || !hidden) {\n          dataPriv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'))\n        }\n      }\n    }\n\n    // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n    for (index = 0; index < length; index++) {\n      elem = elements[index]\n      if (!elem.style) {\n        continue\n      }\n      if (!show || elem.style.display === 'none' || elem.style.display === '') {\n        elem.style.display = show ? values[index] || '' : 'none'\n      }\n    }\n\n    return elements\n  }\n\n  jQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n      opacity: {\n        get: function (elem, computed) {\n          if (computed) {\n            // We should always get a number back from opacity\n            var ret = curCSS(elem, 'opacity')\n            return ret === '' ? '1' : ret\n          }\n        }\n      }\n    },\n\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n      animationIterationCount: true,\n      columnCount: true,\n      fillOpacity: true,\n      flexGrow: true,\n      flexShrink: true,\n      fontWeight: true,\n      lineHeight: true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      widows: true,\n      zIndex: true,\n      zoom: true\n    },\n\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n      float: 'cssFloat'\n    },\n\n    // Get and set the style property on a DOM Node\n    style: function (elem, name, value, extra) {\n      // Don't set styles on text and comment nodes\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\n        return\n      }\n\n      // Make sure that we're working with the right name\n      var ret,\n        type,\n        hooks,\n        origName = jQuery.camelCase(name),\n        style = elem.style\n\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName)\n\n      // Gets hook for the prefixed version, then unprefixed version\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]\n\n      // Check if we're setting a value\n      if (value !== undefined) {\n        type = typeof value\n\n        // Convert \"+=\" or \"-=\" to relative numbers (#7345)\n        if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {\n          value = adjustCSS(elem, name, ret)\n\n          // Fixes bug #9237\n          type = 'number'\n        }\n\n        // Make sure that null and NaN values aren't set (#7116)\n        if (value == null || value !== value) {\n          return\n        }\n\n        // If a number was passed in, add the unit (except for certain CSS properties)\n        if (type === 'number') {\n          value += (ret && ret[3]) || (jQuery.cssNumber[origName] ? '' : 'px')\n        }\n\n        // Support: IE9-11+\n        // background-* props affect original clone's values\n        if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {\n          style[name] = 'inherit'\n        }\n\n        // If a hook was provided, use that value, otherwise just set the specified value\n        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\n          style[name] = value\n        }\n      } else {\n        // If a hook was provided get the non-computed value from there\n        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\n          return ret\n        }\n\n        // Otherwise just get the value from the style object\n        return style[name]\n      }\n    },\n\n    css: function (elem, name, extra, styles) {\n      var val,\n        num,\n        hooks,\n        origName = jQuery.camelCase(name)\n\n      // Make sure that we're working with the right name\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName)\n\n      // Try prefixed name followed by the unprefixed name\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]\n\n      // If a hook was provided get the computed value from there\n      if (hooks && 'get' in hooks) {\n        val = hooks.get(elem, true, extra)\n      }\n\n      // Otherwise, if a way to get the computed value exists, use that\n      if (val === undefined) {\n        val = curCSS(elem, name, styles)\n      }\n\n      // Convert \"normal\" to computed value\n      if (val === 'normal' && name in cssNormalTransform) {\n        val = cssNormalTransform[name]\n      }\n\n      // Make numeric if forced or a qualifier was provided and val looks numeric\n      if (extra === '' || extra) {\n        num = parseFloat(val)\n        return extra === true || isFinite(num) ? num || 0 : val\n      }\n      return val\n    }\n  })\n\n  jQuery.each(['height', 'width'], function (i, name) {\n    jQuery.cssHooks[name] = {\n      get: function (elem, computed, extra) {\n        if (computed) {\n          // Certain elements can have dimension info if we invisibly show them\n          // but it must have a current display style that would benefit\n          return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0\n            ? swap(elem, cssShow, function () {\n                return getWidthOrHeight(elem, name, extra)\n              })\n            : getWidthOrHeight(elem, name, extra)\n        }\n      },\n\n      set: function (elem, value, extra) {\n        var matches,\n          styles = extra && getStyles(elem),\n          subtract =\n            extra &&\n            augmentWidthOrHeight(\n              elem,\n              name,\n              extra,\n              jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',\n              styles\n            )\n\n        // Convert to pixels if value adjustment is needed\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {\n          elem.style[name] = value\n          value = jQuery.css(elem, name)\n        }\n\n        return setPositiveNumber(elem, value, subtract)\n      }\n    }\n  })\n\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\n    if (computed) {\n      return (\n        (parseFloat(curCSS(elem, 'marginLeft')) ||\n          elem.getBoundingClientRect().left -\n            swap(elem, { marginLeft: 0 }, function () {\n              return elem.getBoundingClientRect().left\n            })) + 'px'\n      )\n    }\n  })\n\n  // Support: Android 2.3\n  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\n    if (computed) {\n      return swap(elem, { display: 'inline-block' }, curCSS, [elem, 'marginRight'])\n    }\n  })\n\n  // These hooks are used by animate to expand properties\n  jQuery.each(\n    {\n      margin: '',\n      padding: '',\n      border: 'Width'\n    },\n    function (prefix, suffix) {\n      jQuery.cssHooks[prefix + suffix] = {\n        expand: function (value) {\n          var i = 0,\n            expanded = {},\n            // Assumes a single number if not a string\n            parts = typeof value === 'string' ? value.split(' ') : [value]\n\n          for (; i < 4; i++) {\n            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0]\n          }\n\n          return expanded\n        }\n      }\n\n      if (!rmargin.test(prefix)) {\n        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber\n      }\n    }\n  )\n\n  jQuery.fn.extend({\n    css: function (name, value) {\n      return access(\n        this,\n        function (elem, name, value) {\n          var styles,\n            len,\n            map = {},\n            i = 0\n\n          if (jQuery.isArray(name)) {\n            styles = getStyles(elem)\n            len = name.length\n\n            for (; i < len; i++) {\n              map[name[i]] = jQuery.css(elem, name[i], false, styles)\n            }\n\n            return map\n          }\n\n          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)\n        },\n        name,\n        value,\n        arguments.length > 1\n      )\n    },\n    show: function () {\n      return showHide(this, true)\n    },\n    hide: function () {\n      return showHide(this)\n    },\n    toggle: function (state) {\n      if (typeof state === 'boolean') {\n        return state ? this.show() : this.hide()\n      }\n\n      return this.each(function () {\n        if (isHidden(this)) {\n          jQuery(this).show()\n        } else {\n          jQuery(this).hide()\n        }\n      })\n    }\n  })\n\n  function Tween (elem, options, prop, end, easing) {\n    return new Tween.prototype.init(elem, options, prop, end, easing)\n  }\n  jQuery.Tween = Tween\n\n  Tween.prototype = {\n    constructor: Tween,\n    init: function (elem, options, prop, end, easing, unit) {\n      this.elem = elem\n      this.prop = prop\n      this.easing = easing || jQuery.easing._default\n      this.options = options\n      this.start = this.now = this.cur()\n      this.end = end\n      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px')\n    },\n    cur: function () {\n      var hooks = Tween.propHooks[this.prop]\n\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)\n    },\n    run: function (percent) {\n      var eased,\n        hooks = Tween.propHooks[this.prop]\n\n      if (this.options.duration) {\n        this.pos = eased = jQuery.easing[this.easing](\n          percent,\n          this.options.duration * percent,\n          0,\n          1,\n          this.options.duration\n        )\n      } else {\n        this.pos = eased = percent\n      }\n      this.now = (this.end - this.start) * eased + this.start\n\n      if (this.options.step) {\n        this.options.step.call(this.elem, this.now, this)\n      }\n\n      if (hooks && hooks.set) {\n        hooks.set(this)\n      } else {\n        Tween.propHooks._default.set(this)\n      }\n      return this\n    }\n  }\n\n  Tween.prototype.init.prototype = Tween.prototype\n\n  Tween.propHooks = {\n    _default: {\n      get: function (tween) {\n        var result\n\n        // Use a property on the element directly when it is not a DOM element,\n        // or when there is no matching style property that exists.\n        if (tween.elem.nodeType !== 1 || (tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null)) {\n          return tween.elem[tween.prop]\n        }\n\n        // Passing an empty string as a 3rd parameter to .css will automatically\n        // attempt a parseFloat and fallback to a string if the parse fails.\n        // Simple values such as \"10px\" are parsed to Float;\n        // complex values such as \"rotate(1rad)\" are returned as-is.\n        result = jQuery.css(tween.elem, tween.prop, '')\n\n        // Empty strings, null, undefined and \"auto\" are converted to 0.\n        return !result || result === 'auto' ? 0 : result\n      },\n      set: function (tween) {\n        // Use step hook for back compat.\n        // Use cssHook if its there.\n        // Use .style if available and use plain properties where available.\n        if (jQuery.fx.step[tween.prop]) {\n          jQuery.fx.step[tween.prop](tween)\n        } else if (\n          tween.elem.nodeType === 1 &&\n          (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])\n        ) {\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)\n        } else {\n          tween.elem[tween.prop] = tween.now\n        }\n      }\n    }\n  }\n\n  // Support: IE9\n  // Panic based approach to setting things on disconnected nodes\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function (tween) {\n      if (tween.elem.nodeType && tween.elem.parentNode) {\n        tween.elem[tween.prop] = tween.now\n      }\n    }\n  }\n\n  jQuery.easing = {\n    linear: function (p) {\n      return p\n    },\n    swing: function (p) {\n      return 0.5 - Math.cos(p * Math.PI) / 2\n    },\n    _default: 'swing'\n  }\n\n  jQuery.fx = Tween.prototype.init\n\n  // Back Compat <1.8 extension point\n  jQuery.fx.step = {}\n\n  var fxNow,\n    timerId,\n    rfxtypes = /^(?:toggle|show|hide)$/,\n    rrun = /queueHooks$/\n\n  // Animations created synchronously will run synchronously\n  function createFxNow () {\n    window.setTimeout(function () {\n      fxNow = undefined\n    })\n    return (fxNow = jQuery.now())\n  }\n\n  // Generate parameters to create a standard animation\n  function genFx (type, includeWidth) {\n    var which,\n      i = 0,\n      attrs = { height: type }\n\n    // If we include width, step value is 1 to do all cssExpand values,\n    // otherwise step value is 2 to skip over Left and Right\n    includeWidth = includeWidth ? 1 : 0\n    for (; i < 4; i += 2 - includeWidth) {\n      which = cssExpand[i]\n      attrs['margin' + which] = attrs['padding' + which] = type\n    }\n\n    if (includeWidth) {\n      attrs.opacity = attrs.width = type\n    }\n\n    return attrs\n  }\n\n  function createTween (value, prop, animation) {\n    var tween,\n      collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']),\n      index = 0,\n      length = collection.length\n    for (; index < length; index++) {\n      if ((tween = collection[index].call(animation, prop, value))) {\n        // We're done with this property\n        return tween\n      }\n    }\n  }\n\n  function defaultPrefilter (elem, props, opts) {\n    /* jshint validthis: true */\n    var prop,\n      value,\n      toggle,\n      tween,\n      hooks,\n      oldfire,\n      display,\n      checkDisplay,\n      anim = this,\n      orig = {},\n      style = elem.style,\n      hidden = elem.nodeType && isHidden(elem),\n      dataShow = dataPriv.get(elem, 'fxshow')\n\n    // Handle queue: false promises\n    if (!opts.queue) {\n      hooks = jQuery._queueHooks(elem, 'fx')\n      if (hooks.unqueued == null) {\n        hooks.unqueued = 0\n        oldfire = hooks.empty.fire\n        hooks.empty.fire = function () {\n          if (!hooks.unqueued) {\n            oldfire()\n          }\n        }\n      }\n      hooks.unqueued++\n\n      anim.always(function () {\n        // Ensure the complete handler is called before this completes\n        anim.always(function () {\n          hooks.unqueued--\n          if (!jQuery.queue(elem, 'fx').length) {\n            hooks.empty.fire()\n          }\n        })\n      })\n    }\n\n    // Height/width overflow pass\n    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {\n      // Make sure that nothing sneaks out\n      // Record all 3 overflow attributes because IE9-10 do not\n      // change the overflow attribute when overflowX and\n      // overflowY are set to the same value\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]\n\n      // Set display property to inline-block for height/width\n      // animations on inline elements that are having width/height animated\n      display = jQuery.css(elem, 'display')\n\n      // Test default display if display is currently \"none\"\n      checkDisplay = display === 'none' ? dataPriv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display\n\n      if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {\n        style.display = 'inline-block'\n      }\n    }\n\n    if (opts.overflow) {\n      style.overflow = 'hidden'\n      anim.always(function () {\n        style.overflow = opts.overflow[0]\n        style.overflowX = opts.overflow[1]\n        style.overflowY = opts.overflow[2]\n      })\n    }\n\n    // show/hide pass\n    for (prop in props) {\n      value = props[prop]\n      if (rfxtypes.exec(value)) {\n        delete props[prop]\n        toggle = toggle || value === 'toggle'\n        if (value === (hidden ? 'hide' : 'show')) {\n          // If there is dataShow left over from a stopped hide or show\n          // and we are going to proceed with show, we should pretend to be hidden\n          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {\n            hidden = true\n          } else {\n            continue\n          }\n        }\n        orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop)\n\n        // Any non-fx value stops us from restoring the original display value\n      } else {\n        display = undefined\n      }\n    }\n\n    if (!jQuery.isEmptyObject(orig)) {\n      if (dataShow) {\n        if ('hidden' in dataShow) {\n          hidden = dataShow.hidden\n        }\n      } else {\n        dataShow = dataPriv.access(elem, 'fxshow', {})\n      }\n\n      // Store state if its toggle - enables .stop().toggle() to \"reverse\"\n      if (toggle) {\n        dataShow.hidden = !hidden\n      }\n      if (hidden) {\n        jQuery(elem).show()\n      } else {\n        anim.done(function () {\n          jQuery(elem).hide()\n        })\n      }\n      anim.done(function () {\n        var prop\n\n        dataPriv.remove(elem, 'fxshow')\n        for (prop in orig) {\n          jQuery.style(elem, prop, orig[prop])\n        }\n      })\n      for (prop in orig) {\n        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim)\n\n        if (!(prop in dataShow)) {\n          dataShow[prop] = tween.start\n          if (hidden) {\n            tween.end = tween.start\n            tween.start = prop === 'width' || prop === 'height' ? 1 : 0\n          }\n        }\n      }\n\n      // If this is a noop like .hide().hide(), restore an overwritten display value\n    } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {\n      style.display = display\n    }\n  }\n\n  function propFilter (props, specialEasing) {\n    var index, name, easing, value, hooks\n\n    // camelCase, specialEasing and expand cssHook pass\n    for (index in props) {\n      name = jQuery.camelCase(index)\n      easing = specialEasing[name]\n      value = props[index]\n      if (jQuery.isArray(value)) {\n        easing = value[1]\n        value = props[index] = value[0]\n      }\n\n      if (index !== name) {\n        props[name] = value\n        delete props[index]\n      }\n\n      hooks = jQuery.cssHooks[name]\n      if (hooks && 'expand' in hooks) {\n        value = hooks.expand(value)\n        delete props[name]\n\n        // Not quite $.extend, this won't overwrite existing keys.\n        // Reusing 'index' because we have the correct \"name\"\n        for (index in value) {\n          if (!(index in props)) {\n            props[index] = value[index]\n            specialEasing[index] = easing\n          }\n        }\n      } else {\n        specialEasing[name] = easing\n      }\n    }\n  }\n\n  function Animation (elem, properties, options) {\n    var result,\n      stopped,\n      index = 0,\n      length = Animation.prefilters.length,\n      deferred = jQuery.Deferred().always(function () {\n        // Don't match elem in the :animated selector\n        delete tick.elem\n      }),\n      tick = function () {\n        if (stopped) {\n          return false\n        }\n        var currentTime = fxNow || createFxNow(),\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\n          // Support: Android 2.3\n          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n          temp = remaining / animation.duration || 0,\n          percent = 1 - temp,\n          index = 0,\n          length = animation.tweens.length\n\n        for (; index < length; index++) {\n          animation.tweens[index].run(percent)\n        }\n\n        deferred.notifyWith(elem, [animation, percent, remaining])\n\n        if (percent < 1 && length) {\n          return remaining\n        } else {\n          deferred.resolveWith(elem, [animation])\n          return false\n        }\n      },\n      animation = deferred.promise({\n        elem: elem,\n        props: jQuery.extend({}, properties),\n        opts: jQuery.extend(\n          true,\n          {\n            specialEasing: {},\n            easing: jQuery.easing._default\n          },\n          options\n        ),\n        originalProperties: properties,\n        originalOptions: options,\n        startTime: fxNow || createFxNow(),\n        duration: options.duration,\n        tweens: [],\n        createTween: function (prop, end) {\n          var tween = jQuery.Tween(\n            elem,\n            animation.opts,\n            prop,\n            end,\n            animation.opts.specialEasing[prop] || animation.opts.easing\n          )\n          animation.tweens.push(tween)\n          return tween\n        },\n        stop: function (gotoEnd) {\n          var index = 0,\n            // If we are going to the end, we want to run all the tweens\n            // otherwise we skip this part\n            length = gotoEnd ? animation.tweens.length : 0\n          if (stopped) {\n            return this\n          }\n          stopped = true\n          for (; index < length; index++) {\n            animation.tweens[index].run(1)\n          }\n\n          // Resolve when we played the last frame; otherwise, reject\n          if (gotoEnd) {\n            deferred.notifyWith(elem, [animation, 1, 0])\n            deferred.resolveWith(elem, [animation, gotoEnd])\n          } else {\n            deferred.rejectWith(elem, [animation, gotoEnd])\n          }\n          return this\n        }\n      }),\n      props = animation.props\n\n    propFilter(props, animation.opts.specialEasing)\n\n    for (; index < length; index++) {\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts)\n      if (result) {\n        if (jQuery.isFunction(result.stop)) {\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)\n        }\n        return result\n      }\n    }\n\n    jQuery.map(props, createTween, animation)\n\n    if (jQuery.isFunction(animation.opts.start)) {\n      animation.opts.start.call(elem, animation)\n    }\n\n    jQuery.fx.timer(\n      jQuery.extend(tick, {\n        elem: elem,\n        anim: animation,\n        queue: animation.opts.queue\n      })\n    )\n\n    // attach callbacks from options\n    return animation\n      .progress(animation.opts.progress)\n      .done(animation.opts.done, animation.opts.complete)\n      .fail(animation.opts.fail)\n      .always(animation.opts.always)\n  }\n\n  jQuery.Animation = jQuery.extend(Animation, {\n    tweeners: {\n      '*': [\n        function (prop, value) {\n          var tween = this.createTween(prop, value)\n          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween)\n          return tween\n        }\n      ]\n    },\n\n    tweener: function (props, callback) {\n      if (jQuery.isFunction(props)) {\n        callback = props\n        props = ['*']\n      } else {\n        props = props.match(rnotwhite)\n      }\n\n      var prop,\n        index = 0,\n        length = props.length\n\n      for (; index < length; index++) {\n        prop = props[index]\n        Animation.tweeners[prop] = Animation.tweeners[prop] || []\n        Animation.tweeners[prop].unshift(callback)\n      }\n    },\n\n    prefilters: [defaultPrefilter],\n\n    prefilter: function (callback, prepend) {\n      if (prepend) {\n        Animation.prefilters.unshift(callback)\n      } else {\n        Animation.prefilters.push(callback)\n      }\n    }\n  })\n\n  jQuery.speed = function (speed, easing, fn) {\n    var opt =\n      speed && typeof speed === 'object'\n        ? jQuery.extend({}, speed)\n        : {\n            complete: fn || (!fn && easing) || (jQuery.isFunction(speed) && speed),\n            duration: speed,\n            easing: (fn && easing) || (easing && !jQuery.isFunction(easing) && easing)\n          }\n\n    opt.duration = jQuery.fx.off\n      ? 0\n      : typeof opt.duration === 'number'\n      ? opt.duration\n      : opt.duration in jQuery.fx.speeds\n      ? jQuery.fx.speeds[opt.duration]\n      : jQuery.fx.speeds._default\n\n    // Normalize opt.queue - true/undefined/null -> \"fx\"\n    if (opt.queue == null || opt.queue === true) {\n      opt.queue = 'fx'\n    }\n\n    // Queueing\n    opt.old = opt.complete\n\n    opt.complete = function () {\n      if (jQuery.isFunction(opt.old)) {\n        opt.old.call(this)\n      }\n\n      if (opt.queue) {\n        jQuery.dequeue(this, opt.queue)\n      }\n    }\n\n    return opt\n  }\n\n  jQuery.fn.extend({\n    fadeTo: function (speed, to, easing, callback) {\n      // Show any hidden elements after setting opacity to 0\n      return (\n        this.filter(isHidden)\n          .css('opacity', 0)\n          .show()\n\n          // Animate to the value specified\n          .end()\n          .animate({ opacity: to }, speed, easing, callback)\n      )\n    },\n    animate: function (prop, speed, easing, callback) {\n      var empty = jQuery.isEmptyObject(prop),\n        optall = jQuery.speed(speed, easing, callback),\n        doAnimation = function () {\n          // Operate on a copy of prop so per-property easing won't be lost\n          var anim = Animation(this, jQuery.extend({}, prop), optall)\n\n          // Empty animations, or finishing resolves immediately\n          if (empty || dataPriv.get(this, 'finish')) {\n            anim.stop(true)\n          }\n        }\n      doAnimation.finish = doAnimation\n\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)\n    },\n    stop: function (type, clearQueue, gotoEnd) {\n      var stopQueue = function (hooks) {\n        var stop = hooks.stop\n        delete hooks.stop\n        stop(gotoEnd)\n      }\n\n      if (typeof type !== 'string') {\n        gotoEnd = clearQueue\n        clearQueue = type\n        type = undefined\n      }\n      if (clearQueue && type !== false) {\n        this.queue(type || 'fx', [])\n      }\n\n      return this.each(function () {\n        var dequeue = true,\n          index = type != null && type + 'queueHooks',\n          timers = jQuery.timers,\n          data = dataPriv.get(this)\n\n        if (index) {\n          if (data[index] && data[index].stop) {\n            stopQueue(data[index])\n          }\n        } else {\n          for (index in data) {\n            if (data[index] && data[index].stop && rrun.test(index)) {\n              stopQueue(data[index])\n            }\n          }\n        }\n\n        for (index = timers.length; index--; ) {\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\n            timers[index].anim.stop(gotoEnd)\n            dequeue = false\n            timers.splice(index, 1)\n          }\n        }\n\n        // Start the next in the queue if the last step wasn't forced.\n        // Timers currently will call their complete callbacks, which\n        // will dequeue but only if they were gotoEnd.\n        if (dequeue || !gotoEnd) {\n          jQuery.dequeue(this, type)\n        }\n      })\n    },\n    finish: function (type) {\n      if (type !== false) {\n        type = type || 'fx'\n      }\n      return this.each(function () {\n        var index,\n          data = dataPriv.get(this),\n          queue = data[type + 'queue'],\n          hooks = data[type + 'queueHooks'],\n          timers = jQuery.timers,\n          length = queue ? queue.length : 0\n\n        // Enable finishing flag on private data\n        data.finish = true\n\n        // Empty the queue first\n        jQuery.queue(this, type, [])\n\n        if (hooks && hooks.stop) {\n          hooks.stop.call(this, true)\n        }\n\n        // Look for any active animations, and finish them\n        for (index = timers.length; index--; ) {\n          if (timers[index].elem === this && timers[index].queue === type) {\n            timers[index].anim.stop(true)\n            timers.splice(index, 1)\n          }\n        }\n\n        // Look for any animations in the old queue and finish them\n        for (index = 0; index < length; index++) {\n          if (queue[index] && queue[index].finish) {\n            queue[index].finish.call(this)\n          }\n        }\n\n        // Turn off finishing flag\n        delete data.finish\n      })\n    }\n  })\n\n  jQuery.each(['toggle', 'show', 'hide'], function (i, name) {\n    var cssFn = jQuery.fn[name]\n    jQuery.fn[name] = function (speed, easing, callback) {\n      return speed == null || typeof speed === 'boolean'\n        ? cssFn.apply(this, arguments)\n        : this.animate(genFx(name, true), speed, easing, callback)\n    }\n  })\n\n  // Generate shortcuts for custom animations\n  jQuery.each(\n    {\n      slideDown: genFx('show'),\n      slideUp: genFx('hide'),\n      slideToggle: genFx('toggle'),\n      fadeIn: { opacity: 'show' },\n      fadeOut: { opacity: 'hide' },\n      fadeToggle: { opacity: 'toggle' }\n    },\n    function (name, props) {\n      jQuery.fn[name] = function (speed, easing, callback) {\n        return this.animate(props, speed, easing, callback)\n      }\n    }\n  )\n\n  jQuery.timers = []\n  jQuery.fx.tick = function () {\n    var timer,\n      i = 0,\n      timers = jQuery.timers\n\n    fxNow = jQuery.now()\n\n    for (; i < timers.length; i++) {\n      timer = timers[i]\n\n      // Checks the timer has not already been removed\n      if (!timer() && timers[i] === timer) {\n        timers.splice(i--, 1)\n      }\n    }\n\n    if (!timers.length) {\n      jQuery.fx.stop()\n    }\n    fxNow = undefined\n  }\n\n  jQuery.fx.timer = function (timer) {\n    jQuery.timers.push(timer)\n    if (timer()) {\n      jQuery.fx.start()\n    } else {\n      jQuery.timers.pop()\n    }\n  }\n\n  jQuery.fx.interval = 13\n  jQuery.fx.start = function () {\n    if (!timerId) {\n      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval)\n    }\n  }\n\n  jQuery.fx.stop = function () {\n    window.clearInterval(timerId)\n\n    timerId = null\n  }\n\n  jQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n\n    // Default speed\n    _default: 400\n  }\n\n  // Based off of the plugin by Clint Helfers, with permission.\n  // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\n  jQuery.fn.delay = function (time, type) {\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time\n    type = type || 'fx'\n\n    return this.queue(type, function (next, hooks) {\n      var timeout = window.setTimeout(next, time)\n      hooks.stop = function () {\n        window.clearTimeout(timeout)\n      }\n    })\n  }\n  ;(function () {\n    var input = document.createElement('input'),\n      select = document.createElement('select'),\n      opt = select.appendChild(document.createElement('option'))\n\n    input.type = 'checkbox'\n\n    // Support: iOS<=5.1, Android<=4.2+\n    // Default value for a checkbox should be \"on\"\n    support.checkOn = input.value !== ''\n\n    // Support: IE<=11+\n    // Must access selectedIndex to make default options select\n    support.optSelected = opt.selected\n\n    // Support: Android<=2.3\n    // Options inside disabled selects are incorrectly marked as disabled\n    select.disabled = true\n    support.optDisabled = !opt.disabled\n\n    // Support: IE<=11+\n    // An input loses its value after becoming a radio\n    input = document.createElement('input')\n    input.value = 't'\n    input.type = 'radio'\n    support.radioValue = input.value === 't'\n  })()\n\n  var boolHook,\n    attrHandle = jQuery.expr.attrHandle\n\n  jQuery.fn.extend({\n    attr: function (name, value) {\n      return access(this, jQuery.attr, name, value, arguments.length > 1)\n    },\n\n    removeAttr: function (name) {\n      return this.each(function () {\n        jQuery.removeAttr(this, name)\n      })\n    }\n  })\n\n  jQuery.extend({\n    attr: function (elem, name, value) {\n      var ret,\n        hooks,\n        nType = elem.nodeType\n\n      // Don't get/set attributes on text, comment and attribute nodes\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return\n      }\n\n      // Fallback to prop when attributes are not supported\n      if (typeof elem.getAttribute === 'undefined') {\n        return jQuery.prop(elem, name, value)\n      }\n\n      // All attributes are lowercase\n      // Grab necessary hook if one is defined\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        name = name.toLowerCase()\n        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined)\n      }\n\n      if (value !== undefined) {\n        if (value === null) {\n          jQuery.removeAttr(elem, name)\n          return\n        }\n\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret\n        }\n\n        elem.setAttribute(name, value + '')\n        return value\n      }\n\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret\n      }\n\n      ret = jQuery.find.attr(elem, name)\n\n      // Non-existent attributes return null, we normalize to undefined\n      return ret == null ? undefined : ret\n    },\n\n    attrHooks: {\n      type: {\n        set: function (elem, value) {\n          if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {\n            var val = elem.value\n            elem.setAttribute('type', value)\n            if (val) {\n              elem.value = val\n            }\n            return value\n          }\n        }\n      }\n    },\n\n    removeAttr: function (elem, value) {\n      var name,\n        propName,\n        i = 0,\n        attrNames = value && value.match(rnotwhite)\n\n      if (attrNames && elem.nodeType === 1) {\n        while ((name = attrNames[i++])) {\n          propName = jQuery.propFix[name] || name\n\n          // Boolean attributes get special treatment (#10870)\n          if (jQuery.expr.match.bool.test(name)) {\n            // Set corresponding property to false\n            elem[propName] = false\n          }\n\n          elem.removeAttribute(name)\n        }\n      }\n    }\n  })\n\n  // Hooks for boolean attributes\n  boolHook = {\n    set: function (elem, value, name) {\n      if (value === false) {\n        // Remove boolean attributes when set to false\n        jQuery.removeAttr(elem, name)\n      } else {\n        elem.setAttribute(name, name)\n      }\n      return name\n    }\n  }\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\n    var getter = attrHandle[name] || jQuery.find.attr\n\n    attrHandle[name] = function (elem, name, isXML) {\n      var ret, handle\n      if (!isXML) {\n        // Avoid an infinite loop by temporarily removing this function from the getter\n        handle = attrHandle[name]\n        attrHandle[name] = ret\n        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null\n        attrHandle[name] = handle\n      }\n      return ret\n    }\n  })\n\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\n    rclickable = /^(?:a|area)$/i\n\n  jQuery.fn.extend({\n    prop: function (name, value) {\n      return access(this, jQuery.prop, name, value, arguments.length > 1)\n    },\n\n    removeProp: function (name) {\n      return this.each(function () {\n        delete this[jQuery.propFix[name] || name]\n      })\n    }\n  })\n\n  jQuery.extend({\n    prop: function (elem, name, value) {\n      var ret,\n        hooks,\n        nType = elem.nodeType\n\n      // Don't get/set properties on text, comment and attribute nodes\n      if (nType === 3 || nType === 8 || nType === 2) {\n        return\n      }\n\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\n        // Fix name and attach hooks\n        name = jQuery.propFix[name] || name\n        hooks = jQuery.propHooks[name]\n      }\n\n      if (value !== undefined) {\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\n          return ret\n        }\n\n        return (elem[name] = value)\n      }\n\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\n        return ret\n      }\n\n      return elem[name]\n    },\n\n    propHooks: {\n      tabIndex: {\n        get: function (elem) {\n          // elem.tabIndex doesn't always return the\n          // correct value when it hasn't been explicitly set\n          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n          // Use proper attribute retrieval(#12072)\n          var tabindex = jQuery.find.attr(elem, 'tabindex')\n\n          return tabindex\n            ? parseInt(tabindex, 10)\n            : rfocusable.test(elem.nodeName) || (rclickable.test(elem.nodeName) && elem.href)\n            ? 0\n            : -1\n        }\n      }\n    },\n\n    propFix: {\n      for: 'htmlFor',\n      class: 'className'\n    }\n  })\n\n  // Support: IE <=11 only\n  // Accessing the selectedIndex property\n  // forces the browser to respect setting selected\n  // on the option\n  // The getter ensures a default option is selected\n  // when in an optgroup\n  if (!support.optSelected) {\n    jQuery.propHooks.selected = {\n      get: function (elem) {\n        var parent = elem.parentNode\n        if (parent && parent.parentNode) {\n          parent.parentNode.selectedIndex\n        }\n        return null\n      },\n      set: function (elem) {\n        var parent = elem.parentNode\n        if (parent) {\n          parent.selectedIndex\n\n          if (parent.parentNode) {\n            parent.parentNode.selectedIndex\n          }\n        }\n      }\n    }\n  }\n\n  jQuery.each(\n    [\n      'tabIndex',\n      'readOnly',\n      'maxLength',\n      'cellSpacing',\n      'cellPadding',\n      'rowSpan',\n      'colSpan',\n      'useMap',\n      'frameBorder',\n      'contentEditable'\n    ],\n    function () {\n      jQuery.propFix[this.toLowerCase()] = this\n    }\n  )\n\n  var rclass = /[\\t\\r\\n\\f]/g\n\n  function getClass (elem) {\n    return (elem.getAttribute && elem.getAttribute('class')) || ''\n  }\n\n  jQuery.fn.extend({\n    addClass: function (value) {\n      var classes,\n        elem,\n        cur,\n        curValue,\n        clazz,\n        j,\n        finalValue,\n        i = 0\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).addClass(value.call(this, j, getClass(this)))\n        })\n      }\n\n      if (typeof value === 'string' && value) {\n        classes = value.match(rnotwhite) || []\n\n        while ((elem = this[i++])) {\n          curValue = getClass(elem)\n          cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ')\n\n          if (cur) {\n            j = 0\n            while ((clazz = classes[j++])) {\n              if (cur.indexOf(' ' + clazz + ' ') < 0) {\n                cur += clazz + ' '\n              }\n            }\n\n            // Only assign if different to avoid unneeded rendering.\n            finalValue = jQuery.trim(cur)\n            if (curValue !== finalValue) {\n              elem.setAttribute('class', finalValue)\n            }\n          }\n        }\n      }\n\n      return this\n    },\n\n    removeClass: function (value) {\n      var classes,\n        elem,\n        cur,\n        curValue,\n        clazz,\n        j,\n        finalValue,\n        i = 0\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (j) {\n          jQuery(this).removeClass(value.call(this, j, getClass(this)))\n        })\n      }\n\n      if (!arguments.length) {\n        return this.attr('class', '')\n      }\n\n      if (typeof value === 'string' && value) {\n        classes = value.match(rnotwhite) || []\n\n        while ((elem = this[i++])) {\n          curValue = getClass(elem)\n\n          // This expression is here for better compressibility (see addClass)\n          cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ')\n\n          if (cur) {\n            j = 0\n            while ((clazz = classes[j++])) {\n              // Remove *all* instances\n              while (cur.indexOf(' ' + clazz + ' ') > -1) {\n                cur = cur.replace(' ' + clazz + ' ', ' ')\n              }\n            }\n\n            // Only assign if different to avoid unneeded rendering.\n            finalValue = jQuery.trim(cur)\n            if (curValue !== finalValue) {\n              elem.setAttribute('class', finalValue)\n            }\n          }\n        }\n      }\n\n      return this\n    },\n\n    toggleClass: function (value, stateVal) {\n      var type = typeof value\n\n      if (typeof stateVal === 'boolean' && type === 'string') {\n        return stateVal ? this.addClass(value) : this.removeClass(value)\n      }\n\n      if (jQuery.isFunction(value)) {\n        return this.each(function (i) {\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)\n        })\n      }\n\n      return this.each(function () {\n        var className, i, self, classNames\n\n        if (type === 'string') {\n          // Toggle individual class names\n          i = 0\n          self = jQuery(this)\n          classNames = value.match(rnotwhite) || []\n\n          while ((className = classNames[i++])) {\n            // Check each className given, space separated list\n            if (self.hasClass(className)) {\n              self.removeClass(className)\n            } else {\n              self.addClass(className)\n            }\n          }\n\n          // Toggle whole class name\n        } else if (value === undefined || type === 'boolean') {\n          className = getClass(this)\n          if (className) {\n            // Store className if set\n            dataPriv.set(this, '__className__', className)\n          }\n\n          // If the element has a class name or if we're passed `false`,\n          // then remove the whole classname (if there was one, the above saved it).\n          // Otherwise bring back whatever was previously saved (if anything),\n          // falling back to the empty string if nothing was stored.\n          if (this.setAttribute) {\n            this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '')\n          }\n        }\n      })\n    },\n\n    hasClass: function (selector) {\n      var className,\n        elem,\n        i = 0\n\n      className = ' ' + selector + ' '\n      while ((elem = this[i++])) {\n        if (elem.nodeType === 1 && (' ' + getClass(elem) + ' ').replace(rclass, ' ').indexOf(className) > -1) {\n          return true\n        }\n      }\n\n      return false\n    }\n  })\n\n  var rreturn = /\\r/g,\n    rspaces = /[\\x20\\t\\r\\n\\f]+/g\n\n  jQuery.fn.extend({\n    val: function (value) {\n      var hooks,\n        ret,\n        isFunction,\n        elem = this[0]\n\n      if (!arguments.length) {\n        if (elem) {\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]\n\n          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {\n            return ret\n          }\n\n          ret = elem.value\n\n          return typeof ret === 'string'\n            ? // Handle most common string cases\n              ret.replace(rreturn, '')\n            : // Handle cases where value is null/undef or number\n            ret == null\n            ? ''\n            : ret\n        }\n\n        return\n      }\n\n      isFunction = jQuery.isFunction(value)\n\n      return this.each(function (i) {\n        var val\n\n        if (this.nodeType !== 1) {\n          return\n        }\n\n        if (isFunction) {\n          val = value.call(this, i, jQuery(this).val())\n        } else {\n          val = value\n        }\n\n        // Treat null/undefined as \"\"; convert numbers to string\n        if (val == null) {\n          val = ''\n        } else if (typeof val === 'number') {\n          val += ''\n        } else if (jQuery.isArray(val)) {\n          val = jQuery.map(val, function (value) {\n            return value == null ? '' : value + ''\n          })\n        }\n\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]\n\n        // If set returns undefined, fall back to normal setting\n        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {\n          this.value = val\n        }\n      })\n    }\n  })\n\n  jQuery.extend({\n    valHooks: {\n      option: {\n        get: function (elem) {\n          var val = jQuery.find.attr(elem, 'value')\n          return val != null\n            ? val\n            : // Support: IE10-11+\n              // option.text throws exceptions (#14686, #14858)\n              // Strip and collapse whitespace\n              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n              jQuery.trim(jQuery.text(elem)).replace(rspaces, ' ')\n        }\n      },\n      select: {\n        get: function (elem) {\n          var value,\n            option,\n            options = elem.options,\n            index = elem.selectedIndex,\n            one = elem.type === 'select-one' || index < 0,\n            values = one ? null : [],\n            max = one ? index + 1 : options.length,\n            i = index < 0 ? max : one ? index : 0\n\n          // Loop through all the selected options\n          for (; i < max; i++) {\n            option = options[i]\n\n            // IE8-9 doesn't update selected after form reset (#2551)\n            if (\n              (option.selected || i === index) &&\n              // Don't return options that are disabled or in a disabled optgroup\n              (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) &&\n              (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))\n            ) {\n              // Get the specific value for the option\n              value = jQuery(option).val()\n\n              // We don't need an array for one selects\n              if (one) {\n                return value\n              }\n\n              // Multi-Selects return an array\n              values.push(value)\n            }\n          }\n\n          return values\n        },\n\n        set: function (elem, value) {\n          var optionSet,\n            option,\n            options = elem.options,\n            values = jQuery.makeArray(value),\n            i = options.length\n\n          while (i--) {\n            option = options[i]\n            if ((option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1)) {\n              optionSet = true\n            }\n          }\n\n          // Force browsers to behave consistently when non-matching value is set\n          if (!optionSet) {\n            elem.selectedIndex = -1\n          }\n          return values\n        }\n      }\n    }\n  })\n\n  // Radios and checkboxes getter/setter\n  jQuery.each(['radio', 'checkbox'], function () {\n    jQuery.valHooks[this] = {\n      set: function (elem, value) {\n        if (jQuery.isArray(value)) {\n          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1)\n        }\n      }\n    }\n    if (!support.checkOn) {\n      jQuery.valHooks[this].get = function (elem) {\n        return elem.getAttribute('value') === null ? 'on' : elem.value\n      }\n    }\n  })\n\n  // Return jQuery for attributes-only inclusion\n\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/\n\n  jQuery.extend(jQuery.event, {\n    trigger: function (event, data, elem, onlyHandlers) {\n      var i,\n        cur,\n        tmp,\n        bubbleType,\n        ontype,\n        handle,\n        special,\n        eventPath = [elem || document],\n        type = hasOwn.call(event, 'type') ? event.type : event,\n        namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : []\n\n      cur = tmp = elem = elem || document\n\n      // Don't do events on text and comment nodes\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\n        return\n      }\n\n      // focus/blur morphs to focusin/out; ensure we're not firing them right now\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\n        return\n      }\n\n      if (type.indexOf('.') > -1) {\n        // Namespaced trigger; create a regexp to match event type in handle()\n        namespaces = type.split('.')\n        type = namespaces.shift()\n        namespaces.sort()\n      }\n      ontype = type.indexOf(':') < 0 && 'on' + type\n\n      // Caller can pass in a jQuery.Event object, Object, or just an event type string\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event)\n\n      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n      event.isTrigger = onlyHandlers ? 2 : 3\n      event.namespace = namespaces.join('.')\n      event.rnamespace = event.namespace ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)') : null\n\n      // Clean up the event in case it is being reused\n      event.result = undefined\n      if (!event.target) {\n        event.target = elem\n      }\n\n      // Clone any incoming data and prepend the event, creating the handler arg list\n      data = data == null ? [event] : jQuery.makeArray(data, [event])\n\n      // Allow special events to draw outside the lines\n      special = jQuery.event.special[type] || {}\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\n        return\n      }\n\n      // Determine event propagation path in advance, per W3C events spec (#9951)\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\n        bubbleType = special.delegateType || type\n        if (!rfocusMorph.test(bubbleType + type)) {\n          cur = cur.parentNode\n        }\n        for (; cur; cur = cur.parentNode) {\n          eventPath.push(cur)\n          tmp = cur\n        }\n\n        // Only add window if we got to document (e.g., not plain obj or detached DOM)\n        if (tmp === (elem.ownerDocument || document)) {\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window)\n        }\n      }\n\n      // Fire handlers on the event path\n      i = 0\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\n        event.type = i > 1 ? bubbleType : special.bindType || type\n\n        // jQuery handler\n        handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle')\n        if (handle) {\n          handle.apply(cur, data)\n        }\n\n        // Native handler\n        handle = ontype && cur[ontype]\n        if (handle && handle.apply && acceptData(cur)) {\n          event.result = handle.apply(cur, data)\n          if (event.result === false) {\n            event.preventDefault()\n          }\n        }\n      }\n      event.type = type\n\n      // If nobody prevented the default action, do it now\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\n          // Call a native DOM method on the target with the same name name as the event.\n          // Don't do default actions on window, that's where global variables be (#6170)\n          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\n            // Don't re-trigger an onFOO event when we call its FOO() method\n            tmp = elem[ontype]\n\n            if (tmp) {\n              elem[ontype] = null\n            }\n\n            // Prevent re-triggering of the same event, since we already bubbled it above\n            jQuery.event.triggered = type\n            elem[type]()\n            jQuery.event.triggered = undefined\n\n            if (tmp) {\n              elem[ontype] = tmp\n            }\n          }\n        }\n      }\n\n      return event.result\n    },\n\n    // Piggyback on a donor event to simulate a different one\n    // Used only for `focus(in | out)` events\n    simulate: function (type, elem, event) {\n      var e = jQuery.extend(new jQuery.Event(), event, {\n        type: type,\n        isSimulated: true\n      })\n\n      jQuery.event.trigger(e, null, elem)\n    }\n  })\n\n  jQuery.fn.extend({\n    trigger: function (type, data) {\n      return this.each(function () {\n        jQuery.event.trigger(type, data, this)\n      })\n    },\n    triggerHandler: function (type, data) {\n      var elem = this[0]\n      if (elem) {\n        return jQuery.event.trigger(type, data, elem, true)\n      }\n    }\n  })\n\n  jQuery.each(\n    (\n      'blur focus focusin focusout load resize scroll unload click dblclick ' +\n      'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +\n      'change select submit keydown keypress keyup error contextmenu'\n    ).split(' '),\n    function (i, name) {\n      // Handle event binding\n      jQuery.fn[name] = function (data, fn) {\n        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)\n      }\n    }\n  )\n\n  jQuery.fn.extend({\n    hover: function (fnOver, fnOut) {\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)\n    }\n  })\n\n  support.focusin = 'onfocusin' in window\n\n  // Support: Firefox\n  // Firefox doesn't have focus(in | out) events\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n  //\n  // Support: Chrome, Safari\n  // focus(in | out) events fire after focus & blur events,\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n  // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\n  if (!support.focusin) {\n    jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (orig, fix) {\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\n      var handler = function (event) {\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))\n      }\n\n      jQuery.event.special[fix] = {\n        setup: function () {\n          var doc = this.ownerDocument || this,\n            attaches = dataPriv.access(doc, fix)\n\n          if (!attaches) {\n            doc.addEventListener(orig, handler, true)\n          }\n          dataPriv.access(doc, fix, (attaches || 0) + 1)\n        },\n        teardown: function () {\n          var doc = this.ownerDocument || this,\n            attaches = dataPriv.access(doc, fix) - 1\n\n          if (!attaches) {\n            doc.removeEventListener(orig, handler, true)\n            dataPriv.remove(doc, fix)\n          } else {\n            dataPriv.access(doc, fix, attaches)\n          }\n        }\n      }\n    })\n  }\n  var location = window.location\n\n  var nonce = jQuery.now()\n\n  var rquery = /\\?/\n\n  // Support: Android 2.3\n  // Workaround failure to string-cast null input\n  jQuery.parseJSON = function (data) {\n    return JSON.parse(data + '')\n  }\n\n  // Cross-browser xml parsing\n  jQuery.parseXML = function (data) {\n    var xml\n    if (!data || typeof data !== 'string') {\n      return null\n    }\n\n    // Support: IE9\n    try {\n      xml = new window.DOMParser().parseFromString(data, 'text/xml')\n    } catch (e) {\n      xml = undefined\n    }\n\n    if (!xml || xml.getElementsByTagName('parsererror').length) {\n      jQuery.error('Invalid XML: ' + data)\n    }\n    return xml\n  }\n\n  var rhash = /#.*$/,\n    rts = /([?&])_=[^&]*/,\n    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n    // #7653, #8125, #8152: local protocol detection\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n    rnoContent = /^(?:GET|HEAD)$/,\n    rprotocol = /^\\/\\//,\n    /* Prefilters\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n     * 2) These are called:\n     *    - BEFORE asking for a transport\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\n     * 3) key is the dataType\n     * 4) the catchall symbol \"*\" can be used\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n     */\n    prefilters = {},\n    /* Transports bindings\n     * 1) key is the dataType\n     * 2) the catchall symbol \"*\" can be used\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n     */\n    transports = {},\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n    allTypes = '*/'.concat('*'),\n    // Anchor tag for parsing the document origin\n    originAnchor = document.createElement('a')\n  originAnchor.href = location.href\n\n  // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n  function addToPrefiltersOrTransports (structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== 'string') {\n        func = dataTypeExpression\n        dataTypeExpression = '*'\n      }\n\n      var dataType,\n        i = 0,\n        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || []\n\n      if (jQuery.isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while ((dataType = dataTypes[i++])) {\n          // Prepend if requested\n          if (dataType[0] === '+') {\n            dataType = dataType.slice(1) || '*'\n            ;(structure[dataType] = structure[dataType] || []).unshift(func)\n\n            // Otherwise append\n          } else {\n            ;(structure[dataType] = structure[dataType] || []).push(func)\n          }\n        }\n      }\n    }\n  }\n\n  // Base inspection function for prefilters and transports\n  function inspectPrefiltersOrTransports (structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n      seekingTransport = structure === transports\n\n    function inspect (dataType) {\n      var selected\n      inspected[dataType] = true\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR)\n        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport)\n          inspect(dataTypeOrTransport)\n          return false\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport)\n        }\n      })\n      return selected\n    }\n\n    return inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'))\n  }\n\n  // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n  function ajaxExtend (target, src) {\n    var key,\n      deep,\n      flatOptions = jQuery.ajaxSettings.flatOptions || {}\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        ;(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]\n      }\n    }\n    if (deep) {\n      jQuery.extend(true, target, deep)\n    }\n\n    return target\n  }\n\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n  function ajaxHandleResponses (s, jqXHR, responses) {\n    var ct,\n      type,\n      finalDataType,\n      firstDataType,\n      contents = s.contents,\n      dataTypes = s.dataTypes\n\n    // Remove auto dataType and get content-type in the process\n    while (dataTypes[0] === '*') {\n      dataTypes.shift()\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type')\n      }\n    }\n\n    // Check if we're dealing with a known content-type\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type)\n          break\n        }\n      }\n    }\n\n    // Check to see if we have a response for the expected dataType\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0]\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {\n          finalDataType = type\n          break\n        }\n        if (!firstDataType) {\n          firstDataType = type\n        }\n      }\n\n      // Or just use first one\n      finalDataType = finalDataType || firstDataType\n    }\n\n    // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType)\n      }\n      return responses[finalDataType]\n    }\n  }\n\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n  function ajaxConvert (s, response, jqXHR, isSuccess) {\n    var conv2,\n      current,\n      conv,\n      tmp,\n      prev,\n      converters = {},\n      // Work with a copy of dataTypes in case we need to modify it for conversion\n      dataTypes = s.dataTypes.slice()\n\n    // Create converters map with lowercased keys\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv]\n      }\n    }\n\n    current = dataTypes.shift()\n\n    // Convert to each sequential dataType\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response\n      }\n\n      // Apply the dataFilter if provided\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType)\n      }\n\n      prev = current\n      current = dataTypes.shift()\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === '*') {\n          current = prev\n\n          // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== '*' && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + ' ' + current] || converters['* ' + current]\n\n          // If none found, seek a pair\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(' ')\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]]\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]\n\n                    // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0]\n                    dataTypes.unshift(tmp[1])\n                  }\n                  break\n                }\n              }\n            }\n          }\n\n          // Apply converter (if not an equivalence)\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s.throws) {\n              response = conv(response)\n            } else {\n              try {\n                response = conv(response)\n              } catch (e) {\n                return {\n                  state: 'parsererror',\n                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return { state: 'success', data: response }\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n\n    ajaxSettings: {\n      url: location.href,\n      type: 'GET',\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',\n      /*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n      accepts: {\n        '*': allTypes,\n        text: 'text/plain',\n        html: 'text/html',\n        xml: 'application/xml, text/xml',\n        json: 'application/json, text/javascript'\n      },\n\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n\n      responseFields: {\n        xml: 'responseXML',\n        text: 'responseText',\n        json: 'responseJSON'\n      },\n\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        '* text': String,\n\n        // Text to html (true = no transformation)\n        'text html': true,\n\n        // Evaluate text as a json expression\n        'text json': jQuery.parseJSON,\n\n        // Parse text as xml\n        'text xml': jQuery.parseXML\n      },\n\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function (target, settings) {\n      return settings\n        ? // Building a settings object\n          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)\n        : // Extending ajaxSettings\n          ajaxExtend(jQuery.ajaxSettings, target)\n    },\n\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n\n    // Main method\n    ajax: function (url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (typeof url === 'object') {\n        options = url\n        url = undefined\n      }\n\n      // Force options to be an object\n      options = options || {}\n\n      var transport,\n        // URL without anti-cache param\n        cacheURL,\n        // Response headers\n        responseHeadersString,\n        responseHeaders,\n        // timeout handle\n        timeoutTimer,\n        // Url cleanup var\n        urlAnchor,\n        // To know if global events are to be dispatched\n        fireGlobals,\n        // Loop variable\n        i,\n        // Create the final options object\n        s = jQuery.ajaxSetup({}, options),\n        // Callbacks context\n        callbackContext = s.context || s,\n        // Context for global events is callbackContext if it is a DOM node or jQuery collection\n        globalEventContext =\n          s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n        // Deferreds\n        deferred = jQuery.Deferred(),\n        completeDeferred = jQuery.Callbacks('once memory'),\n        // Status-dependent callbacks\n        statusCode = s.statusCode || {},\n        // Headers (they are sent all at once)\n        requestHeaders = {},\n        requestHeadersNames = {},\n        // The jqXHR state\n        state = 0,\n        // Default abort message\n        strAbort = 'canceled',\n        // Fake xhr\n        jqXHR = {\n          readyState: 0,\n\n          // Builds headers hashtable if needed\n          getResponseHeader: function (key) {\n            var match\n            if (state === 2) {\n              if (!responseHeaders) {\n                responseHeaders = {}\n                while ((match = rheaders.exec(responseHeadersString))) {\n                  responseHeaders[match[1].toLowerCase()] = match[2]\n                }\n              }\n              match = responseHeaders[key.toLowerCase()]\n            }\n            return match == null ? null : match\n          },\n\n          // Raw string\n          getAllResponseHeaders: function () {\n            return state === 2 ? responseHeadersString : null\n          },\n\n          // Caches the header\n          setRequestHeader: function (name, value) {\n            var lname = name.toLowerCase()\n            if (!state) {\n              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name\n              requestHeaders[name] = value\n            }\n            return this\n          },\n\n          // Overrides response content-type header\n          overrideMimeType: function (type) {\n            if (!state) {\n              s.mimeType = type\n            }\n            return this\n          },\n\n          // Status-dependent callbacks\n          statusCode: function (map) {\n            var code\n            if (map) {\n              if (state < 2) {\n                for (code in map) {\n                  // Lazy-add the new callback in a way that preserves old ones\n                  statusCode[code] = [statusCode[code], map[code]]\n                }\n              } else {\n                // Execute the appropriate callbacks\n                jqXHR.always(map[jqXHR.status])\n              }\n            }\n            return this\n          },\n\n          // Cancel the request\n          abort: function (statusText) {\n            var finalText = statusText || strAbort\n            if (transport) {\n              transport.abort(finalText)\n            }\n            done(0, finalText)\n            return this\n          }\n        }\n\n      // Attach deferreds\n      deferred.promise(jqXHR).complete = completeDeferred.add\n      jqXHR.success = jqXHR.done\n      jqXHR.error = jqXHR.fail\n\n      // Remove hash character (#7531: and string promotion)\n      // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n      s.url = ((url || s.url || location.href) + '').replace(rhash, '').replace(rprotocol, location.protocol + '//')\n\n      // Alias method option to type as per ticket #12004\n      s.type = options.method || options.type || s.method || s.type\n\n      // Extract dataTypes list\n      s.dataTypes = jQuery\n        .trim(s.dataType || '*')\n        .toLowerCase()\n        .match(rnotwhite) || ['']\n\n      // A cross-domain request is in order when the origin doesn't match the current origin.\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement('a')\n\n        // Support: IE8-11+\n        // IE throws exception if url is malformed, e.g. http://example.com:80x/\n        try {\n          urlAnchor.href = s.url\n\n          // Support: IE8-11+\n          // Anchor's host property isn't correctly set when s.url is relative\n          urlAnchor.href = urlAnchor.href\n          s.crossDomain =\n            originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true\n        }\n      }\n\n      // Convert data if not already a string\n      if (s.data && s.processData && typeof s.data !== 'string') {\n        s.data = jQuery.param(s.data, s.traditional)\n      }\n\n      // Apply prefilters\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)\n\n      // If request was aborted inside a prefilter, stop there\n      if (state === 2) {\n        return jqXHR\n      }\n\n      // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n      fireGlobals = jQuery.event && s.global\n\n      // Watch for a new set of requests\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger('ajaxStart')\n      }\n\n      // Uppercase the type\n      s.type = s.type.toUpperCase()\n\n      // Determine if request has content\n      s.hasContent = !rnoContent.test(s.type)\n\n      // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      cacheURL = s.url\n\n      // More options handling for requests with no content\n      if (!s.hasContent) {\n        // If data is available, append data to url\n        if (s.data) {\n          cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data\n\n          // #9682: remove data so that it's not used in an eventual retry\n          delete s.data\n        }\n\n        // Add anti-cache in url if needed\n        if (s.cache === false) {\n          s.url = rts.test(cacheURL)\n            ? // If there is already a '_' parameter, set its value\n              cacheURL.replace(rts, '$1_=' + nonce++)\n            : // Otherwise add one to the end\n              cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++\n        }\n      }\n\n      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL])\n        }\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL])\n        }\n      }\n\n      // Set the correct header, if data is being sent\n      if ((s.data && s.hasContent && s.contentType !== false) || options.contentType) {\n        jqXHR.setRequestHeader('Content-Type', s.contentType)\n      }\n\n      // Set the Accepts header for the server, depending on the dataType\n      jqXHR.setRequestHeader(\n        'Accept',\n        s.dataTypes[0] && s.accepts[s.dataTypes[0]]\n          ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '')\n          : s.accepts['*']\n      )\n\n      // Check for headers option\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i])\n      }\n\n      // Allow custom headers/mimetypes and early abort\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n        // Abort if not done already and return\n        return jqXHR.abort()\n      }\n\n      // Aborting is no longer a cancellation\n      strAbort = 'abort'\n\n      // Install callbacks on deferreds\n      for (i in { success: 1, error: 1, complete: 1 }) {\n        jqXHR[i](s[i])\n      }\n\n      // Get transport\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)\n\n      // If no transport, we auto-abort\n      if (!transport) {\n        done(-1, 'No Transport')\n      } else {\n        jqXHR.readyState = 1\n\n        // Send global event\n        if (fireGlobals) {\n          globalEventContext.trigger('ajaxSend', [jqXHR, s])\n        }\n\n        // If request was aborted inside ajaxSend, stop there\n        if (state === 2) {\n          return jqXHR\n        }\n\n        // Timeout\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort('timeout')\n          }, s.timeout)\n        }\n\n        try {\n          state = 1\n          transport.send(requestHeaders, done)\n        } catch (e) {\n          // Propagate exception as error if not done\n          if (state < 2) {\n            done(-1, e)\n\n            // Simply rethrow otherwise\n          } else {\n            throw e\n          }\n        }\n      }\n\n      // Callback for when everything is done\n      function done (status, nativeStatusText, responses, headers) {\n        var isSuccess,\n          success,\n          error,\n          response,\n          modified,\n          statusText = nativeStatusText\n\n        // Called once\n        if (state === 2) {\n          return\n        }\n\n        // State is \"done\" now\n        state = 2\n\n        // Clear timeout if it exists\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer)\n        }\n\n        // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n        transport = undefined\n\n        // Cache response headers\n        responseHeadersString = headers || ''\n\n        // Set readyState\n        jqXHR.readyState = status > 0 ? 4 : 0\n\n        // Determine if successful\n        isSuccess = (status >= 200 && status < 300) || status === 304\n\n        // Get response data\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses)\n        }\n\n        // Convert no matter what (that way responseXXX fields are always set)\n        response = ajaxConvert(s, response, jqXHR, isSuccess)\n\n        // If successful, handle type chaining\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader('Last-Modified')\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified\n            }\n            modified = jqXHR.getResponseHeader('etag')\n            if (modified) {\n              jQuery.etag[cacheURL] = modified\n            }\n          }\n\n          // if no content\n          if (status === 204 || s.type === 'HEAD') {\n            statusText = 'nocontent'\n\n            // if not modified\n          } else if (status === 304) {\n            statusText = 'notmodified'\n\n            // If we have data, let's convert it\n          } else {\n            statusText = response.state\n            success = response.data\n            error = response.error\n            isSuccess = !error\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText\n          if (status || !statusText) {\n            statusText = 'error'\n            if (status < 0) {\n              status = 0\n            }\n          }\n        }\n\n        // Set data for the fake xhr object\n        jqXHR.status = status\n        jqXHR.statusText = (nativeStatusText || statusText) + ''\n\n        // Success/Error\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR])\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error])\n        }\n\n        // Status-dependent callbacks\n        jqXHR.statusCode(statusCode)\n        statusCode = undefined\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [jqXHR, s, isSuccess ? success : error])\n        }\n\n        // Complete\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText])\n\n        if (fireGlobals) {\n          globalEventContext.trigger('ajaxComplete', [jqXHR, s])\n\n          // Handle the global AJAX counter\n          if (!--jQuery.active) {\n            jQuery.event.trigger('ajaxStop')\n          }\n        }\n      }\n\n      return jqXHR\n    },\n\n    getJSON: function (url, data, callback) {\n      return jQuery.get(url, data, callback, 'json')\n    },\n\n    getScript: function (url, callback) {\n      return jQuery.get(url, undefined, callback, 'script')\n    }\n  })\n\n  jQuery.each(['get', 'post'], function (i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (jQuery.isFunction(data)) {\n        type = type || callback\n        callback = data\n        data = undefined\n      }\n\n      // The url can be an options object (which then must have .url)\n      return jQuery.ajax(\n        jQuery.extend(\n          {\n            url: url,\n            type: method,\n            dataType: type,\n            data: data,\n            success: callback\n          },\n          jQuery.isPlainObject(url) && url\n        )\n      )\n    }\n  })\n\n  jQuery._evalUrl = function (url) {\n    return jQuery.ajax({\n      url: url,\n\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\n      type: 'GET',\n      dataType: 'script',\n      async: false,\n      global: false,\n      throws: true\n    })\n  }\n\n  jQuery.fn.extend({\n    wrapAll: function (html) {\n      var wrap\n\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapAll(html.call(this, i))\n        })\n      }\n\n      if (this[0]) {\n        // The elements to wrap the target around\n        wrap = jQuery(html, this[0].ownerDocument)\n          .eq(0)\n          .clone(true)\n\n        if (this[0].parentNode) {\n          wrap.insertBefore(this[0])\n        }\n\n        wrap\n          .map(function () {\n            var elem = this\n\n            while (elem.firstElementChild) {\n              elem = elem.firstElementChild\n            }\n\n            return elem\n          })\n          .append(this)\n      }\n\n      return this\n    },\n\n    wrapInner: function (html) {\n      if (jQuery.isFunction(html)) {\n        return this.each(function (i) {\n          jQuery(this).wrapInner(html.call(this, i))\n        })\n      }\n\n      return this.each(function () {\n        var self = jQuery(this),\n          contents = self.contents()\n\n        if (contents.length) {\n          contents.wrapAll(html)\n        } else {\n          self.append(html)\n        }\n      })\n    },\n\n    wrap: function (html) {\n      var isFunction = jQuery.isFunction(html)\n\n      return this.each(function (i) {\n        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)\n      })\n    },\n\n    unwrap: function () {\n      return this.parent()\n        .each(function () {\n          if (!jQuery.nodeName(this, 'body')) {\n            jQuery(this).replaceWith(this.childNodes)\n          }\n        })\n        .end()\n    }\n  })\n\n  jQuery.expr.filters.hidden = function (elem) {\n    return !jQuery.expr.filters.visible(elem)\n  }\n  jQuery.expr.filters.visible = function (elem) {\n    // Support: Opera <= 12.12\n    // Opera reports offsetWidths and offsetHeights less than zero on some elements\n    // Use OR instead of AND as the element is not visible if either is true\n    // See tickets #10406 and #13132\n    return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0\n  }\n\n  var r20 = /%20/g,\n    rbracket = /\\[\\]$/,\n    rCRLF = /\\r?\\n/g,\n    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n    rsubmittable = /^(?:input|select|textarea|keygen)/i\n\n  function buildParams (prefix, obj, traditional, add) {\n    var name\n\n    if (jQuery.isArray(obj)) {\n      // Serialize array item.\n      jQuery.each(obj, function (i, v) {\n        if (traditional || rbracket.test(prefix)) {\n          // Treat each array item as a scalar.\n          add(prefix, v)\n        } else {\n          // Item is non-scalar (array or object), encode its numeric index.\n          buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add)\n        }\n      })\n    } else if (!traditional && jQuery.type(obj) === 'object') {\n      // Serialize object item.\n      for (name in obj) {\n        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)\n      }\n    } else {\n      // Serialize scalar item.\n      add(prefix, obj)\n    }\n  }\n\n  // Serialize an array of form elements or a set of\n  // key/values into a query string\n  jQuery.param = function (a, traditional) {\n    var prefix,\n      s = [],\n      add = function (key, value) {\n        // If value is a function, invoke it and return its value\n        value = jQuery.isFunction(value) ? value() : value == null ? '' : value\n        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value)\n      }\n\n    // Set traditional to true for jQuery <= 1.3.2 behavior.\n    if (traditional === undefined) {\n      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional\n    }\n\n    // If an array was passed in, assume that it is an array of form elements.\n    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {\n      // Serialize the form elements\n      jQuery.each(a, function () {\n        add(this.name, this.value)\n      })\n    } else {\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\n      // did it), otherwise encode params recursively.\n      for (prefix in a) {\n        buildParams(prefix, a[prefix], traditional, add)\n      }\n    }\n\n    // Return the resulting serialization\n    return s.join('&').replace(r20, '+')\n  }\n\n  jQuery.fn.extend({\n    serialize: function () {\n      return jQuery.param(this.serializeArray())\n    },\n    serializeArray: function () {\n      return this.map(function () {\n        // Can add propHook for \"elements\" to filter or add form elements\n        var elements = jQuery.prop(this, 'elements')\n        return elements ? jQuery.makeArray(elements) : this\n      })\n        .filter(function () {\n          var type = this.type\n\n          // Use .is( \":disabled\" ) so that fieldset[disabled] works\n          return (\n            this.name &&\n            !jQuery(this).is(':disabled') &&\n            rsubmittable.test(this.nodeName) &&\n            !rsubmitterTypes.test(type) &&\n            (this.checked || !rcheckableType.test(type))\n          )\n        })\n        .map(function (i, elem) {\n          var val = jQuery(this).val()\n\n          return val == null\n            ? null\n            : jQuery.isArray(val)\n            ? jQuery.map(val, function (val) {\n                return { name: elem.name, value: val.replace(rCRLF, '\\r\\n') }\n              })\n            : { name: elem.name, value: val.replace(rCRLF, '\\r\\n') }\n        })\n        .get()\n    }\n  })\n\n  jQuery.ajaxSettings.xhr = function () {\n    try {\n      return new window.XMLHttpRequest()\n    } catch (e) {}\n  }\n\n  var xhrSuccessStatus = {\n      // File protocol always yields status code 0, assume 200\n      0: 200,\n\n      // Support: IE9\n      // #1450: sometimes IE returns 1223 when it should be 204\n      1223: 204\n    },\n    xhrSupported = jQuery.ajaxSettings.xhr()\n\n  support.cors = !!xhrSupported && 'withCredentials' in xhrSupported\n  support.ajax = xhrSupported = !!xhrSupported\n\n  jQuery.ajaxTransport(function (options) {\n    var callback, errorCallback\n\n    // Cross domain only allowed if supported through XMLHttpRequest\n    if (support.cors || (xhrSupported && !options.crossDomain)) {\n      return {\n        send: function (headers, complete) {\n          var i,\n            xhr = options.xhr()\n\n          xhr.open(options.type, options.url, options.async, options.username, options.password)\n\n          // Apply custom fields if provided\n          if (options.xhrFields) {\n            for (i in options.xhrFields) {\n              xhr[i] = options.xhrFields[i]\n            }\n          }\n\n          // Override mime type if needed\n          if (options.mimeType && xhr.overrideMimeType) {\n            xhr.overrideMimeType(options.mimeType)\n          }\n\n          // X-Requested-With header\n          // For cross-domain requests, seeing as conditions for a preflight are\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\n          // (it can always be set on a per-request basis or even using ajaxSetup)\n          // For same-domain requests, won't change header if already provided.\n          if (!options.crossDomain && !headers['X-Requested-With']) {\n            headers['X-Requested-With'] = 'XMLHttpRequest'\n          }\n\n          // Set headers\n          for (i in headers) {\n            xhr.setRequestHeader(i, headers[i])\n          }\n\n          // Callback\n          callback = function (type) {\n            return function () {\n              if (callback) {\n                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null\n\n                if (type === 'abort') {\n                  xhr.abort()\n                } else if (type === 'error') {\n                  // Support: IE9\n                  // On a manual native abort, IE9 throws\n                  // errors on any property access that is not readyState\n                  if (typeof xhr.status !== 'number') {\n                    complete(0, 'error')\n                  } else {\n                    complete(\n                      // File: protocol always yields status 0; see #8605, #14207\n                      xhr.status,\n                      xhr.statusText\n                    )\n                  }\n                } else {\n                  complete(\n                    xhrSuccessStatus[xhr.status] || xhr.status,\n                    xhr.statusText,\n\n                    // Support: IE9 only\n                    // IE9 has no XHR2 but throws on binary (trac-11426)\n                    // For XHR2 non-text, let the caller handle it (gh-2498)\n                    (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string'\n                      ? { binary: xhr.response }\n                      : { text: xhr.responseText },\n                    xhr.getAllResponseHeaders()\n                  )\n                }\n              }\n            }\n          }\n\n          // Listen to events\n          xhr.onload = callback()\n          errorCallback = xhr.onerror = callback('error')\n\n          // Support: IE9\n          // Use onreadystatechange to replace onabort\n          // to handle uncaught aborts\n          if (xhr.onabort !== undefined) {\n            xhr.onabort = errorCallback\n          } else {\n            xhr.onreadystatechange = function () {\n              // Check readyState before timeout as it changes\n              if (xhr.readyState === 4) {\n                // Allow onerror to be called first,\n                // but that will not handle a native abort\n                // Also, save errorCallback to a variable\n                // as xhr.onerror cannot be accessed\n                window.setTimeout(function () {\n                  if (callback) {\n                    errorCallback()\n                  }\n                })\n              }\n            }\n          }\n\n          // Create the abort callback\n          callback = callback('abort')\n\n          try {\n            // Do send the request (this may raise an exception)\n            xhr.send((options.hasContent && options.data) || null)\n          } catch (e) {\n            // #14683: Only rethrow if this hasn't been notified as an error yet\n            if (callback) {\n              throw e\n            }\n          }\n        },\n\n        abort: function () {\n          if (callback) {\n            callback()\n          }\n        }\n      }\n    }\n  })\n\n  // Install script dataType\n  jQuery.ajaxSetup({\n    accepts: {\n      script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript'\n    },\n    contents: {\n      script: /\\b(?:java|ecma)script\\b/\n    },\n    converters: {\n      'text script': function (text) {\n        jQuery.globalEval(text)\n        return text\n      }\n    }\n  })\n\n  // Handle cache's special case and crossDomain\n  jQuery.ajaxPrefilter('script', function (s) {\n    if (s.cache === undefined) {\n      s.cache = false\n    }\n    if (s.crossDomain) {\n      s.type = 'GET'\n    }\n  })\n\n  // Bind script tag hack transport\n  jQuery.ajaxTransport('script', function (s) {\n    // This transport only deals with cross domain requests\n    if (s.crossDomain) {\n      var script, callback\n      return {\n        send: function (_, complete) {\n          script = jQuery('<script>')\n            .prop({\n              charset: s.scriptCharset,\n              src: s.url\n            })\n            .on(\n              'load error',\n              (callback = function (evt) {\n                script.remove()\n                callback = null\n                if (evt) {\n                  complete(evt.type === 'error' ? 404 : 200, evt.type)\n                }\n              })\n            )\n\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\n          document.head.appendChild(script[0])\n        },\n        abort: function () {\n          if (callback) {\n            callback()\n          }\n        }\n      }\n    }\n  })\n\n  var oldCallbacks = [],\n    rjsonp = /(=)\\?(?=&|$)|\\?\\?/\n\n  // Default jsonp settings\n  jQuery.ajaxSetup({\n    jsonp: 'callback',\n    jsonpCallback: function () {\n      var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++\n      this[callback] = true\n      return callback\n    }\n  })\n\n  // Detect, normalize options and install callbacks for jsonp requests\n  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {\n    var callbackName,\n      overwritten,\n      responseContainer,\n      jsonProp =\n        s.jsonp !== false &&\n        (rjsonp.test(s.url)\n          ? 'url'\n          : typeof s.data === 'string' &&\n            (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 &&\n            rjsonp.test(s.data) &&\n            'data')\n\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n    if (jsonProp || s.dataTypes[0] === 'jsonp') {\n      // Get callback name, remembering preexisting value associated with it\n      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback\n\n      // Insert callback into url or form data\n      if (jsonProp) {\n        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName)\n      } else if (s.jsonp !== false) {\n        s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName\n      }\n\n      // Use data converter to retrieve json after script execution\n      s.converters['script json'] = function () {\n        if (!responseContainer) {\n          jQuery.error(callbackName + ' was not called')\n        }\n        return responseContainer[0]\n      }\n\n      // Force json dataType\n      s.dataTypes[0] = 'json'\n\n      // Install callback\n      overwritten = window[callbackName]\n      window[callbackName] = function () {\n        responseContainer = arguments\n      }\n\n      // Clean-up function (fires after converters)\n      jqXHR.always(function () {\n        // If previous value didn't exist - remove it\n        if (overwritten === undefined) {\n          jQuery(window).removeProp(callbackName)\n\n          // Otherwise restore preexisting value\n        } else {\n          window[callbackName] = overwritten\n        }\n\n        // Save back as free\n        if (s[callbackName]) {\n          // Make sure that re-using the options doesn't screw things around\n          s.jsonpCallback = originalSettings.jsonpCallback\n\n          // Save the callback name for future use\n          oldCallbacks.push(callbackName)\n        }\n\n        // Call if it was a function and we have a response\n        if (responseContainer && jQuery.isFunction(overwritten)) {\n          overwritten(responseContainer[0])\n        }\n\n        responseContainer = overwritten = undefined\n      })\n\n      // Delegate to script\n      return 'script'\n    }\n  })\n\n  // Argument \"data\" should be string of html\n  // context (optional): If specified, the fragment will be created in this context,\n  // defaults to document\n  // keepScripts (optional): If true, will include scripts passed in the html string\n  jQuery.parseHTML = function (data, context, keepScripts) {\n    if (!data || typeof data !== 'string') {\n      return null\n    }\n    if (typeof context === 'boolean') {\n      keepScripts = context\n      context = false\n    }\n    context = context || document\n\n    var parsed = rsingleTag.exec(data),\n      scripts = !keepScripts && []\n\n    // Single tag\n    if (parsed) {\n      return [context.createElement(parsed[1])]\n    }\n\n    parsed = buildFragment([data], context, scripts)\n\n    if (scripts && scripts.length) {\n      jQuery(scripts).remove()\n    }\n\n    return jQuery.merge([], parsed.childNodes)\n  }\n\n  // Keep a copy of the old load method\n  var _load = jQuery.fn.load\n\n  /**\n   * Load a url into a page\n   */\n  jQuery.fn.load = function (url, params, callback) {\n    if (typeof url !== 'string' && _load) {\n      return _load.apply(this, arguments)\n    }\n\n    var selector,\n      type,\n      response,\n      self = this,\n      off = url.indexOf(' ')\n\n    if (off > -1) {\n      selector = jQuery.trim(url.slice(off))\n      url = url.slice(0, off)\n    }\n\n    // If it's a function\n    if (jQuery.isFunction(params)) {\n      // We assume that it's the callback\n      callback = params\n      params = undefined\n\n      // Otherwise, build a param string\n    } else if (params && typeof params === 'object') {\n      type = 'POST'\n    }\n\n    // If we have elements to modify, make the request\n    if (self.length > 0) {\n      jQuery\n        .ajax({\n          url: url,\n\n          // If \"type\" variable is undefined, then \"GET\" method will be used.\n          // Make value of this field explicit since\n          // user can override it through ajaxSetup method\n          type: type || 'GET',\n          dataType: 'html',\n          data: params\n        })\n        .done(function (responseText) {\n          // Save response for use in complete callback\n          response = arguments\n\n          self.html(\n            selector\n              ? // If a selector was specified, locate the right elements in a dummy div\n                // Exclude scripts to avoid IE 'Permission Denied' errors\n                jQuery('<div>')\n                  .append(jQuery.parseHTML(responseText))\n                  .find(selector)\n              : // Otherwise use the full result\n                responseText\n          )\n\n          // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n          // but they are ignored because response was set above.\n          // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n        })\n        .always(\n          callback &&\n            function (jqXHR, status) {\n              self.each(function () {\n                callback.apply(this, response || [jqXHR.responseText, status, jqXHR])\n              })\n            }\n        )\n    }\n\n    return this\n  }\n\n  // Attach a bunch of functions for handling common AJAX events\n  jQuery.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (i, type) {\n    jQuery.fn[type] = function (fn) {\n      return this.on(type, fn)\n    }\n  })\n\n  jQuery.expr.filters.animated = function (elem) {\n    return jQuery.grep(jQuery.timers, function (fn) {\n      return elem === fn.elem\n    }).length\n  }\n\n  /**\n   * Gets a window from an element\n   */\n  function getWindow (elem) {\n    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView\n  }\n\n  jQuery.offset = {\n    setOffset: function (elem, options, i) {\n      var curPosition,\n        curLeft,\n        curCSSTop,\n        curTop,\n        curOffset,\n        curCSSLeft,\n        calculatePosition,\n        position = jQuery.css(elem, 'position'),\n        curElem = jQuery(elem),\n        props = {}\n\n      // Set position first, in-case top/left are set even on static elem\n      if (position === 'static') {\n        elem.style.position = 'relative'\n      }\n\n      curOffset = curElem.offset()\n      curCSSTop = jQuery.css(elem, 'top')\n      curCSSLeft = jQuery.css(elem, 'left')\n      calculatePosition =\n        (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1\n\n      // Need to be able to calculate position if either\n      // top or left is auto and position is either absolute or fixed\n      if (calculatePosition) {\n        curPosition = curElem.position()\n        curTop = curPosition.top\n        curLeft = curPosition.left\n      } else {\n        curTop = parseFloat(curCSSTop) || 0\n        curLeft = parseFloat(curCSSLeft) || 0\n      }\n\n      if (jQuery.isFunction(options)) {\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n        options = options.call(elem, i, jQuery.extend({}, curOffset))\n      }\n\n      if (options.top != null) {\n        props.top = options.top - curOffset.top + curTop\n      }\n      if (options.left != null) {\n        props.left = options.left - curOffset.left + curLeft\n      }\n\n      if ('using' in options) {\n        options.using.call(elem, props)\n      } else {\n        curElem.css(props)\n      }\n    }\n  }\n\n  jQuery.fn.extend({\n    offset: function (options) {\n      if (arguments.length) {\n        return options === undefined\n          ? this\n          : this.each(function (i) {\n              jQuery.offset.setOffset(this, options, i)\n            })\n      }\n\n      var docElem,\n        win,\n        elem = this[0],\n        box = { top: 0, left: 0 },\n        doc = elem && elem.ownerDocument\n\n      if (!doc) {\n        return\n      }\n\n      docElem = doc.documentElement\n\n      // Make sure it's not a disconnected DOM node\n      if (!jQuery.contains(docElem, elem)) {\n        return box\n      }\n\n      box = elem.getBoundingClientRect()\n      win = getWindow(doc)\n      return {\n        top: box.top + win.pageYOffset - docElem.clientTop,\n        left: box.left + win.pageXOffset - docElem.clientLeft\n      }\n    },\n\n    position: function () {\n      if (!this[0]) {\n        return\n      }\n\n      var offsetParent,\n        offset,\n        elem = this[0],\n        parentOffset = { top: 0, left: 0 }\n\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\n      // because it is its only offset parent\n      if (jQuery.css(elem, 'position') === 'fixed') {\n        // Assume getBoundingClientRect is there when computed position is fixed\n        offset = elem.getBoundingClientRect()\n      } else {\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent()\n\n        // Get correct offsets\n        offset = this.offset()\n        if (!jQuery.nodeName(offsetParent[0], 'html')) {\n          parentOffset = offsetParent.offset()\n        }\n\n        // Add offsetParent borders\n        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true)\n        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true)\n      }\n\n      // Subtract parent offsets and element margins\n      return {\n        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),\n        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)\n      }\n    },\n\n    // This method will return documentElement in the following cases:\n    // 1) For the element inside the iframe without offsetParent, this method will return\n    //    documentElement of the parent window\n    // 2) For the hidden or detached element\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\n    //\n    // but those exceptions were never presented as a real life use-cases\n    // and might be considered as more preferable results.\n    //\n    // This logic, however, is not guaranteed and can change at any point in the future\n    offsetParent: function () {\n      return this.map(function () {\n        var offsetParent = this.offsetParent\n\n        while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {\n          offsetParent = offsetParent.offsetParent\n        }\n\n        return offsetParent || documentElement\n      })\n    }\n  })\n\n  // Create scrollLeft and scrollTop methods\n  jQuery.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (method, prop) {\n    var top = 'pageYOffset' === prop\n\n    jQuery.fn[method] = function (val) {\n      return access(\n        this,\n        function (elem, method, val) {\n          var win = getWindow(elem)\n\n          if (val === undefined) {\n            return win ? win[prop] : elem[method]\n          }\n\n          if (win) {\n            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset)\n          } else {\n            elem[method] = val\n          }\n        },\n        method,\n        val,\n        arguments.length\n      )\n    }\n  })\n\n  // Support: Safari<7-8+, Chrome<37-44+\n  // Add the top/left cssHooks using jQuery.fn.position\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n  // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\n  // rather than make the css module depend on the offset module, just check for it here\n  jQuery.each(['top', 'left'], function (i, prop) {\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\n      if (computed) {\n        computed = curCSS(elem, prop)\n\n        // If curCSS returns percentage, fallback to offset\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed\n      }\n    })\n  })\n\n  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\n  jQuery.each({ Height: 'height', Width: 'width' }, function (name, type) {\n    jQuery.each({ padding: 'inner' + name, content: type, '': 'outer' + name }, function (defaultExtra, funcName) {\n      // Margin is only for outerHeight, outerWidth\n      jQuery.fn[funcName] = function (margin, value) {\n        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),\n          extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border')\n\n        return access(\n          this,\n          function (elem, type, value) {\n            var doc\n\n            if (jQuery.isWindow(elem)) {\n              // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n              // isn't a whole lot we can do. See pull request at this URL for discussion:\n              // https://github.com/jquery/jquery/pull/764\n              return elem.document.documentElement['client' + name]\n            }\n\n            // Get document width or height\n            if (elem.nodeType === 9) {\n              doc = elem.documentElement\n\n              // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n              // whichever is greatest\n              return Math.max(\n                elem.body['scroll' + name],\n                doc['scroll' + name],\n                elem.body['offset' + name],\n                doc['offset' + name],\n                doc['client' + name]\n              )\n            }\n\n            return value === undefined\n              ? // Get width or height on the element, requesting but not forcing parseFloat\n                jQuery.css(elem, type, extra)\n              : // Set width or height on the element\n                jQuery.style(elem, type, value, extra)\n          },\n          type,\n          chainable ? margin : undefined,\n          chainable,\n          null\n        )\n      }\n    })\n  })\n\n  jQuery.fn.extend({\n    bind: function (types, data, fn) {\n      return this.on(types, null, data, fn)\n    },\n    unbind: function (types, fn) {\n      return this.off(types, null, fn)\n    },\n\n    delegate: function (selector, types, data, fn) {\n      return this.on(types, selector, data, fn)\n    },\n    undelegate: function (selector, types, fn) {\n      // ( namespace ) or ( selector, types [, fn] )\n      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn)\n    },\n    size: function () {\n      return this.length\n    }\n  })\n\n  jQuery.fn.andSelf = jQuery.fn.addBack\n\n  // Register as a named AMD module, since jQuery can be concatenated with other\n  // files that may use define, but not via a proper concatenation script that\n  // understands anonymous AMD modules. A named AMD is safest and most robust\n  // way to register. Lowercase jquery is used because AMD module names are\n  // derived from file names, and jQuery is normally delivered in a lowercase\n  // file name. Do this after creating the global so that if an AMD module wants\n  // to call noConflict to hide this version of jQuery, it will work.\n\n  // Note that for maximum portability, libraries that are not jQuery should\n  // declare themselves as anonymous modules, and avoid setting a global if an\n  // AMD loader is present. jQuery is a special case. For more information, see\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return jQuery\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  }\n\n  var // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n    // Map over the $ in case of overwrite\n    _$ = window.$\n\n  jQuery.noConflict = function (deep) {\n    if (window.$ === jQuery) {\n      window.$ = _$\n    }\n\n    if (deep && window.jQuery === jQuery) {\n      window.jQuery = _jQuery\n    }\n\n    return jQuery\n  }\n\n  // Expose jQuery and $ identifiers, even in AMD\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n  // and CommonJS for browser emulators (#13566)\n  if (!noGlobal) {\n    window.jQuery = window.$ = jQuery\n  }\n\n  return jQuery\n})\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/jquery/jquery.js?");

/***/ }),

/***/ "./src/public/js/vendor/modernizr/modernizr.js":
/*!*****************************************************!*\
  !*** ./src/public/js/vendor/modernizr/modernizr.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_Modernizr) {/*! modernizr 3.3.1 (Custom Build) | MIT *\n * https://modernizr.com/download/?-animation-applicationcache-audio-audioloop-audiopreload-backgroundblendmode-backgroundcliptext-backgroundsize-bgpositionshorthand-bgpositionxy-bgrepeatspace_bgrepeatround-bgsizecover-borderradius-boxshadow-boxsizing-canvas-canvasblending-canvastext-canvaswinding-checked-contextmenu-cookies-cors-cssanimations-csscolumns-cssfilters-cssmask-cssremunit-cssscrollbar-csstransforms-csstransitions-cssvalid-cssvhunit-cssvwunit-cubicbezierrange-customevent-ellipsis-emoji-eventlistener-fileinput-filereader-flash-flexbox-flexboxlegacy-flexboxtweener-flexwrap-formvalidation-generatedcontent-geolocation-history-htmlimports-imgcrossorigin-inlinesvg-input-inputtypes-json-lastchild-localstorage-mediaqueries-multiplebgs-notification-nthchild-olreversed-opacity-overflowscrolling-placeholder-queryselector-requestanimationframe-rgba-search-supports-svg-svgfilters-textareamaxlength-todataurljpeg_todataurlpng_todataurlwebp-unicode-unicoderange-video-webaudio-webgl-websockets-setclasses !*/\n!(function (A, e, t) {\n  function n (A, e) {\n    return typeof A === e\n  }\n  function a () {\n    var A, e, t, a, i, o, r\n    for (var d in E)\n      if (E.hasOwnProperty(d)) {\n        if (\n          ((A = []),\n          (e = E[d]),\n          e.name && (A.push(e.name.toLowerCase()), e.options && e.options.aliases && e.options.aliases.length))\n        )\n          for (t = 0; t < e.options.aliases.length; t++) A.push(e.options.aliases[t].toLowerCase())\n        for (a = n(e.fn, 'function') ? e.fn() : e.fn, i = 0; i < A.length; i++)\n          (o = A[i]),\n            (r = o.split('.')),\n            1 === r.length\n              ? (Modernizr[r[0]] = a)\n              : (!Modernizr[r[0]] ||\n                  Modernizr[r[0]] instanceof Boolean ||\n                  (Modernizr[r[0]] = new Boolean(Modernizr[r[0]])),\n                (Modernizr[r[0]][r[1]] = a)),\n            v.push((a ? '' : 'no-') + r.join('-'))\n      }\n  }\n  function i (A) {\n    var e = I.className,\n      t = Modernizr._config.classPrefix || ''\n    if ((y && (e = e.baseVal), Modernizr._config.enableJSClass)) {\n      var n = new RegExp('(^|\\\\s)' + t + 'no-js(\\\\s|$)')\n      e = e.replace(n, '$1' + t + 'js$2')\n    }\n    Modernizr._config.enableClasses &&\n      ((e += ' ' + t + A.join(' ' + t)), y ? (I.className.baseVal = e) : (I.className = e))\n  }\n  function o () {\n    return 'function' != typeof e.createElement\n      ? e.createElement(arguments[0])\n      : y\n      ? e.createElementNS.call(e, 'http://www.w3.org/2000/svg', arguments[0])\n      : e.createElement.apply(e, arguments)\n  }\n  function r () {\n    var A = e.body\n    return A || ((A = o(y ? 'svg' : 'body')), (A.fake = !0)), A\n  }\n  function d (A, e) {\n    if ('object' == typeof A) for (var t in A) k(A, t) && d(t, A[t])\n    else {\n      A = A.toLowerCase()\n      var n = A.split('.'),\n        a = Modernizr[n[0]]\n      if ((2 == n.length && (a = a[n[1]]), 'undefined' != typeof a)) return Modernizr\n      ;(e = 'function' == typeof e ? e() : e),\n        1 == n.length\n          ? (Modernizr[n[0]] = e)\n          : (!Modernizr[n[0]] || Modernizr[n[0]] instanceof Boolean || (Modernizr[n[0]] = new Boolean(Modernizr[n[0]])),\n            (Modernizr[n[0]][n[1]] = e)),\n        i([(e && 0 != e ? '' : 'no-') + n.join('-')]),\n        Modernizr._trigger(A, e)\n    }\n    return Modernizr\n  }\n  function w (A) {\n    return A.replace(/([a-z])-([a-z])/g, function (A, e, t) {\n      return e + t.toUpperCase()\n    }).replace(/^-/, '')\n  }\n  function s (A, t, n, a) {\n    var i,\n      d,\n      w,\n      s,\n      l = 'modernizr',\n      D = o('div'),\n      u = r()\n    if (parseInt(n, 10)) for (; n--; ) (w = o('div')), (w.id = a ? a[n] : l + (n + 1)), D.appendChild(w)\n    return (\n      (i = o('style')),\n      (i.type = 'text/css'),\n      (i.id = 's' + l),\n      (u.fake ? u : D).appendChild(i),\n      u.appendChild(D),\n      i.styleSheet ? (i.styleSheet.cssText = A) : i.appendChild(e.createTextNode(A)),\n      (D.id = l),\n      u.fake &&\n        ((u.style.background = ''),\n        (u.style.overflow = 'hidden'),\n        (s = I.style.overflow),\n        (I.style.overflow = 'hidden'),\n        I.appendChild(u)),\n      (d = t(D, A)),\n      u.fake ? (u.parentNode.removeChild(u), (I.style.overflow = s), I.offsetHeight) : D.parentNode.removeChild(D),\n      !!d\n    )\n  }\n  function l (A, e) {\n    return !!~('' + A).indexOf(e)\n  }\n  function D (A, e) {\n    return function () {\n      return A.apply(e, arguments)\n    }\n  }\n  function u (A, e, t) {\n    var a\n    for (var i in A) if (A[i] in e) return t === !1 ? A[i] : ((a = e[A[i]]), n(a, 'function') ? D(a, t || e) : a)\n    return !1\n  }\n  function P (A) {\n    return A.replace(/([A-Z])/g, function (A, e) {\n      return '-' + e.toLowerCase()\n    }).replace(/^ms-/, '-ms-')\n  }\n  function c (e, n) {\n    var a = e.length\n    if ('CSS' in A && 'supports' in A.CSS) {\n      for (; a--; ) if (A.CSS.supports(P(e[a]), n)) return !0\n      return !1\n    }\n    if ('CSSSupportsRule' in A) {\n      for (var i = []; a--; ) i.push('(' + P(e[a]) + ':' + n + ')')\n      return (\n        (i = i.join(' or ')),\n        s('@supports (' + i + ') { #modernizr { position: absolute; } }', function (A) {\n          return 'absolute' == getComputedStyle(A, null).position\n        })\n      )\n    }\n    return t\n  }\n  function f (A, e, a, i) {\n    function r () {\n      s && (delete O.style, delete O.modElem)\n    }\n    if (((i = n(i, 'undefined') ? !1 : i), !n(a, 'undefined'))) {\n      var d = c(A, a)\n      if (!n(d, 'undefined')) return d\n    }\n    for (var s, D, u, P, f, p = ['modernizr', 'tspan', 'samp']; !O.style && p.length; )\n      (s = !0), (O.modElem = o(p.shift())), (O.style = O.modElem.style)\n    for (u = A.length, D = 0; u > D; D++)\n      if (((P = A[D]), (f = O.style[P]), l(P, '-') && (P = w(P)), O.style[P] !== t)) {\n        if (i || n(a, 'undefined')) return r(), 'pfx' == e ? P : !0\n        try {\n          O.style[P] = a\n        } catch (g) {}\n        if (O.style[P] != f) return r(), 'pfx' == e ? P : !0\n      }\n    return r(), !1\n  }\n  function p (A, e, t, a, i) {\n    var o = A.charAt(0).toUpperCase() + A.slice(1),\n      r = (A + ' ' + Z.join(o + ' ') + o).split(' ')\n    return n(e, 'string') || n(e, 'undefined')\n      ? f(r, e, a, i)\n      : ((r = (A + ' ' + F.join(o + ' ') + o).split(' ')), u(r, e, t))\n  }\n  function g (A, e, n) {\n    return p(A, t, t, e, n)\n  }\n  var v = [],\n    E = [],\n    B = {\n      _version: '3.3.1',\n      _config: { classPrefix: '', enableClasses: !0, enableJSClass: !0, usePrefixes: !0 },\n      _q: [],\n      on: function (A, e) {\n        var t = this\n        setTimeout(function () {\n          e(t[A])\n        }, 0)\n      },\n      addTest: function (A, e, t) {\n        E.push({ name: A, fn: e, options: t })\n      },\n      addAsyncTest: function (A) {\n        E.push({ name: null, fn: A })\n      }\n    },\n    Modernizr = function () {}\n  ;(Modernizr.prototype = B),\n    (Modernizr = new Modernizr()),\n    Modernizr.addTest('applicationcache', 'applicationCache' in A),\n    Modernizr.addTest('cookies', function () {\n      try {\n        e.cookie = 'cookietest=1'\n        var A = -1 != e.cookie.indexOf('cookietest=')\n        return (e.cookie = 'cookietest=1; expires=Thu, 01-Jan-1970 00:00:01 GMT'), A\n      } catch (t) {\n        return !1\n      }\n    }),\n    Modernizr.addTest('cors', 'XMLHttpRequest' in A && 'withCredentials' in new XMLHttpRequest()),\n    Modernizr.addTest('customevent', 'CustomEvent' in A && 'function' == typeof A.CustomEvent),\n    Modernizr.addTest('eventlistener', 'addEventListener' in A),\n    Modernizr.addTest('geolocation', 'geolocation' in navigator),\n    Modernizr.addTest('history', function () {\n      var e = navigator.userAgent\n      return (-1 === e.indexOf('Android 2.') && -1 === e.indexOf('Android 4.0')) ||\n        -1 === e.indexOf('Mobile Safari') ||\n        -1 !== e.indexOf('Chrome') ||\n        -1 !== e.indexOf('Windows Phone')\n        ? A.history && 'pushState' in A.history\n        : !1\n    }),\n    Modernizr.addTest('json', 'JSON' in A && 'parse' in JSON && 'stringify' in JSON),\n    Modernizr.addTest('queryselector', 'querySelector' in e && 'querySelectorAll' in e),\n    Modernizr.addTest(\n      'svg',\n      !!e.createElementNS && !!e.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect\n    )\n  var Q = !1\n  try {\n    Q = 'WebSocket' in A && 2 === A.WebSocket.CLOSING\n  } catch (m) {}\n  Modernizr.addTest('websockets', Q),\n    Modernizr.addTest('webaudio', function () {\n      var e = 'webkitAudioContext' in A,\n        t = 'AudioContext' in A\n      return Modernizr._config.usePrefixes ? e || t : t\n    })\n  var C = 'CSS' in A && 'supports' in A.CSS,\n    h = 'supportsCSS' in A\n  Modernizr.addTest('supports', C || h),\n    Modernizr.addTest('filereader', !!(A.File && A.FileList && A.FileReader)),\n    Modernizr.addTest('localstorage', function () {\n      var A = 'modernizr'\n      try {\n        return localStorage.setItem(A, A), localStorage.removeItem(A), !0\n      } catch (e) {\n        return !1\n      }\n    }),\n    Modernizr.addTest('svgfilters', function () {\n      var e = !1\n      try {\n        e = 'SVGFEColorMatrixElement' in A && 2 == SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE\n      } catch (t) {}\n      return e\n    })\n  var I = e.documentElement\n  Modernizr.addTest('contextmenu', 'contextMenu' in I && 'HTMLMenuItemElement' in A)\n  var y = 'svg' === I.nodeName.toLowerCase()\n  Modernizr.addTest('audio', function () {\n    var A = o('audio'),\n      e = !1\n    try {\n      ;(e = !!A.canPlayType) &&\n        ((e = new Boolean(e)),\n        (e.ogg = A.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\n        (e.mp3 = A.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, '')),\n        (e.opus =\n          A.canPlayType('audio/ogg; codecs=\"opus\"') || A.canPlayType('audio/webm; codecs=\"opus\"').replace(/^no$/, '')),\n        (e.wav = A.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\n        (e.m4a = (A.canPlayType('audio/x-m4a;') || A.canPlayType('audio/aac;')).replace(/^no$/, '')))\n    } catch (t) {}\n    return e\n  }),\n    Modernizr.addTest('canvas', function () {\n      var A = o('canvas')\n      return !(!A.getContext || !A.getContext('2d'))\n    }),\n    Modernizr.addTest('canvastext', function () {\n      return Modernizr.canvas === !1 ? !1 : 'function' == typeof o('canvas').getContext('2d').fillText\n    }),\n    Modernizr.addTest('emoji', function () {\n      if (!Modernizr.canvastext) return !1\n      var e = A.devicePixelRatio || 1,\n        t = 12 * e,\n        n = o('canvas'),\n        a = n.getContext('2d')\n      return (\n        (a.fillStyle = '#f00'),\n        (a.textBaseline = 'top'),\n        (a.font = '32px Arial'),\n        a.fillText('', 0, 0),\n        0 !== a.getImageData(t, t, 1, 1).data[0]\n      )\n    }),\n    Modernizr.addTest('olreversed', 'reversed' in o('ol')),\n    Modernizr.addTest('video', function () {\n      var A = o('video'),\n        e = !1\n      try {\n        ;(e = !!A.canPlayType) &&\n          ((e = new Boolean(e)),\n          (e.ogg = A.canPlayType('video/ogg; codecs=\"theora\"').replace(/^no$/, '')),\n          (e.h264 = A.canPlayType('video/mp4; codecs=\"avc1.42E01E\"').replace(/^no$/, '')),\n          (e.webm = A.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/^no$/, '')),\n          (e.vp9 = A.canPlayType('video/webm; codecs=\"vp9\"').replace(/^no$/, '')),\n          (e.hls = A.canPlayType('application/x-mpegURL; codecs=\"avc1.42E01E\"').replace(/^no$/, '')))\n      } catch (t) {}\n      return e\n    }),\n    Modernizr.addTest('webanimations', 'animate' in o('div')),\n    Modernizr.addTest('webgl', function () {\n      var e = o('canvas'),\n        t = 'probablySupportsContext' in e ? 'probablySupportsContext' : 'supportsContext'\n      return t in e ? e[t]('webgl') || e[t]('experimental-webgl') : 'WebGLRenderingContext' in A\n    }),\n    Modernizr.addTest('canvasblending', function () {\n      if (Modernizr.canvas === !1) return !1\n      var A = o('canvas').getContext('2d')\n      try {\n        A.globalCompositeOperation = 'screen'\n      } catch (e) {}\n      return 'screen' === A.globalCompositeOperation\n    }),\n    Modernizr.addTest('audioloop', 'loop' in o('audio'))\n  var b = o('canvas')\n  Modernizr.addTest('todataurljpeg', function () {\n    return !!Modernizr.canvas && 0 === b.toDataURL('image/jpeg').indexOf('data:image/jpeg')\n  }),\n    Modernizr.addTest('todataurlpng', function () {\n      return !!Modernizr.canvas && 0 === b.toDataURL('image/png').indexOf('data:image/png')\n    }),\n    Modernizr.addTest('todataurlwebp', function () {\n      var A = !1\n      try {\n        A = !!Modernizr.canvas && 0 === b.toDataURL('image/webp').indexOf('data:image/webp')\n      } catch (e) {}\n      return A\n    }),\n    Modernizr.addTest('canvaswinding', function () {\n      if (Modernizr.canvas === !1) return !1\n      var A = o('canvas').getContext('2d')\n      return A.rect(0, 0, 10, 10), A.rect(2, 2, 6, 6), A.isPointInPath(5, 5, 'evenodd') === !1\n    }),\n    Modernizr.addTest('bgpositionshorthand', function () {\n      var A = o('a'),\n        e = A.style,\n        t = 'right 10px bottom 10px'\n      return (e.cssText = 'background-position: ' + t + ';'), e.backgroundPosition === t\n    }),\n    Modernizr.addTest('multiplebgs', function () {\n      var A = o('a').style\n      return (\n        (A.cssText = 'background:url(https://),url(https://),red url(https://)'), /(url\\s*\\(.*?){3}/.test(A.background)\n      )\n    }),\n    Modernizr.addTest('cssremunit', function () {\n      var A = o('a').style\n      try {\n        A.fontSize = '3rem'\n      } catch (e) {}\n      return /rem/.test(A.fontSize)\n    }),\n    Modernizr.addTest('rgba', function () {\n      var A = o('a').style\n      return (A.cssText = 'background-color:rgba(150,255,150,.5)'), ('' + A.backgroundColor).indexOf('rgba') > -1\n    }),\n    Modernizr.addTest('fileinput', function () {\n      if (\n        navigator.userAgent.match(\n          /(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\\/(1.0|2.0|2.5|3.0))/\n        )\n      )\n        return !1\n      var A = o('input')\n      return (A.type = 'file'), !A.disabled\n    }),\n    Modernizr.addTest('placeholder', 'placeholder' in o('input') && 'placeholder' in o('textarea')),\n    Modernizr.addTest('imgcrossorigin', 'crossOrigin' in o('img')),\n    Modernizr.addTest('inlinesvg', function () {\n      var A = o('div')\n      return (\n        (A.innerHTML = '<svg/>'),\n        'http://www.w3.org/2000/svg' == ('undefined' != typeof SVGRect && A.firstChild && A.firstChild.namespaceURI)\n      )\n    }),\n    Modernizr.addTest('textareamaxlength', !!('maxLength' in o('textarea')))\n  var V = o('input'),\n    q = 'autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '),\n    S = {}\n  Modernizr.input = (function (e) {\n    for (var t = 0, n = e.length; n > t; t++) S[e[t]] = !!(e[t] in V)\n    return S.list && (S.list = !(!o('datalist') || !A.HTMLDataListElement)), S\n  })(q)\n  var M = 'search tel url email datetime date month week time datetime-local number range color'.split(' '),\n    x = {}\n  Modernizr.inputtypes = (function (A) {\n    for (var n, a, i, o = A.length, r = '1)', d = 0; o > d; d++)\n      V.setAttribute('type', (n = A[d])),\n        (i = 'text' !== V.type && 'style' in V),\n        i &&\n          ((V.value = r),\n          (V.style.cssText = 'position:absolute;visibility:hidden;'),\n          /^range$/.test(n) && V.style.WebkitAppearance !== t\n            ? (I.appendChild(V),\n              (a = e.defaultView),\n              (i =\n                a.getComputedStyle &&\n                'textfield' !== a.getComputedStyle(V, null).WebkitAppearance &&\n                0 !== V.offsetHeight),\n              I.removeChild(V))\n            : /^(search|tel)$/.test(n) ||\n              (i = /^(url|email)$/.test(n) ? V.checkValidity && V.checkValidity() === !1 : V.value != r)),\n        (x[A[d]] = !!i)\n    return x\n  })(M)\n  var T = (function () {\n    function A (A, e) {\n      var a\n      return A\n        ? ((e && 'string' != typeof e) || (e = o(e || 'div')),\n          (A = 'on' + A),\n          (a = A in e),\n          !a &&\n            n &&\n            (e.setAttribute || (e = o('div')),\n            e.setAttribute(A, ''),\n            (a = 'function' == typeof e[A]),\n            e[A] !== t && (e[A] = t),\n            e.removeAttribute(A)),\n          a)\n        : !1\n    }\n    var n = !('onblur' in e.documentElement)\n    return A\n  })()\n  ;(B.hasEvent = T), Modernizr.addTest('inputsearchevent', T('search'))\n  var R = B._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['', '']\n  ;(B._prefixes = R),\n    Modernizr.addTest('cubicbezierrange', function () {\n      var A = o('a')\n      return (A.style.cssText = R.join('transition-timing-function:cubic-bezier(1,0,0,1.1); ')), !!A.style.length\n    }),\n    Modernizr.addTest('opacity', function () {\n      var A = o('a').style\n      return (A.cssText = R.join('opacity:.55;')), /^0.55$/.test(A.opacity)\n    })\n  var k\n  !(function () {\n    var A = {}.hasOwnProperty\n    k =\n      n(A, 'undefined') || n(A.call, 'undefined')\n        ? function (A, e) {\n            return e in A && n(A.constructor.prototype[e], 'undefined')\n          }\n        : function (e, t) {\n            return A.call(e, t)\n          }\n  })(),\n    (B._l = {}),\n    (B.on = function (A, e) {\n      this._l[A] || (this._l[A] = []),\n        this._l[A].push(e),\n        Modernizr.hasOwnProperty(A) &&\n          setTimeout(function () {\n            Modernizr._trigger(A, Modernizr[A])\n          }, 0)\n    }),\n    (B._trigger = function (A, e) {\n      if (this._l[A]) {\n        var t = this._l[A]\n        setTimeout(function () {\n          var A, n\n          for (A = 0; A < t.length; A++) (n = t[A])(e)\n        }, 0),\n          delete this._l[A]\n      }\n    }),\n    Modernizr._q.push(function () {\n      B.addTest = d\n    }),\n    Modernizr.addAsyncTest(function () {\n      var t,\n        n,\n        a = function (A) {\n          I.contains(A) || I.appendChild(A)\n        },\n        i = function (A) {\n          A.fake && A.parentNode && A.parentNode.removeChild(A)\n        },\n        w = function (A, e) {\n          var t = !!A\n          if (\n            (t && ((t = new Boolean(t)), (t.blocked = 'blocked' === A)),\n            d('flash', function () {\n              return t\n            }),\n            e && P.contains(e))\n          ) {\n            for (; e.parentNode !== P; ) e = e.parentNode\n            P.removeChild(e)\n          }\n        }\n      try {\n        n = 'ActiveXObject' in A && 'Pan' in new A.ActiveXObject('ShockwaveFlash.ShockwaveFlash')\n      } catch (s) {}\n      if (((t = !(('plugins' in navigator && 'Shockwave Flash' in navigator.plugins) || n)), t || y)) w(!1)\n      else {\n        var l,\n          D,\n          u = o('embed'),\n          P = r()\n        if (((u.type = 'application/x-shockwave-flash'), P.appendChild(u), !('Pan' in u || n)))\n          return a(P), w('blocked', u), void i(P)\n        ;(l = function () {\n          return (\n            a(P),\n            I.contains(P)\n              ? (I.contains(u) ? ((D = u.style.cssText), '' !== D ? w('blocked', u) : w(!0, u)) : w('blocked'),\n                void i(P))\n              : ((P = e.body || P),\n                (u = o('embed')),\n                (u.type = 'application/x-shockwave-flash'),\n                P.appendChild(u),\n                setTimeout(l, 1e3))\n          )\n        }),\n          setTimeout(l, 10)\n      }\n    }),\n    d('htmlimports', 'import' in o('link')),\n    Modernizr.addAsyncTest(function () {\n      function A (n) {\n        clearTimeout(e)\n        var i = n !== t && 'loadeddata' === n.type ? !0 : !1\n        a.removeEventListener('loadeddata', A, !1), d('audiopreload', i), a.parentNode.removeChild(a)\n      }\n      var e,\n        n = 300,\n        a = o('audio'),\n        i = a.style\n      if (!(Modernizr.audio && 'preload' in a)) return void d('audiopreload', !1)\n      ;(i.position = 'absolute'), (i.height = 0), (i.width = 0)\n      try {\n        if (Modernizr.audio.mp3)\n          a.src =\n            'data:audio/mpeg;base64,//MUxAAB6AXgAAAAAPP+c6nf//yi/6f3//MUxAMAAAIAAAjEcH//0fTX6C9Lf//0//MUxA4BeAIAAAAAAKX2/6zv//+IlR4f//MUxBMCMAH8AAAAABYWalVMQU1FMy45//MUxBUB0AH0AAAAADkuM1VVVVVVVVVV//MUxBgBUATowAAAAFVVVVVVVVVVVVVV'\n        else if (Modernizr.audio.m4a)\n          a.src =\n            'data:audio/x-m4a;base64,AAAAGGZ0eXBNNEEgAAACAGlzb21pc28yAAAACGZyZWUAAAAfbWRhdN4EAABsaWJmYWFjIDEuMjgAAAFoAQBHAAACiG1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAYAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAG0dHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAYAAAAAAAAAAAAAAAAAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAABUG1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAArEQAAAQAVcQAAAAAAC1oZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU291bmRIYW5kbGVyAAAAAPttaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAL9zdGJsAAAAW3N0c2QAAAAAAAAAAQAAAEttcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAACdlc2RzAAAAAAMZAAEABBFAFQAAAAABftAAAAAABQISCAYBAgAAABhzdHRzAAAAAAAAAAEAAAABAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAXAAAAAQAAABRzdGNvAAAAAAAAAAEAAAAoAAAAYHVkdGEAAABYbWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAraWxzdAAAACOpdG9vAAAAG2RhdGEAAAABAAAAAExhdmY1Mi42NC4y'\n        else if (Modernizr.audio.ogg)\n          a.src =\n            'data:audio/ogg;base64,T2dnUwACAAAAAAAAAAD/QwAAAAAAAM2LVKsBHgF2b3JiaXMAAAAAAUSsAAAAAAAAgLsAAAAAAAC4AU9nZ1MAAAAAAAAAAAAA/0MAAAEAAADmvOe6Dy3/////////////////MgN2b3JiaXMdAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAwNzA2MjIAAAAAAQV2b3JiaXMfQkNWAQAAAQAYY1QpRplS0kqJGXOUMUaZYpJKiaWEFkJInXMUU6k515xrrLm1IIQQGlNQKQWZUo5SaRljkCkFmVIQS0kldBI6J51jEFtJwdaYa4tBthyEDZpSTCnElFKKQggZU4wpxZRSSkIHJXQOOuYcU45KKEG4nHOrtZaWY4updJJK5yRkTEJIKYWSSgelU05CSDWW1lIpHXNSUmpB6CCEEEK2IIQNgtCQVQAAAQDAQBAasgoAUAAAEIqhGIoChIasAgAyAAAEoCiO4iiOIzmSY0kWEBqyCgAAAgAQAADAcBRJkRTJsSRL0ixL00RRVX3VNlVV9nVd13Vd13UgNGQVAAABAEBIp5mlGiDCDGQYCA1ZBQAgAAAARijCEANCQ1YBAAABAABiKDmIJrTmfHOOg2Y5aCrF5nRwItXmSW4q5uacc845J5tzxjjnnHOKcmYxaCa05pxzEoNmKWgmtOacc57E5kFrqrTmnHPGOaeDcUYY55xzmrTmQWo21uaccxa0pjlqLsXmnHMi5eZJbS7V5pxzzjnnnHPOOeecc6oXp3NwTjjnnHOi9uZabkIX55xzPhmne3NCOOecc84555xzzjnnnHOC0JBVAAAQAABBGDaGcacgSJ+jgRhFiGnIpAfdo8MkaAxyCqlHo6ORUuoglFTGSSmdIDRkFQAACAAAIYQUUkghhRRSSCGFFFKIIYYYYsgpp5yCCiqppKKKMsoss8wyyyyzzDLrsLPOOuwwxBBDDK20EktNtdVYY62555xrDtJaaa211koppZRSSikIDVkFAIAAABAIGWSQQUYhhRRSiCGmnHLKKaigAkJDVgEAgAAAAgAAADzJc0RHdERHdERHdERHdETHczxHlERJlERJtEzL1ExPFVXVlV1b1mXd9m1hF3bd93Xf93Xj14VhWZZlWZZlWZZlWZZlWZZlWYLQkFUAAAgAAIAQQgghhRRSSCGlGGPMMeegk1BCIDRkFQAACAAgAAAAwFEcxXEkR3IkyZIsSZM0S7M8zdM8TfREURRN01RFV3RF3bRF2ZRN13RN2XRVWbVdWbZt2dZtX5Zt3/d93/d93/d93/d93/d1HQgNWQUASAAA6EiOpEiKpEiO4ziSJAGhIasAABkAAAEAKIqjOI7jSJIkSZakSZ7lWaJmaqZneqqoAqEhqwAAQAAAAQAAAAAAKJriKabiKaLiOaIjSqJlWqKmaq4om7Lruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7rui4QGrIKAJAAANCRHMmRHEmRFEmRHMkBQkNWAQAyAAACAHAMx5AUybEsS9M8zdM8TfRET/RMTxVd0QVCQ1YBAIAAAAIAAAAAADAkw1IsR3M0SZRUS7VUTbVUSxVVT1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTVN0zRNIDRkJQAABADAYo3B5SAhJSXl3hDCEJOeMSYhtV4hBJGS3jEGFYOeMqIMct5C4xCDHggNWREARAEAAMYgxxBzyDlHqZMSOeeodJQa5xyljlJnKcWYYs0oldhSrI1zjlJHraOUYiwtdpRSjanGAgAAAhwAAAIshEJDVgQAUQAAhDFIKaQUYow5p5xDjCnnmHOGMeYcc44556B0UirnnHROSsQYc445p5xzUjonlXNOSiehAACAAAcAgAALodCQFQFAnACAQZI8T/I0UZQ0TxRFU3RdUTRd1/I81fRMU1U90VRVU1Vt2VRVWZY8zzQ901RVzzRV1VRVWTZVVZZFVdVt03V123RV3ZZt2/ddWxZ2UVVt3VRd2zdV1/Zd2fZ9WdZ1Y/I8VfVM03U903Rl1XVtW3VdXfdMU5ZN15Vl03Vt25VlXXdl2fc103Rd01Vl2XRd2XZlV7ddWfZ903WF35VlX1dlWRh2XfeFW9eV5XRd3VdlVzdWWfZ9W9eF4dZ1YZk8T1U903RdzzRdV3VdX1dd19Y105Rl03Vt2VRdWXZl2fddV9Z1zzRl2XRd2zZdV5ZdWfZ9V5Z13XRdX1dlWfhVV/Z1WdeV4dZt4Tdd1/dVWfaFV5Z14dZ1Ybl1XRg+VfV9U3aF4XRl39eF31luXTiW0XV9YZVt4VhlWTl+4ViW3feVZXRdX1ht2RhWWRaGX/id5fZ943h1XRlu3efMuu8Mx++k+8rT1W1jmX3dWWZfd47hGDq/8OOpqq+brisMpywLv+3rxrP7vrKMruv7qiwLvyrbwrHrvvP8vrAso+z6wmrLwrDatjHcvm4sv3Acy2vryjHrvlG2dXxfeArD83R1XXlmXcf2dXTjRzh+ygAAgAEHAIAAE8pAoSErAoA4AQCPJImiZFmiKFmWKIqm6LqiaLqupGmmqWmeaVqaZ5qmaaqyKZquLGmaaVqeZpqap5mmaJqua5qmrIqmKcumasqyaZqy7LqybbuubNuiacqyaZqybJqmLLuyq9uu7Oq6pFmmqXmeaWqeZ5qmasqyaZquq3meanqeaKqeKKqqaqqqraqqLFueZ5qa6KmmJ4qqaqqmrZqqKsumqtqyaaq2bKqqbbuq7Pqybeu6aaqybaqmLZuqatuu7OqyLNu6L2maaWqeZ5qa55mmaZqybJqqK1uep5qeKKqq5ommaqqqLJumqsqW55mqJ4qq6omea5qqKsumatqqaZq2bKqqLZumKsuubfu+68qybqqqbJuqauumasqybMu+78qq7oqmKcumqtqyaaqyLduy78uyrPuiacqyaaqybaqqLsuybRuzbPu6aJqybaqmLZuqKtuyLfu6LNu678qub6uqrOuyLfu67vqucOu6MLyybPuqrPq6K9u6b+sy2/Z9RNOUZVM1bdtUVVl2Zdn2Zdv2fdE0bVtVVVs2TdW2ZVn2fVm2bWE0Tdk2VVXWTdW0bVmWbWG2ZeF2Zdm3ZVv2ddeVdV/XfePXZd3murLty7Kt+6qr+rbu+8Jw667wCgAAGHAAAAgwoQwUGrISAIgCAACMYYwxCI1SzjkHoVHKOecgZM5BCCGVzDkIIZSSOQehlJQy5yCUklIIoZSUWgshlJRSawUAABQ4AAAE2KApsThAoSErAYBUAACD41iW55miatqyY0meJ4qqqaq27UiW54miaaqqbVueJ4qmqaqu6+ua54miaaqq6+q6aJqmqaqu67q6Lpqiqaqq67qyrpumqqquK7uy7Oumqqqq68quLPvCqrquK8uybevCsKqu68qybNu2b9y6ruu+7/vCka3rui78wjEMRwEA4AkOAEAFNqyOcFI0FlhoyEoAIAMAgDAGIYMQQgYhhJBSSiGllBIAADDgAAAQYEIZKDRkRQAQJwAAGEMppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkgppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkqppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoplVJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSCgCQinAAkHowoQwUGrISAEgFAACMUUopxpyDEDHmGGPQSSgpYsw5xhyUklLlHIQQUmktt8o5CCGk1FJtmXNSWosx5hgz56SkFFvNOYdSUoux5ppr7qS0VmuuNedaWqs115xzzbm0FmuuOdecc8sx15xzzjnnGHPOOeecc84FAOA0OACAHtiwOsJJ0VhgoSErAYBUAAACGaUYc8456BBSjDnnHIQQIoUYc845CCFUjDnnHHQQQqgYc8w5CCGEkDnnHIQQQgghcw466CCEEEIHHYQQQgihlM5BCCGEEEooIYQQQgghhBA6CCGEEEIIIYQQQgghhFJKCCGEEEIJoZRQAABggQMAQIANqyOcFI0FFhqyEgAAAgCAHJagUs6EQY5Bjw1BylEzDUJMOdGZYk5qMxVTkDkQnXQSGWpB2V4yCwAAgCAAIMAEEBggKPhCCIgxAABBiMwQCYVVsMCgDBoc5gHAA0SERACQmKBIu7iALgNc0MVdB0IIQhCCWBxAAQk4OOGGJ97whBucoFNU6iAAAAAAAAwA4AEA4KAAIiKaq7C4wMjQ2ODo8AgAAAAAABYA+AAAOD6AiIjmKiwuMDI0Njg6PAIAAAAAAAAAAICAgAAAAAAAQAAAAICAT2dnUwAE7AwAAAAAAAD/QwAAAgAAADuydfsFAQEBAQEACg4ODg=='\n        else {\n          if (!Modernizr.audio.wav) return void d('audiopreload', !1)\n          a.src =\n            'data:audio/wav;base64,UklGRvwZAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YdgZAAAAAAEA/v8CAP//AAABAP////8DAPz/BAD9/wEAAAAAAAAAAAABAP7/AgD//wAAAQD//wAAAQD//wAAAQD+/wIA//8AAAAAAAD//wIA/v8BAAAA//8BAAAA//8BAP//AQAAAP//AQD//wEAAAD//wEA//8BAP//AQD//wEA//8BAP//AQD+/wMA/f8DAP3/AgD+/wIA/////wMA/f8CAP7/AgD+/wMA/f8CAP7/AgD//wAAAAAAAAAAAQD+/wIA/v8CAP7/AwD9/wIA/v8BAAEA/v8CAP7/AQAAAAAAAAD//wEAAAD//wIA/f8DAP7/AQD//wEAAAD//wEA//8CAP7/AQD//wIA/v8CAP7/AQAAAAAAAAD//wEAAAAAAAAA//8BAP//AgD9/wQA+/8FAPz/AgAAAP//AgD+/wEAAAD//wIA/v8CAP3/BAD8/wQA/P8DAP7/AwD8/wQA/P8DAP7/AQAAAAAA//8BAP//AgD+/wEAAAD//wIA/v8BAP//AQD//wEAAAD//wEA//8BAAAAAAAAAP//AgD+/wEAAAAAAAAAAAD//wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AgD+/wIA/v8BAP//AQABAP7/AQD//wIA/v8CAP3/AwD/////AgD9/wMA/v8BAP//AQAAAP//AQD//wEA//8BAP//AAABAP//AAABAP//AQD//wAAAAACAP3/AwD9/wIA//8BAP//AQD//wEA//8BAP//AgD9/wMA/v8AAAIA/f8CAAAA/v8EAPv/BAD9/wIAAAD+/wQA+v8HAPr/BAD+/wEAAAD//wIA/f8EAPz/BAD7/wUA/P8EAPz/AwD+/wEAAAD//wEAAAAAAP//AgD8/wUA+/8FAPz/AwD9/wIA//8AAAEA/v8CAP//AQD//wAAAAABAP//AgD9/wMA/f8EAPz/AwD+/wAAAwD7/wUA/P8DAP7/AQAAAP//AgD+/wEAAQD+/wIA/v8BAAEA/v8CAP7/AQAAAP//AgD9/wMA/f8DAP7/AgD+/wEAAAAAAAEA//8AAAEA/v8DAP3/AgD//wEA//8BAP7/AwD9/wMA/v8BAP//AQAAAP//AgD9/wMA/v8BAP//AQAAAP//AgD+/wEAAQD+/wIA/////wIA//8AAAEA/f8DAP//AAABAP////8DAP3/AwD+/wEA//8BAP//AQAAAAAA//8BAP//AQD//wEA//8BAP//AAAAAAEA//8BAP7/AgD//wEA//8AAAAAAAAAAAAAAAD//wIA/v8BAAAA//8BAAEA/v8BAAAA//8DAPz/AwD+/wIA/v8CAP3/AwD+/wEAAAD//wEA//8BAAAA//8BAAAA/v8EAPv/BAD+/wAAAAABAP7/AgD//wAAAAABAP7/AgD//wAAAAAAAAAAAAABAP3/BAD8/wQA/f8BAAAAAAABAP7/AgD+/wIA/v8CAP7/AgD+/wIA/v8BAAAAAAD//wIA/f8DAP7/AAABAP//AAACAPz/BAD9/wIA//8AAP//AwD9/wMA/P8EAP3/AwD9/wIA//8BAP//AQD+/wMA/f8DAP7/AAABAP//AQAAAP//AQD//wIA/f8DAP7/AQAAAP//AQAAAAAA//8CAP7/AQABAP7/AgD+/wEAAQD+/wIA/v8CAP////8CAP7/AgD//wAAAAABAP7/AwD9/wIAAAD+/wMA/f8CAP//AQD+/wMA/f8CAP//AAACAPz/BQD6/wUA/v///wIA/v8CAP3/BAD7/wYA+v8FAPz/AwD/////AgD+/wEAAAD//wEAAAD//wIA/f8DAP7/AQAAAP//AgD//wAA//8BAAAAAAAAAP//AQD//wEA//8AAAIA/f8DAP3/AgAAAP//AQD//wEA//8AAAEA//8BAP////8CAP//AAABAP3/BAD9/wIA/v8BAAEA//8BAP7/AgD//wEA//8AAAEA//8BAP//AAAAAAEA//8BAP7/AgD//wEA//8AAAAAAQD+/wIA/v8BAAAAAAD//wIA/v8BAAAAAAAAAAAAAQD+/wMA/f8CAP//AQD//wIA/f8DAP7/AQD//wEA//8CAP7/AAABAP7/AwD9/wMA/v8AAAEA//8BAAAAAAD//wIA/v8BAAAA//8CAP7/AgD+/wEA//8CAP7/AgD//wAAAAAAAAAAAQD//wEA/v8DAPz/BQD8/wIA//8AAAEAAAD//wEA//8BAP//AQAAAAAA//8BAP//AgD+/wEAAAAAAP//AQD+/wMA/////wEA/v8CAP//AQD//wEA//8AAAEA//8BAAAA/v8EAPz/AwD+/wEAAAAAAAAA//8CAP7/AQD//wEA//8BAP//AAABAP7/AwD9/wIA//8BAP//AQD//wEA//8AAAEA/v8EAPv/BAD9/wIA//8BAP7/AwD9/wIA//8AAAEA//8BAP//AQD//wAAAQD//wEAAAD+/wMA/v8AAAIA/f8DAP7/AQD//wAAAQD+/wMA/f8CAP//AAABAP7/AgD+/wMA/f8CAP7/AQABAP7/AgD+/wIA/v8CAP7/AwD8/wMA//8AAAEA//8AAAAAAAABAP//AQD//wAAAQD//wIA/f8DAP3/AwD+/wAAAgD9/wIA//8AAAEAAAD+/wMA/P8FAPv/BAD9/wIA//8AAP//AgD+/wIA/v8BAAAAAAD//wEAAAAAAP//AQD//wEA//8BAP//AAABAP7/AwD9/wIA//8BAP//AAABAP//AQD//wAAAQD//wEA//8BAP//AAABAAAA//8BAP7/AwD9/wMA/f8DAP3/AgD//wEA//8BAP7/AgD//wAAAgD8/wQA/f8CAP//AQD+/wMA/f8CAP7/AgD//wAAAAAAAAAAAAABAP7/AwD9/wIA/v8DAP3/AwD9/wIA/v8DAPz/BQD7/wQA/f8CAP7/AwD9/wMA/f8CAP//AQAAAP7/AwD+/wEA//8AAAEAAAAAAP//AAABAP//AQAAAP7/AwD9/wMA/f8CAP//AQD//wEA//8AAAIA/f8CAAAA//8BAAAA//8BAAAA/v8EAPv/BAD9/wIA//8AAAEA/v8CAP//AAABAP//AAABAP//AAABAP7/AwD8/wQA/f8CAAAA/v8DAP3/AwD9/wMA/v8BAAAA//8BAAAA//8CAP7/AQAAAAAAAAAAAAAA//8CAP7/AgD+/wIA/v8CAP7/AgD//wAAAQD//wAAAQD//wAAAQD//wAAAQD+/wIA//8AAAAAAQD+/wMA/f8CAP//AQD//wEA//8AAAEA/v8DAP3/AgD//wAAAAABAP7/AwD9/wIA//8AAAEA/v8DAP3/AgD//wAAAAABAP7/AwD8/wMA/v8CAP//AAD//wIA/v8CAP7/AQABAP7/AQAAAP//AgD/////AQD//wEAAAD//wEA/v8EAPv/BAD9/wMA/v8BAAAA//8BAAEA/P8GAPr/BQD8/wMA/v8BAAAA//8CAP7/AQABAP3/BAD7/wYA+/8EAPz/AwD//wEA//8BAP7/BAD8/wMA/v8AAAIA/v8BAAAA//8BAAAA//8BAAAA//8CAP3/AwD+/wAAAgD8/wUA/P8DAP7/AAABAAAAAAD//wEAAAD//wIA/f8DAP7/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/f8EAPz/AwD/////AgD+/wIA/f8DAP7/AgD+/wEA//8CAP7/AQD//wEAAAAAAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAP//AQAAAP//AAACAP3/BAD7/wQA/v8BAAAA//8BAP//AQAAAP//AQAAAP7/BAD7/wUA+/8EAP3/AgD//wAAAQD+/wIA//8AAAEA/v8CAP//AQD+/wEAAAAAAAAAAAD//wEA//8CAP3/AwD9/wIA//8AAAAAAAAAAAAA//8BAP//AgD+/wEA//8CAP7/AQAAAP//AgD/////AgD/////AgD+/wIA//8AAP//AQABAP7/AgD9/wMA/v8CAP////8BAAAAAAAAAAAA//8CAP////8DAPz/AwD+/wEAAAAAAP//AQD//wEAAAD//wEAAAD+/wQA+/8FAPz/AgAAAP//AgD9/wMA/v8BAAAAAAD//wEAAAD//wIA/v8BAAAAAAD//wIA/v8BAAAA//8BAAAA//8CAP7/AQD//wEA//8BAAAA//8BAP//AAABAP//AQAAAP7/AgD//wEA//8AAAAAAQD+/wMA/P8EAP7///8DAPz/BQD8/wEAAQD+/wMA/v8AAAEA//8BAP//AQD//wEA/v8CAP//AQD//wAAAAABAAAA//8BAP//AQAAAAAA//8BAP//AgD+/wAAAQD//wIA/f8CAP//AQAAAP7/AwD9/wMA/v8BAP//AAABAP//AgD9/wIA//8BAAAA//8BAAAA//8CAP3/AwD+/wEAAAD+/wQA/P8DAP7/AAACAP7/AQAAAP//AQAAAP//AQAAAP//AgD9/wIAAAD//wIA/f8DAP7/AQD//wEA//8CAP7/AQD//wAAAQD//wEA//8AAAAAAQD//wEAAAD9/wUA+/8FAPz/AgD//wAAAQD//wAAAQD+/wMA/f8BAAEA/v8CAP7/AgD+/wIA/v8BAAAAAAAAAAAAAAD//wIA/v8CAP////8CAP7/AgD+/wIA/v8CAP7/AQAAAP//AQAAAP//AQD//wAAAQD//wAAAQD+/wMA/f8CAAAA/v8DAP3/AgAAAP//AQAAAP7/AwD9/wMA/v8BAP//AQD//wEAAAD+/wMA/f8CAAAA/v8CAP//AAAAAAEA//8AAAEA/v8DAP3/AwD9/wIA//8BAP//AgD8/wQA/v8BAAAA/v8CAP//AQD//wAAAAAAAAEA/f8EAPz/BAD9/wIA//8AAAAAAAABAP//AAAAAAAAAAABAP3/BAD9/wIA/v8BAAEA//8AAAAA//8CAP7/AgD9/wQA+/8FAPv/BQD8/wMA/f8DAP3/AwD+/wAAAgD9/wMA/f8CAAAA/v8EAPv/BQD7/wUA/P8DAP///v8DAP3/BAD8/wMA/f8DAP7/AQD//wEAAAD//wEA/v8CAAAA/v8CAP7/AgD//wAAAAAAAAAAAQD+/wIA//8AAAEA/v8DAPz/BAD9/wIA//8AAP//AgD//wEA/v8BAAAAAQD//wAAAAAAAAEA//8AAAEA//8BAP//AAABAP//AQD+/wIA/v8DAPz/BAD8/wQA/f8BAAAAAQD+/wMA/P8DAP//AAAAAAAAAAD//wMA+/8FAP3/AQABAP3/BAD8/wMA/v8BAAAA//8CAP3/AwD+/wEAAQD9/wMA/f8EAPz/BAD7/wQA/v8BAAEA/f8DAP7/AQAAAP//AgD+/wEAAAD//wIA/v8CAP7/AgD+/wEAAQD//wEA/v8CAP7/BAD7/wQA/f8CAAAA//8AAAAAAAABAP//AQD+/wEAAQD+/wMA/f8BAAEA/v8DAPz/AwD/////AwD8/wQA/P8DAP7/AgD//wAA//8BAAAAAAAAAP//AgD+/wEAAAD//wIA/v8BAAAA//8CAP3/AgD//wAAAQD+/wIA/v8BAAAA//8CAP7/AgD+/wEA//8CAP3/BAD7/wQA/v8BAAAA//8AAAEAAAD//wIA/f8DAP7/AgD+/wIA/v8CAP7/AgD+/wEAAAAAAP//AgD9/wMA/v8BAP//AgD9/wMA/v8AAAEA//8BAP//AQD//wEA//8AAAEA/v8EAPz/AgD//wAAAQAAAP//AAABAP//AQD//wEAAAD//wEA//8BAAEA/f8DAP7/AQABAP3/AwD+/wIA/////wEAAAAAAAAAAAD//wIA/v8CAP////8CAP7/AgD//wAA//8CAP3/BAD9/wAAAgD9/wMA/v8BAP//AQAAAP//AQAAAP//AgD9/wMA/f8EAPz/AwD+/wEAAAAAAAAAAAD//wIA/f8EAP3/AAABAAAA//8CAP7/AQAAAP//AQAAAAAA//8BAP//AQAAAP//AQAAAP//AQAAAP//AgD9/wMA/v8BAP//AQAAAP//AQD//wIA/v8CAP3/BAD9/wEAAAD//wEAAQD9/wMA/f8CAAAA/v8DAP3/AgD//wAAAQD+/wIA/v8CAP7/AQAAAP//AgD+/wEAAAAAAP//AwD7/wUA/f8BAAEA/v8BAAEA/v8DAP3/AgD//wEA//8BAP//AQD//wEA//8CAP3/BAD7/wQA/////wIA/v8AAAIA/v8CAP3/BAD7/wUA/P8DAP3/AwD9/wMA/v8AAAIA/v8CAP7/AgD+/wIA//8AAAEA/v8CAP7/AgD//wAAAAD//wEAAAAAAAAA//8BAP7/BAD7/wUA/P8CAAAA//8BAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAAAA//8CAP3/AwD+/wEA//8CAP3/AwD+/wAAAwD8/wIAAAD//wIA/////wIA/v8CAP7/AgD+/wEAAAAAAAAAAAAAAP//AgD+/wIA//8AAAAA//8CAP7/AgD+/wEA//8CAP3/AwD9/wMA/v8BAP7/AwD9/wMA/f8CAP//AQD+/wIA//8BAP//AQD+/wMA/v8BAAAA//8BAAAA//8CAP7/AQAAAP//AgD+/wIA/v8CAP//AAAAAAEA//8BAP//AAABAAAA//8BAP//AQD//wEA//8BAP//AQAAAP//AQD//wEAAAD//wIA/f8CAAAA//8BAAAA//8BAP//AAABAP//AQD//wAAAAAAAAEA/v8CAP//AQD//wAAAAABAP7/AwD9/wIAAAD+/wIA//8BAP//AgD9/wMA/f8DAP7/AgD+/wEAAAAAAAEA/v8CAP7/AgD//wAAAAAAAAAAAAAAAP//AgD/////AgD9/wQA/f8BAAAAAAAAAAEA/f8DAP////8DAP3/AQABAP7/AgD//wAAAQD+/wMA/f8CAP7/AQABAP7/AwD7/wYA+v8FAP3/AQABAP7/AgD+/wMA/f8CAP7/AwD+/wEA//8BAP//AQAAAP7/BQD5/wcA+v8FAPz/AwD+/wIA/v8BAAAA//8DAPv/BQD8/wMA/////wEAAAAAAAAAAAD//wIA/f8DAP7/AQAAAP//AQAAAP//AgD+/wIA/v8BAAEA/f8EAPz/AwD+/wEA//8CAP7/AQD//wEA//8CAP7/AQAAAP//AgD+/wEAAAAAAAAAAAAAAAAAAAD//wIA/f8EAPz/AwD+/wEA//8CAP7/AgD+/wEAAQD+/wEAAQD+/wIA/////wIA//8AAAAAAAAAAAAAAAD//wEAAAAAAP//AgD9/wMA/v8BAP//AQAAAP//AQD//wEA//8BAP//AQD//wEA//8BAP//AQAAAP7/AwD9/wMA/v8BAP7/AwD9/wMA/v8BAP//AAABAP//AQD//wAAAAABAP//AAAAAAAAAQD//wEA/v8CAAAA/v8EAPv/BAD9/wIAAAD+/wMA/P8DAP//AAAAAP//AQD//wIA/f8DAP3/AwD9/wMA/v8BAAAA//8BAAAA//8CAP3/AwD9/wQA+/8FAPv/BQD8/wMA/v8BAAAA//8BAP//AgD+/wEAAAD//wIA/v8BAAEA/f8DAP3/AgAAAP//AQD//wAAAQD//wEA//8BAP//AQD//wEA/v8DAP3/AgAAAP7/AwD9/wIAAAD//wEAAAD//wIA/f8DAP7/AgD9/wQA+/8FAPz/AgAAAP//AgD9/wIA//8BAP//AQD//wEA//8BAP//AQD//wIA/f8DAP3/AgD//wAAAQD+/wIA/v8BAAEA/v8CAP7/AgD+/wMA/P8DAP//AAABAP7/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/v8CAP3/BAD8/wMA/v8BAAAAAAD//wEAAAAAAAAAAAD//wEAAAAAAAAA//8BAP//AgD+/wEA//8CAP3/AwD9/wMA/f8EAPv/BAD+/wAAAQD//wEA//8BAP//AAABAP//AQD//wEAAAD//wEA//8BAP//AgD9/wMA/v8AAAIA/f8DAP7/AAACAP3/AwD+/wEA//8BAP//AQAAAP//AQAAAP7/AwD9/wMA/v8AAAEA//8BAP//AAAAAAEA//8AAAEA/v8CAP//AAAAAAEA/v8DAPz/BAD9/wEAAQD+/wEAAQD9/wQA/P8DAP7/AQAAAAAAAAAAAAAAAAAAAAAAAQD+/wIA/////wIA/v8BAAAA//8BAP//AQD//wEA//8BAAAA/v8EAPz/AwD///7/BAD8/wMA/////wIA/v8CAP////8CAP7/AgD+/wIA/v8CAP////8CAP7/AwD9/wIA/v8CAP//AAABAP7/AwD9/wEAAQD+/wMA/f8CAP//AAAAAAEA/v8DAPz/BAD9/wIA/v8CAP7/AgD//wAAAAD//wIA/v8CAP7/AQAAAAAA//8CAP7/AgD+/wIA/v8CAP7/AwD8/wUA+v8GAPv/AwD//wAAAAAAAAAA//8DAPv/BQD9/wAAAgD9/wMA/v8BAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAAAAAAAAAP//AQAAAAAAAAD//wEA//8CAP3/AwD+/wAAAgD+/wEAAAD//wIA/v8CAP7/AgD/////AwD8/wUA/P8CAP//AQD//wIA/f8DAP3/AwD+/wAAAQD+/wMA/f8DAP3/AgD//wAAAQD//wEA//8BAP7/AwD+/wEA//8AAAEA//8CAPz/BAD9/wIA//8AAAEA/v8DAPz/BAD9/wIA//8AAAEA/v8CAP7/AgD//wEA/f8EAPz/BAD+////AgD//wAAAQD//wAAAQD//wEA//8BAP7/AwD+/wEA'\n        }\n      } catch (r) {\n        return void d('audiopreload', !1)\n      }\n      a.setAttribute('preload', 'auto'),\n        (a.style.cssText = 'display:none'),\n        I.appendChild(a),\n        setTimeout(function () {\n          a.addEventListener('loadeddata', A, !1), (e = setTimeout(A, n))\n        }, 0)\n    })\n  var U = (B.testStyles = s)\n  Modernizr.addTest('unicoderange', function () {\n    return Modernizr.testStyles(\n      '@font-face{font-family:\"unicodeRange\";src:local(\"Arial\");unicode-range:U+0020,U+002E}#modernizr span{font-size:20px;display:inline-block;font-family:\"unicodeRange\",monospace}#modernizr .mono{font-family:monospace}',\n      function (A) {\n        for (var e = ['.', '.', 'm', 'm'], t = 0; t < e.length; t++) {\n          var n = o('span')\n          ;(n.innerHTML = e[t]), (n.className = t % 2 ? 'mono' : ''), A.appendChild(n), (e[t] = n.clientWidth)\n        }\n        return e[0] !== e[1] && e[2] === e[3]\n      }\n    )\n  }),\n    Modernizr.addTest('unicode', function () {\n      var A,\n        e = o('span'),\n        t = o('span')\n      return (\n        U('#modernizr{font-family:Arial,sans;font-size:300em;}', function (n) {\n          ;(e.innerHTML = y ? '' : '&#5987;'),\n            (t.innerHTML = y ? '' : '&#9734;'),\n            n.appendChild(e),\n            n.appendChild(t),\n            (A = 'offsetWidth' in e && e.offsetWidth !== t.offsetWidth)\n        }),\n        A\n      )\n    }),\n    Modernizr.addTest('checked', function () {\n      return U(\n        '#modernizr {position:absolute} #modernizr input {margin-left:10px} #modernizr :checked {margin-left:20px;display:block}',\n        function (A) {\n          var e = o('input')\n          return (\n            e.setAttribute('type', 'checkbox'),\n            e.setAttribute('checked', 'checked'),\n            A.appendChild(e),\n            20 === e.offsetLeft\n          )\n        }\n      )\n    }),\n    U('#modernizr{font:0/0 a}#modernizr:after{content:\":)\";visibility:hidden;font:7px/1 a}', function (A) {\n      Modernizr.addTest('generatedcontent', A.offsetHeight >= 7)\n    }),\n    U(\n      '#modernizr div {width:100px} #modernizr :last-child{width:200px;display:block}',\n      function (A) {\n        Modernizr.addTest('lastchild', A.lastChild.offsetWidth > A.firstChild.offsetWidth)\n      },\n      2\n    ),\n    Modernizr.addTest('cssvalid', function () {\n      return U(\n        '#modernizr input{height:0;border:0;padding:0;margin:0;width:10px} #modernizr input:valid{width:50px}',\n        function (A) {\n          var e = o('input')\n          return A.appendChild(e), e.clientWidth > 10\n        }\n      )\n    }),\n    U('#modernizr { height: 50vh; }', function (e) {\n      var t = parseInt(A.innerHeight / 2, 10),\n        n = parseInt((A.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle).height, 10)\n      Modernizr.addTest('cssvhunit', n == t)\n    }),\n    U(\n      '#modernizr div {width:1px} #modernizr div:nth-child(2n) {width:2px;}',\n      function (A) {\n        for (var e = A.getElementsByTagName('div'), t = !0, n = 0; 5 > n; n++) t = t && e[n].offsetWidth === (n % 2) + 1\n        Modernizr.addTest('nthchild', t)\n      },\n      5\n    ),\n    U('#modernizr { width: 50vw; }', function (e) {\n      var t = parseInt(A.innerWidth / 2, 10),\n        n = parseInt((A.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle).width, 10)\n      Modernizr.addTest('cssvwunit', n == t)\n    }),\n    U(\n      '#modernizr{overflow: scroll; width: 40px; height: 40px; }#' +\n        R.join('scrollbar{width:0px} #modernizr::')\n          .split('#')\n          .slice(1)\n          .join('#') +\n        'scrollbar{width:0px}',\n      function (A) {\n        Modernizr.addTest('cssscrollbar', 40 == A.scrollWidth)\n      }\n    ),\n    Modernizr.addTest('formvalidation', function () {\n      var e = o('form')\n      if (!('checkValidity' in e && 'addEventListener' in e)) return !1\n      if ('reportValidity' in e) return !0\n      var t,\n        n = !1\n      return (\n        (Modernizr.formvalidationapi = !0),\n        e.addEventListener(\n          'submit',\n          function (e) {\n            ;(!A.opera || A.operamini) && e.preventDefault(), e.stopPropagation()\n          },\n          !1\n        ),\n        (e.innerHTML = '<input name=\"modTest\" required=\"required\" /><button></button>'),\n        U('#modernizr form{position:absolute;top:-99999em}', function (A) {\n          A.appendChild(e),\n            (t = e.getElementsByTagName('input')[0]),\n            t.addEventListener(\n              'invalid',\n              function (A) {\n                ;(n = !0), A.preventDefault(), A.stopPropagation()\n              },\n              !1\n            ),\n            (Modernizr.formvalidationmessage = !!t.validationMessage),\n            e.getElementsByTagName('button')[0].click()\n        }),\n        n\n      )\n    })\n  var W = (function () {\n    var e = A.matchMedia || A.msMatchMedia\n    return e\n      ? function (A) {\n          var t = e(A)\n          return (t && t.matches) || !1\n        }\n      : function (e) {\n          var t = !1\n          return (\n            s('@media ' + e + ' { #modernizr { position: absolute; } }', function (e) {\n              t = 'absolute' == (A.getComputedStyle ? A.getComputedStyle(e, null) : e.currentStyle).position\n            }),\n            t\n          )\n        }\n  })()\n  ;(B.mq = W), Modernizr.addTest('mediaqueries', W('only all'))\n  var z = 'Moz O ms Webkit',\n    Z = B._config.usePrefixes ? z.split(' ') : []\n  B._cssomPrefixes = Z\n  var K = function (e) {\n    var n,\n      a = R.length,\n      i = A.CSSRule\n    if ('undefined' == typeof i) return t\n    if (!e) return !1\n    if (((e = e.replace(/^@/, '')), (n = e.replace(/-/g, '_').toUpperCase() + '_RULE'), n in i)) return '@' + e\n    for (var o = 0; a > o; o++) {\n      var r = R[o],\n        d = r.toUpperCase() + '_' + n\n      if (d in i) return '@-' + r.toLowerCase() + '-' + e\n    }\n    return !1\n  }\n  B.atRule = K\n  var F = B._config.usePrefixes ? z.toLowerCase().split(' ') : []\n  B._domPrefixes = F\n  var J = { elem: o('modernizr') }\n  Modernizr._q.push(function () {\n    delete J.elem\n  })\n  var O = { style: J.elem.style }\n  Modernizr._q.unshift(function () {\n    delete O.style\n  }),\n    (B.testAllProps = p)\n  var G = (B.prefixed = function (A, e, t) {\n    return 0 === A.indexOf('@') ? K(A) : (-1 != A.indexOf('-') && (A = w(A)), e ? p(A, e, t) : p(A, 'pfx'))\n  })\n  Modernizr.addTest('requestanimationframe', !!G('requestAnimationFrame', A), { aliases: ['raf'] }),\n    Modernizr.addTest('backgroundblendmode', G('backgroundBlendMode', 'text')),\n    (B.testAllProps = g),\n    Modernizr.addTest('cssanimations', g('animationName', 'a', !0)),\n    Modernizr.addTest('backgroundcliptext', function () {\n      return g('backgroundClip', 'text')\n    }),\n    Modernizr.addTest('bgpositionxy', function () {\n      return g('backgroundPositionX', '3px', !0) && g('backgroundPositionY', '5px', !0)\n    }),\n    Modernizr.addTest('bgrepeatround', g('backgroundRepeat', 'round')),\n    Modernizr.addTest('bgrepeatspace', g('backgroundRepeat', 'space')),\n    Modernizr.addTest('backgroundsize', g('backgroundSize', '100%', !0)),\n    Modernizr.addTest('bgsizecover', g('backgroundSize', 'cover')),\n    Modernizr.addTest('borderradius', g('borderRadius', '0px', !0)),\n    (function () {\n      Modernizr.addTest('csscolumns', function () {\n        var A = !1,\n          e = g('columnCount')\n        try {\n          ;(A = !!e) && (A = new Boolean(A))\n        } catch (t) {}\n        return A\n      })\n      for (\n        var A,\n          e,\n          t = [\n            'Width',\n            'Span',\n            'Fill',\n            'Gap',\n            'Rule',\n            'RuleColor',\n            'RuleStyle',\n            'RuleWidth',\n            'BreakBefore',\n            'BreakAfter',\n            'BreakInside'\n          ],\n          n = 0;\n        n < t.length;\n        n++\n      )\n        (A = t[n].toLowerCase()),\n          (e = g('column' + t[n])),\n          ('breakbefore' === A || 'breakafter' === A || 'breakinside' == A) && (e = e || g(t[n])),\n          Modernizr.addTest('csscolumns.' + A, e)\n    })(),\n    Modernizr.addTest('ellipsis', g('textOverflow', 'ellipsis')),\n    Modernizr.addTest('cssfilters', function () {\n      if (Modernizr.supports) return g('filter', 'blur(2px)')\n      var A = o('a')\n      return (\n        (A.style.cssText = R.join('filter:blur(2px); ')),\n        !!A.style.length && (e.documentMode === t || e.documentMode > 9)\n      )\n    }),\n    Modernizr.addTest('boxshadow', g('boxShadow', '1px 1px', !0)),\n    Modernizr.addTest('boxsizing', g('boxSizing', 'border-box', !0) && (e.documentMode === t || e.documentMode > 7)),\n    Modernizr.addTest('flexbox', g('flexBasis', '1px', !0)),\n    Modernizr.addTest('flexboxlegacy', g('boxDirection', 'reverse', !0)),\n    Modernizr.addTest('flexboxtweener', g('flexAlign', 'end', !0)),\n    Modernizr.addTest('flexwrap', g('flexWrap', 'wrap', !0)),\n    Modernizr.addTest('cssmask', g('maskRepeat', 'repeat-x', !0)),\n    Modernizr.addTest('csstransforms', function () {\n      return -1 === navigator.userAgent.indexOf('Android 2.') && g('transform', 'scale(1)', !0)\n    }),\n    Modernizr.addTest('csstransitions', g('transition', 'all', !0)),\n    Modernizr.addTest('overflowscrolling', g('overflowScrolling', 'touch', !0)),\n    a(),\n    i(v),\n    delete B.addTest,\n    delete B.addAsyncTest\n  for (var Y = 0; Y < Modernizr._q.length; Y++) Modernizr._q[Y]()\n  __webpack_provided_window_dot_Modernizr = Modernizr\n})(window, document)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! modernizr */ \"./src/public/js/vendor/modernizr/modernizr.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/modernizr/modernizr.js?");

/***/ }),

/***/ "./src/public/js/vendor/underscore/underscore.js":
/*!*******************************************************!*\
  !*** ./src/public/js/vendor/underscore/underscore.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n;(function () {\n  function n (n) {\n    function t (t, r, e, u, i, o) {\n      for (; i >= 0 && o > i; i += n) {\n        var a = u ? u[i] : i\n        e = r(e, t[a], a, t)\n      }\n      return e\n    }\n    return function (r, e, u, i) {\n      e = b(e, i, 4)\n      var o = !k(r) && m.keys(r),\n        a = (o || r).length,\n        c = n > 0 ? 0 : a - 1\n      return arguments.length < 3 && ((u = r[o ? o[c] : c]), (c += n)), t(r, e, u, o, c, a)\n    }\n  }\n  function t (n) {\n    return function (t, r, e) {\n      r = x(r, e)\n      for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i\n      return -1\n    }\n  }\n  function r (n, t, r) {\n    return function (e, u, i) {\n      var o = 0,\n        a = O(e)\n      if ('number' == typeof i)\n        n > 0 ? (o = i >= 0 ? i : Math.max(i + a, o)) : (a = i >= 0 ? Math.min(i + 1, a) : i + a + 1)\n      else if (r && i && a) return (i = r(e, u)), e[i] === u ? i : -1\n      if (u !== u) return (i = t(l.call(e, o, a), m.isNaN)), i >= 0 ? i + o : -1\n      for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i\n      return -1\n    }\n  }\n  function e (n, t) {\n    var r = I.length,\n      e = n.constructor,\n      u = (m.isFunction(e) && e.prototype) || a,\n      i = 'constructor'\n    for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--; )\n      (i = I[r]), i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i)\n  }\n  var u = this,\n    i = u._,\n    o = Array.prototype,\n    a = Object.prototype,\n    c = Function.prototype,\n    f = o.push,\n    l = o.slice,\n    s = a.toString,\n    p = a.hasOwnProperty,\n    h = Array.isArray,\n    v = Object.keys,\n    g = c.bind,\n    y = Object.create,\n    d = function () {},\n    m = function (n) {\n      return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n)\n    }\n   true\n    ? ( true && module.exports && (exports = module.exports = m), (exports._ = m))\n    : (undefined),\n    (m.VERSION = '1.8.3')\n  var b = function (n, t, r) {\n      if (t === void 0) return n\n      switch (null == r ? 3 : r) {\n        case 1:\n          return function (r) {\n            return n.call(t, r)\n          }\n        case 2:\n          return function (r, e) {\n            return n.call(t, r, e)\n          }\n        case 3:\n          return function (r, e, u) {\n            return n.call(t, r, e, u)\n          }\n        case 4:\n          return function (r, e, u, i) {\n            return n.call(t, r, e, u, i)\n          }\n      }\n      return function () {\n        return n.apply(t, arguments)\n      }\n    },\n    x = function (n, t, r) {\n      return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n)\n    }\n  m.iteratee = function (n, t) {\n    return x(n, t, 1 / 0)\n  }\n  var _ = function (n, t) {\n      return function (r) {\n        var e = arguments.length\n        if (2 > e || null == r) return r\n        for (var u = 1; e > u; u++)\n          for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {\n            var f = o[c]\n            ;(t && r[f] !== void 0) || (r[f] = i[f])\n          }\n        return r\n      }\n    },\n    j = function (n) {\n      if (!m.isObject(n)) return {}\n      if (y) return y(n)\n      d.prototype = n\n      var t = new d()\n      return (d.prototype = null), t\n    },\n    w = function (n) {\n      return function (t) {\n        return null == t ? void 0 : t[n]\n      }\n    },\n    A = Math.pow(2, 53) - 1,\n    O = w('length'),\n    k = function (n) {\n      var t = O(n)\n      return 'number' == typeof t && t >= 0 && A >= t\n    }\n  ;(m.each = m.forEach = function (n, t, r) {\n    t = b(t, r)\n    var e, u\n    if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n)\n    else {\n      var i = m.keys(n)\n      for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n)\n    }\n    return n\n  }),\n    (m.map = m.collect = function (n, t, r) {\n      t = x(t, r)\n      for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {\n        var a = e ? e[o] : o\n        i[o] = t(n[a], a, n)\n      }\n      return i\n    }),\n    (m.reduce = m.foldl = m.inject = n(1)),\n    (m.reduceRight = m.foldr = n(-1)),\n    (m.find = m.detect = function (n, t, r) {\n      var e\n      return (e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r)), e !== void 0 && e !== -1 ? n[e] : void 0\n    }),\n    (m.filter = m.select = function (n, t, r) {\n      var e = []\n      return (\n        (t = x(t, r)),\n        m.each(n, function (n, r, u) {\n          t(n, r, u) && e.push(n)\n        }),\n        e\n      )\n    }),\n    (m.reject = function (n, t, r) {\n      return m.filter(n, m.negate(x(t)), r)\n    }),\n    (m.every = m.all = function (n, t, r) {\n      t = x(t, r)\n      for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {\n        var o = e ? e[i] : i\n        if (!t(n[o], o, n)) return !1\n      }\n      return !0\n    }),\n    (m.some = m.any = function (n, t, r) {\n      t = x(t, r)\n      for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {\n        var o = e ? e[i] : i\n        if (t(n[o], o, n)) return !0\n      }\n      return !1\n    }),\n    (m.contains = m.includes = m.include = function (n, t, r, e) {\n      return k(n) || (n = m.values(n)), ('number' != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0\n    }),\n    (m.invoke = function (n, t) {\n      var r = l.call(arguments, 2),\n        e = m.isFunction(t)\n      return m.map(n, function (n) {\n        var u = e ? t : n[t]\n        return null == u ? u : u.apply(n, r)\n      })\n    }),\n    (m.pluck = function (n, t) {\n      return m.map(n, m.property(t))\n    }),\n    (m.where = function (n, t) {\n      return m.filter(n, m.matcher(t))\n    }),\n    (m.findWhere = function (n, t) {\n      return m.find(n, m.matcher(t))\n    }),\n    (m.max = function (n, t, r) {\n      var e,\n        u,\n        i = -1 / 0,\n        o = -1 / 0\n      if (null == t && null != n) {\n        n = k(n) ? n : m.values(n)\n        for (var a = 0, c = n.length; c > a; a++) (e = n[a]), e > i && (i = e)\n      } else\n        (t = x(t, r)),\n          m.each(n, function (n, r, e) {\n            ;(u = t(n, r, e)), (u > o || (u === -1 / 0 && i === -1 / 0)) && ((i = n), (o = u))\n          })\n      return i\n    }),\n    (m.min = function (n, t, r) {\n      var e,\n        u,\n        i = 1 / 0,\n        o = 1 / 0\n      if (null == t && null != n) {\n        n = k(n) ? n : m.values(n)\n        for (var a = 0, c = n.length; c > a; a++) (e = n[a]), i > e && (i = e)\n      } else\n        (t = x(t, r)),\n          m.each(n, function (n, r, e) {\n            ;(u = t(n, r, e)), (o > u || (1 / 0 === u && 1 / 0 === i)) && ((i = n), (o = u))\n          })\n      return i\n    }),\n    (m.shuffle = function (n) {\n      for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++)\n        (t = m.random(0, i)), t !== i && (u[i] = u[t]), (u[t] = r[i])\n      return u\n    }),\n    (m.sample = function (n, t, r) {\n      return null == t || r\n        ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)])\n        : m.shuffle(n).slice(0, Math.max(0, t))\n    }),\n    (m.sortBy = function (n, t, r) {\n      return (\n        (t = x(t, r)),\n        m.pluck(\n          m\n            .map(n, function (n, r, e) {\n              return { value: n, index: r, criteria: t(n, r, e) }\n            })\n            .sort(function (n, t) {\n              var r = n.criteria,\n                e = t.criteria\n              if (r !== e) {\n                if (r > e || r === void 0) return 1\n                if (e > r || e === void 0) return -1\n              }\n              return n.index - t.index\n            }),\n          'value'\n        )\n      )\n    })\n  var F = function (n) {\n    return function (t, r, e) {\n      var u = {}\n      return (\n        (r = x(r, e)),\n        m.each(t, function (e, i) {\n          var o = r(e, i, t)\n          n(u, e, o)\n        }),\n        u\n      )\n    }\n  }\n  ;(m.groupBy = F(function (n, t, r) {\n    m.has(n, r) ? n[r].push(t) : (n[r] = [t])\n  })),\n    (m.indexBy = F(function (n, t, r) {\n      n[r] = t\n    })),\n    (m.countBy = F(function (n, t, r) {\n      m.has(n, r) ? n[r]++ : (n[r] = 1)\n    })),\n    (m.toArray = function (n) {\n      return n ? (m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n)) : []\n    }),\n    (m.size = function (n) {\n      return null == n ? 0 : k(n) ? n.length : m.keys(n).length\n    }),\n    (m.partition = function (n, t, r) {\n      t = x(t, r)\n      var e = [],\n        u = []\n      return (\n        m.each(n, function (n, r, i) {\n          ;(t(n, r, i) ? e : u).push(n)\n        }),\n        [e, u]\n      )\n    }),\n    (m.first = m.head = m.take = function (n, t, r) {\n      return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t)\n    }),\n    (m.initial = function (n, t, r) {\n      return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)))\n    }),\n    (m.last = function (n, t, r) {\n      return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t))\n    }),\n    (m.rest = m.tail = m.drop = function (n, t, r) {\n      return l.call(n, null == t || r ? 1 : t)\n    }),\n    (m.compact = function (n) {\n      return m.filter(n, m.identity)\n    })\n  var S = function (n, t, r, e) {\n    for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {\n      var c = n[o]\n      if (k(c) && (m.isArray(c) || m.isArguments(c))) {\n        t || (c = S(c, t, r))\n        var f = 0,\n          l = c.length\n        for (u.length += l; l > f; ) u[i++] = c[f++]\n      } else r || (u[i++] = c)\n    }\n    return u\n  }\n  ;(m.flatten = function (n, t) {\n    return S(n, t, !1)\n  }),\n    (m.without = function (n) {\n      return m.difference(n, l.call(arguments, 1))\n    }),\n    (m.uniq = m.unique = function (n, t, r, e) {\n      m.isBoolean(t) || ((e = r), (r = t), (t = !1)), null != r && (r = x(r, e))\n      for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {\n        var c = n[o],\n          f = r ? r(c, o, n) : c\n        t\n          ? ((o && i === f) || u.push(c), (i = f))\n          : r\n          ? m.contains(i, f) || (i.push(f), u.push(c))\n          : m.contains(u, c) || u.push(c)\n      }\n      return u\n    }),\n    (m.union = function () {\n      return m.uniq(S(arguments, !0, !0))\n    }),\n    (m.intersection = function (n) {\n      for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {\n        var i = n[e]\n        if (!m.contains(t, i)) {\n          for (var o = 1; r > o && m.contains(arguments[o], i); o++);\n          o === r && t.push(i)\n        }\n      }\n      return t\n    }),\n    (m.difference = function (n) {\n      var t = S(arguments, !0, !0, 1)\n      return m.filter(n, function (n) {\n        return !m.contains(t, n)\n      })\n    }),\n    (m.zip = function () {\n      return m.unzip(arguments)\n    }),\n    (m.unzip = function (n) {\n      for (var t = (n && m.max(n, O).length) || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e)\n      return r\n    }),\n    (m.object = function (n, t) {\n      for (var r = {}, e = 0, u = O(n); u > e; e++) t ? (r[n[e]] = t[e]) : (r[n[e][0]] = n[e][1])\n      return r\n    }),\n    (m.findIndex = t(1)),\n    (m.findLastIndex = t(-1)),\n    (m.sortedIndex = function (n, t, r, e) {\n      r = x(r, e, 1)\n      for (var u = r(t), i = 0, o = O(n); o > i; ) {\n        var a = Math.floor((i + o) / 2)\n        r(n[a]) < u ? (i = a + 1) : (o = a)\n      }\n      return i\n    }),\n    (m.indexOf = r(1, m.findIndex, m.sortedIndex)),\n    (m.lastIndexOf = r(-1, m.findLastIndex)),\n    (m.range = function (n, t, r) {\n      null == t && ((t = n || 0), (n = 0)), (r = r || 1)\n      for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r) u[i] = n\n      return u\n    })\n  var E = function (n, t, r, e, u) {\n    if (!(e instanceof t)) return n.apply(r, u)\n    var i = j(n.prototype),\n      o = n.apply(i, u)\n    return m.isObject(o) ? o : i\n  }\n  ;(m.bind = function (n, t) {\n    if (g && n.bind === g) return g.apply(n, l.call(arguments, 1))\n    if (!m.isFunction(n)) throw new TypeError('Bind must be called on a function')\n    var r = l.call(arguments, 2),\n      e = function () {\n        return E(n, e, t, this, r.concat(l.call(arguments)))\n      }\n    return e\n  }),\n    (m.partial = function (n) {\n      var t = l.call(arguments, 1),\n        r = function () {\n          for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o]\n          for (; e < arguments.length; ) i.push(arguments[e++])\n          return E(n, r, this, this, i)\n        }\n      return r\n    }),\n    (m.bindAll = function (n) {\n      var t,\n        r,\n        e = arguments.length\n      if (1 >= e) throw new Error('bindAll must be passed function names')\n      for (t = 1; e > t; t++) (r = arguments[t]), (n[r] = m.bind(n[r], n))\n      return n\n    }),\n    (m.memoize = function (n, t) {\n      var r = function (e) {\n        var u = r.cache,\n          i = '' + (t ? t.apply(this, arguments) : e)\n        return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i]\n      }\n      return (r.cache = {}), r\n    }),\n    (m.delay = function (n, t) {\n      var r = l.call(arguments, 2)\n      return setTimeout(function () {\n        return n.apply(null, r)\n      }, t)\n    }),\n    (m.defer = m.partial(m.delay, m, 1)),\n    (m.throttle = function (n, t, r) {\n      var e,\n        u,\n        i,\n        o = null,\n        a = 0\n      r || (r = {})\n      var c = function () {\n        ;(a = r.leading === !1 ? 0 : m.now()), (o = null), (i = n.apply(e, u)), o || (e = u = null)\n      }\n      return function () {\n        var f = m.now()\n        a || r.leading !== !1 || (a = f)\n        var l = t - (f - a)\n        return (\n          (e = this),\n          (u = arguments),\n          0 >= l || l > t\n            ? (o && (clearTimeout(o), (o = null)), (a = f), (i = n.apply(e, u)), o || (e = u = null))\n            : o || r.trailing === !1 || (o = setTimeout(c, l)),\n          i\n        )\n      }\n    }),\n    (m.debounce = function (n, t, r) {\n      var e,\n        u,\n        i,\n        o,\n        a,\n        c = function () {\n          var f = m.now() - o\n          t > f && f >= 0 ? (e = setTimeout(c, t - f)) : ((e = null), r || ((a = n.apply(i, u)), e || (i = u = null)))\n        }\n      return function () {\n        ;(i = this), (u = arguments), (o = m.now())\n        var f = r && !e\n        return e || (e = setTimeout(c, t)), f && ((a = n.apply(i, u)), (i = u = null)), a\n      }\n    }),\n    (m.wrap = function (n, t) {\n      return m.partial(t, n)\n    }),\n    (m.negate = function (n) {\n      return function () {\n        return !n.apply(this, arguments)\n      }\n    }),\n    (m.compose = function () {\n      var n = arguments,\n        t = n.length - 1\n      return function () {\n        for (var r = t, e = n[t].apply(this, arguments); r--; ) e = n[r].call(this, e)\n        return e\n      }\n    }),\n    (m.after = function (n, t) {\n      return function () {\n        return --n < 1 ? t.apply(this, arguments) : void 0\n      }\n    }),\n    (m.before = function (n, t) {\n      var r\n      return function () {\n        return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r\n      }\n    }),\n    (m.once = m.partial(m.before, 2))\n  var M = !{ toString: null }.propertyIsEnumerable('toString'),\n    I = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']\n  ;(m.keys = function (n) {\n    if (!m.isObject(n)) return []\n    if (v) return v(n)\n    var t = []\n    for (var r in n) m.has(n, r) && t.push(r)\n    return M && e(n, t), t\n  }),\n    (m.allKeys = function (n) {\n      if (!m.isObject(n)) return []\n      var t = []\n      for (var r in n) t.push(r)\n      return M && e(n, t), t\n    }),\n    (m.values = function (n) {\n      for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]]\n      return e\n    }),\n    (m.mapObject = function (n, t, r) {\n      t = x(t, r)\n      for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) (e = u[a]), (o[e] = t(n[e], e, n))\n      return o\n    }),\n    (m.pairs = function (n) {\n      for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]]\n      return e\n    }),\n    (m.invert = function (n) {\n      for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e]\n      return t\n    }),\n    (m.functions = m.methods = function (n) {\n      var t = []\n      for (var r in n) m.isFunction(n[r]) && t.push(r)\n      return t.sort()\n    }),\n    (m.extend = _(m.allKeys)),\n    (m.extendOwn = m.assign = _(m.keys)),\n    (m.findKey = function (n, t, r) {\n      t = x(t, r)\n      for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (((e = u[i]), t(n[e], e, n))) return e\n    }),\n    (m.pick = function (n, t, r) {\n      var e,\n        u,\n        i = {},\n        o = n\n      if (null == o) return i\n      m.isFunction(t)\n        ? ((u = m.allKeys(o)), (e = b(t, r)))\n        : ((u = S(arguments, !1, !1, 1)),\n          (e = function (n, t, r) {\n            return t in r\n          }),\n          (o = Object(o)))\n      for (var a = 0, c = u.length; c > a; a++) {\n        var f = u[a],\n          l = o[f]\n        e(l, f, o) && (i[f] = l)\n      }\n      return i\n    }),\n    (m.omit = function (n, t, r) {\n      if (m.isFunction(t)) t = m.negate(t)\n      else {\n        var e = m.map(S(arguments, !1, !1, 1), String)\n        t = function (n, t) {\n          return !m.contains(e, t)\n        }\n      }\n      return m.pick(n, t, r)\n    }),\n    (m.defaults = _(m.allKeys, !0)),\n    (m.create = function (n, t) {\n      var r = j(n)\n      return t && m.extendOwn(r, t), r\n    }),\n    (m.clone = function (n) {\n      return m.isObject(n) ? (m.isArray(n) ? n.slice() : m.extend({}, n)) : n\n    }),\n    (m.tap = function (n, t) {\n      return t(n), n\n    }),\n    (m.isMatch = function (n, t) {\n      var r = m.keys(t),\n        e = r.length\n      if (null == n) return !e\n      for (var u = Object(n), i = 0; e > i; i++) {\n        var o = r[i]\n        if (t[o] !== u[o] || !(o in u)) return !1\n      }\n      return !0\n    })\n  var N = function (n, t, r, e) {\n    if (n === t) return 0 !== n || 1 / n === 1 / t\n    if (null == n || null == t) return n === t\n    n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped)\n    var u = s.call(n)\n    if (u !== s.call(t)) return !1\n    switch (u) {\n      case '[object RegExp]':\n      case '[object String]':\n        return '' + n == '' + t\n      case '[object Number]':\n        return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t\n      case '[object Date]':\n      case '[object Boolean]':\n        return +n === +t\n    }\n    var i = '[object Array]' === u\n    if (!i) {\n      if ('object' != typeof n || 'object' != typeof t) return !1\n      var o = n.constructor,\n        a = t.constructor\n      if (\n        o !== a &&\n        !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) &&\n        'constructor' in n &&\n        'constructor' in t\n      )\n        return !1\n    }\n    ;(r = r || []), (e = e || [])\n    for (var c = r.length; c--; ) if (r[c] === n) return e[c] === t\n    if ((r.push(n), e.push(t), i)) {\n      if (((c = n.length), c !== t.length)) return !1\n      for (; c--; ) if (!N(n[c], t[c], r, e)) return !1\n    } else {\n      var f,\n        l = m.keys(n)\n      if (((c = l.length), m.keys(t).length !== c)) return !1\n      for (; c--; ) if (((f = l[c]), !m.has(t, f) || !N(n[f], t[f], r, e))) return !1\n    }\n    return r.pop(), e.pop(), !0\n  }\n  ;(m.isEqual = function (n, t) {\n    return N(n, t)\n  }),\n    (m.isEmpty = function (n) {\n      return null == n\n        ? !0\n        : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n))\n        ? 0 === n.length\n        : 0 === m.keys(n).length\n    }),\n    (m.isElement = function (n) {\n      return !(!n || 1 !== n.nodeType)\n    }),\n    (m.isArray =\n      h ||\n      function (n) {\n        return '[object Array]' === s.call(n)\n      }),\n    (m.isObject = function (n) {\n      var t = typeof n\n      return 'function' === t || ('object' === t && !!n)\n    }),\n    m.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (n) {\n      m['is' + n] = function (t) {\n        return s.call(t) === '[object ' + n + ']'\n      }\n    }),\n    m.isArguments(arguments) ||\n      (m.isArguments = function (n) {\n        return m.has(n, 'callee')\n      }),\n     true &&\n      'object' != typeof Int8Array &&\n      (m.isFunction = function (n) {\n        return 'function' == typeof n || !1\n      }),\n    (m.isFinite = function (n) {\n      return isFinite(n) && !isNaN(parseFloat(n))\n    }),\n    (m.isNaN = function (n) {\n      return m.isNumber(n) && n !== +n\n    }),\n    (m.isBoolean = function (n) {\n      return n === !0 || n === !1 || '[object Boolean]' === s.call(n)\n    }),\n    (m.isNull = function (n) {\n      return null === n\n    }),\n    (m.isUndefined = function (n) {\n      return n === void 0\n    }),\n    (m.has = function (n, t) {\n      return null != n && p.call(n, t)\n    }),\n    (m.noConflict = function () {\n      return (u._ = i), this\n    }),\n    (m.identity = function (n) {\n      return n\n    }),\n    (m.constant = function (n) {\n      return function () {\n        return n\n      }\n    }),\n    (m.noop = function () {}),\n    (m.property = w),\n    (m.propertyOf = function (n) {\n      return null == n\n        ? function () {}\n        : function (t) {\n            return n[t]\n          }\n    }),\n    (m.matcher = m.matches = function (n) {\n      return (\n        (n = m.extendOwn({}, n)),\n        function (t) {\n          return m.isMatch(t, n)\n        }\n      )\n    }),\n    (m.times = function (n, t, r) {\n      var e = Array(Math.max(0, n))\n      t = b(t, r, 1)\n      for (var u = 0; n > u; u++) e[u] = t(u)\n      return e\n    }),\n    (m.random = function (n, t) {\n      return null == t && ((t = n), (n = 0)), n + Math.floor(Math.random() * (t - n + 1))\n    }),\n    (m.now =\n      Date.now ||\n      function () {\n        return new Date().getTime()\n      })\n  var B = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#x27;', '`': '&#x60;' },\n    T = m.invert(B),\n    R = function (n) {\n      var t = function (t) {\n          return n[t]\n        },\n        r = '(?:' + m.keys(n).join('|') + ')',\n        e = RegExp(r),\n        u = RegExp(r, 'g')\n      return function (n) {\n        return (n = null == n ? '' : '' + n), e.test(n) ? n.replace(u, t) : n\n      }\n    }\n  ;(m.escape = R(B)),\n    (m.unescape = R(T)),\n    (m.result = function (n, t, r) {\n      var e = null == n ? void 0 : n[t]\n      return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e\n    })\n  var q = 0\n  ;(m.uniqueId = function (n) {\n    var t = ++q + ''\n    return n ? n + t : t\n  }),\n    (m.templateSettings = { evaluate: /<%([\\s\\S]+?)%>/g, interpolate: /<%=([\\s\\S]+?)%>/g, escape: /<%-([\\s\\S]+?)%>/g })\n  var K = /(.)^/,\n    z = { \"'\": \"'\", '\\\\': '\\\\', '\\r': 'r', '\\n': 'n', '\\u2028': 'u2028', '\\u2029': 'u2029' },\n    D = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g,\n    L = function (n) {\n      return '\\\\' + z[n]\n    }\n  ;(m.template = function (n, t, r) {\n    !t && r && (t = r), (t = m.defaults({}, t, m.templateSettings))\n    var e = RegExp(\n        [(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join('|') + '|$',\n        'g'\n      ),\n      u = 0,\n      i = \"__p+='\"\n    n.replace(e, function (t, r, e, o, a) {\n      return (\n        (i += n.slice(u, a).replace(D, L)),\n        (u = a + t.length),\n        r\n          ? (i += \"'+\\n((__t=(\" + r + \"))==null?'':_.escape(__t))+\\n'\")\n          : e\n          ? (i += \"'+\\n((__t=(\" + e + \"))==null?'':__t)+\\n'\")\n          : o && (i += \"';\\n\" + o + \"\\n__p+='\"),\n        t\n      )\n    }),\n      (i += \"';\\n\"),\n      t.variable || (i = 'with(obj||{}){\\n' + i + '}\\n'),\n      (i =\n        \"var __t,__p='',__j=Array.prototype.join,\" +\n        \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n        i +\n        'return __p;\\n')\n    try {\n      var o = new Function(t.variable || 'obj', '_', i)\n    } catch (a) {\n      throw ((a.source = i), a)\n    }\n    var c = function (n) {\n        return o.call(this, n, m)\n      },\n      f = t.variable || 'obj'\n    return (c.source = 'function(' + f + '){\\n' + i + '}'), c\n  }),\n    (m.chain = function (n) {\n      var t = m(n)\n      return (t._chain = !0), t\n    })\n  var P = function (n, t) {\n    return n._chain ? m(t).chain() : t\n  }\n  ;(m.mixin = function (n) {\n    m.each(m.functions(n), function (t) {\n      var r = (m[t] = n[t])\n      m.prototype[t] = function () {\n        var n = [this._wrapped]\n        return f.apply(n, arguments), P(this, r.apply(m, n))\n      }\n    })\n  }),\n    m.mixin(m),\n    m.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (n) {\n      var t = o[n]\n      m.prototype[n] = function () {\n        var r = this._wrapped\n        return t.apply(r, arguments), ('shift' !== n && 'splice' !== n) || 0 !== r.length || delete r[0], P(this, r)\n      }\n    }),\n    m.each(['concat', 'join', 'slice'], function (n) {\n      var t = o[n]\n      m.prototype[n] = function () {\n        return P(this, t.apply(this._wrapped, arguments))\n      }\n    }),\n    (m.prototype.value = function () {\n      return this._wrapped\n    }),\n    (m.prototype.valueOf = m.prototype.toJSON = m.prototype.value),\n    (m.prototype.toString = function () {\n      return '' + this._wrapped\n    }),\n     true &&\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return m\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n}.call(this))\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/underscore/underscore.js?");

/***/ }),

/***/ 6:
/*!*************************************************************************************************************************************************************!*\
  !*** multi jquery jquery_custom angular angularRoute angularCookies angularSanitize datatables dt_responsive dt_grouping dt_ipaddress modernizr underscore ***!
  \*************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! jquery */\"./src/public/js/vendor/jquery/jquery.js\");\n__webpack_require__(/*! jquery_custom */\"./src/public/js/plugins/jquery.custom.js\");\n__webpack_require__(/*! angular */\"./src/public/js/vendor/angular/angular.min.js\");\n__webpack_require__(/*! angularRoute */\"./src/public/js/vendor/angular/angular-route.min.js\");\n__webpack_require__(/*! angularCookies */\"./src/public/js/vendor/angular/angular-cookies.min.js\");\n__webpack_require__(/*! angularSanitize */\"./src/public/js/vendor/angular/angular-sanitize.min.js\");\n__webpack_require__(/*! datatables */\"./src/public/js/vendor/datatables/jquery.dataTables.js\");\n__webpack_require__(/*! dt_responsive */\"./src/public/js/vendor/datatables/dataTables.responsive.js\");\n__webpack_require__(/*! dt_grouping */\"./src/public/js/vendor/datatables/dataTables.grouping.js\");\n__webpack_require__(/*! dt_ipaddress */\"./src/public/js/vendor/datatables/dataTables.ipaddress.js\");\n__webpack_require__(/*! modernizr */\"./src/public/js/vendor/modernizr/modernizr.js\");\nmodule.exports = __webpack_require__(/*! underscore */\"./src/public/js/vendor/underscore/underscore.js\");\n\n\n//# sourceURL=webpack:///multi_jquery_jquery_custom_angular_angularRoute_angularCookies_angularSanitize_datatables_dt_responsive_dt_grouping_dt_ipaddress_modernizr_underscore?");

/***/ })

}]);