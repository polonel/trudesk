/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 25:
/*!************************************************!*\
  !*** ./src/public/js/plugins/jquery.custom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/*!\r\n * jQuery serializeObject - v0.2 - 1/20/2010\r\n * http://benalman.com/projects/jquery-misc-plugins/\r\n *\r\n * Copyright (c) 2010 \"Cowboy\" Ben Alman\r\n * Dual licensed under the MIT and GPL licenses.\r\n * http://benalman.com/about/license/\r\n */\r\n\r\n// Whereas .serializeArray() serializes a form into an array, .serializeObject()\r\n// serializes a form into an (arguably more useful) object.\r\n\r\n;(function ($, undefined) {\r\n  '$:nomunge' // Used by YUI compressor.\r\n\r\n  $.fn.serializeObject = function () {\r\n    var obj = {}\r\n\r\n    $.each(this.serializeArray(), function (i, o) {\r\n      var n = o.name,\r\n        v = o.value\r\n\r\n      obj[n] = obj[n] === undefined ? v : $.isArray(obj[n]) ? obj[n].concat(v) : [obj[n], v]\r\n    })\r\n\r\n    return obj\r\n  }\r\n\r\n  /**\r\n   This is a jQuery plugin to support resizing text areas.\r\n\r\n   Originally based off text area resizer by Ryan O'Dell : http://plugins.jquery.com/misc/textarea.js\r\n   Modifications by Discourse https://github.com/discourse/discourse\r\n   @module $.fn.DivResizer\r\n   **/\r\n\r\n  var div,\r\n    endDrag,\r\n    grip,\r\n    lastMousePos,\r\n    min,\r\n    mousePosition,\r\n    originalDivHeight,\r\n    originalPos,\r\n    performDrag,\r\n    startDrag,\r\n    wrappedEndDrag,\r\n    wrappedPerformDrag\r\n  div = void 0\r\n  originalPos = void 0\r\n  originalDivHeight = void 0\r\n  lastMousePos = 0\r\n  min = 350\r\n  grip = void 0\r\n  wrappedEndDrag = void 0\r\n  wrappedPerformDrag = void 0\r\n\r\n  startDrag = function (e, opts) {\r\n    div = $(e.data.el)\r\n    div.addClass('clear-transitions')\r\n    div.blur()\r\n    lastMousePos = mousePosition(e).y\r\n    originalPos = lastMousePos\r\n    originalDivHeight = div.height()\r\n    wrappedPerformDrag = (function () {\r\n      return function (e) {\r\n        return performDrag(e, opts)\r\n      }\r\n    })()\r\n    wrappedEndDrag = (function () {\r\n      return function (e) {\r\n        return endDrag(e, opts)\r\n      }\r\n    })()\r\n    $(document)\r\n      .mousemove(wrappedPerformDrag)\r\n      .mouseup(wrappedEndDrag)\r\n    return false\r\n  }\r\n\r\n  performDrag = function (e, opts) {\r\n    $(div).trigger('div-resizing')\r\n\r\n    var size, sizePx, thisMousePos\r\n    thisMousePos = mousePosition(e).y\r\n    size = originalDivHeight + (originalPos - thisMousePos)\r\n    lastMousePos = thisMousePos\r\n\r\n    var maxHeight = $(window).height()\r\n    if (opts.maxHeight) {\r\n      maxHeight = opts.maxHeight(maxHeight)\r\n    }\r\n    size = Math.min(size, maxHeight)\r\n    size = Math.max(min, size)\r\n    sizePx = size + 'px'\r\n    if (typeof opts.onDrag === 'function') {\r\n      opts.onDrag(sizePx)\r\n    }\r\n    div.height(sizePx)\r\n    if (size < min) {\r\n      endDrag(e, opts)\r\n    }\r\n    return false\r\n  }\r\n\r\n  endDrag = function (e, opts) {\r\n    $(document)\r\n      .unbind('mousemove', wrappedPerformDrag)\r\n      .unbind('mouseup', wrappedEndDrag)\r\n    div.removeClass('clear-transitions')\r\n    div.focus()\r\n    if (typeof opts.resize === 'function') {\r\n      opts.resize()\r\n    }\r\n    $(div).trigger('div-resized')\r\n    div = null\r\n  }\r\n\r\n  mousePosition = function (e) {\r\n    return {\r\n      x: e.clientX + document.documentElement.scrollLeft,\r\n      y: e.clientY + document.documentElement.scrollTop\r\n    }\r\n  }\r\n\r\n  $.fn.DivResizer = function (opts) {\r\n    return this.each(function () {\r\n      var grippie, start, staticOffset\r\n      div = $(this)\r\n      if (div.hasClass('processed')) return\r\n      div.addClass('processed')\r\n      staticOffset = null\r\n      start = function () {\r\n        return function (e) {\r\n          return startDrag(e, opts)\r\n        }\r\n      }\r\n      grippie = div\r\n        .prepend(\"<div class='grippie'></div>\")\r\n        .find('.grippie')\r\n        .bind(\r\n          'mousedown',\r\n          {\r\n            el: this\r\n          },\r\n          start()\r\n        )\r\n    })\r\n  }\r\n})(jQuery)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/plugins/jquery.custom.js?");

/***/ }),

/***/ 29:
/*!****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.grouping.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/*\r\n * File:        jquery.dataTables.grouping.js\r\n * Version:     1.2.9.\r\n * Author:      Jovan Popovic\r\n *\r\n * Copyright 2013 Jovan Popovic, all rights reserved.\r\n *\r\n * This source file is free software, under either the GPL v2 license or a\r\n * BSD style license, as supplied with this software.\r\n *\r\n * This source file is distributed in the hope that it will be useful, but\r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n * or FITNESS FOR A PARTICULAR PURPOSE.\r\n * Parameters:\r\n * @iGroupingColumnIndex                                 Integer             Index of the column that will be used for grouping - default 0\r\n * @sGroupingColumnSortDirection                         Enumeration         Sort direction of the group\r\n * @iGroupingOrderByColumnIndex                          Integer             Index of the column that will be used for ordering groups\r\n * @sGroupingClass                                       String              Class that will be associated to the group row. Default - \"group\"\r\n * @sGroupItemClass                                      String              Class that will be associated to the group row of group items. Default - \"group-item\"\r\n * @bSetGroupingClassOnTR                                Boolean             If set class will be set to the TR instead of the TD withing the grouping TR\r\n * @bHideGroupingColumn                                  Boolean             Hide column used for grouping once results are grouped. Default - true\r\n * @bHideGroupingOrderByColumn                           Boolean             Hide column used for ordering groups once results are grouped. Default - true\r\n * @sGroupBy                                             Enumeration         Type of grouping that should be applied. Values \"name\"(default), \"letter\", \"year\"\r\n * @sGroupLabelPrefix                                    String              Prefix that will be added to each group cell\r\n * @bExpandableGrouping                                  Boolean             Attach expand/collapse handlers to the grouping rows\r\n * @bExpandSingleGroup                                   Boolean             Use accordon grouping\r\n * @iExpandGroupOffset                                   Integer             Number of pixels to set scroll position above the currently selected group. If -1 scroll will be alligned to the table\r\n * General settings\r\n * @sDateFormat: \"dd/MM/yyyy\"                            String              Date format used for grouping\r\n * @sEmptyGroupLabel                                     String              Lable that will be placed as group if grouping cells are empty. Default \"-\"\r\n\r\n * Parameters used in the second level grouping\r\n * @iGroupingColumnIndex2                                Integer             Index of the secondary column that will be used for grouping - default 0\r\n * @sGroupingColumnSortDirection2                        Enumeration         Sort direction of the secondary group\r\n * @iGroupingOrderByColumnIndex2                         Integer             Index of the column that will be used for ordering secondary groups\r\n * @sGroupingClass2                                      String              Class that will be associated to the secondary group row. Default \"subgroup\"\r\n * @sGroupItemClass2                                     String              Class that will be associated to the secondary group row of group items. Default \"subgroup-item\"\r\n * @bHideGroupingColumn2                                 Boolean             Hide column used for secondary grouping once results are grouped. Default - true,\r\n * @bHideGroupingOrderByColumn2                          Boolean             Hide column used for ordering secondary groups once results are grouped. Default - true,\r\n * @sGroupBy2                                            Enumeration         Type of grouping that should be applied to secondary column. Values \"name\"(default), \"letter\", \"year\",\r\n * @sGroupLabelPrefix2                                   String              Prefix that will be added to each secondary group cell\r\n * @fnOnGrouped                                          Function            Function that is called when grouping is finished. Function has no parameters.\r\n */\r\n;(function (a) {\r\n  a.fn.rowGrouping = function (e) {\r\n    function b () {}\r\n    function c (j, h, i) {}\r\n    function d (j, h, i) {}\r\n    function g (i) {\r\n      var h = [\r\n        'January',\r\n        'February',\r\n        'March',\r\n        'April',\r\n        'May',\r\n        'June',\r\n        'July',\r\n        'August',\r\n        'September',\r\n        'October',\r\n        'November',\r\n        'December'\r\n      ]\r\n      return h[i - 1]\r\n    }\r\n    var f = {\r\n      iGroupingColumnIndex: 0,\r\n      sGroupingColumnSortDirection: '',\r\n      iGroupingOrderByColumnIndex: -1,\r\n      sGroupingClass: 'group',\r\n      sGroupItemClass: 'group-item',\r\n      bHideGroupingColumn: true,\r\n      bHideGroupingOrderByColumn: true,\r\n      sGroupBy: 'name',\r\n      sGroupLabelPrefix: '',\r\n      fnGroupLabelFormat: function (h) {\r\n        return h\r\n      },\r\n      bExpandableGrouping: false,\r\n      bExpandSingleGroup: false,\r\n      iExpandGroupOffset: 100,\r\n      asExpandedGroups: null,\r\n      sDateFormat: 'dd/MM/yyyy',\r\n      sEmptyGroupLabel: '-',\r\n      bSetGroupingClassOnTR: false,\r\n      iGroupingColumnIndex2: -1,\r\n      sGroupingColumnSortDirection2: '',\r\n      iGroupingOrderByColumnIndex2: -1,\r\n      sGroupingClass2: 'subgroup',\r\n      sGroupItemClass2: 'subgroup-item',\r\n      bHideGroupingColumn2: true,\r\n      bHideGroupingOrderByColumn2: true,\r\n      sGroupBy2: 'name',\r\n      sGroupLabelPrefix2: '',\r\n      fnGroupLabelFormat2: function (h) {\r\n        return h\r\n      },\r\n      bExpandableGrouping2: false,\r\n      fnOnGrouped: b,\r\n      fnOnGroupCreated: c,\r\n      fnOnGroupCompleted: d,\r\n      oHideEffect: null,\r\n      oShowEffect: null,\r\n      bUseFilteringForGrouping: false\r\n    }\r\n    return this.each(function (s, J) {\r\n      var E = a(J).dataTable()\r\n      var B = new Array()\r\n      a(this).dataTableExt.aoGroups = B\r\n      function q (T, i, P) {\r\n        var R = document.createElement('tr')\r\n        var S = document.createElement('td')\r\n        R.id = 'group-id-' + E.attr('id') + '_' + T\r\n        var Q = {\r\n          id: R.id,\r\n          key: T,\r\n          text: i,\r\n          level: 0,\r\n          groupItemClass: '.group-item-' + T,\r\n          dataGroup: T,\r\n          aoSubgroups: new Array()\r\n        }\r\n        if (t.bSetGroupingClassOnTR) {\r\n          R.className = t.sGroupingClass + ' ' + T\r\n        } else {\r\n          S.className = t.sGroupingClass + ' ' + T\r\n        }\r\n        S.colSpan = P\r\n        S.innerHTML = t.sGroupLabelPrefix + t.fnGroupLabelFormat(i == '' ? t.sEmptyGroupLabel : i, Q)\r\n        if (t.bExpandableGrouping) {\r\n          if (!I(T)) {\r\n            S.className += ' expanded-group'\r\n            Q.state = 'expanded'\r\n          } else {\r\n            S.className += ' collapsed-group'\r\n            Q.state = 'collapsed'\r\n          }\r\n          S.className += ' group-item-expander'\r\n          a(S).attr('data-group', Q.dataGroup)\r\n          a(S).attr('data-group-level', Q.level)\r\n          a(S).click(h)\r\n        }\r\n        R.appendChild(S)\r\n        B[T] = Q\r\n        Q.nGroup = R\r\n        t.fnOnGroupCreated(Q, T, 1)\r\n        return Q\r\n      }\r\n      function w (R, Q, P, T) {\r\n        var i = document.createElement('tr')\r\n        i.id = T.id + '_' + R\r\n        var V = document.createElement('td')\r\n        var U = T.dataGroup + '_' + R\r\n        var S = {\r\n          id: i.id,\r\n          key: R,\r\n          text: Q,\r\n          level: T.level + 1,\r\n          groupItemClass: '.group-item-' + U,\r\n          dataGroup: U,\r\n          aoSubgroups: new Array()\r\n        }\r\n        if (t.bSetGroupingClassOnTR) {\r\n          i.className = t.sGroupingClass2 + ' ' + R\r\n        } else {\r\n          V.className = t.sGroupingClass2 + ' ' + R\r\n        }\r\n        V.colSpan = P\r\n        V.innerHTML = t.sGroupLabelPrefix2 + t.fnGroupLabelFormat2(Q == '' ? t.sEmptyGroupLabel : Q, S)\r\n        if (t.bExpandableGrouping) {\r\n          i.className += ' group-item-' + T.dataGroup\r\n        }\r\n        if (t.bExpandableGrouping && t.bExpandableGrouping2) {\r\n          if (!I(S.dataGroup)) {\r\n            V.className += ' expanded-group'\r\n            S.state = 'expanded'\r\n          } else {\r\n            V.className += ' collapsed-group'\r\n            S.state = 'collapsed'\r\n          }\r\n          V.className += ' group-item-expander'\r\n          a(V).attr('data-group', S.dataGroup)\r\n          a(V).attr('data-group-level', S.level)\r\n          a(V).click(h)\r\n        }\r\n        i.appendChild(V)\r\n        T.aoSubgroups[S.dataGroup] = S\r\n        B[S.dataGroup] = S\r\n        S.nGroup = i\r\n        t.fnOnGroupCreated(S, R, 2)\r\n        return S\r\n      }\r\n      function I (i) {\r\n        if (B[i] != null) {\r\n          return B[i].state == 'collapsed'\r\n        } else {\r\n          if (i.indexOf('_') > -1) {\r\n            true\r\n          } else {\r\n            if (l && (j == null || j.length == 0)) {\r\n              return false\r\n            } else {\r\n              return a.inArray(i, j) == -1\r\n            }\r\n          }\r\n        }\r\n      }\r\n      function L (i) {\r\n        if (i.length < x + K) {\r\n          return i\r\n        } else {\r\n          return i.substr(x, K)\r\n        }\r\n      }\r\n      function y (i) {\r\n        return i\r\n      }\r\n      function M (i) {\r\n        return i.substr(0, 1)\r\n      }\r\n      function O (i) {\r\n        return L(i)\r\n      }\r\n      function C (i) {\r\n        return i.substr(x, K) + ' ' + g(i.substr(r, H))\r\n      }\r\n      function u (i) {\r\n        if (i === '') {\r\n          return '-'\r\n        }\r\n        return i.toLowerCase().replace(/[^a-zA-Z0-9\\u0080-\\uFFFF]+/g, '-')\r\n      }\r\n      function D (R, P, i) {\r\n        if (R.nTable.id !== E[0].id) {\r\n          return true\r\n        }\r\n        var Q = P[t.iGroupingColumnIndex]\r\n        if (typeof Q === 'undefined') {\r\n          Q = P[R.aoColumns[t.iGroupingColumnIndex].mDataProp]\r\n        }\r\n        if (I(u(Q))) {\r\n          if (E.fnIsOpen(E.fnGetNodes(i))) {\r\n            if (t.fnOnRowClosed != null) {\r\n              t.fnOnRowClosed(this)\r\n            }\r\n            E.fnClose(E.fnGetNodes(i))\r\n          }\r\n          return false\r\n        }\r\n        return true\r\n      }\r\n      function p (i) {\r\n        B[i].state = 'expanded'\r\n        a(\"td[data-group^='\" + i + \"']\").removeClass('collapsed-group')\r\n        a(\"td[data-group^='\" + i + \"']\").addClass('expanded-group')\r\n        if (t.bUseFilteringForGrouping) {\r\n          E.fnDraw()\r\n          return\r\n        }\r\n        if (jQuery.inArray(i, j) == -1) {\r\n          j.push(i)\r\n        }\r\n        if (t.oHideEffect != null) {\r\n          a('.group-item-' + i, E)[t.oShowEffect.method](t.oShowEffect.duration, t.oShowEffect.easing, function () {})\r\n        } else {\r\n          a('.group-item-' + i, E).show()\r\n        }\r\n      }\r\n      function m (i) {\r\n        B[i].state = 'collapsed'\r\n        a(\"td[data-group^='\" + i + \"']\").removeClass('expanded-group')\r\n        a(\"td[data-group^='\" + i + \"']\").addClass('collapsed-group')\r\n        if (t.bUseFilteringForGrouping) {\r\n          E.fnDraw()\r\n          return\r\n        }\r\n        a('.group-item-' + i).each(function () {\r\n          if (E.fnIsOpen(this)) {\r\n            if (t.fnOnRowClosed != null) {\r\n              t.fnOnRowClosed(this)\r\n            }\r\n            E.fnClose(this)\r\n          }\r\n        })\r\n        if (t.oHideEffect != null) {\r\n          a('.group-item-' + i, E)[t.oHideEffect.method](t.oHideEffect.duration, t.oHideEffect.easing, function () {})\r\n        } else {\r\n          a('.group-item-' + i, E).hide()\r\n        }\r\n      }\r\n      function h (T) {\r\n        var Q = a(this).attr('data-group')\r\n        var S = a(this).attr('data-group-level')\r\n        var R = !I(Q)\r\n        if (t.bExpandSingleGroup) {\r\n          if (!R) {\r\n            var P = a('td.expanded-group').attr('data-group')\r\n            m(P)\r\n            p(Q)\r\n            if (t.iExpandGroupOffset != -1) {\r\n              var i = a('#group-id-' + E.attr('id') + '_' + Q).offset().top - t.iExpandGroupOffset\r\n              window.scroll(0, i)\r\n            } else {\r\n              var i = E.offset().top\r\n              window.scroll(0, i)\r\n            }\r\n          }\r\n        } else {\r\n          if (R) {\r\n            m(Q)\r\n          } else {\r\n            p(Q)\r\n          }\r\n        }\r\n        T.preventDefault()\r\n      }\r\n      function A (V) {\r\n        if (E.fnSettings().oFeatures.bServerSide) {\r\n          l = true\r\n        }\r\n        var Z = false\r\n        if (t.iGroupingColumnIndex2 != -1) {\r\n          Z = true\r\n        }\r\n        if (V.aiDisplayMaster.length == 0) {\r\n          return\r\n        }\r\n        var T = a('tbody tr', E)\r\n        var Q = 0\r\n        for (var ae = 0; ae < V.aoColumns.length; ae++) {\r\n          if (V.aoColumns[ae].bVisible) {\r\n            Q += 1\r\n          }\r\n        }\r\n        var ah = null\r\n        var aa = null\r\n        if (V.aiDisplay.length > 0) {\r\n          for (var ag = 0; ag < T.length; ag++) {\r\n            var U = V._iDisplayStart + ag\r\n            if (E.fnSettings().oFeatures.bServerSide) {\r\n              U = ag\r\n            }\r\n            var S = ''\r\n            var af = null\r\n            var P = ''\r\n            var Y = null\r\n            S = this.fnGetData(T[ag], t.iGroupingColumnIndex)\r\n            var af = S\r\n            if (t.sGroupBy != 'year') {\r\n              af = N(S)\r\n            }\r\n            if (Z) {\r\n              P = V.aoData[V.aiDisplay[U]]._aData[t.iGroupingColumnIndex2]\r\n              if (P == undefined) {\r\n                P = V.aoData[V.aiDisplay[U]]._aData[V.aoColumns[t.iGroupingColumnIndex2].mDataProp]\r\n              }\r\n              if (t.sGroupBy2 != 'year') {\r\n                Y = N(P)\r\n              }\r\n            }\r\n            if (ah == null || u(af) != u(ah)) {\r\n              var ab = u(af)\r\n              if (ah != null) {\r\n                t.fnOnGroupCompleted(B[u(ah)])\r\n              }\r\n              if (t.bAddAllGroupsAsExpanded && jQuery.inArray(ab, j) == -1) {\r\n                j.push(ab)\r\n              }\r\n              var W = q(ab, af, Q)\r\n              var R = W.nGroup\r\n              if (T[ag].parentNode != null) {\r\n                T[ag].parentNode.insertBefore(R, T[ag])\r\n              } else {\r\n                a(T[ag]).before(R)\r\n              }\r\n              ah = af\r\n              aa = null\r\n            }\r\n            a(T[ag]).attr('data-group', B[ab].dataGroup)\r\n            a(T[ag]).addClass(t.sGroupItemClass)\r\n            a(T[ag]).addClass('group-item-' + ab)\r\n            if (t.bExpandableGrouping) {\r\n              if (I(ab) && !t.bUseFilteringForGrouping) {\r\n                a(T[ag]).hide()\r\n              }\r\n            }\r\n            if (Z) {\r\n              if (aa == null || u(Y) != u(aa)) {\r\n                var X = u(af) + '-' + u(Y)\r\n                var ac = w(X, Y, Q, B[ab])\r\n                var ad = ac.nGroup\r\n                T[ag].parentNode.insertBefore(ad, T[ag])\r\n                aa = Y\r\n              }\r\n              a(T[ag])\r\n                .attr('data-group', ac.dataGroup)\r\n                .addClass(t.sGroupItemClass2)\r\n                .addClass('group-item-' + ac.dataGroup)\r\n            }\r\n          }\r\n        }\r\n        if (ah != null) {\r\n          t.fnOnGroupCompleted(B[u(ah)])\r\n        }\r\n        t.fnOnGrouped(B)\r\n        l = false\r\n      }\r\n      var x = 6\r\n      var K = 4\r\n      var j = new Array()\r\n      var l = true\r\n      var t = a.extend(f, e)\r\n      if (t.iGroupingOrderByColumnIndex == -1) {\r\n        t.bCustomColumnOrdering = false\r\n        t.iGroupingOrderByColumnIndex = t.iGroupingColumnIndex\r\n      } else {\r\n        t.bCustomColumnOrdering = true\r\n      }\r\n      if (t.sGroupingColumnSortDirection == '') {\r\n        if (t.sGroupBy == 'year') {\r\n          t.sGroupingColumnSortDirection = 'desc'\r\n        } else {\r\n          t.sGroupingColumnSortDirection = 'asc'\r\n        }\r\n      }\r\n      if (t.iGroupingOrderByColumnIndex2 == -1) {\r\n        t.bCustomColumnOrdering2 = false\r\n        t.iGroupingOrderByColumnIndex2 = t.iGroupingColumnIndex2\r\n      } else {\r\n        t.bCustomColumnOrdering2 = true\r\n      }\r\n      if (t.sGroupingColumnSortDirection2 == '') {\r\n        if (t.sGroupBy2 == 'year') {\r\n          t.sGroupingColumnSortDirection2 = 'desc'\r\n        } else {\r\n          t.sGroupingColumnSortDirection2 = 'asc'\r\n        }\r\n      }\r\n      x = t.sDateFormat.toLowerCase().indexOf('yy')\r\n      K = t.sDateFormat.toLowerCase().lastIndexOf('y') - t.sDateFormat.toLowerCase().indexOf('y') + 1\r\n      var r = t.sDateFormat.toLowerCase().indexOf('mm')\r\n      var H = t.sDateFormat.toLowerCase().lastIndexOf('m') - t.sDateFormat.toLowerCase().indexOf('m') + 1\r\n      var N = y\r\n      switch (t.sGroupBy) {\r\n        case 'letter':\r\n          N = M\r\n          break\r\n        case 'year':\r\n          N = O\r\n          break\r\n        case 'month':\r\n          N = C\r\n          break\r\n        default:\r\n          N = y\r\n          break\r\n      }\r\n      if (t.asExpandedGroups != null) {\r\n        if (t.asExpandedGroups == 'NONE') {\r\n          t.asExpandedGroups = []\r\n          j = t.asExpandedGroups\r\n          l = false\r\n        } else {\r\n          if (t.asExpandedGroups == 'ALL') {\r\n            t.bAddAllGroupsAsExpanded = true\r\n          } else {\r\n            if (t.asExpandedGroups.constructor == String) {\r\n              var k = t.asExpandedGroups\r\n              t.asExpandedGroups = new Array()\r\n              t.asExpandedGroups.push(u(k))\r\n              j = t.asExpandedGroups\r\n              l = false\r\n            } else {\r\n              if (t.asExpandedGroups.constructor == Array) {\r\n                for (var G = 0; G < t.asExpandedGroups.length; G++) {\r\n                  j.push(u(t.asExpandedGroups[G]))\r\n                  if (t.bExpandSingleGroup) {\r\n                    break\r\n                  }\r\n                }\r\n                l = false\r\n              }\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        t.asExpandedGroups = new Array()\r\n        t.bAddAllGroupsAsExpanded = true\r\n      }\r\n      if (t.bExpandSingleGroup) {\r\n        var o = a('tbody tr', E)\r\n        var n = E.fnGetData(o[0], t.iGroupingColumnIndex)\r\n        var F = n\r\n        if (t.sGroupBy != 'year') {\r\n          F = N(n)\r\n        }\r\n        var z = u(F)\r\n        t.asExpandedGroups = new Array()\r\n        t.asExpandedGroups.push(z)\r\n      }\r\n      E.fnSetColumnVis(t.iGroupingColumnIndex, !t.bHideGroupingColumn)\r\n      if (t.bCustomColumnOrdering) {\r\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex, !t.bHideGroupingOrderByColumn)\r\n      }\r\n      if (t.iGroupingColumnIndex2 != -1) {\r\n        E.fnSetColumnVis(t.iGroupingColumnIndex2, !t.bHideGroupingColumn2)\r\n      }\r\n      if (t.bCustomColumnOrdering2) {\r\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex2, !t.bHideGroupingOrderByColumn2)\r\n      }\r\n      E.fnSettings().aoDrawCallback.push({ fn: A, sName: 'fnRowGrouping' })\r\n      var v = new Array()\r\n      v.push([t.iGroupingOrderByColumnIndex, t.sGroupingColumnSortDirection])\r\n      if (t.iGroupingColumnIndex2 != -1) {\r\n        v.push([t.iGroupingOrderByColumnIndex2, t.sGroupingColumnSortDirection2])\r\n      }\r\n      E.fnSettings().aaSortingFixed = v\r\n      switch (t.sGroupBy) {\r\n        case 'name':\r\n          break\r\n        case 'letter':\r\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-letter'\r\n          a.fn.dataTableExt.afnSortData['rg-letter'] = function (Q, P) {\r\n            var i = []\r\n            a('td:eq(' + P + ')', Q.oApi._fnGetTrNodes(Q)).each(function () {\r\n              i.push(M(this.innerHTML))\r\n            })\r\n            return i\r\n          }\r\n          break\r\n        case 'year':\r\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-date'\r\n          a.fn.dataTableExt.afnSortData['rg-date'] = function (R, P) {\r\n            var i = []\r\n            var Q = R.oApi._fnGetTrNodes(R)\r\n            for (G = 0; G < Q.length; G++) {\r\n              i.push(L(E.fnGetData(Q[G], P)))\r\n            }\r\n            return i\r\n          }\r\n          break\r\n        default:\r\n          break\r\n      }\r\n      if (t.bUseFilteringForGrouping) {\r\n        a.fn.dataTableExt.afnFiltering.push(D)\r\n      }\r\n      E.fnDraw()\r\n    })\r\n  }\r\n})(jQuery)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/dataTables.grouping.js?");

/***/ }),

/***/ 9:
/*!*****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.ipaddress.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\n/**\r\n * Sorts a column containing IP addresses (IPv4 and IPv6) in typical dot\r\n * notation / colon. This can be most useful when using DataTables for a\r\n * networking application, and reporting information containing IP address.\r\n *\r\n *  @name IP addresses\r\n *  @summary Sort IP addresses numerically\r\n *  @author Dominique Fournier\r\n *  @author Brad Wasson\r\n *\r\n *  @example\r\n *    $('#example').dataTable( {\r\n *       columnDefs: [\r\n *         { type: 'ip-address', targets: 0 }\r\n *       ]\r\n *    } );\r\n */\r\n\r\njQuery.extend(jQuery.fn.dataTableExt.oSort, {\r\n  'ip-address-pre': function (a) {\r\n    var i, item\r\n    var m = a.split('.'),\r\n      n = a.split(':'),\r\n      x = '',\r\n      xa = ''\r\n\r\n    if (m.length == 4) {\r\n      // IPV4\r\n      for (i = 0; i < m.length; i++) {\r\n        item = m[i]\r\n\r\n        if (item.length == 1) {\r\n          x += '00' + item\r\n        } else if (item.length == 2) {\r\n          x += '0' + item\r\n        } else {\r\n          x += item\r\n        }\r\n      }\r\n    } else if (n.length > 0) {\r\n      // IPV6\r\n      var count = 0\r\n      for (i = 0; i < n.length; i++) {\r\n        item = n[i]\r\n\r\n        if (i > 0) {\r\n          xa += ':'\r\n        }\r\n\r\n        if (item.length === 0) {\r\n          count += 0\r\n        } else if (item.length == 1) {\r\n          xa += '000' + item\r\n          count += 4\r\n        } else if (item.length == 2) {\r\n          xa += '00' + item\r\n          count += 4\r\n        } else if (item.length == 3) {\r\n          xa += '0' + item\r\n          count += 4\r\n        } else {\r\n          xa += item\r\n          count += 4\r\n        }\r\n      }\r\n\r\n      // Padding the ::\r\n      n = xa.split(':')\r\n      var paddDone = 0\r\n\r\n      for (i = 0; i < n.length; i++) {\r\n        item = n[i]\r\n\r\n        if (item.length === 0 && paddDone === 0) {\r\n          for (var padding = 0; padding < 32 - count; padding++) {\r\n            x += '0'\r\n            paddDone = 1\r\n          }\r\n        } else {\r\n          x += item\r\n        }\r\n      }\r\n    }\r\n\r\n    return x\r\n  },\r\n\r\n  'ip-address-asc': function (a, b) {\r\n    return a < b ? -1 : a > b ? 1 : 0\r\n  },\r\n\r\n  'ip-address-desc': function (a, b) {\r\n    return a < b ? 1 : a > b ? -1 : 0\r\n  }\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/dataTables.ipaddress.js?");

/***/ }),

/***/ 28:
/*!******************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.responsive.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 1.0.1\r\n * 2014 SpryMedia Ltd - datatables.net/license\r\n */\r\n\r\n/**\r\n * @summary     Responsive\r\n * @description Responsive tables plug-in for DataTables\r\n * @version     1.0.1\r\n * @file        dataTables.responsive.js\r\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\r\n * @contact     www.sprymedia.co.uk/contact\r\n * @copyright   Copyright 2014 SpryMedia Ltd.\r\n *\r\n * This source file is free software, available under the following license:\r\n *   MIT license - http://datatables.net/license/mit\r\n *\r\n * This source file is distributed in the hope that it will be useful, but\r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\r\n *\r\n * For details please refer to: http://www.datatables.net\r\n */\r\n\r\n;(function (window, document, undefined) {\r\n  var factory = function ($, DataTable) {\r\n    'use strict'\r\n\r\n    /**\r\n     * Responsive is a plug-in for the DataTables library that makes use of\r\n     * DataTables' ability to change the visibility of columns, changing the\r\n     * visibility of columns so the displayed columns fit into the table container.\r\n     * The end result is that complex tables will be dynamically adjusted to fit\r\n     * into the viewport, be it on a desktop, tablet or mobile browser.\r\n     *\r\n     * Responsive for DataTables has two modes of operation, which can used\r\n     * individually or combined:\r\n     *\r\n     * * Class name based control - columns assigned class names that match the\r\n     *   breakpoint logic can be shown / hidden as required for each breakpoint.\r\n     * * Automatic control - columns are automatically hidden when there is no\r\n     *   room left to display them. Columns removed from the right.\r\n     *\r\n     * In additional to column visibility control, Responsive also has built into\r\n     * options to use DataTables' child row display to show / hide the information\r\n     * from the table that has been hidden. There are also two modes of operation\r\n     * for this child row display:\r\n     *\r\n     * * Inline - when the control element that the user can use to show / hide\r\n     *   child rows is displayed inside the first column of the table.\r\n     * * Column - where a whole column is dedicated to be the show / hide control.\r\n     *\r\n     * Initialisation of Responsive is performed by:\r\n     *\r\n     * * Adding the class `responsive` or `dt-responsive` to the table. In this case\r\n     *   Responsive will automatically be initialised with the default configuration\r\n     *   options when the DataTable is created.\r\n     * * Using the `responsive` option in the DataTables configuration options. This\r\n     *   can also be used to specify the configuration options, or simply set to\r\n     *   `true` to use the defaults.\r\n     *\r\n     *  @class\r\n     *  @param {object} settings DataTables settings object for the host table\r\n     *  @param {object} [opts] Configuration options\r\n     *  @requires jQuery 1.7+\r\n     *  @requires DataTables 1.10.1+\r\n     *\r\n     *  @example\r\n     *      $('#example').DataTable( {\r\n     *        responsive: true\r\n     *      } );\r\n     *    } );\r\n     */\r\n    var Responsive = function (settings, opts) {\r\n      // Sanity check that we are using DataTables 1.10 or newer\r\n      if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.1')) {\r\n        throw 'DataTables Responsive requires DataTables 1.10.1 or newer'\r\n      } else if (settings.responsive) {\r\n        return\r\n      }\r\n\r\n      this.s = {\r\n        dt: new DataTable.Api(settings),\r\n        columns: []\r\n      }\r\n\r\n      // details is an object, but for simplicity the user can give it as a string\r\n      if (opts && typeof opts.details === 'string') {\r\n        opts.details = { type: opts.details }\r\n      }\r\n\r\n      this.c = $.extend(true, {}, Responsive.defaults, opts)\r\n      settings.responsive = this\r\n      this._constructor()\r\n    }\r\n\r\n    Responsive.prototype = {\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Constructor\r\n       */\r\n\r\n      /**\r\n       * Initialise the Responsive instance\r\n       *\r\n       * @private\r\n       */\r\n      _constructor: function () {\r\n        var that = this\r\n        var dt = this.s.dt\r\n\r\n        dt.settings()[0]._responsive = this\r\n\r\n        // Use DataTables' private throttle function to avoid processor thrashing\r\n        $(window).on(\r\n          'resize.dtr orientationchange.dtr',\r\n          dt.settings()[0].oApi._fnThrottle(function () {\r\n            that._resize()\r\n          })\r\n        )\r\n\r\n        // Destroy event handler\r\n        dt.on('destroy.dtr', function () {\r\n          $(window).off('resize.dtr orientationchange.dtr')\r\n        })\r\n\r\n        // Reorder the breakpoints array here in case they have been added out\r\n        // of order\r\n        this.c.breakpoints.sort(function (a, b) {\r\n          return a.width < b.width ? 1 : a.width > b.width ? -1 : 0\r\n        })\r\n\r\n        this._classLogic()\r\n        this._resizeAuto()\r\n\r\n        // First pass - draw the table for the current viewport size\r\n        this._resize()\r\n\r\n        // Details handler\r\n        var details = this.c.details\r\n        if (details.type) {\r\n          that._detailsInit()\r\n          this._detailsVis()\r\n\r\n          dt.on('column-visibility.dtr', function () {\r\n            that._detailsVis()\r\n          })\r\n\r\n          $(dt.table().node()).addClass('dtr-' + details.type)\r\n        }\r\n      },\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Private methods\r\n       */\r\n\r\n      /**\r\n       * Calculate the visibility for the columns in a table for a given\r\n       * breakpoint. The result is pre-determined based on the class logic if\r\n       * class names are used to control all columns, but the width of the table\r\n       * is also used if there are columns which are to be automatically shown\r\n       * and hidden.\r\n       *\r\n       * @param  {string} breakpoint Breakpoint name to use for the calculation\r\n       * @return {array} Array of boolean values initiating the visibility of each\r\n       *   column.\r\n       *  @private\r\n       */\r\n      _columnsVisiblity: function (breakpoint) {\r\n        var dt = this.s.dt\r\n        var columns = this.s.columns\r\n        var i, ien\r\n\r\n        // Class logic - determine which columns are in this breakpoint based\r\n        // on the classes. If no class control (i.e. `auto`) then `-` is used\r\n        // to indicate this to the rest of the function\r\n        var display = $.map(columns, function (col) {\r\n          return col.auto && col.minWidth === null\r\n            ? false\r\n            : col.auto === true\r\n            ? '-'\r\n            : col.includeIn.indexOf(breakpoint) !== -1\r\n        })\r\n\r\n        // Auto column control - first pass: how much width is taken by the\r\n        // ones that must be included from the non-auto columns\r\n        var requiredWidth = 0\r\n        for (i = 0, ien = display.length; i < ien; i++) {\r\n          if (display[i] === true) {\r\n            requiredWidth += columns[i].minWidth\r\n          }\r\n        }\r\n\r\n        // Second pass, use up any remaining width for other columns\r\n        var widthAvailable = dt.table().container().offsetWidth\r\n        var usedWidth = widthAvailable - requiredWidth\r\n\r\n        for (i = 0, ien = display.length; i < ien; i++) {\r\n          // Control column needs to always be included. This makes it sub-\r\n          // optimal in terms of using the available with, but to stop layout\r\n          // thrashing or overflow\r\n          if (columns[i].control) {\r\n            usedWidth -= columns[i].minWidth\r\n          } else if (display[i] === '-') {\r\n            // Otherwise, remove the width\r\n            display[i] = usedWidth - columns[i].minWidth < 0 ? false : true\r\n\r\n            // Continue counting down the width, so a smaller column to the\r\n            // left won't be shown\r\n            usedWidth -= columns[i].minWidth\r\n          }\r\n        }\r\n\r\n        // Determine if the 'control' column should be shown (if there is one).\r\n        // This is the case when there is a hidden column (that is not the\r\n        // control column). The two loops look inefficient here, but they are\r\n        // trivial and will fly through. We need to know the outcome from the\r\n        // first , before the action in the second can be taken\r\n        var showControl = false\r\n\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          if (!columns[i].control && !display[i]) {\r\n            showControl = true\r\n            break\r\n          }\r\n        }\r\n\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          if (columns[i].control) {\r\n            display[i] = showControl\r\n          }\r\n        }\r\n\r\n        return display\r\n      },\r\n\r\n      /**\r\n       * Create the internal `columns` array with information about the columns\r\n       * for the table. This includes determining which breakpoints the column\r\n       * will appear in, based upon class names in the column, which makes up the\r\n       * vast majority of this method.\r\n       *\r\n       * @private\r\n       */\r\n      _classLogic: function () {\r\n        var that = this\r\n        var calc = {}\r\n        var breakpoints = this.c.breakpoints\r\n        var columns = this.s.dt\r\n          .columns()\r\n          .eq(0)\r\n          .map(function (i) {\r\n            return {\r\n              className: this.column(i).header().className,\r\n              includeIn: [],\r\n              auto: false,\r\n              control: false\r\n            }\r\n          })\r\n\r\n        // Simply add a breakpoint to `includeIn` array, ensuring that there are\r\n        // no duplicates\r\n        var add = function (colIdx, name) {\r\n          var includeIn = columns[colIdx].includeIn\r\n\r\n          if (includeIn.indexOf(name) === -1) {\r\n            includeIn.push(name)\r\n          }\r\n        }\r\n\r\n        var column = function (colIdx, name, operator, matched) {\r\n          var size, i, ien\r\n\r\n          if (!operator) {\r\n            columns[colIdx].includeIn.push(name)\r\n          } else if (operator === 'max-') {\r\n            // Add this breakpoint and all smaller\r\n            size = that._find(name).width\r\n\r\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\r\n              if (breakpoints[i].width <= size) {\r\n                add(colIdx, breakpoints[i].name)\r\n              }\r\n            }\r\n          } else if (operator === 'min-') {\r\n            // Add this breakpoint and all larger\r\n            size = that._find(name).width\r\n\r\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\r\n              if (breakpoints[i].width >= size) {\r\n                add(colIdx, breakpoints[i].name)\r\n              }\r\n            }\r\n          } else if (operator === 'not-') {\r\n            // Add all but this breakpoint (xxx need extra information)\r\n\r\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\r\n              if (breakpoints[i].name.indexOf(matched) === -1) {\r\n                add(colIdx, breakpoints[i].name)\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Loop over each column and determine if it has a responsive control\r\n        // class\r\n        columns.each(function (col, i) {\r\n          var classNames = col.className.split(' ')\r\n          var hasClass = false\r\n\r\n          // Split the class name up so multiple rules can be applied if needed\r\n          for (var k = 0, ken = classNames.length; k < ken; k++) {\r\n            var className = $.trim(classNames[k])\r\n\r\n            if (className === 'all') {\r\n              // Include in all\r\n              hasClass = true\r\n              col.includeIn = $.map(breakpoints, function (a) {\r\n                return a.name\r\n              })\r\n              return\r\n            } else if (className === 'none') {\r\n              // Include in none (default) and no auto\r\n              hasClass = true\r\n              return\r\n            } else if (className === 'control') {\r\n              // Special column that is only visible, when one of the other\r\n              // columns is hidden. This is used for the details control\r\n              hasClass = true\r\n              col.control = true\r\n              return\r\n            }\r\n\r\n            $.each(breakpoints, function (j, breakpoint) {\r\n              // Does this column have a class that matches this breakpoint?\r\n              var brokenPoint = breakpoint.name.split('-')\r\n              var re = new RegExp('(min\\\\-|max\\\\-|not\\\\-)?(' + brokenPoint[0] + ')(\\\\-[_a-zA-Z0-9])?')\r\n              var match = className.match(re)\r\n\r\n              if (match) {\r\n                hasClass = true\r\n\r\n                if (match[2] === brokenPoint[0] && match[3] === '-' + brokenPoint[1]) {\r\n                  // Class name matches breakpoint name fully\r\n                  column(i, breakpoint.name, match[1], match[2] + match[3])\r\n                } else if (match[2] === brokenPoint[0] && !match[3]) {\r\n                  // Class name matched primary breakpoint name with no qualifier\r\n                  column(i, breakpoint.name, match[1], match[2])\r\n                }\r\n              }\r\n            })\r\n          }\r\n\r\n          // If there was no control class, then automatic sizing is used\r\n          if (!hasClass) {\r\n            col.auto = true\r\n          }\r\n        })\r\n\r\n        this.s.columns = columns\r\n      },\r\n\r\n      /**\r\n       * Initialisation for the details handler\r\n       *\r\n       * @private\r\n       */\r\n      _detailsInit: function () {\r\n        var that = this\r\n        var dt = this.s.dt\r\n        var details = this.c.details\r\n\r\n        // The inline type always uses the first child as the target\r\n        if (details.type === 'inline') {\r\n          details.target = 'td:first-child'\r\n        }\r\n\r\n        // type.target can be a string jQuery selector or a column index\r\n        var target = details.target\r\n        var selector = typeof target === 'string' ? target : 'td'\r\n\r\n        // Click handler to show / hide the details rows when they are available\r\n        $(dt.table().body()).on('click', selector, function (e) {\r\n          // If the table is not collapsed (i.e. there is no hidden columns)\r\n          // then take no action\r\n          if (!$(dt.table().node()).hasClass('collapsed')) {\r\n            return\r\n          }\r\n\r\n          // For column index, we determine if we should act or not in the\r\n          // handler - otherwise it is already okay\r\n          if (typeof target === 'number') {\r\n            var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target\r\n\r\n            if (dt.cell(this).index().column !== targetIdx) {\r\n              return\r\n            }\r\n          }\r\n\r\n          // $().closest() includes itself in its check\r\n          var row = dt.row($(this).closest('tr'))\r\n\r\n          if (row.child.isShown()) {\r\n            row.child(false)\r\n            $(row.node()).removeClass('parent')\r\n          } else {\r\n            var info = that.c.details.renderer(dt, row[0])\r\n            row.child(info, 'child').show()\r\n            $(row.node()).addClass('parent')\r\n          }\r\n        })\r\n      },\r\n\r\n      /**\r\n       * Update the child rows in the table whenever the column visibility changes\r\n       *\r\n       * @private\r\n       */\r\n      _detailsVis: function () {\r\n        var that = this\r\n        var dt = this.s.dt\r\n\r\n        var hiddenColumns = dt\r\n          .columns(':hidden')\r\n          .indexes()\r\n          .flatten()\r\n        var haveHidden = true\r\n\r\n        if (hiddenColumns.length === 0 || (hiddenColumns.length === 1 && this.s.columns[hiddenColumns[0]].control)) {\r\n          haveHidden = false\r\n        }\r\n\r\n        if (haveHidden) {\r\n          // Got hidden columns\r\n          $(dt.table().node()).addClass('collapsed')\r\n\r\n          // Show all existing child rows\r\n          dt.rows()\r\n            .eq(0)\r\n            .each(function (idx) {\r\n              var row = dt.row(idx)\r\n\r\n              if (row.child()) {\r\n                var info = that.c.details.renderer(dt, row[0])\r\n\r\n                // The renderer can return false to have no child row\r\n                if (info === false) {\r\n                  row.child.hide()\r\n                } else {\r\n                  row.child(info, 'child').show()\r\n                }\r\n              }\r\n            })\r\n        } else {\r\n          // No hidden columns\r\n          $(dt.table().node()).removeClass('collapsed')\r\n\r\n          // Hide all existing child rows\r\n          dt.rows()\r\n            .eq(0)\r\n            .each(function (idx) {\r\n              dt.row(idx).child.hide()\r\n            })\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Find a breakpoint object from a name\r\n       * @param  {string} name Breakpoint name to find\r\n       * @return {object}      Breakpoint description object\r\n       */\r\n      _find: function (name) {\r\n        var breakpoints = this.c.breakpoints\r\n\r\n        for (var i = 0, ien = breakpoints.length; i < ien; i++) {\r\n          if (breakpoints[i].name === name) {\r\n            return breakpoints[i]\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n       * Alter the table display for a resized viewport. This involves first\r\n       * determining what breakpoint the window currently is in, getting the\r\n       * column visibilities to apply and then setting them.\r\n       *\r\n       * @private\r\n       */\r\n      _resize: function () {\r\n        var dt = this.s.dt\r\n        var width = $(window).width()\r\n        var breakpoints = this.c.breakpoints\r\n        var breakpoint = breakpoints[0].name\r\n\r\n        // Determine what breakpoint we are currently at\r\n        for (var i = breakpoints.length - 1; i >= 0; i--) {\r\n          if (width <= breakpoints[i].width) {\r\n            breakpoint = breakpoints[i].name\r\n            break\r\n          }\r\n        }\r\n\r\n        // Show the columns for that break point\r\n        var columns = this._columnsVisiblity(breakpoint)\r\n\r\n        dt.columns()\r\n          .eq(0)\r\n          .each(function (colIdx, i) {\r\n            dt.column(colIdx).visible(columns[i])\r\n          })\r\n      },\r\n\r\n      /**\r\n       * Determine the width of each column in the table so the auto column hiding\r\n       * has that information to work with. This method is never going to be 100%\r\n       * perfect since column widths can change slightly per page, but without\r\n       * seriously compromising performance this is quite effective.\r\n       *\r\n       * @private\r\n       */\r\n      _resizeAuto: function () {\r\n        var dt = this.s.dt\r\n        var columns = this.s.columns\r\n\r\n        // Are we allowed to do auto sizing?\r\n        if (!this.c.auto) {\r\n          return\r\n        }\r\n\r\n        // Are there any columns that actually need auto-sizing, or do they all\r\n        // have classes defined\r\n        if (\r\n          $.inArray(\r\n            true,\r\n            $.map(columns, function (c) {\r\n              return c.auto\r\n            })\r\n          ) === -1\r\n        ) {\r\n          return\r\n        }\r\n\r\n        // Clone the table with the current data in it\r\n        var tableWidth = dt.table().node().offsetWidth\r\n        var columnWidths = dt.columns\r\n        var clonedTable = dt\r\n          .table()\r\n          .node()\r\n          .cloneNode(false)\r\n        var clonedHeader = $(\r\n          dt\r\n            .table()\r\n            .header()\r\n            .cloneNode(false)\r\n        ).appendTo(clonedTable)\r\n        var clonedBody = $(\r\n          dt\r\n            .table()\r\n            .body()\r\n            .cloneNode(false)\r\n        ).appendTo(clonedTable)\r\n\r\n        // This is a bit slow, but we need to get a clone of each row that\r\n        // includes all columns. As such, try to do this as little as possible.\r\n        dt.rows({ page: 'current' })\r\n          .indexes()\r\n          .each(function (idx) {\r\n            var clone = dt\r\n              .row(idx)\r\n              .node()\r\n              .cloneNode(true)\r\n\r\n            if (dt.columns(':hidden').flatten().length) {\r\n              $(clone).append(\r\n                dt\r\n                  .cells(idx, ':hidden')\r\n                  .nodes()\r\n                  .to$()\r\n                  .clone()\r\n              )\r\n            }\r\n\r\n            $(clone).appendTo(clonedBody)\r\n          })\r\n\r\n        var cells = dt\r\n          .columns()\r\n          .header()\r\n          .to$()\r\n          .clone(false)\r\n          .wrapAll('tr')\r\n          .appendTo(clonedHeader)\r\n        var inserted = $('<div/>')\r\n          .css({\r\n            width: 1,\r\n            height: 1,\r\n            overflow: 'hidden'\r\n          })\r\n          .append(clonedTable)\r\n          .insertBefore(dt.table().node())\r\n\r\n        // The cloned header now contains the smallest that each column can be\r\n        dt.columns()\r\n          .eq(0)\r\n          .each(function (idx) {\r\n            columns[idx].minWidth = cells[idx].offsetWidth || 0\r\n          })\r\n\r\n        inserted.remove()\r\n      }\r\n    }\r\n\r\n    /**\r\n     * List of default breakpoints. Each item in the array is an object with two\r\n     * properties:\r\n     *\r\n     * * `name` - the breakpoint name.\r\n     * * `width` - the breakpoint width\r\n     *\r\n     * @name Responsive.breakpoints\r\n     * @static\r\n     */\r\n    Responsive.breakpoints = [\r\n      { name: 'desktop', width: Infinity },\r\n      { name: 'tablet-l', width: 1024 },\r\n      { name: 'tablet-p', width: 768 },\r\n      { name: 'mobile-l', width: 480 },\r\n      { name: 'mobile-p', width: 320 }\r\n    ]\r\n\r\n    /**\r\n     * Responsive default settings for initialisation\r\n     *\r\n     * @namespace\r\n     * @name Responsive.defaults\r\n     * @static\r\n     */\r\n    Responsive.defaults = {\r\n      /**\r\n       * List of breakpoints for the instance. Note that this means that each\r\n       * instance can have its own breakpoints. Additionally, the breakpoints\r\n       * cannot be changed once an instance has been creased.\r\n       *\r\n       * @type {Array}\r\n       * @default Takes the value of `Responsive.breakpoints`\r\n       */\r\n      breakpoints: Responsive.breakpoints,\r\n\r\n      /**\r\n       * Enable / disable auto hiding calculations. It can help to increase\r\n       * performance slightly if you disable this option, but all columns would\r\n       * need to have breakpoint classes assigned to them\r\n       *\r\n       * @type {Boolean}\r\n       * @default  `true`\r\n       */\r\n      auto: true,\r\n\r\n      /**\r\n       * Details control. If given as a string value, the `type` property of the\r\n       * default object is set to that value, and the defaults used for the rest\r\n       * of the object - this is for ease of implementation.\r\n       *\r\n       * The object consists of the following properties:\r\n       *\r\n       * * `renderer` - function that is called for display of the child row data.\r\n       *   The default function will show the data from the hidden columns\r\n       * * `target` - Used as the selector for what objects to attach the child\r\n       *   open / close to\r\n       * * `type` - `false` to disable the details display, `inline` or `column`\r\n       *   for the two control types\r\n       *\r\n       * @type {Object|string}\r\n       */\r\n      details: {\r\n        renderer: function (api, rowIdx) {\r\n          var data = api\r\n            .cells(rowIdx, ':hidden')\r\n            .eq(0)\r\n            .map(function (cell) {\r\n              var header = $(api.column(cell.column).header())\r\n\r\n              if (header.hasClass('control')) {\r\n                return ''\r\n              }\r\n\r\n              return (\r\n                '<li>' +\r\n                '<span class=\"dtr-title\">' +\r\n                header.text() +\r\n                ':' +\r\n                '</span> ' +\r\n                '<span class=\"dtr-data\">' +\r\n                api.cell(cell).data() +\r\n                '</span>' +\r\n                '</li>'\r\n              )\r\n            })\r\n            .toArray()\r\n            .join('')\r\n\r\n          return data ? $('<ul/>').append(data) : false\r\n        },\r\n\r\n        target: 0,\r\n\r\n        type: 'inline'\r\n      }\r\n    }\r\n\r\n    /*\r\n     * API\r\n     */\r\n    var Api = $.fn.dataTable.Api\r\n\r\n    // Doesn't do anything - work around for a bug in DT... Not documented\r\n    Api.register('responsive()', function () {\r\n      return this\r\n    })\r\n\r\n    Api.register('responsive.recalc()', function (rowIdx, intParse, virtual) {\r\n      this.iterator('table', function (ctx) {\r\n        if (ctx._responsive) {\r\n          ctx._responsive._resizeAuto()\r\n          ctx._responsive._resize()\r\n        }\r\n      })\r\n    })\r\n\r\n    /**\r\n     * Version information\r\n     *\r\n     * @name Responsive.version\r\n     * @static\r\n     */\r\n    Responsive.version = '1.0.1'\r\n\r\n    $.fn.dataTable.Responsive = Responsive\r\n    $.fn.DataTable.Responsive = Responsive\r\n\r\n    // Attach a listener to the document which listens for DataTables initialisation\r\n    // events so we can automatically initialise\r\n    $(document).on('init.dt.dtr', function (e, settings, json) {\r\n      if (\r\n        $(settings.nTable).hasClass('responsive') ||\r\n        $(settings.nTable).hasClass('dt-responsive') ||\r\n        settings.oInit.responsive\r\n      ) {\r\n        var init = settings.oInit.responsive\r\n\r\n        if (init !== false) {\r\n          new Responsive(settings, $.isPlainObject(init) ? init : {})\r\n        }\r\n      }\r\n    })\r\n\r\n    return Responsive\r\n  } // /factory\r\n\r\n  // Define as an AMD module if possible\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0), __webpack_require__(/*! datatables */ 3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  } else {}\r\n})(window, document)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/dataTables.responsive.js?");

/***/ }),

/***/ 3:
/*!**************************************************************!*\
  !*** ./src/public/js/vendor/datatables/jquery.dataTables.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* provided dependency */ var jQuery = __webpack_require__(/*! jquery */ 0);\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.2\r\n * ©2008-2014 SpryMedia Ltd - datatables.net/license\r\n */\r\n\r\n/**\r\n * @summary     DataTables\r\n * @description Paginate, search and order HTML tables\r\n * @version     1.10.2\r\n * @file        jquery.dataTables.js\r\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\r\n * @contact     www.sprymedia.co.uk/contact\r\n * @copyright   Copyright 2008-2014 SpryMedia Ltd.\r\n *\r\n * This source file is free software, available under the following license:\r\n *   MIT license - http://datatables.net/license\r\n *\r\n * This source file is distributed in the hope that it will be useful, but\r\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\r\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\r\n *\r\n * For details please refer to: http://www.datatables.net\r\n */\r\n\r\n/*jslint evil: true, undef: true, browser: true */\r\n/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidateRow,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/\r\n\r\n/** @lends <global> */ ;(function (window, document, undefined) {\r\n  ;(function (factory) {\r\n    'use strict'\r\n\r\n    if (true) {\r\n      // Define as an AMD module if possible\r\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ 0)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n    } else {}\r\n  })(\r\n    /** @lends <global> */ function ($) {\r\n      'use strict'\r\n\r\n      /**\r\n       * DataTables is a plug-in for the jQuery Javascript library. It is a highly\r\n       * flexible tool, based upon the foundations of progressive enhancement,\r\n       * which will add advanced interaction controls to any HTML table. For a\r\n       * full list of features please refer to\r\n       * [DataTables.net](href=\"http://datatables.net).\r\n       *\r\n       * Note that the `DataTable` object is not a global variable but is aliased\r\n       * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may\r\n       * be  accessed.\r\n       *\r\n       *  @class\r\n       *  @param {object} [init={}] Configuration object for DataTables. Options\r\n       *    are defined by {@link DataTable.defaults}\r\n       *  @requires jQuery 1.7+\r\n       *\r\n       *  @example\r\n       *    // Basic initialisation\r\n       *    $(document).ready( function {\r\n       *      $('#example').dataTable();\r\n       *    } );\r\n       *\r\n       *  @example\r\n       *    // Initialisation with configuration options - in this case, disable\r\n       *    // pagination and sorting.\r\n       *    $(document).ready( function {\r\n       *      $('#example').dataTable( {\r\n       *        \"paginate\": false,\r\n       *        \"sort\": false\r\n       *      } );\r\n       *    } );\r\n       */\r\n      var DataTable\r\n\r\n      /*\r\n       * It is useful to have variables which are scoped locally so only the\r\n       * DataTables functions can access them and they don't leak into global space.\r\n       * At the same time these functions are often useful over multiple files in the\r\n       * core and API, so we list, or at least document, all variables which are used\r\n       * by DataTables as private variables here. This also ensures that there is no\r\n       * clashing of variable names and that they can easily referenced for reuse.\r\n       */\r\n\r\n      // Defined else where\r\n      //  _selector_run\r\n      //  _selector_opts\r\n      //  _selector_first\r\n      //  _selector_row_indexes\r\n\r\n      var _ext // DataTable.ext\r\n      var _Api // DataTable.Api\r\n      var _api_register // DataTable.Api.register\r\n      var _api_registerPlural // DataTable.Api.registerPlural\r\n\r\n      var _re_dic = {}\r\n      var _re_new_lines = /[\\r\\n]/g\r\n      var _re_html = /<.*?>/g\r\n      var _re_date_start = /^[\\w\\+\\-]/\r\n      var _re_date_end = /[\\w\\+\\-]$/\r\n\r\n      // Escape regular expression special characters\r\n      var _re_escape_regex = new RegExp(\r\n        '(\\\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-'].join('|\\\\') + ')',\r\n        'g'\r\n      )\r\n\r\n      // U+2009 is thin space and U+202F is narrow no-break space, both used in many\r\n      // standards as thousands separators\r\n      var _re_formatted_numeric = /[',$£€¥%\\u2009\\u202F]/g\r\n\r\n      var _empty = function (d) {\r\n        return !d || d === true || d === '-' ? true : false\r\n      }\r\n\r\n      var _intVal = function (s) {\r\n        var integer = parseInt(s, 10)\r\n        return !isNaN(integer) && isFinite(s) ? integer : null\r\n      }\r\n\r\n      // Convert from a formatted number with characters other than `.` as the\r\n      // decimal place, to a Javascript number\r\n      var _numToDecimal = function (num, decimalPoint) {\r\n        // Cache created regular expressions for speed as this function is called often\r\n        if (!_re_dic[decimalPoint]) {\r\n          _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g')\r\n        }\r\n        return typeof num === 'string' ? num.replace(/\\./g, '').replace(_re_dic[decimalPoint], '.') : num\r\n      }\r\n\r\n      var _isNumber = function (d, decimalPoint, formatted) {\r\n        var strType = typeof d === 'string'\r\n\r\n        if (decimalPoint && strType) {\r\n          d = _numToDecimal(d, decimalPoint)\r\n        }\r\n\r\n        if (formatted && strType) {\r\n          d = d.replace(_re_formatted_numeric, '')\r\n        }\r\n\r\n        return _empty(d) || (!isNaN(parseFloat(d)) && isFinite(d))\r\n      }\r\n\r\n      // A string without HTML in it can be considered to be HTML still\r\n      var _isHtml = function (d) {\r\n        return _empty(d) || typeof d === 'string'\r\n      }\r\n\r\n      var _htmlNumeric = function (d, decimalPoint, formatted) {\r\n        if (_empty(d)) {\r\n          return true\r\n        }\r\n\r\n        var html = _isHtml(d)\r\n        return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null\r\n      }\r\n\r\n      var _pluck = function (a, prop, prop2) {\r\n        var out = []\r\n        var i = 0,\r\n          ien = a.length\r\n\r\n        // Could have the test in the loop for slightly smaller code, but speed\r\n        // is essential here\r\n        if (prop2 !== undefined) {\r\n          for (; i < ien; i++) {\r\n            if (a[i] && a[i][prop]) {\r\n              out.push(a[i][prop][prop2])\r\n            }\r\n          }\r\n        } else {\r\n          for (; i < ien; i++) {\r\n            if (a[i]) {\r\n              out.push(a[i][prop])\r\n            }\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      // Basically the same as _pluck, but rather than looping over `a` we use `order`\r\n      // as the indexes to pick from `a`\r\n      var _pluck_order = function (a, order, prop, prop2) {\r\n        var out = []\r\n        var i = 0,\r\n          ien = order.length\r\n\r\n        // Could have the test in the loop for slightly smaller code, but speed\r\n        // is essential here\r\n        if (prop2 !== undefined) {\r\n          for (; i < ien; i++) {\r\n            out.push(a[order[i]][prop][prop2])\r\n          }\r\n        } else {\r\n          for (; i < ien; i++) {\r\n            out.push(a[order[i]][prop])\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      var _range = function (len, start) {\r\n        var out = []\r\n        var end\r\n\r\n        if (start === undefined) {\r\n          start = 0\r\n          end = len\r\n        } else {\r\n          end = start\r\n          start = len\r\n        }\r\n\r\n        for (var i = start; i < end; i++) {\r\n          out.push(i)\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      var _stripHtml = function (d) {\r\n        return d.replace(_re_html, '')\r\n      }\r\n\r\n      /**\r\n       * Find the unique elements in a source array.\r\n       *\r\n       * @param  {array} src Source array\r\n       * @return {array} Array of unique items\r\n       * @ignore\r\n       */\r\n      var _unique = function (src) {\r\n        // A faster unique method is to use object keys to identify used values,\r\n        // but this doesn't work with arrays or objects, which we must also\r\n        // consider. See jsperf.com/compare-array-unique-versions/4 for more\r\n        // information.\r\n        var out = [],\r\n          val,\r\n          i,\r\n          ien = src.length,\r\n          j,\r\n          k = 0\r\n\r\n        again: for (i = 0; i < ien; i++) {\r\n          val = src[i]\r\n\r\n          for (j = 0; j < k; j++) {\r\n            if (out[j] === val) {\r\n              continue again\r\n            }\r\n          }\r\n\r\n          out.push(val)\r\n          k++\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      /**\r\n       * Create a mapping object that allows camel case parameters to be looked up\r\n       * for their Hungarian counterparts. The mapping is stored in a private\r\n       * parameter called `_hungarianMap` which can be accessed on the source object.\r\n       *  @param {object} o\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnHungarianMap (o) {\r\n        var hungarian = 'a aa ai ao as b fn i m o s ',\r\n          match,\r\n          newKey,\r\n          map = {}\r\n\r\n        $.each(o, function (key, val) {\r\n          match = key.match(/^([^A-Z]+?)([A-Z])/)\r\n\r\n          if (match && hungarian.indexOf(match[1] + ' ') !== -1) {\r\n            newKey = key.replace(match[0], match[2].toLowerCase())\r\n            map[newKey] = key\r\n\r\n            //console.log( key, match );\r\n            if (match[1] === 'o') {\r\n              _fnHungarianMap(o[key])\r\n            }\r\n          }\r\n        })\r\n\r\n        o._hungarianMap = map\r\n      }\r\n\r\n      /**\r\n       * Convert from camel case parameters to Hungarian, based on a Hungarian map\r\n       * created by _fnHungarianMap.\r\n       *  @param {object} src The model object which holds all parameters that can be\r\n       *    mapped.\r\n       *  @param {object} user The object to convert from camel case to Hungarian.\r\n       *  @param {boolean} force When set to `true`, properties which already have a\r\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\r\n       *    won't be.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCamelToHungarian (src, user, force) {\r\n        if (!src._hungarianMap) {\r\n          _fnHungarianMap(src)\r\n        }\r\n\r\n        var hungarianKey\r\n\r\n        $.each(user, function (key, val) {\r\n          hungarianKey = src._hungarianMap[key]\r\n\r\n          if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {\r\n            // For objects, we need to buzz down into the object to copy parameters\r\n            if (hungarianKey.charAt(0) === 'o') {\r\n              // Copy the camelCase options over to the hungarian\r\n              if (!user[hungarianKey]) {\r\n                user[hungarianKey] = {}\r\n              }\r\n              $.extend(true, user[hungarianKey], user[key])\r\n\r\n              _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force)\r\n            } else {\r\n              user[hungarianKey] = user[key]\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Language compatibility - when certain options are given, and others aren't, we\r\n       * need to duplicate the values over, in order to provide backwards compatibility\r\n       * with older language files.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnLanguageCompat (lang) {\r\n        var defaults = DataTable.defaults.oLanguage\r\n        var zeroRecords = lang.sZeroRecords\r\n\r\n        /* Backwards compatibility - if there is no sEmptyTable given, then use the same as\r\n         * sZeroRecords - assuming that is given.\r\n         */\r\n        if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === 'No data available in table') {\r\n          _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable')\r\n        }\r\n\r\n        /* Likewise with loading records */\r\n        if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === 'Loading...') {\r\n          _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords')\r\n        }\r\n\r\n        // Old parameter name of the thousands separator mapped onto the new\r\n        if (lang.sInfoThousands) {\r\n          lang.sThousands = lang.sInfoThousands\r\n        }\r\n\r\n        var decimal = lang.sDecimal\r\n        if (decimal) {\r\n          _addNumericSort(decimal)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Map one parameter onto another\r\n       *  @param {object} o Object to map\r\n       *  @param {*} knew The new parameter name\r\n       *  @param {*} old The old parameter name\r\n       */\r\n      var _fnCompatMap = function (o, knew, old) {\r\n        if (o[knew] !== undefined) {\r\n          o[old] = o[knew]\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Provide backwards compatibility for the main DT options. Note that the new\r\n       * options are mapped onto the old parameters, so this is an external interface\r\n       * change only.\r\n       *  @param {object} init Object to map\r\n       */\r\n      function _fnCompatOpts (init) {\r\n        _fnCompatMap(init, 'ordering', 'bSort')\r\n        _fnCompatMap(init, 'orderMulti', 'bSortMulti')\r\n        _fnCompatMap(init, 'orderClasses', 'bSortClasses')\r\n        _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop')\r\n        _fnCompatMap(init, 'order', 'aaSorting')\r\n        _fnCompatMap(init, 'orderFixed', 'aaSortingFixed')\r\n        _fnCompatMap(init, 'paging', 'bPaginate')\r\n        _fnCompatMap(init, 'pagingType', 'sPaginationType')\r\n        _fnCompatMap(init, 'pageLength', 'iDisplayLength')\r\n        _fnCompatMap(init, 'searching', 'bFilter')\r\n\r\n        // Column search objects are in an array, so it needs to be converted\r\n        // element by element\r\n        var searchCols = init.aoSearchCols\r\n\r\n        if (searchCols) {\r\n          for (var i = 0, ien = searchCols.length; i < ien; i++) {\r\n            if (searchCols[i]) {\r\n              _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i])\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Provide backwards compatibility for column options. Note that the new options\r\n       * are mapped onto the old parameters, so this is an external interface change\r\n       * only.\r\n       *  @param {object} init Object to map\r\n       */\r\n      function _fnCompatCols (init) {\r\n        _fnCompatMap(init, 'orderable', 'bSortable')\r\n        _fnCompatMap(init, 'orderData', 'aDataSort')\r\n        _fnCompatMap(init, 'orderSequence', 'asSorting')\r\n        _fnCompatMap(init, 'orderDataType', 'sortDataType')\r\n      }\r\n\r\n      /**\r\n       * Browser feature detection for capabilities, quirks\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnBrowserDetect (settings) {\r\n        var browser = settings.oBrowser\r\n\r\n        // Scrolling feature / quirks detection\r\n        var n = $('<div/>')\r\n          .css({\r\n            position: 'absolute',\r\n            top: 0,\r\n            left: 0,\r\n            height: 1,\r\n            width: 1,\r\n            overflow: 'hidden'\r\n          })\r\n          .append(\r\n            $('<div/>')\r\n              .css({\r\n                position: 'absolute',\r\n                top: 1,\r\n                left: 1,\r\n                width: 100,\r\n                overflow: 'scroll'\r\n              })\r\n              .append(\r\n                $('<div class=\"test\"/>').css({\r\n                  width: '100%',\r\n                  height: 10\r\n                })\r\n              )\r\n          )\r\n          .appendTo('body')\r\n\r\n        var test = n.find('.test')\r\n\r\n        // IE6/7 will oversize a width 100% element inside a scrolling element, to\r\n        // include the width of the scrollbar, while other browsers ensure the inner\r\n        // element is contained without forcing scrolling\r\n        browser.bScrollOversize = test[0].offsetWidth === 100\r\n\r\n        // In rtl text layout, some browsers (most, but not all) will place the\r\n        // scrollbar on the left, rather than the right.\r\n        browser.bScrollbarLeft = test.offset().left !== 1\r\n\r\n        n.remove()\r\n      }\r\n\r\n      /**\r\n       * Array.prototype reduce[Right] method, used for browsers which don't support\r\n       * JS 1.6. Done this way to reduce code size, since we iterate either way\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnReduce (that, fn, init, start, end, inc) {\r\n        var i = start,\r\n          value,\r\n          isSet = false\r\n\r\n        if (init !== undefined) {\r\n          value = init\r\n          isSet = true\r\n        }\r\n\r\n        while (i !== end) {\r\n          if (!that.hasOwnProperty(i)) {\r\n            continue\r\n          }\r\n\r\n          value = isSet ? fn(value, that[i], i, that) : that[i]\r\n\r\n          isSet = true\r\n          i += inc\r\n        }\r\n\r\n        return value\r\n      }\r\n\r\n      /**\r\n       * Add a column to the list used for the table with default values\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} nTh The th element for this column\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddColumn (oSettings, nTh) {\r\n        // Add column to aoColumns array\r\n        var oDefaults = DataTable.defaults.column\r\n        var iCol = oSettings.aoColumns.length\r\n        var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {\r\n          nTh: nTh ? nTh : document.createElement('th'),\r\n          sTitle: oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',\r\n          aDataSort: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\r\n          mData: oDefaults.mData ? oDefaults.mData : iCol,\r\n          idx: iCol\r\n        })\r\n        oSettings.aoColumns.push(oCol)\r\n\r\n        // Add search object for column specific search. Note that the `searchCols[ iCol ]`\r\n        // passed into extend can be undefined. This allows the user to give a default\r\n        // with only some of the parameters defined, and also not give a default\r\n        var searchCols = oSettings.aoPreSearchCols\r\n        searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol])\r\n\r\n        // Use the default column options function to initialise classes etc\r\n        _fnColumnOptions(oSettings, iCol, null)\r\n      }\r\n\r\n      /**\r\n       * Apply options for a column\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iCol column index to consider\r\n       *  @param {object} oOptions object with sType, bVisible and bSearchable etc\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnColumnOptions (oSettings, iCol, oOptions) {\r\n        var oCol = oSettings.aoColumns[iCol]\r\n        var oClasses = oSettings.oClasses\r\n        var th = $(oCol.nTh)\r\n\r\n        // Try to get width information from the DOM. We can't get it from CSS\r\n        // as we'd need to parse the CSS stylesheet. `width` option can override\r\n        if (!oCol.sWidthOrig) {\r\n          // Width attribute\r\n          oCol.sWidthOrig = th.attr('width') || null\r\n\r\n          // Style attribute\r\n          var t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/)\r\n          if (t) {\r\n            oCol.sWidthOrig = t[1]\r\n          }\r\n        }\r\n\r\n        /* User specified column options */\r\n        if (oOptions !== undefined && oOptions !== null) {\r\n          // Backwards compatibility\r\n          _fnCompatCols(oOptions)\r\n\r\n          // Map camel case parameters to their Hungarian counterparts\r\n          _fnCamelToHungarian(DataTable.defaults.column, oOptions)\r\n\r\n          /* Backwards compatibility for mDataProp */\r\n          if (oOptions.mDataProp !== undefined && !oOptions.mData) {\r\n            oOptions.mData = oOptions.mDataProp\r\n          }\r\n\r\n          if (oOptions.sType) {\r\n            oCol._sManualType = oOptions.sType\r\n          }\r\n\r\n          // `class` is a reserved word in Javascript, so we need to provide\r\n          // the ability to use a valid name for the camel case input\r\n          if (oOptions.className && !oOptions.sClass) {\r\n            oOptions.sClass = oOptions.className\r\n          }\r\n\r\n          $.extend(oCol, oOptions)\r\n          _fnMap(oCol, oOptions, 'sWidth', 'sWidthOrig')\r\n\r\n          /* iDataSort to be applied (backwards compatibility), but aDataSort will take\r\n           * priority if defined\r\n           */\r\n          if (typeof oOptions.iDataSort === 'number') {\r\n            oCol.aDataSort = [oOptions.iDataSort]\r\n          }\r\n          _fnMap(oCol, oOptions, 'aDataSort')\r\n        }\r\n\r\n        /* Cache the data get and set functions for speed */\r\n        var mDataSrc = oCol.mData\r\n        var mData = _fnGetObjectDataFn(mDataSrc)\r\n        var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null\r\n\r\n        var attrTest = function (src) {\r\n          return typeof src === 'string' && src.indexOf('@') !== -1\r\n        }\r\n        oCol._bAttrSrc =\r\n          $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter))\r\n\r\n        oCol.fnGetData = function (rowData, type, meta) {\r\n          var innerData = mData(rowData, type, undefined, meta)\r\n\r\n          return mRender && type ? mRender(innerData, type, rowData, meta) : innerData\r\n        }\r\n        oCol.fnSetData = function (rowData, val, meta) {\r\n          return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta)\r\n        }\r\n\r\n        /* Feature sorting overrides column specific when off */\r\n        if (!oSettings.oFeatures.bSort) {\r\n          oCol.bSortable = false\r\n          th.addClass(oClasses.sSortableNone) // Have to add class here as order event isn't called\r\n        }\r\n\r\n        /* Check that the class assignment is correct for sorting */\r\n        var bAsc = $.inArray('asc', oCol.asSorting) !== -1\r\n        var bDesc = $.inArray('desc', oCol.asSorting) !== -1\r\n        if (!oCol.bSortable || (!bAsc && !bDesc)) {\r\n          oCol.sSortingClass = oClasses.sSortableNone\r\n          oCol.sSortingClassJUI = ''\r\n        } else if (bAsc && !bDesc) {\r\n          oCol.sSortingClass = oClasses.sSortableAsc\r\n          oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed\r\n        } else if (!bAsc && bDesc) {\r\n          oCol.sSortingClass = oClasses.sSortableDesc\r\n          oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed\r\n        } else {\r\n          oCol.sSortingClass = oClasses.sSortable\r\n          oCol.sSortingClassJUI = oClasses.sSortJUI\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Adjust the table column widths for new data. Note: you would probably want to\r\n       * do a redraw after calling this function!\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAdjustColumnSizing (settings) {\r\n        /* Not interested in doing column width calculation if auto-width is disabled */\r\n        if (settings.oFeatures.bAutoWidth !== false) {\r\n          var columns = settings.aoColumns\r\n\r\n          _fnCalculateColumnWidths(settings)\r\n          for (var i = 0, iLen = columns.length; i < iLen; i++) {\r\n            columns[i].nTh.style.width = columns[i].sWidth\r\n          }\r\n        }\r\n\r\n        var scroll = settings.oScroll\r\n        if (scroll.sY !== '' || scroll.sX !== '') {\r\n          _fnScrollDraw(settings)\r\n        }\r\n\r\n        _fnCallbackFire(settings, null, 'column-sizing', [settings])\r\n      }\r\n\r\n      /**\r\n       * Covert the index of a visible column to the index in the data array (take account\r\n       * of hidden columns)\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iMatch Visible column index to lookup\r\n       *  @returns {int} i the data index\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnVisibleToColumnIndex (oSettings, iMatch) {\r\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\r\n\r\n        return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null\r\n      }\r\n\r\n      /**\r\n       * Covert the index of an index in the data array and convert it to the visible\r\n       *   column index (take account of hidden columns)\r\n       *  @param {int} iMatch Column index to lookup\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {int} i the data index\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnColumnIndexToVisible (oSettings, iMatch) {\r\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\r\n        var iPos = $.inArray(iMatch, aiVis)\r\n\r\n        return iPos !== -1 ? iPos : null\r\n      }\r\n\r\n      /**\r\n       * Get the number of visible columns\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {int} i the number of visible columns\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnVisbleColumns (oSettings) {\r\n        return _fnGetColumns(oSettings, 'bVisible').length\r\n      }\r\n\r\n      /**\r\n       * Get an array of column indexes that match a given property\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {string} sParam Parameter in aoColumns to look for - typically\r\n       *    bVisible or bSearchable\r\n       *  @returns {array} Array of indexes with matched properties\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetColumns (oSettings, sParam) {\r\n        var a = []\r\n\r\n        $.map(oSettings.aoColumns, function (val, i) {\r\n          if (val[sParam]) {\r\n            a.push(i)\r\n          }\r\n        })\r\n\r\n        return a\r\n      }\r\n\r\n      /**\r\n       * Calculate the 'type' of a column\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnColumnTypes (settings) {\r\n        var columns = settings.aoColumns\r\n        var data = settings.aoData\r\n        var types = DataTable.ext.type.detect\r\n        var i, ien, j, jen, k, ken\r\n        var col, cell, detectedType, cache\r\n\r\n        // For each column, spin over the\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          col = columns[i]\r\n          cache = []\r\n\r\n          if (!col.sType && col._sManualType) {\r\n            col.sType = col._sManualType\r\n          } else if (!col.sType) {\r\n            for (j = 0, jen = types.length; j < jen; j++) {\r\n              for (k = 0, ken = data.length; k < ken; k++) {\r\n                // Use a cache array so we only need to get the type data\r\n                // from the formatter once (when using multiple detectors)\r\n                if (cache[k] === undefined) {\r\n                  cache[k] = _fnGetCellData(settings, k, i, 'type')\r\n                }\r\n\r\n                detectedType = types[j](cache[k], settings)\r\n\r\n                // Doesn't match, so break early, since this type can't\r\n                // apply to this column. Also, HTML is a special case since\r\n                // it is so similar to `string`. Just a single match is\r\n                // needed for a column to be html type\r\n                if (!detectedType || detectedType === 'html') {\r\n                  break\r\n                }\r\n              }\r\n\r\n              // Type is valid for all data points in the column - use this\r\n              // type\r\n              if (detectedType) {\r\n                col.sType = detectedType\r\n                break\r\n              }\r\n            }\r\n\r\n            // Fall back - if no type was detected, always use string\r\n            if (!col.sType) {\r\n              col.sType = 'string'\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Take the column definitions and static columns arrays and calculate how\r\n       * they relate to column indexes. The callback function will then apply the\r\n       * definition found for a column to a suitable configuration object.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\r\n       *  @param {array} aoCols The aoColumns array that defines columns individually\r\n       *  @param {function} fn Callback function - takes two parameters, the calculated\r\n       *    column index and the definition for that column.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnApplyColumnDefs (oSettings, aoColDefs, aoCols, fn) {\r\n        var i, iLen, j, jLen, k, kLen, def\r\n        var columns = oSettings.aoColumns\r\n\r\n        // Column definitions with aTargets\r\n        if (aoColDefs) {\r\n          /* Loop over the definitions array - loop in reverse so first instance has priority */\r\n          for (i = aoColDefs.length - 1; i >= 0; i--) {\r\n            def = aoColDefs[i]\r\n\r\n            /* Each definition can target multiple columns, as it is an array */\r\n            var aTargets = def.targets !== undefined ? def.targets : def.aTargets\r\n\r\n            if (!$.isArray(aTargets)) {\r\n              aTargets = [aTargets]\r\n            }\r\n\r\n            for (j = 0, jLen = aTargets.length; j < jLen; j++) {\r\n              if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {\r\n                /* Add columns that we don't yet know about */\r\n                while (columns.length <= aTargets[j]) {\r\n                  _fnAddColumn(oSettings)\r\n                }\r\n\r\n                /* Integer, basic index */\r\n                fn(aTargets[j], def)\r\n              } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {\r\n                /* Negative integer, right to left column counting */\r\n                fn(columns.length + aTargets[j], def)\r\n              } else if (typeof aTargets[j] === 'string') {\r\n                /* Class name matching on TH element */\r\n                for (k = 0, kLen = columns.length; k < kLen; k++) {\r\n                  if (aTargets[j] == '_all' || $(columns[k].nTh).hasClass(aTargets[j])) {\r\n                    fn(k, def)\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Statically defined columns array\r\n        if (aoCols) {\r\n          for (i = 0, iLen = aoCols.length; i < iLen; i++) {\r\n            fn(i, aoCols[i])\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Add a data array to the table, creating DOM node etc. This is the parallel to\r\n       * _fnGatherData, but for adding rows from a Javascript source, rather than a\r\n       * DOM source.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {array} aData data array to be added\r\n       *  @param {node} [nTr] TR element to add to the table - optional. If not given,\r\n       *    DataTables will create a row automatically\r\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\r\n       *    if nTr is.\r\n       *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddData (oSettings, aDataIn, nTr, anTds) {\r\n        /* Create the object for storing information about this new row */\r\n        var iRow = oSettings.aoData.length\r\n        var oData = $.extend(true, {}, DataTable.models.oRow, {\r\n          src: nTr ? 'dom' : 'data'\r\n        })\r\n\r\n        oData._aData = aDataIn\r\n        oSettings.aoData.push(oData)\r\n\r\n        /* Create the cells */\r\n        var nTd, sThisType\r\n        var columns = oSettings.aoColumns\r\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\r\n          // When working with a row, the data source object must be populated. In\r\n          // all other cases, the data source object is already populated, so we\r\n          // don't overwrite it, which might break bindings etc\r\n          if (nTr) {\r\n            _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i))\r\n          }\r\n          columns[i].sType = null\r\n        }\r\n\r\n        /* Add to the display array */\r\n        oSettings.aiDisplayMaster.push(iRow)\r\n\r\n        /* Create the DOM information, or register it if already present */\r\n        if (nTr || !oSettings.oFeatures.bDeferRender) {\r\n          _fnCreateTr(oSettings, iRow, nTr, anTds)\r\n        }\r\n\r\n        return iRow\r\n      }\r\n\r\n      /**\r\n       * Add one or more TR elements to the table. Generally we'd expect to\r\n       * use this for reading data from a DOM sourced table, but it could be\r\n       * used for an TR element. Note that if a TR is given, it is used (i.e.\r\n       * it is not cloned).\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {array|node|jQuery} trs The TR element(s) to add to the table\r\n       *  @returns {array} Array of indexes for the added rows\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddTr (settings, trs) {\r\n        var row\r\n\r\n        // Allow an individual node to be passed in\r\n        if (!(trs instanceof $)) {\r\n          trs = $(trs)\r\n        }\r\n\r\n        return trs.map(function (i, el) {\r\n          row = _fnGetRowElements(settings, el)\r\n          return _fnAddData(settings, row.data, el, row.cells)\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Take a TR element and convert it to an index in aoData\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} n the TR element to find\r\n       *  @returns {int} index if the node is found, null if not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnNodeToDataIndex (oSettings, n) {\r\n        return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null\r\n      }\r\n\r\n      /**\r\n       * Take a TD element and convert it into a column data index (not the visible index)\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iRow The row number the TD/TH can be found in\r\n       *  @param {node} n The TD/TH element to find\r\n       *  @returns {int} index if the node is found, -1 if not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnNodeToColumnIndex (oSettings, iRow, n) {\r\n        return $.inArray(n, oSettings.aoData[iRow].anCells)\r\n      }\r\n\r\n      /**\r\n       * Get the data for a given cell from the internal cache, taking into account data mapping\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} rowIdx aoData row id\r\n       *  @param {int} colIdx Column index\r\n       *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\r\n       *  @returns {*} Cell data\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetCellData (settings, rowIdx, colIdx, type) {\r\n        var draw = settings.iDraw\r\n        var col = settings.aoColumns[colIdx]\r\n        var rowData = settings.aoData[rowIdx]._aData\r\n        var defaultContent = col.sDefaultContent\r\n        var cellData = col.fnGetData(rowData, type, {\r\n          settings: settings,\r\n          row: rowIdx,\r\n          col: colIdx\r\n        })\r\n\r\n        if (cellData === undefined) {\r\n          if (settings.iDrawError != draw && defaultContent === null) {\r\n            _fnLog(\r\n              settings,\r\n              0,\r\n              'Requested unknown parameter ' +\r\n                (typeof col.mData == 'function' ? '{function}' : \"'\" + col.mData + \"'\") +\r\n                ' for row ' +\r\n                rowIdx,\r\n              4\r\n            )\r\n            settings.iDrawError = draw\r\n          }\r\n          return defaultContent\r\n        }\r\n\r\n        /* When the data source is null, we can use default column data */\r\n        if ((cellData === rowData || cellData === null) && defaultContent !== null) {\r\n          cellData = defaultContent\r\n        } else if (typeof cellData === 'function') {\r\n          // If the data source is a function, then we run it and use the return,\r\n          // executing in the scope of the data object (for instances)\r\n          return cellData.call(rowData)\r\n        }\r\n\r\n        if (cellData === null && type == 'display') {\r\n          return ''\r\n        }\r\n        return cellData\r\n      }\r\n\r\n      /**\r\n       * Set the value for a specific cell, into the internal data cache\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} rowIdx aoData row id\r\n       *  @param {int} colIdx Column index\r\n       *  @param {*} val Value to set\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSetCellData (settings, rowIdx, colIdx, val) {\r\n        var col = settings.aoColumns[colIdx]\r\n        var rowData = settings.aoData[rowIdx]._aData\r\n\r\n        col.fnSetData(rowData, val, {\r\n          settings: settings,\r\n          row: rowIdx,\r\n          col: colIdx\r\n        })\r\n      }\r\n\r\n      // Private variable that is used to match action syntax in the data property object\r\n      var __reArray = /\\[.*?\\]$/\r\n      var __reFn = /\\(\\)$/\r\n\r\n      /**\r\n       * Split string on periods, taking into account escaped periods\r\n       * @param  {string} str String to split\r\n       * @return {array} Split string\r\n       */\r\n      function _fnSplitObjNotation (str) {\r\n        return $.map(str.match(/(\\\\.|[^\\.])+/g), function (s) {\r\n          return s.replace(/\\\\./g, '.')\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Return a function that can be used to get data from a source object, taking\r\n       * into account the ability to use nested objects as a source\r\n       *  @param {string|int|function} mSource The data source for the object\r\n       *  @returns {function} Data get function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetObjectDataFn (mSource) {\r\n        if ($.isPlainObject(mSource)) {\r\n          /* Build an object of get functions, and wrap them in a single call */\r\n          var o = {}\r\n          $.each(mSource, function (key, val) {\r\n            if (val) {\r\n              o[key] = _fnGetObjectDataFn(val)\r\n            }\r\n          })\r\n\r\n          return function (data, type, row, meta) {\r\n            var t = o[type] || o._\r\n            return t !== undefined ? t(data, type, row, meta) : data\r\n          }\r\n        } else if (mSource === null) {\r\n          /* Give an empty string for rendering / sorting etc */\r\n          return function (data) {\r\n            // type, row and meta also passed, but not used\r\n            return data\r\n          }\r\n        } else if (typeof mSource === 'function') {\r\n          return function (data, type, row, meta) {\r\n            return mSource(data, type, row, meta)\r\n          }\r\n        } else if (\r\n          typeof mSource === 'string' &&\r\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\r\n        ) {\r\n          /* If there is a . in the source string then the data source is in a\r\n           * nested object so we loop over the data for each level to get the next\r\n           * level down. On each loop we test for undefined, and if found immediately\r\n           * return. This allows entire objects to be missing and sDefaultContent to\r\n           * be used if defined, rather than throwing an error\r\n           */\r\n          var fetchData = function (data, type, src) {\r\n            var arrayNotation, funcNotation, out, innerSrc\r\n\r\n            if (src !== '') {\r\n              var a = _fnSplitObjNotation(src)\r\n\r\n              for (var i = 0, iLen = a.length; i < iLen; i++) {\r\n                // Check if we are dealing with special notation\r\n                arrayNotation = a[i].match(__reArray)\r\n                funcNotation = a[i].match(__reFn)\r\n\r\n                if (arrayNotation) {\r\n                  // Array notation\r\n                  a[i] = a[i].replace(__reArray, '')\r\n\r\n                  // Condition allows simply [] to be passed in\r\n                  if (a[i] !== '') {\r\n                    data = data[a[i]]\r\n                  }\r\n                  out = []\r\n\r\n                  // Get the remainder of the nested object to get\r\n                  a.splice(0, i + 1)\r\n                  innerSrc = a.join('.')\r\n\r\n                  // Traverse each entry in the array getting the properties requested\r\n                  for (var j = 0, jLen = data.length; j < jLen; j++) {\r\n                    out.push(fetchData(data[j], type, innerSrc))\r\n                  }\r\n\r\n                  // If a string is given in between the array notation indicators, that\r\n                  // is used to join the strings together, otherwise an array is returned\r\n                  var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1)\r\n                  data = join === '' ? out : out.join(join)\r\n\r\n                  // The inner call to fetchData has already traversed through the remainder\r\n                  // of the source requested, so we exit from the loop\r\n                  break\r\n                } else if (funcNotation) {\r\n                  // Function call\r\n                  a[i] = a[i].replace(__reFn, '')\r\n                  data = data[a[i]]()\r\n                  continue\r\n                }\r\n\r\n                if (data === null || data[a[i]] === undefined) {\r\n                  return undefined\r\n                }\r\n                data = data[a[i]]\r\n              }\r\n            }\r\n\r\n            return data\r\n          }\r\n\r\n          return function (data, type) {\r\n            // row and meta also passed, but not used\r\n            return fetchData(data, type, mSource)\r\n          }\r\n        } else {\r\n          /* Array or flat object mapping */\r\n          return function (data, type) {\r\n            // row and meta also passed, but not used\r\n            return data[mSource]\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Return a function that can be used to set data from a source object, taking\r\n       * into account the ability to use nested objects as a source\r\n       *  @param {string|int|function} mSource The data source for the object\r\n       *  @returns {function} Data set function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSetObjectDataFn (mSource) {\r\n        if ($.isPlainObject(mSource)) {\r\n          /* Unlike get, only the underscore (global) option is used for for\r\n           * setting data since we don't know the type here. This is why an object\r\n           * option is not documented for `mData` (which is read/write), but it is\r\n           * for `mRender` which is read only.\r\n           */\r\n          return _fnSetObjectDataFn(mSource._)\r\n        } else if (mSource === null) {\r\n          /* Nothing to do when the data source is null */\r\n          return function () {}\r\n        } else if (typeof mSource === 'function') {\r\n          return function (data, val, meta) {\r\n            mSource(data, 'set', val, meta)\r\n          }\r\n        } else if (\r\n          typeof mSource === 'string' &&\r\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\r\n        ) {\r\n          /* Like the get, we need to get data from a nested object */\r\n          var setData = function (data, val, src) {\r\n            var a = _fnSplitObjNotation(src),\r\n              b\r\n            var aLast = a[a.length - 1]\r\n            var arrayNotation, funcNotation, o, innerSrc\r\n\r\n            for (var i = 0, iLen = a.length - 1; i < iLen; i++) {\r\n              // Check if we are dealing with an array notation request\r\n              arrayNotation = a[i].match(__reArray)\r\n              funcNotation = a[i].match(__reFn)\r\n\r\n              if (arrayNotation) {\r\n                a[i] = a[i].replace(__reArray, '')\r\n                data[a[i]] = []\r\n\r\n                // Get the remainder of the nested object to set so we can recurse\r\n                b = a.slice()\r\n                b.splice(0, i + 1)\r\n                innerSrc = b.join('.')\r\n\r\n                // Traverse each entry in the array setting the properties requested\r\n                for (var j = 0, jLen = val.length; j < jLen; j++) {\r\n                  o = {}\r\n                  setData(o, val[j], innerSrc)\r\n                  data[a[i]].push(o)\r\n                }\r\n\r\n                // The inner call to setData has already traversed through the remainder\r\n                // of the source and has set the data, thus we can exit here\r\n                return\r\n              } else if (funcNotation) {\r\n                // Function call\r\n                a[i] = a[i].replace(__reFn, '')\r\n                data = data[a[i]](val)\r\n              }\r\n\r\n              // If the nested object doesn't currently exist - since we are\r\n              // trying to set the value - create it\r\n              if (data[a[i]] === null || data[a[i]] === undefined) {\r\n                data[a[i]] = {}\r\n              }\r\n              data = data[a[i]]\r\n            }\r\n\r\n            // Last item in the input - i.e, the actual set\r\n            if (aLast.match(__reFn)) {\r\n              // Function call\r\n              data = data[aLast.replace(__reFn, '')](val)\r\n            } else {\r\n              // If array notation is used, we just want to strip it and use the property name\r\n              // and assign the value. If it isn't used, then we get the result we want anyway\r\n              data[aLast.replace(__reArray, '')] = val\r\n            }\r\n          }\r\n\r\n          return function (data, val) {\r\n            // meta is also passed in, but not used\r\n            return setData(data, val, mSource)\r\n          }\r\n        } else {\r\n          /* Array or flat object mapping */\r\n          return function (data, val) {\r\n            // meta is also passed in, but not used\r\n            data[mSource] = val\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Return an array with the full table data\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns array {array} aData Master data array\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetDataMaster (settings) {\r\n        return _pluck(settings.aoData, '_aData')\r\n      }\r\n\r\n      /**\r\n       * Nuke the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnClearTable (settings) {\r\n        settings.aoData.length = 0\r\n        settings.aiDisplayMaster.length = 0\r\n        settings.aiDisplay.length = 0\r\n      }\r\n\r\n      /**\r\n       * Take an array of integers (index array) and remove a target integer (value - not\r\n       * the key!)\r\n       *  @param {array} a Index array to target\r\n       *  @param {int} iTarget value to find\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDeleteIndex (a, iTarget, splice) {\r\n        var iTargetIndex = -1\r\n\r\n        for (var i = 0, iLen = a.length; i < iLen; i++) {\r\n          if (a[i] == iTarget) {\r\n            iTargetIndex = i\r\n          } else if (a[i] > iTarget) {\r\n            a[i]--\r\n          }\r\n        }\r\n\r\n        if (iTargetIndex != -1 && splice === undefined) {\r\n          a.splice(iTargetIndex, 1)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Mark cached data as invalid such that a re-read of the data will occur when\r\n       * the cached data is next requested. Also update from the data source object.\r\n       *\r\n       * @param {object} settings DataTables settings object\r\n       * @param  {int}    rowIdx   Row index to invalidate\r\n       * @memberof DataTable#oApi\r\n       *\r\n       * @todo For the modularisation of v1.11 this will need to become a callback, so\r\n       *   the sort and filter methods can subscribe to it. That will required\r\n       *   initialisation options for sorting, which is why it is not already baked in\r\n       */\r\n      function _fnInvalidateRow (settings, rowIdx, src, column) {\r\n        var row = settings.aoData[rowIdx]\r\n        var i, ien\r\n\r\n        // Are we reading last data from DOM or the data object?\r\n        if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {\r\n          // Read the data from the DOM\r\n          row._aData = _fnGetRowElements(settings, row).data\r\n        } else {\r\n          // Reading from data object, update the DOM\r\n          var cells = row.anCells\r\n          var cell\r\n\r\n          if (cells) {\r\n            for (i = 0, ien = cells.length; i < ien; i++) {\r\n              cell = cells[i]\r\n\r\n              // This is very frustrating, but in IE if you just write directly\r\n              // to innerHTML, and elements that are overwritten are GC'ed,\r\n              // even if there is a reference to them elsewhere\r\n              while (cell.childNodes.length) {\r\n                cell.removeChild(cell.firstChild)\r\n              }\r\n\r\n              cells[i].innerHTML = _fnGetCellData(settings, rowIdx, i, 'display')\r\n            }\r\n          }\r\n        }\r\n\r\n        row._aSortData = null\r\n        row._aFilterData = null\r\n\r\n        // Invalidate the type for a specific column (if given) or all columns since\r\n        // the data might have changed\r\n        var cols = settings.aoColumns\r\n        if (column !== undefined) {\r\n          cols[column].sType = null\r\n        } else {\r\n          for (i = 0, ien = cols.length; i < ien; i++) {\r\n            cols[i].sType = null\r\n          }\r\n        }\r\n\r\n        // Update DataTables special `DT_*` attributes for the row\r\n        _fnRowAttributes(row)\r\n      }\r\n\r\n      /**\r\n       * Build a data source object from an HTML row, reading the contents of the\r\n       * cells that are in the row.\r\n       *\r\n       * @param {object} settings DataTables settings object\r\n       * @param {node|object} TR element from which to read data or existing row\r\n       *   object from which to re-read the data from the cells\r\n       * @returns {object} Object with two parameters: `data` the data read, in\r\n       *   document order, and `cells` and array of nodes (they can be useful to the\r\n       *   caller, so rather than needing a second traversal to get them, just return\r\n       *   them from here).\r\n       * @memberof DataTable#oApi\r\n       */\r\n      function _fnGetRowElements (settings, row) {\r\n        var d = [],\r\n          tds = [],\r\n          td = row.firstChild,\r\n          name,\r\n          col,\r\n          o,\r\n          i = 0,\r\n          contents,\r\n          columns = settings.aoColumns\r\n\r\n        var attr = function (str, data, td) {\r\n          if (typeof str === 'string') {\r\n            var idx = str.indexOf('@')\r\n\r\n            if (idx !== -1) {\r\n              var src = str.substring(idx + 1)\r\n              o['@' + src] = td.getAttribute(src)\r\n            }\r\n          }\r\n        }\r\n\r\n        var cellProcess = function (cell) {\r\n          col = columns[i]\r\n          contents = $.trim(cell.innerHTML)\r\n\r\n          if (col && col._bAttrSrc) {\r\n            o = {\r\n              display: contents\r\n            }\r\n\r\n            attr(col.mData.sort, o, cell)\r\n            attr(col.mData.type, o, cell)\r\n            attr(col.mData.filter, o, cell)\r\n\r\n            d.push(o)\r\n          } else {\r\n            d.push(contents)\r\n          }\r\n\r\n          i++\r\n        }\r\n\r\n        if (td) {\r\n          // `tr` element passed in\r\n          while (td) {\r\n            name = td.nodeName.toUpperCase()\r\n\r\n            if (name == 'TD' || name == 'TH') {\r\n              cellProcess(td)\r\n              tds.push(td)\r\n            }\r\n\r\n            td = td.nextSibling\r\n          }\r\n        } else {\r\n          // Existing row object passed in\r\n          tds = row.anCells\r\n\r\n          for (var j = 0, jen = tds.length; j < jen; j++) {\r\n            cellProcess(tds[j])\r\n          }\r\n        }\r\n\r\n        return {\r\n          data: d,\r\n          cells: tds\r\n        }\r\n      }\r\n      /**\r\n       * Create a new TR element (and it's TD children) for a row\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {int} iRow Row to consider\r\n       *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\r\n       *    DataTables will create a row automatically\r\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\r\n       *    if nTr is.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCreateTr (oSettings, iRow, nTrIn, anTds) {\r\n        var row = oSettings.aoData[iRow],\r\n          rowData = row._aData,\r\n          cells = [],\r\n          nTr,\r\n          nTd,\r\n          oCol,\r\n          i,\r\n          iLen\r\n\r\n        if (row.nTr === null) {\r\n          nTr = nTrIn || document.createElement('tr')\r\n\r\n          row.nTr = nTr\r\n          row.anCells = cells\r\n\r\n          /* Use a private property on the node to allow reserve mapping from the node\r\n           * to the aoData array for fast look up\r\n           */\r\n          nTr._DT_RowIndex = iRow\r\n\r\n          /* Special parameters can be given by the data source to be used on the row */\r\n          _fnRowAttributes(row)\r\n\r\n          /* Process each column */\r\n          for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {\r\n            oCol = oSettings.aoColumns[i]\r\n\r\n            nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType)\r\n            cells.push(nTd)\r\n\r\n            // Need to create the HTML if new, or if a rendering function is defined\r\n            if (!nTrIn || oCol.mRender || oCol.mData !== i) {\r\n              nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display')\r\n            }\r\n\r\n            /* Add user defined class */\r\n            if (oCol.sClass) {\r\n              nTd.className += ' ' + oCol.sClass\r\n            }\r\n\r\n            // Visibility - add or remove as required\r\n            if (oCol.bVisible && !nTrIn) {\r\n              nTr.appendChild(nTd)\r\n            } else if (!oCol.bVisible && nTrIn) {\r\n              nTd.parentNode.removeChild(nTd)\r\n            }\r\n\r\n            if (oCol.fnCreatedCell) {\r\n              oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i)\r\n            }\r\n          }\r\n\r\n          _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow])\r\n        }\r\n\r\n        // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved\r\n        // and deployed\r\n        row.nTr.setAttribute('role', 'row')\r\n      }\r\n\r\n      /**\r\n       * Add attributes to a row based on the special `DT_*` parameters in a data\r\n       * source object.\r\n       *  @param {object} DataTables row object for the row to be modified\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnRowAttributes (row) {\r\n        var tr = row.nTr\r\n        var data = row._aData\r\n\r\n        if (tr) {\r\n          if (data.DT_RowId) {\r\n            tr.id = data.DT_RowId\r\n          }\r\n\r\n          if (data.DT_RowClass) {\r\n            // Remove any classes added by DT_RowClass before\r\n            var a = data.DT_RowClass.split(' ')\r\n            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a\r\n\r\n            $(tr)\r\n              .removeClass(row.__rowc.join(' '))\r\n              .addClass(data.DT_RowClass)\r\n          }\r\n\r\n          if (data.DT_RowData) {\r\n            $(tr).data(data.DT_RowData)\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Create the HTML header for the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnBuildHead (oSettings) {\r\n        var i, ien, cell, row, column\r\n        var thead = oSettings.nTHead\r\n        var tfoot = oSettings.nTFoot\r\n        var createHeader = $('th, td', thead).length === 0\r\n        var classes = oSettings.oClasses\r\n        var columns = oSettings.aoColumns\r\n\r\n        if (createHeader) {\r\n          row = $('<tr/>').appendTo(thead)\r\n        }\r\n\r\n        for (i = 0, ien = columns.length; i < ien; i++) {\r\n          column = columns[i]\r\n          cell = $(column.nTh).addClass(column.sClass)\r\n\r\n          if (createHeader) {\r\n            cell.appendTo(row)\r\n          }\r\n\r\n          // 1.11 move into sorting\r\n          if (oSettings.oFeatures.bSort) {\r\n            cell.addClass(column.sSortingClass)\r\n\r\n            if (column.bSortable !== false) {\r\n              cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId)\r\n\r\n              _fnSortAttachListener(oSettings, column.nTh, i)\r\n            }\r\n          }\r\n\r\n          if (column.sTitle != cell.html()) {\r\n            cell.html(column.sTitle)\r\n          }\r\n\r\n          _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes)\r\n        }\r\n\r\n        if (createHeader) {\r\n          _fnDetectHeader(oSettings.aoHeader, thead)\r\n        }\r\n\r\n        /* ARIA role for the rows */\r\n        $(thead)\r\n          .find('>tr')\r\n          .attr('role', 'row')\r\n\r\n        /* Deal with the footer - add classes if required */\r\n        $(thead)\r\n          .find('>tr>th, >tr>td')\r\n          .addClass(classes.sHeaderTH)\r\n        $(tfoot)\r\n          .find('>tr>th, >tr>td')\r\n          .addClass(classes.sFooterTH)\r\n\r\n        // Cache the footer cells. Note that we only take the cells from the first\r\n        // row in the footer. If there is more than one row the user wants to\r\n        // interact with, they need to use the table().foot() method. Note also this\r\n        // allows cells to be used for multiple columns using colspan\r\n        if (tfoot !== null) {\r\n          var cells = oSettings.aoFooter[0]\r\n\r\n          for (i = 0, ien = cells.length; i < ien; i++) {\r\n            column = columns[i]\r\n            column.nTf = cells[i].cell\r\n\r\n            if (column.sClass) {\r\n              $(column.nTf).addClass(column.sClass)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Draw the header (or footer) element based on the column visibility states. The\r\n       * methodology here is to use the layout array from _fnDetectHeader, modified for\r\n       * the instantaneous column visibility, to construct the new layout. The grid is\r\n       * traversed over cell at a time in a rows x columns grid fashion, although each\r\n       * cell insert can cover multiple elements in the grid - which is tracks using the\r\n       * aApplied array. Cell inserts in the grid will only occur where there isn't\r\n       * already a cell in that position.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param array {objects} aoSource Layout array from _fnDetectHeader\r\n       *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDrawHead (oSettings, aoSource, bIncludeHidden) {\r\n        var i, iLen, j, jLen, k, kLen, n, nLocalTr\r\n        var aoLocal = []\r\n        var aApplied = []\r\n        var iColumns = oSettings.aoColumns.length\r\n        var iRowspan, iColspan\r\n\r\n        if (!aoSource) {\r\n          return\r\n        }\r\n\r\n        if (bIncludeHidden === undefined) {\r\n          bIncludeHidden = false\r\n        }\r\n\r\n        /* Make a copy of the master layout array, but without the visible columns in it */\r\n        for (i = 0, iLen = aoSource.length; i < iLen; i++) {\r\n          aoLocal[i] = aoSource[i].slice()\r\n          aoLocal[i].nTr = aoSource[i].nTr\r\n\r\n          /* Remove any columns which are currently hidden */\r\n          for (j = iColumns - 1; j >= 0; j--) {\r\n            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {\r\n              aoLocal[i].splice(j, 1)\r\n            }\r\n          }\r\n\r\n          /* Prep the applied array - it needs an element for each row */\r\n          aApplied.push([])\r\n        }\r\n\r\n        for (i = 0, iLen = aoLocal.length; i < iLen; i++) {\r\n          nLocalTr = aoLocal[i].nTr\r\n\r\n          /* All cells are going to be replaced, so empty out the row */\r\n          if (nLocalTr) {\r\n            while ((n = nLocalTr.firstChild)) {\r\n              nLocalTr.removeChild(n)\r\n            }\r\n          }\r\n\r\n          for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {\r\n            iRowspan = 1\r\n            iColspan = 1\r\n\r\n            /* Check to see if there is already a cell (row/colspan) covering our target\r\n             * insert point. If there is, then there is nothing to do.\r\n             */\r\n            if (aApplied[i][j] === undefined) {\r\n              nLocalTr.appendChild(aoLocal[i][j].cell)\r\n              aApplied[i][j] = 1\r\n\r\n              /* Expand the cell to cover as many rows as needed */\r\n              while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {\r\n                aApplied[i + iRowspan][j] = 1\r\n                iRowspan++\r\n              }\r\n\r\n              /* Expand the cell to cover as many columns as needed */\r\n              while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {\r\n                /* Must update the applied array over the rows for the columns */\r\n                for (k = 0; k < iRowspan; k++) {\r\n                  aApplied[i + k][j + iColspan] = 1\r\n                }\r\n                iColspan++\r\n              }\r\n\r\n              /* Do the actual expansion in the DOM */\r\n              $(aoLocal[i][j].cell)\r\n                .attr('rowspan', iRowspan)\r\n                .attr('colspan', iColspan)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Insert the required TR nodes into the table for display\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDraw (oSettings) {\r\n        /* Provide a pre-callback function which can be used to cancel the draw is false is returned */\r\n        var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings])\r\n        if ($.inArray(false, aPreDraw) !== -1) {\r\n          _fnProcessingDisplay(oSettings, false)\r\n          return\r\n        }\r\n\r\n        var i, iLen, n\r\n        var anRows = []\r\n        var iRowCount = 0\r\n        var asStripeClasses = oSettings.asStripeClasses\r\n        var iStripes = asStripeClasses.length\r\n        var iOpenRows = oSettings.aoOpenRows.length\r\n        var oLang = oSettings.oLanguage\r\n        var iInitDisplayStart = oSettings.iInitDisplayStart\r\n        var bServerSide = _fnDataSource(oSettings) == 'ssp'\r\n        var aiDisplay = oSettings.aiDisplay\r\n\r\n        oSettings.bDrawing = true\r\n\r\n        /* Check and see if we have an initial draw position from state saving */\r\n        if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {\r\n          oSettings._iDisplayStart = bServerSide\r\n            ? iInitDisplayStart\r\n            : iInitDisplayStart >= oSettings.fnRecordsDisplay()\r\n            ? 0\r\n            : iInitDisplayStart\r\n\r\n          oSettings.iInitDisplayStart = -1\r\n        }\r\n\r\n        var iDisplayStart = oSettings._iDisplayStart\r\n        var iDisplayEnd = oSettings.fnDisplayEnd()\r\n\r\n        /* Server-side processing draw intercept */\r\n        if (oSettings.bDeferLoading) {\r\n          oSettings.bDeferLoading = false\r\n          oSettings.iDraw++\r\n          _fnProcessingDisplay(oSettings, false)\r\n        } else if (!bServerSide) {\r\n          oSettings.iDraw++\r\n        } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {\r\n          return\r\n        }\r\n\r\n        if (aiDisplay.length !== 0) {\r\n          var iStart = bServerSide ? 0 : iDisplayStart\r\n          var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd\r\n\r\n          for (var j = iStart; j < iEnd; j++) {\r\n            var iDataIndex = aiDisplay[j]\r\n            var aoData = oSettings.aoData[iDataIndex]\r\n            if (aoData.nTr === null) {\r\n              _fnCreateTr(oSettings, iDataIndex)\r\n            }\r\n\r\n            var nRow = aoData.nTr\r\n\r\n            /* Remove the old striping classes and then add the new one */\r\n            if (iStripes !== 0) {\r\n              var sStripe = asStripeClasses[iRowCount % iStripes]\r\n              if (aoData._sRowStripe != sStripe) {\r\n                $(nRow)\r\n                  .removeClass(aoData._sRowStripe)\r\n                  .addClass(sStripe)\r\n                aoData._sRowStripe = sStripe\r\n              }\r\n            }\r\n\r\n            /* Row callback functions - might want to manipulate the row */\r\n            _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j])\r\n\r\n            anRows.push(nRow)\r\n            iRowCount++\r\n          }\r\n        } else {\r\n          /* Table is empty - create a row with an empty message in it */\r\n          var sZero = oLang.sZeroRecords\r\n          if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {\r\n            sZero = oLang.sLoadingRecords\r\n          } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {\r\n            sZero = oLang.sEmptyTable\r\n          }\r\n\r\n          anRows[0] = $('<tr/>', { class: iStripes ? asStripeClasses[0] : '' }).append(\r\n            $('<td />', {\r\n              valign: 'top',\r\n              colSpan: _fnVisbleColumns(oSettings),\r\n              class: oSettings.oClasses.sRowEmpty\r\n            }).html(sZero)\r\n          )[0]\r\n        }\r\n\r\n        /* Header and footer callbacks */\r\n        _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [\r\n          $(oSettings.nTHead).children('tr')[0],\r\n          _fnGetDataMaster(oSettings),\r\n          iDisplayStart,\r\n          iDisplayEnd,\r\n          aiDisplay\r\n        ])\r\n\r\n        _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [\r\n          $(oSettings.nTFoot).children('tr')[0],\r\n          _fnGetDataMaster(oSettings),\r\n          iDisplayStart,\r\n          iDisplayEnd,\r\n          aiDisplay\r\n        ])\r\n\r\n        var body = $(oSettings.nTBody)\r\n\r\n        body.children().detach()\r\n        body.append($(anRows))\r\n\r\n        /* Call all required callback functions for the end of a draw */\r\n        _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings])\r\n\r\n        /* Draw is complete, sorting and filtering must be as well */\r\n        oSettings.bSorted = false\r\n        oSettings.bFiltered = false\r\n        oSettings.bDrawing = false\r\n      }\r\n\r\n      /**\r\n       * Redraw the table - taking account of the various features which are enabled\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {boolean} [holdPosition] Keep the current paging position. By default\r\n       *    the paging is reset to the first page\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnReDraw (settings, holdPosition) {\r\n        var features = settings.oFeatures,\r\n          sort = features.bSort,\r\n          filter = features.bFilter\r\n\r\n        if (sort) {\r\n          _fnSort(settings)\r\n        }\r\n\r\n        if (filter) {\r\n          _fnFilterComplete(settings, settings.oPreviousSearch)\r\n        } else {\r\n          // No filtering, so we want to just use the display master\r\n          settings.aiDisplay = settings.aiDisplayMaster.slice()\r\n        }\r\n\r\n        if (holdPosition !== true) {\r\n          settings._iDisplayStart = 0\r\n        }\r\n\r\n        // Let any modules know about the draw hold position state (used by\r\n        // scrolling internally)\r\n        settings._drawHold = holdPosition\r\n\r\n        _fnDraw(settings)\r\n\r\n        settings._drawHold = false\r\n      }\r\n\r\n      /**\r\n       * Add the options to the page HTML for the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAddOptionsHtml (oSettings) {\r\n        var classes = oSettings.oClasses\r\n        var table = $(oSettings.nTable)\r\n        var holding = $('<div/>').insertBefore(table) // Holding element for speed\r\n        var features = oSettings.oFeatures\r\n\r\n        // All DataTables are wrapped in a div\r\n        var insert = $('<div/>', {\r\n          id: oSettings.sTableId + '_wrapper',\r\n          class: classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)\r\n        })\r\n\r\n        oSettings.nHolding = holding[0]\r\n        oSettings.nTableWrapper = insert[0]\r\n        oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling\r\n\r\n        /* Loop over the user set positioning and place the elements as needed */\r\n        var aDom = oSettings.sDom.split('')\r\n        var featureNode, cOption, nNewNode, cNext, sAttr, j\r\n        for (var i = 0; i < aDom.length; i++) {\r\n          featureNode = null\r\n          cOption = aDom[i]\r\n\r\n          if (cOption == '<') {\r\n            /* New container div */\r\n            nNewNode = $('<div/>')[0]\r\n\r\n            /* Check to see if we should append an id and/or a class name to the container */\r\n            cNext = aDom[i + 1]\r\n            if (cNext == \"'\" || cNext == '\"') {\r\n              sAttr = ''\r\n              j = 2\r\n              while (aDom[i + j] != cNext) {\r\n                sAttr += aDom[i + j]\r\n                j++\r\n              }\r\n\r\n              /* Replace jQuery UI constants @todo depreciated */\r\n              if (sAttr == 'H') {\r\n                sAttr = classes.sJUIHeader\r\n              } else if (sAttr == 'F') {\r\n                sAttr = classes.sJUIFooter\r\n              }\r\n\r\n              /* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\r\n               * breaks the string into parts and applies them as needed\r\n               */\r\n              if (sAttr.indexOf('.') != -1) {\r\n                var aSplit = sAttr.split('.')\r\n                nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1)\r\n                nNewNode.className = aSplit[1]\r\n              } else if (sAttr.charAt(0) == '#') {\r\n                nNewNode.id = sAttr.substr(1, sAttr.length - 1)\r\n              } else {\r\n                nNewNode.className = sAttr\r\n              }\r\n\r\n              i += j /* Move along the position array */\r\n            }\r\n\r\n            insert.append(nNewNode)\r\n            insert = $(nNewNode)\r\n          } else if (cOption == '>') {\r\n            /* End container div */\r\n            insert = insert.parent()\r\n          }\r\n          // @todo Move options into their own plugins?\r\n          else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {\r\n            /* Length */\r\n            featureNode = _fnFeatureHtmlLength(oSettings)\r\n          } else if (cOption == 'f' && features.bFilter) {\r\n            /* Filter */\r\n            featureNode = _fnFeatureHtmlFilter(oSettings)\r\n          } else if (cOption == 'r' && features.bProcessing) {\r\n            /* pRocessing */\r\n            featureNode = _fnFeatureHtmlProcessing(oSettings)\r\n          } else if (cOption == 't') {\r\n            /* Table */\r\n            featureNode = _fnFeatureHtmlTable(oSettings)\r\n          } else if (cOption == 'i' && features.bInfo) {\r\n            /* Info */\r\n            featureNode = _fnFeatureHtmlInfo(oSettings)\r\n          } else if (cOption == 'p' && features.bPaginate) {\r\n            /* Pagination */\r\n            featureNode = _fnFeatureHtmlPaginate(oSettings)\r\n          } else if (DataTable.ext.feature.length !== 0) {\r\n            /* Plug-in features */\r\n            var aoFeatures = DataTable.ext.feature\r\n            for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {\r\n              if (cOption == aoFeatures[k].cFeature) {\r\n                featureNode = aoFeatures[k].fnInit(oSettings)\r\n                break\r\n              }\r\n            }\r\n          }\r\n\r\n          /* Add to the 2D features array */\r\n          if (featureNode) {\r\n            var aanFeatures = oSettings.aanFeatures\r\n\r\n            if (!aanFeatures[cOption]) {\r\n              aanFeatures[cOption] = []\r\n            }\r\n\r\n            aanFeatures[cOption].push(featureNode)\r\n            insert.append(featureNode)\r\n          }\r\n        }\r\n\r\n        /* Built our DOM structure - replace the holding div with what we want */\r\n        holding.replaceWith(insert)\r\n      }\r\n\r\n      /**\r\n       * Use the DOM source to create up an array of header cells. The idea here is to\r\n       * create a layout grid (array) of rows x columns, which contains a reference\r\n       * to the cell that that point in the grid (regardless of col/rowspan), such that\r\n       * any column / row could be removed and the new grid constructed\r\n       *  @param array {object} aLayout Array to store the calculated layout in\r\n       *  @param {node} nThead The header/footer element for the table\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDetectHeader (aLayout, nThead) {\r\n        var nTrs = $(nThead).children('tr')\r\n        var nTr, nCell\r\n        var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan\r\n        var bUnique\r\n        var fnShiftCol = function (a, i, j) {\r\n          var k = a[i]\r\n          while (k[j]) {\r\n            j++\r\n          }\r\n          return j\r\n        }\r\n\r\n        aLayout.splice(0, aLayout.length)\r\n\r\n        /* We know how many rows there are in the layout - so prep it */\r\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\r\n          aLayout.push([])\r\n        }\r\n\r\n        /* Calculate a layout array */\r\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\r\n          nTr = nTrs[i]\r\n          iColumn = 0\r\n\r\n          /* For every cell in the row... */\r\n          nCell = nTr.firstChild\r\n          while (nCell) {\r\n            if (nCell.nodeName.toUpperCase() == 'TD' || nCell.nodeName.toUpperCase() == 'TH') {\r\n              /* Get the col and rowspan attributes from the DOM and sanitise them */\r\n              iColspan = nCell.getAttribute('colspan') * 1\r\n              iRowspan = nCell.getAttribute('rowspan') * 1\r\n              iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan\r\n              iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan\r\n\r\n              /* There might be colspan cells already in this row, so shift our target\r\n               * accordingly\r\n               */\r\n              iColShifted = fnShiftCol(aLayout, i, iColumn)\r\n\r\n              /* Cache calculation for unique columns */\r\n              bUnique = iColspan === 1 ? true : false\r\n\r\n              /* If there is col / rowspan, copy the information into the layout grid */\r\n              for (l = 0; l < iColspan; l++) {\r\n                for (k = 0; k < iRowspan; k++) {\r\n                  aLayout[i + k][iColShifted + l] = {\r\n                    cell: nCell,\r\n                    unique: bUnique\r\n                  }\r\n                  aLayout[i + k].nTr = nTr\r\n                }\r\n              }\r\n            }\r\n            nCell = nCell.nextSibling\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get an array of unique th elements, one for each column\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} nHeader automatically detect the layout from this node - optional\r\n       *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\r\n       *  @returns array {node} aReturn list of unique th's\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetUniqueThs (oSettings, nHeader, aLayout) {\r\n        var aReturn = []\r\n        if (!aLayout) {\r\n          aLayout = oSettings.aoHeader\r\n          if (nHeader) {\r\n            aLayout = []\r\n            _fnDetectHeader(aLayout, nHeader)\r\n          }\r\n        }\r\n\r\n        for (var i = 0, iLen = aLayout.length; i < iLen; i++) {\r\n          for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {\r\n            if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {\r\n              aReturn[j] = aLayout[i][j].cell\r\n            }\r\n          }\r\n        }\r\n\r\n        return aReturn\r\n      }\r\n\r\n      /**\r\n       * Create an Ajax call based on the table's settings, taking into account that\r\n       * parameters can have multiple forms, and backwards compatibility.\r\n       *\r\n       * @param {object} oSettings dataTables settings object\r\n       * @param {array} data Data to send to the server, required by\r\n       *     DataTables - may be augmented by developer callbacks\r\n       * @param {function} fn Callback function to run when data is obtained\r\n       */\r\n      function _fnBuildAjax (oSettings, data, fn) {\r\n        // Compatibility with 1.9-, allow fnServerData and event to manipulate\r\n        _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data])\r\n\r\n        // Convert to object based for 1.10+ if using the old array scheme which can\r\n        // come from server-side processing or serverParams\r\n        if (data && $.isArray(data)) {\r\n          var tmp = {}\r\n          var rbracket = /(.*?)\\[\\]$/\r\n\r\n          $.each(data, function (key, val) {\r\n            var match = val.name.match(rbracket)\r\n\r\n            if (match) {\r\n              // Support for arrays\r\n              var name = match[0]\r\n\r\n              if (!tmp[name]) {\r\n                tmp[name] = []\r\n              }\r\n              tmp[name].push(val.value)\r\n            } else {\r\n              tmp[val.name] = val.value\r\n            }\r\n          })\r\n          data = tmp\r\n        }\r\n\r\n        var ajaxData\r\n        var ajax = oSettings.ajax\r\n        var instance = oSettings.oInstance\r\n\r\n        if ($.isPlainObject(ajax) && ajax.data) {\r\n          ajaxData = ajax.data\r\n\r\n          var newData = $.isFunction(ajaxData)\r\n            ? ajaxData(data) // fn can manipulate data or return an object\r\n            : ajaxData // object or array to merge\r\n\r\n          // If the function returned an object, use that alone\r\n          data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData)\r\n\r\n          // Remove the data property as we've resolved it already and don't want\r\n          // jQuery to do it again (it is restored at the end of the function)\r\n          delete ajax.data\r\n        }\r\n\r\n        var baseAjax = {\r\n          data: data,\r\n          success: function (json) {\r\n            var error = json.error || json.sError\r\n            if (error) {\r\n              oSettings.oApi._fnLog(oSettings, 0, error)\r\n            }\r\n\r\n            oSettings.json = json\r\n            _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json])\r\n            fn(json)\r\n          },\r\n          dataType: 'json',\r\n          cache: false,\r\n          type: oSettings.sServerMethod,\r\n          error: function (xhr, error, thrown) {\r\n            var log = oSettings.oApi._fnLog\r\n\r\n            if (error == 'parsererror') {\r\n              log(oSettings, 0, 'Invalid JSON response', 1)\r\n            } else if (xhr.readyState === 4) {\r\n              log(oSettings, 0, 'Ajax error', 7)\r\n            }\r\n\r\n            _fnProcessingDisplay(oSettings, false)\r\n          }\r\n        }\r\n\r\n        // Store the data submitted for the API\r\n        oSettings.oAjaxData = data\r\n\r\n        // Allow plug-ins and external processes to modify the data\r\n        _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data])\r\n\r\n        if (oSettings.fnServerData) {\r\n          // DataTables 1.9- compatibility\r\n          oSettings.fnServerData.call(\r\n            instance,\r\n            oSettings.sAjaxSource,\r\n            $.map(data, function (val, key) {\r\n              // Need to convert back to 1.9 trad format\r\n              return { name: key, value: val }\r\n            }),\r\n            fn,\r\n            oSettings\r\n          )\r\n        } else if (oSettings.sAjaxSource || typeof ajax === 'string') {\r\n          // DataTables 1.9- compatibility\r\n          oSettings.jqXHR = $.ajax(\r\n            $.extend(baseAjax, {\r\n              url: ajax || oSettings.sAjaxSource\r\n            })\r\n          )\r\n        } else if ($.isFunction(ajax)) {\r\n          // Is a function - let the caller define what needs to be done\r\n          oSettings.jqXHR = ajax.call(instance, data, fn, oSettings)\r\n        } else {\r\n          // Object to extend the base settings\r\n          oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax))\r\n\r\n          // Restore for next time around\r\n          ajax.data = ajaxData\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Update the table using an Ajax call\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {boolean} Block the table drawing or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAjaxUpdate (settings) {\r\n        if (settings.bAjaxDataGet) {\r\n          settings.iDraw++\r\n          _fnProcessingDisplay(settings, true)\r\n\r\n          _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {\r\n            _fnAjaxUpdateDraw(settings, json)\r\n          })\r\n\r\n          return false\r\n        }\r\n        return true\r\n      }\r\n\r\n      /**\r\n       * Build up the parameters in an object needed for a server-side processing\r\n       * request. Note that this is basically done twice, is different ways - a modern\r\n       * method which is used by default in DataTables 1.10 which uses objects and\r\n       * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\r\n       * the sAjaxSource option is used in the initialisation, or the legacyAjax\r\n       * option is set.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {bool} block the table drawing or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAjaxParameters (settings) {\r\n        var columns = settings.aoColumns,\r\n          columnCount = columns.length,\r\n          features = settings.oFeatures,\r\n          preSearch = settings.oPreviousSearch,\r\n          preColSearch = settings.aoPreSearchCols,\r\n          i,\r\n          data = [],\r\n          dataProp,\r\n          column,\r\n          columnSearch,\r\n          sort = _fnSortFlatten(settings),\r\n          displayStart = settings._iDisplayStart,\r\n          displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1\r\n\r\n        var param = function (name, value) {\r\n          data.push({ name: name, value: value })\r\n        }\r\n\r\n        // DataTables 1.9- compatible method\r\n        param('sEcho', settings.iDraw)\r\n        param('iColumns', columnCount)\r\n        param('sColumns', _pluck(columns, 'sName').join(','))\r\n        param('iDisplayStart', displayStart)\r\n        param('iDisplayLength', displayLength)\r\n\r\n        // DataTables 1.10+ method\r\n        var d = {\r\n          draw: settings.iDraw,\r\n          columns: [],\r\n          order: [],\r\n          start: displayStart,\r\n          length: displayLength,\r\n          search: {\r\n            value: preSearch.sSearch,\r\n            regex: preSearch.bRegex\r\n          }\r\n        }\r\n\r\n        for (i = 0; i < columnCount; i++) {\r\n          column = columns[i]\r\n          columnSearch = preColSearch[i]\r\n          dataProp = typeof column.mData == 'function' ? 'function' : column.mData\r\n\r\n          d.columns.push({\r\n            data: dataProp,\r\n            name: column.sName,\r\n            searchable: column.bSearchable,\r\n            orderable: column.bSortable,\r\n            search: {\r\n              value: columnSearch.sSearch,\r\n              regex: columnSearch.bRegex\r\n            }\r\n          })\r\n\r\n          param('mDataProp_' + i, dataProp)\r\n\r\n          if (features.bFilter) {\r\n            param('sSearch_' + i, columnSearch.sSearch)\r\n            param('bRegex_' + i, columnSearch.bRegex)\r\n            param('bSearchable_' + i, column.bSearchable)\r\n          }\r\n\r\n          if (features.bSort) {\r\n            param('bSortable_' + i, column.bSortable)\r\n          }\r\n        }\r\n\r\n        if (features.bFilter) {\r\n          param('sSearch', preSearch.sSearch)\r\n          param('bRegex', preSearch.bRegex)\r\n        }\r\n\r\n        if (features.bSort) {\r\n          $.each(sort, function (i, val) {\r\n            d.order.push({ column: val.col, dir: val.dir })\r\n\r\n            param('iSortCol_' + i, val.col)\r\n            param('sSortDir_' + i, val.dir)\r\n          })\r\n\r\n          param('iSortingCols', sort.length)\r\n        }\r\n\r\n        // If the legacy.ajax parameter is null, then we automatically decide which\r\n        // form to use, based on sAjaxSource\r\n        var legacy = DataTable.ext.legacy.ajax\r\n        if (legacy === null) {\r\n          return settings.sAjaxSource ? data : d\r\n        }\r\n\r\n        // Otherwise, if legacy has been specified then we use that to decide on the\r\n        // form\r\n        return legacy ? data : d\r\n      }\r\n\r\n      /**\r\n       * Data the data from the server (nuking the old) and redraw the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} json json data return from the server.\r\n       *  @param {string} json.sEcho Tracking flag for DataTables to match requests\r\n       *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\r\n       *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\r\n       *  @param {array} json.aaData The data to display on this page\r\n       *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnAjaxUpdateDraw (settings, json) {\r\n        // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\r\n        // Support both\r\n        var compat = function (old, modern) {\r\n          return json[old] !== undefined ? json[old] : json[modern]\r\n        }\r\n\r\n        var draw = compat('sEcho', 'draw')\r\n        var recordsTotal = compat('iTotalRecords', 'recordsTotal')\r\n        var rocordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered')\r\n\r\n        if (draw) {\r\n          // Protect against out of sequence returns\r\n          if (draw * 1 < settings.iDraw) {\r\n            return\r\n          }\r\n          settings.iDraw = draw * 1\r\n        }\r\n\r\n        _fnClearTable(settings)\r\n        settings._iRecordsTotal = parseInt(recordsTotal, 10)\r\n        settings._iRecordsDisplay = parseInt(rocordsFiltered, 10)\r\n\r\n        var data = _fnAjaxDataSrc(settings, json)\r\n        for (var i = 0, ien = data.length; i < ien; i++) {\r\n          _fnAddData(settings, data[i])\r\n        }\r\n        settings.aiDisplay = settings.aiDisplayMaster.slice()\r\n\r\n        settings.bAjaxDataGet = false\r\n        _fnDraw(settings)\r\n\r\n        if (!settings._bInitComplete) {\r\n          _fnInitComplete(settings, json)\r\n        }\r\n\r\n        settings.bAjaxDataGet = true\r\n        _fnProcessingDisplay(settings, false)\r\n      }\r\n\r\n      /**\r\n       * Get the data from the JSON data source to use for drawing a table. Using\r\n       * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\r\n       * source object, or from a processing function.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param  {object} json Data source object / array from the server\r\n       *  @return {array} Array of data to use\r\n       */\r\n      function _fnAjaxDataSrc (oSettings, json) {\r\n        var dataSrc =\r\n          $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined\r\n            ? oSettings.ajax.dataSrc\r\n            : oSettings.sAjaxDataProp // Compatibility with 1.9-.\r\n\r\n        // Compatibility with 1.9-. In order to read from aaData, check if the\r\n        // default has been changed, if not, check for aaData\r\n        if (dataSrc === 'data') {\r\n          return json.aaData || json[dataSrc]\r\n        }\r\n\r\n        return dataSrc !== '' ? _fnGetObjectDataFn(dataSrc)(json) : json\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for filtering text\r\n       *  @returns {node} Filter control element\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlFilter (settings) {\r\n        var classes = settings.oClasses\r\n        var tableId = settings.sTableId\r\n        var language = settings.oLanguage\r\n        var previousSearch = settings.oPreviousSearch\r\n        var features = settings.aanFeatures\r\n        var input = '<input type=\"search\" class=\"' + classes.sFilterInput + '\"/>'\r\n\r\n        var str = language.sSearch\r\n        str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input\r\n\r\n        var filter = $('<div/>', {\r\n          id: !features.f ? tableId + '_filter' : null,\r\n          class: classes.sFilter\r\n        }).append($('<label/>').append(str))\r\n\r\n        var searchFn = function () {\r\n          /* Update all other filter input elements for the new display */\r\n          var n = features.f\r\n          var val = !this.value ? '' : this.value // mental IE8 fix :-(\r\n\r\n          /* Now do the filter */\r\n          if (val != previousSearch.sSearch) {\r\n            _fnFilterComplete(settings, {\r\n              sSearch: val,\r\n              bRegex: previousSearch.bRegex,\r\n              bSmart: previousSearch.bSmart,\r\n              bCaseInsensitive: previousSearch.bCaseInsensitive\r\n            })\r\n\r\n            // Need to redraw, without resorting\r\n            settings._iDisplayStart = 0\r\n            _fnDraw(settings)\r\n          }\r\n        }\r\n        var jqFilter = $('input', filter)\r\n          .val(previousSearch.sSearch)\r\n          .attr('placeholder', language.sSearchPlaceholder)\r\n          .bind(\r\n            'keyup.DT search.DT input.DT paste.DT cut.DT',\r\n            _fnDataSource(settings) === 'ssp' ? _fnThrottle(searchFn, 400) : searchFn\r\n          )\r\n          .bind('keypress.DT', function (e) {\r\n            /* Prevent form submission */\r\n            if (e.keyCode == 13) {\r\n              return false\r\n            }\r\n          })\r\n          .attr('aria-controls', tableId)\r\n\r\n        // Update the input elements whenever the table is filtered\r\n        $(settings.nTable).on('search.dt.DT', function (ev, s) {\r\n          if (settings === s) {\r\n            // IE9 throws an 'unknown error' if document.activeElement is used\r\n            // inside an iframe or frame...\r\n            try {\r\n              if (jqFilter[0] !== document.activeElement) {\r\n                jqFilter.val(previousSearch.sSearch)\r\n              }\r\n            } catch (e) {}\r\n          }\r\n        })\r\n\r\n        return filter[0]\r\n      }\r\n\r\n      /**\r\n       * Filter the table using both the global filter and column based filtering\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} oSearch search information\r\n       *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterComplete (oSettings, oInput, iForce) {\r\n        var oPrevSearch = oSettings.oPreviousSearch\r\n        var aoPrevSearch = oSettings.aoPreSearchCols\r\n        var fnSaveFilter = function (oFilter) {\r\n          /* Save the filtering values */\r\n          oPrevSearch.sSearch = oFilter.sSearch\r\n          oPrevSearch.bRegex = oFilter.bRegex\r\n          oPrevSearch.bSmart = oFilter.bSmart\r\n          oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive\r\n        }\r\n        var fnRegex = function (o) {\r\n          // Backwards compatibility with the bEscapeRegex option\r\n          return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex\r\n        }\r\n\r\n        // Resolve any column types that are unknown due to addition or invalidation\r\n        // @todo As per sort - can this be moved into an event handler?\r\n        _fnColumnTypes(oSettings)\r\n\r\n        /* In server-side processing all filtering is done by the server, so no point hanging around here */\r\n        if (_fnDataSource(oSettings) != 'ssp') {\r\n          /* Global filter */\r\n          _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive)\r\n          fnSaveFilter(oInput)\r\n\r\n          /* Now do the individual column filter */\r\n          for (var i = 0; i < aoPrevSearch.length; i++) {\r\n            _fnFilterColumn(\r\n              oSettings,\r\n              aoPrevSearch[i].sSearch,\r\n              i,\r\n              fnRegex(aoPrevSearch[i]),\r\n              aoPrevSearch[i].bSmart,\r\n              aoPrevSearch[i].bCaseInsensitive\r\n            )\r\n          }\r\n\r\n          /* Custom filtering */\r\n          _fnFilterCustom(oSettings)\r\n        } else {\r\n          fnSaveFilter(oInput)\r\n        }\r\n\r\n        /* Tell the draw function we have been filtering */\r\n        oSettings.bFiltered = true\r\n        _fnCallbackFire(oSettings, null, 'search', [oSettings])\r\n      }\r\n\r\n      /**\r\n       * Apply custom filtering functions\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterCustom (settings) {\r\n        var filters = DataTable.ext.search\r\n        var displayRows = settings.aiDisplay\r\n        var row, rowIdx\r\n\r\n        for (var i = 0, ien = filters.length; i < ien; i++) {\r\n          var rows = []\r\n\r\n          // Loop over each row and see if it should be included\r\n          for (var j = 0, jen = displayRows.length; j < jen; j++) {\r\n            rowIdx = displayRows[j]\r\n            row = settings.aoData[rowIdx]\r\n\r\n            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {\r\n              rows.push(rowIdx)\r\n            }\r\n          }\r\n\r\n          // So the array reference doesn't break set the results into the\r\n          // existing array\r\n          displayRows.length = 0\r\n          displayRows.push.apply(displayRows, rows)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Filter the table on a per-column basis\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {string} sInput string to filter on\r\n       *  @param {int} iColumn column to filter\r\n       *  @param {bool} bRegex treat search string as a regular expression or not\r\n       *  @param {bool} bSmart use smart filtering or not\r\n       *  @param {bool} bCaseInsensitive Do case insenstive matching or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterColumn (settings, searchStr, colIdx, regex, smart, caseInsensitive) {\r\n        if (searchStr === '') {\r\n          return\r\n        }\r\n\r\n        var data\r\n        var display = settings.aiDisplay\r\n        var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive)\r\n\r\n        for (var i = display.length - 1; i >= 0; i--) {\r\n          data = settings.aoData[display[i]]._aFilterData[colIdx]\r\n\r\n          if (!rpSearch.test(data)) {\r\n            display.splice(i, 1)\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Filter the data table based on user input and draw the table\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {string} input string to filter on\r\n       *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\r\n       *  @param {bool} regex treat as a regular expression or not\r\n       *  @param {bool} smart perform smart filtering or not\r\n       *  @param {bool} caseInsensitive Do case insenstive matching or not\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilter (settings, input, force, regex, smart, caseInsensitive) {\r\n        var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive)\r\n        var prevSearch = settings.oPreviousSearch.sSearch\r\n        var displayMaster = settings.aiDisplayMaster\r\n        var display, invalidated, i\r\n\r\n        // Need to take account of custom filtering functions - always filter\r\n        if (DataTable.ext.search.length !== 0) {\r\n          force = true\r\n        }\r\n\r\n        // Check if any of the rows were invalidated\r\n        invalidated = _fnFilterData(settings)\r\n\r\n        // If the input is blank - we just want the full data set\r\n        if (input.length <= 0) {\r\n          settings.aiDisplay = displayMaster.slice()\r\n        } else {\r\n          // New search - start from the master array\r\n          if (\r\n            invalidated ||\r\n            force ||\r\n            prevSearch.length > input.length ||\r\n            input.indexOf(prevSearch) !== 0 ||\r\n            settings.bSorted // On resort, the display master needs to be\r\n            // re-filtered since indexes will have changed\r\n          ) {\r\n            settings.aiDisplay = displayMaster.slice()\r\n          }\r\n\r\n          // Search the display array\r\n          display = settings.aiDisplay\r\n\r\n          for (i = display.length - 1; i >= 0; i--) {\r\n            if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {\r\n              display.splice(i, 1)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Build a regular expression object suitable for searching a table\r\n       *  @param {string} sSearch string to search for\r\n       *  @param {bool} bRegex treat as a regular expression or not\r\n       *  @param {bool} bSmart perform smart filtering or not\r\n       *  @param {bool} bCaseInsensitive Do case insensitive matching or not\r\n       *  @returns {RegExp} constructed object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFilterCreateSearch (search, regex, smart, caseInsensitive) {\r\n        search = regex ? search : _fnEscapeRegex(search)\r\n\r\n        if (smart) {\r\n          /* For smart filtering we want to allow the search to work regardless of\r\n           * word order. We also want double quoted text to be preserved, so word\r\n           * order is important - a la google. So this is what we want to\r\n           * generate:\r\n           *\r\n           * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\r\n           */\r\n          var a = $.map(search.match(/\"[^\"]+\"|[^ ]+/g) || '', function (word) {\r\n            return word.charAt(0) === '\"' ? word.match(/^\"(.*)\"$/)[1] : word\r\n          })\r\n\r\n          search = '^(?=.*?' + a.join(')(?=.*?') + ').*$'\r\n        }\r\n\r\n        return new RegExp(search, caseInsensitive ? 'i' : '')\r\n      }\r\n\r\n      /**\r\n       * scape a string such that it can be used in a regular expression\r\n       *  @param {string} sVal string to escape\r\n       *  @returns {string} escaped string\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnEscapeRegex (sVal) {\r\n        return sVal.replace(_re_escape_regex, '\\\\$1')\r\n      }\r\n\r\n      var __filter_div = $('<div>')[0]\r\n      var __filter_div_textContent = __filter_div.textContent !== undefined\r\n\r\n      // Update the filtering data for each row if needed (by invalidation or first run)\r\n      function _fnFilterData (settings) {\r\n        var columns = settings.aoColumns\r\n        var column\r\n        var i, j, ien, jen, filterData, cellData, row\r\n        var fomatters = DataTable.ext.type.search\r\n        var wasInvalidated = false\r\n\r\n        for (i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n          row = settings.aoData[i]\r\n\r\n          if (!row._aFilterData) {\r\n            filterData = []\r\n\r\n            for (j = 0, jen = columns.length; j < jen; j++) {\r\n              column = columns[j]\r\n\r\n              if (column.bSearchable) {\r\n                cellData = _fnGetCellData(settings, i, j, 'filter')\r\n\r\n                if (fomatters[column.sType]) {\r\n                  cellData = fomatters[column.sType](cellData)\r\n                }\r\n\r\n                // Search in DataTables 1.10 is string based. In 1.11 this\r\n                // should be altered to also allow strict type checking.\r\n                if (cellData === null) {\r\n                  cellData = ''\r\n                }\r\n\r\n                if (typeof cellData !== 'string' && cellData.toString) {\r\n                  cellData = cellData.toString()\r\n                }\r\n              } else {\r\n                cellData = ''\r\n              }\r\n\r\n              // If it looks like there is an HTML entity in the string,\r\n              // attempt to decode it so sorting works as expected. Note that\r\n              // we could use a single line of jQuery to do this, but the DOM\r\n              // method used here is much faster http://jsperf.com/html-decode\r\n              if (cellData.indexOf && cellData.indexOf('&') !== -1) {\r\n                __filter_div.innerHTML = cellData\r\n                cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText\r\n              }\r\n\r\n              if (cellData.replace) {\r\n                cellData = cellData.replace(/[\\r\\n]/g, '')\r\n              }\r\n\r\n              filterData.push(cellData)\r\n            }\r\n\r\n            row._aFilterData = filterData\r\n            row._sFilterRow = filterData.join('  ')\r\n            wasInvalidated = true\r\n          }\r\n        }\r\n\r\n        return wasInvalidated\r\n      }\r\n\r\n      /**\r\n       * Convert from the internal Hungarian notation to camelCase for external\r\n       * interaction\r\n       *  @param {object} obj Object to convert\r\n       *  @returns {object} Inverted object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSearchToCamel (obj) {\r\n        return {\r\n          search: obj.sSearch,\r\n          smart: obj.bSmart,\r\n          regex: obj.bRegex,\r\n          caseInsensitive: obj.bCaseInsensitive\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Convert from camelCase notation to the internal Hungarian. We could use the\r\n       * Hungarian convert function here, but this is cleaner\r\n       *  @param {object} obj Object to convert\r\n       *  @returns {object} Inverted object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSearchToHung (obj) {\r\n        return {\r\n          sSearch: obj.search,\r\n          bSmart: obj.smart,\r\n          bRegex: obj.regex,\r\n          bCaseInsensitive: obj.caseInsensitive\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for the info display\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {node} Information element\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlInfo (settings) {\r\n        var tid = settings.sTableId,\r\n          nodes = settings.aanFeatures.i,\r\n          n = $('<div/>', {\r\n            class: settings.oClasses.sInfo,\r\n            id: !nodes ? tid + '_info' : null\r\n          })\r\n\r\n        if (!nodes) {\r\n          // Update display on each draw\r\n          settings.aoDrawCallback.push({\r\n            fn: _fnUpdateInfo,\r\n            sName: 'information'\r\n          })\r\n\r\n          n.attr('role', 'status').attr('aria-live', 'polite')\r\n\r\n          // Table is described by our info div\r\n          $(settings.nTable).attr('aria-describedby', tid + '_info')\r\n        }\r\n\r\n        return n[0]\r\n      }\r\n\r\n      /**\r\n       * Update the information elements in the display\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnUpdateInfo (settings) {\r\n        /* Show information about the table */\r\n        var nodes = settings.aanFeatures.i\r\n        if (nodes.length === 0) {\r\n          return\r\n        }\r\n\r\n        var lang = settings.oLanguage,\r\n          start = settings._iDisplayStart + 1,\r\n          end = settings.fnDisplayEnd(),\r\n          max = settings.fnRecordsTotal(),\r\n          total = settings.fnRecordsDisplay(),\r\n          out = total ? lang.sInfo : lang.sInfoEmpty\r\n\r\n        if (total !== max) {\r\n          /* Record set after filtering */\r\n          out += ' ' + lang.sInfoFiltered\r\n        }\r\n\r\n        // Convert the macros\r\n        out += lang.sInfoPostFix\r\n        out = _fnInfoMacros(settings, out)\r\n\r\n        var callback = lang.fnInfoCallback\r\n        if (callback !== null) {\r\n          out = callback.call(settings.oInstance, settings, start, end, max, total, out)\r\n        }\r\n\r\n        $(nodes).html(out)\r\n      }\r\n\r\n      function _fnInfoMacros (settings, str) {\r\n        // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\r\n        // internally\r\n        var formatter = settings.fnFormatNumber,\r\n          start = settings._iDisplayStart + 1,\r\n          len = settings._iDisplayLength,\r\n          vis = settings.fnRecordsDisplay(),\r\n          all = len === -1\r\n\r\n        return str\r\n          .replace(/_START_/g, formatter.call(settings, start))\r\n          .replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd()))\r\n          .replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal()))\r\n          .replace(/_TOTAL_/g, formatter.call(settings, vis))\r\n          .replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len)))\r\n          .replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)))\r\n      }\r\n\r\n      /**\r\n       * Draw the table for the first time, adding all required features\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnInitialise (settings) {\r\n        var i,\r\n          iLen,\r\n          iAjaxStart = settings.iInitDisplayStart\r\n        var columns = settings.aoColumns,\r\n          column\r\n        var features = settings.oFeatures\r\n\r\n        /* Ensure that the table data is fully initialised */\r\n        if (!settings.bInitialised) {\r\n          setTimeout(function () {\r\n            _fnInitialise(settings)\r\n          }, 200)\r\n          return\r\n        }\r\n\r\n        /* Show the display HTML options */\r\n        _fnAddOptionsHtml(settings)\r\n\r\n        /* Build and draw the header / footer for the table */\r\n        _fnBuildHead(settings)\r\n        _fnDrawHead(settings, settings.aoHeader)\r\n        _fnDrawHead(settings, settings.aoFooter)\r\n\r\n        /* Okay to show that something is going on now */\r\n        _fnProcessingDisplay(settings, true)\r\n\r\n        /* Calculate sizes for columns */\r\n        if (features.bAutoWidth) {\r\n          _fnCalculateColumnWidths(settings)\r\n        }\r\n\r\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\r\n          column = columns[i]\r\n\r\n          if (column.sWidth) {\r\n            column.nTh.style.width = _fnStringToCss(column.sWidth)\r\n          }\r\n        }\r\n\r\n        // If there is default sorting required - let's do it. The sort function\r\n        // will do the drawing for us. Otherwise we draw the table regardless of the\r\n        // Ajax source - this allows the table to look initialised for Ajax sourcing\r\n        // data (show 'loading' message possibly)\r\n        _fnReDraw(settings)\r\n\r\n        // Server-side processing init complete is done by _fnAjaxUpdateDraw\r\n        var dataSrc = _fnDataSource(settings)\r\n        if (dataSrc != 'ssp') {\r\n          // if there is an ajax source load the data\r\n          if (dataSrc == 'ajax') {\r\n            _fnBuildAjax(\r\n              settings,\r\n              [],\r\n              function (json) {\r\n                var aData = _fnAjaxDataSrc(settings, json)\r\n\r\n                // Got the data - add it to the table\r\n                for (i = 0; i < aData.length; i++) {\r\n                  _fnAddData(settings, aData[i])\r\n                }\r\n\r\n                // Reset the init display for cookie saving. We've already done\r\n                // a filter, and therefore cleared it before. So we need to make\r\n                // it appear 'fresh'\r\n                settings.iInitDisplayStart = iAjaxStart\r\n\r\n                _fnReDraw(settings)\r\n\r\n                _fnProcessingDisplay(settings, false)\r\n                _fnInitComplete(settings, json)\r\n              },\r\n              settings\r\n            )\r\n          } else {\r\n            _fnProcessingDisplay(settings, false)\r\n            _fnInitComplete(settings)\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Draw the table for the first time, adding all required features\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\r\n       *    with client-side processing (optional)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnInitComplete (settings, json) {\r\n        settings._bInitComplete = true\r\n\r\n        // On an Ajax load we now have data and therefore want to apply the column\r\n        // sizing\r\n        if (json) {\r\n          _fnAdjustColumnSizing(settings)\r\n        }\r\n\r\n        _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json])\r\n      }\r\n\r\n      function _fnLengthChange (settings, val) {\r\n        var len = parseInt(val, 10)\r\n        settings._iDisplayLength = len\r\n\r\n        _fnLengthOverflow(settings)\r\n\r\n        // Fire length change event\r\n        _fnCallbackFire(settings, null, 'length', [settings, len])\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for user display length changing\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {node} Display length feature node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlLength (settings) {\r\n        var classes = settings.oClasses,\r\n          tableId = settings.sTableId,\r\n          menu = settings.aLengthMenu,\r\n          d2 = $.isArray(menu[0]),\r\n          lengths = d2 ? menu[0] : menu,\r\n          language = d2 ? menu[1] : menu\r\n\r\n        var select = $('<select/>', {\r\n          name: tableId + '_length',\r\n          'aria-controls': tableId,\r\n          class: classes.sLengthSelect\r\n        })\r\n\r\n        for (var i = 0, ien = lengths.length; i < ien; i++) {\r\n          select[0][i] = new Option(language[i], lengths[i])\r\n        }\r\n\r\n        var div = $('<div><label/></div>').addClass(classes.sLength)\r\n        if (!settings.aanFeatures.l) {\r\n          div[0].id = tableId + '_length'\r\n        }\r\n\r\n        div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML))\r\n\r\n        // Can't use `select` variable as user might provide their own and the\r\n        // reference is broken by the use of outerHTML\r\n        $('select', div)\r\n          .val(settings._iDisplayLength)\r\n          .bind('change.DT', function (e) {\r\n            _fnLengthChange(settings, $(this).val())\r\n            _fnDraw(settings)\r\n          })\r\n\r\n        // Update node value whenever anything changes the table's length\r\n        $(settings.nTable).bind('length.dt.DT', function (e, s, len) {\r\n          if (settings === s) {\r\n            $('select', div).val(len)\r\n          }\r\n        })\r\n\r\n        return div[0]\r\n      }\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Note that most of the paging logic is done in\r\n       * DataTable.ext.pager\r\n       */\r\n\r\n      /**\r\n       * Generate the node required for default pagination\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @returns {node} Pagination feature node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlPaginate (settings) {\r\n        var type = settings.sPaginationType,\r\n          plugin = DataTable.ext.pager[type],\r\n          modern = typeof plugin === 'function',\r\n          redraw = function (settings) {\r\n            _fnDraw(settings)\r\n          },\r\n          node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],\r\n          features = settings.aanFeatures\r\n\r\n        if (!modern) {\r\n          plugin.fnInit(settings, node, redraw)\r\n        }\r\n\r\n        /* Add a draw callback for the pagination on first instance, to update the paging display */\r\n        if (!features.p) {\r\n          node.id = settings.sTableId + '_paginate'\r\n\r\n          settings.aoDrawCallback.push({\r\n            fn: function (settings) {\r\n              if (modern) {\r\n                var start = settings._iDisplayStart,\r\n                  len = settings._iDisplayLength,\r\n                  visRecords = settings.fnRecordsDisplay(),\r\n                  all = len === -1,\r\n                  page = all ? 0 : Math.ceil(start / len),\r\n                  pages = all ? 1 : Math.ceil(visRecords / len),\r\n                  buttons = plugin(page, pages),\r\n                  i,\r\n                  ien\r\n\r\n                for (i = 0, ien = features.p.length; i < ien; i++) {\r\n                  _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages)\r\n                }\r\n              } else {\r\n                plugin.fnUpdate(settings, redraw)\r\n              }\r\n            },\r\n            sName: 'pagination'\r\n          })\r\n        }\r\n\r\n        return node\r\n      }\r\n\r\n      /**\r\n       * Alter the display settings to change the page\r\n       *  @param {object} settings DataTables settings object\r\n       *  @param {string|int} action Paging action to take: \"first\", \"previous\",\r\n       *    \"next\" or \"last\" or page number to jump to (integer)\r\n       *  @param [bool] redraw Automatically draw the update or not\r\n       *  @returns {bool} true page has changed, false - no change\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnPageChange (settings, action, redraw) {\r\n        var start = settings._iDisplayStart,\r\n          len = settings._iDisplayLength,\r\n          records = settings.fnRecordsDisplay()\r\n\r\n        if (records === 0 || len === -1) {\r\n          start = 0\r\n        } else if (typeof action === 'number') {\r\n          start = action * len\r\n\r\n          if (start > records) {\r\n            start = 0\r\n          }\r\n        } else if (action == 'first') {\r\n          start = 0\r\n        } else if (action == 'previous') {\r\n          start = len >= 0 ? start - len : 0\r\n\r\n          if (start < 0) {\r\n            start = 0\r\n          }\r\n        } else if (action == 'next') {\r\n          if (start + len < records) {\r\n            start += len\r\n          }\r\n        } else if (action == 'last') {\r\n          start = Math.floor((records - 1) / len) * len\r\n        } else {\r\n          _fnLog(settings, 0, 'Unknown paging action: ' + action, 5)\r\n        }\r\n\r\n        var changed = settings._iDisplayStart !== start\r\n        settings._iDisplayStart = start\r\n\r\n        if (changed) {\r\n          _fnCallbackFire(settings, null, 'page', [settings])\r\n\r\n          if (redraw) {\r\n            _fnDraw(settings)\r\n          }\r\n        }\r\n\r\n        return changed\r\n      }\r\n\r\n      /**\r\n       * Generate the node required for the processing node\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {node} Processing element\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlProcessing (settings) {\r\n        return $('<div/>', {\r\n          id: !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,\r\n          class: settings.oClasses.sProcessing\r\n        })\r\n          .html(settings.oLanguage.sProcessing)\r\n          .insertBefore(settings.nTable)[0]\r\n      }\r\n\r\n      /**\r\n       * Display or hide the processing indicator\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {bool} show Show the processing indicator (true) or not (false)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnProcessingDisplay (settings, show) {\r\n        if (settings.oFeatures.bProcessing) {\r\n          $(settings.aanFeatures.r).css('display', show ? 'block' : 'none')\r\n        }\r\n\r\n        _fnCallbackFire(settings, null, 'processing', [settings, show])\r\n      }\r\n\r\n      /**\r\n       * Add any control elements for the table - specifically scrolling\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {node} Node to add to the DOM\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnFeatureHtmlTable (settings) {\r\n        var table = $(settings.nTable)\r\n\r\n        // Add the ARIA grid role to the table\r\n        table.attr('role', 'grid')\r\n\r\n        // Scrolling from here on in\r\n        var scroll = settings.oScroll\r\n\r\n        if (scroll.sX === '' && scroll.sY === '') {\r\n          return settings.nTable\r\n        }\r\n\r\n        var scrollX = scroll.sX\r\n        var scrollY = scroll.sY\r\n        var classes = settings.oClasses\r\n        var caption = table.children('caption')\r\n        var captionSide = caption.length ? caption[0]._captionSide : null\r\n        var headerClone = $(table[0].cloneNode(false))\r\n        var footerClone = $(table[0].cloneNode(false))\r\n        var footer = table.children('tfoot')\r\n        var _div = '<div/>'\r\n        var size = function (s) {\r\n          return !s ? null : _fnStringToCss(s)\r\n        }\r\n\r\n        // This is fairly messy, but with x scrolling enabled, if the table has a\r\n        // width attribute, regardless of any width applied using the column width\r\n        // options, the browser will shrink or grow the table as needed to fit into\r\n        // that 100%. That would make the width options useless. So we remove it.\r\n        // This is okay, under the assumption that width:100% is applied to the\r\n        // table in CSS (it is in the default stylesheet) which will set the table\r\n        // width as appropriate (the attribute and css behave differently...)\r\n        if (scroll.sX && table.attr('width') === '100%') {\r\n          table.removeAttr('width')\r\n        }\r\n\r\n        if (!footer.length) {\r\n          footer = null\r\n        }\r\n\r\n        /*\r\n         * The HTML structure that we want to generate in this function is:\r\n         *  div - scroller\r\n         *    div - scroll head\r\n         *      div - scroll head inner\r\n         *        table - scroll head table\r\n         *          thead - thead\r\n         *    div - scroll body\r\n         *      table - table (master table)\r\n         *        thead - thead clone for sizing\r\n         *        tbody - tbody\r\n         *    div - scroll foot\r\n         *      div - scroll foot inner\r\n         *        table - scroll foot table\r\n         *          tfoot - tfoot\r\n         */\r\n        var scroller = $(_div, { class: classes.sScrollWrapper })\r\n          .append(\r\n            $(_div, { class: classes.sScrollHead })\r\n              .css({\r\n                overflow: 'hidden',\r\n                position: 'relative',\r\n                border: 0,\r\n                width: scrollX ? size(scrollX) : '100%'\r\n              })\r\n              .append(\r\n                $(_div, { class: classes.sScrollHeadInner })\r\n                  .css({\r\n                    'box-sizing': 'content-box',\r\n                    width: scroll.sXInner || '100%'\r\n                  })\r\n                  .append(\r\n                    headerClone\r\n                      .removeAttr('id')\r\n                      .css('margin-left', 0)\r\n                      .append(table.children('thead'))\r\n                  )\r\n              )\r\n              .append(captionSide === 'top' ? caption : null)\r\n          )\r\n          .append(\r\n            $(_div, { class: classes.sScrollBody })\r\n              .css({\r\n                overflow: 'auto',\r\n                height: size(scrollY),\r\n                width: size(scrollX)\r\n              })\r\n              .append(table)\r\n          )\r\n\r\n        if (footer) {\r\n          scroller.append(\r\n            $(_div, { class: classes.sScrollFoot })\r\n              .css({\r\n                overflow: 'hidden',\r\n                border: 0,\r\n                width: scrollX ? size(scrollX) : '100%'\r\n              })\r\n              .append(\r\n                $(_div, { class: classes.sScrollFootInner }).append(\r\n                  footerClone\r\n                    .removeAttr('id')\r\n                    .css('margin-left', 0)\r\n                    .append(table.children('tfoot'))\r\n                )\r\n              )\r\n              .append(captionSide === 'bottom' ? caption : null)\r\n          )\r\n        }\r\n\r\n        var children = scroller.children()\r\n        var scrollHead = children[0]\r\n        var scrollBody = children[1]\r\n        var scrollFoot = footer ? children[2] : null\r\n\r\n        // When the body is scrolled, then we also want to scroll the headers\r\n        if (scrollX) {\r\n          $(scrollBody).scroll(function (e) {\r\n            var scrollLeft = this.scrollLeft\r\n\r\n            scrollHead.scrollLeft = scrollLeft\r\n\r\n            if (footer) {\r\n              scrollFoot.scrollLeft = scrollLeft\r\n            }\r\n          })\r\n        }\r\n\r\n        settings.nScrollHead = scrollHead\r\n        settings.nScrollBody = scrollBody\r\n        settings.nScrollFoot = scrollFoot\r\n\r\n        // On redraw - align columns\r\n        settings.aoDrawCallback.push({\r\n          fn: _fnScrollDraw,\r\n          sName: 'scrolling'\r\n        })\r\n\r\n        return scroller[0]\r\n      }\r\n\r\n      /**\r\n       * Update the header, footer and body tables for resizing - i.e. column\r\n       * alignment.\r\n       *\r\n       * Welcome to the most horrible function DataTables. The process that this\r\n       * function follows is basically:\r\n       *   1. Re-create the table inside the scrolling div\r\n       *   2. Take live measurements from the DOM\r\n       *   3. Apply the measurements to align the columns\r\n       *   4. Clean up\r\n       *\r\n       *  @param {object} settings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnScrollDraw (settings) {\r\n        // Given that this is such a monster function, a lot of variables are use\r\n        // to try and keep the minimised size as small as possible\r\n        var scroll = settings.oScroll,\r\n          scrollX = scroll.sX,\r\n          scrollXInner = scroll.sXInner,\r\n          scrollY = scroll.sY,\r\n          barWidth = scroll.iBarWidth,\r\n          divHeader = $(settings.nScrollHead),\r\n          divHeaderStyle = divHeader[0].style,\r\n          divHeaderInner = divHeader.children('div'),\r\n          divHeaderInnerStyle = divHeaderInner[0].style,\r\n          divHeaderTable = divHeaderInner.children('table'),\r\n          divBodyEl = settings.nScrollBody,\r\n          divBody = $(divBodyEl),\r\n          divBodyStyle = divBodyEl.style,\r\n          divFooter = $(settings.nScrollFoot),\r\n          divFooterInner = divFooter.children('div'),\r\n          divFooterTable = divFooterInner.children('table'),\r\n          header = $(settings.nTHead),\r\n          table = $(settings.nTable),\r\n          tableEl = table[0],\r\n          tableStyle = tableEl.style,\r\n          footer = settings.nTFoot ? $(settings.nTFoot) : null,\r\n          browser = settings.oBrowser,\r\n          ie67 = browser.bScrollOversize,\r\n          headerTrgEls,\r\n          footerTrgEls,\r\n          headerSrcEls,\r\n          footerSrcEls,\r\n          headerCopy,\r\n          footerCopy,\r\n          headerWidths = [],\r\n          footerWidths = [],\r\n          headerContent = [],\r\n          idx,\r\n          correction,\r\n          sanityWidth,\r\n          zeroOut = function (nSizer) {\r\n            var style = nSizer.style\r\n            style.paddingTop = '0'\r\n            style.paddingBottom = '0'\r\n            style.borderTopWidth = '0'\r\n            style.borderBottomWidth = '0'\r\n            style.height = 0\r\n          }\r\n\r\n        /*\r\n         * 1. Re-create the table inside the scrolling div\r\n         */\r\n\r\n        // Remove the old minimised thead and tfoot elements in the inner table\r\n        table.children('thead, tfoot').remove()\r\n\r\n        // Clone the current header and footer elements and then place it into the inner table\r\n        headerCopy = header.clone().prependTo(table)\r\n        headerTrgEls = header.find('tr') // original header is in its own table\r\n        headerSrcEls = headerCopy.find('tr')\r\n        headerCopy.find('th, td').removeAttr('tabindex')\r\n\r\n        if (footer) {\r\n          footerCopy = footer.clone().prependTo(table)\r\n          footerTrgEls = footer.find('tr') // the original tfoot is in its own table and must be sized\r\n          footerSrcEls = footerCopy.find('tr')\r\n        }\r\n\r\n        /*\r\n         * 2. Take live measurements from the DOM - do not alter the DOM itself!\r\n         */\r\n\r\n        // Remove old sizing and apply the calculated column widths\r\n        // Get the unique column headers in the newly created (cloned) header. We want to apply the\r\n        // calculated sizes to this header\r\n        if (!scrollX) {\r\n          divBodyStyle.width = '100%'\r\n          divHeader[0].style.width = '100%'\r\n        }\r\n\r\n        $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {\r\n          idx = _fnVisibleToColumnIndex(settings, i)\r\n          el.style.width = settings.aoColumns[idx].sWidth\r\n        })\r\n\r\n        if (footer) {\r\n          _fnApplyToChildren(function (n) {\r\n            n.style.width = ''\r\n          }, footerSrcEls)\r\n        }\r\n\r\n        // If scroll collapse is enabled, when we put the headers back into the body for sizing, we\r\n        // will end up forcing the scrollbar to appear, making our measurements wrong for when we\r\n        // then hide it (end of this function), so add the header height to the body scroller.\r\n        if (scroll.bCollapse && scrollY !== '') {\r\n          divBodyStyle.height = divBody[0].offsetHeight + header[0].offsetHeight + 'px'\r\n        }\r\n\r\n        // Size the table as a whole\r\n        sanityWidth = table.outerWidth()\r\n        if (scrollX === '') {\r\n          // No x scrolling\r\n          tableStyle.width = '100%'\r\n\r\n          // IE7 will make the width of the table when 100% include the scrollbar\r\n          // - which is shouldn't. When there is a scrollbar we need to take this\r\n          // into account.\r\n          if (\r\n            ie67 &&\r\n            (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')\r\n          ) {\r\n            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth)\r\n          }\r\n        } else {\r\n          // x scrolling\r\n          if (scrollXInner !== '') {\r\n            // x scroll inner has been given - use it\r\n            tableStyle.width = _fnStringToCss(scrollXInner)\r\n          } else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {\r\n            // There is y-scrolling - try to take account of the y scroll bar\r\n            tableStyle.width = _fnStringToCss(sanityWidth - barWidth)\r\n            if (table.outerWidth() > sanityWidth - barWidth) {\r\n              // Not possible to take account of it\r\n              tableStyle.width = _fnStringToCss(sanityWidth)\r\n            }\r\n          } else {\r\n            // When all else fails\r\n            tableStyle.width = _fnStringToCss(sanityWidth)\r\n          }\r\n        }\r\n\r\n        // Recalculate the sanity width - now that we've applied the required width,\r\n        // before it was a temporary variable. This is required because the column\r\n        // width calculation is done before this table DOM is created.\r\n        sanityWidth = table.outerWidth()\r\n\r\n        // Hidden header should have zero height, so remove padding and borders. Then\r\n        // set the width based on the real headers\r\n\r\n        // Apply all styles in one pass\r\n        _fnApplyToChildren(zeroOut, headerSrcEls)\r\n\r\n        // Read all widths in next pass\r\n        _fnApplyToChildren(function (nSizer) {\r\n          headerContent.push(nSizer.innerHTML)\r\n          headerWidths.push(_fnStringToCss($(nSizer).css('width')))\r\n        }, headerSrcEls)\r\n\r\n        // Apply all widths in final pass\r\n        _fnApplyToChildren(function (nToSize, i) {\r\n          nToSize.style.width = headerWidths[i]\r\n        }, headerTrgEls)\r\n\r\n        $(headerSrcEls).height(0)\r\n\r\n        /* Same again with the footer if we have one */\r\n        if (footer) {\r\n          _fnApplyToChildren(zeroOut, footerSrcEls)\r\n\r\n          _fnApplyToChildren(function (nSizer) {\r\n            footerWidths.push(_fnStringToCss($(nSizer).css('width')))\r\n          }, footerSrcEls)\r\n\r\n          _fnApplyToChildren(function (nToSize, i) {\r\n            nToSize.style.width = footerWidths[i]\r\n          }, footerTrgEls)\r\n\r\n          $(footerSrcEls).height(0)\r\n        }\r\n\r\n        /*\r\n         * 3. Apply the measurements\r\n         */\r\n\r\n        // \"Hide\" the header and footer that we used for the sizing. We need to keep\r\n        // the content of the cell so that the width applied to the header and body\r\n        // both match, but we want to hide it completely. We want to also fix their\r\n        // width to what they currently are\r\n        _fnApplyToChildren(function (nSizer, i) {\r\n          nSizer.innerHTML =\r\n            '<div class=\"dataTables_sizing\" style=\"height:0;overflow:hidden;\">' + headerContent[i] + '</div>'\r\n          nSizer.style.width = headerWidths[i]\r\n        }, headerSrcEls)\r\n\r\n        if (footer) {\r\n          _fnApplyToChildren(function (nSizer, i) {\r\n            nSizer.innerHTML = ''\r\n            nSizer.style.width = footerWidths[i]\r\n          }, footerSrcEls)\r\n        }\r\n\r\n        // Sanity check that the table is of a sensible width. If not then we are going to get\r\n        // misalignment - try to prevent this by not allowing the table to shrink below its min width\r\n        if (table.outerWidth() < sanityWidth) {\r\n          // The min width depends upon if we have a vertical scrollbar visible or not */\r\n          correction =\r\n            divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll'\r\n              ? sanityWidth + barWidth\r\n              : sanityWidth\r\n\r\n          // IE6/7 are a law unto themselves...\r\n          if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')) {\r\n            tableStyle.width = _fnStringToCss(correction - barWidth)\r\n          }\r\n\r\n          // And give the user a warning that we've stopped the table getting too small\r\n          if (scrollX === '' || scrollXInner !== '') {\r\n            _fnLog(settings, 1, 'Possible column misalignment', 6)\r\n          }\r\n        } else {\r\n          correction = '100%'\r\n        }\r\n\r\n        // Apply to the container elements\r\n        divBodyStyle.width = _fnStringToCss(correction)\r\n        divHeaderStyle.width = _fnStringToCss(correction)\r\n\r\n        if (footer) {\r\n          settings.nScrollFoot.style.width = _fnStringToCss(correction)\r\n        }\r\n\r\n        /*\r\n         * 4. Clean up\r\n         */\r\n        if (!scrollY) {\r\n          /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\r\n           * the scrollbar height from the visible display, rather than adding it on. We need to\r\n           * set the height in order to sort this. Don't want to do it in any other browsers.\r\n           */\r\n          if (ie67) {\r\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth)\r\n          }\r\n        }\r\n\r\n        if (scrollY && scroll.bCollapse) {\r\n          divBodyStyle.height = _fnStringToCss(scrollY)\r\n\r\n          var iExtra = scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth ? barWidth : 0\r\n\r\n          if (tableEl.offsetHeight < divBodyEl.offsetHeight) {\r\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra)\r\n          }\r\n        }\r\n\r\n        /* Finally set the width's of the header and footer tables */\r\n        var iOuterWidth = table.outerWidth()\r\n        divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth)\r\n        divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth)\r\n\r\n        // Figure out if there are scrollbar present - if so then we need a the header and footer to\r\n        // provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\r\n        var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == 'scroll'\r\n        var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right')\r\n        divHeaderInnerStyle[padding] = bScrolling ? barWidth + 'px' : '0px'\r\n\r\n        if (footer) {\r\n          divFooterTable[0].style.width = _fnStringToCss(iOuterWidth)\r\n          divFooterInner[0].style.width = _fnStringToCss(iOuterWidth)\r\n          divFooterInner[0].style[padding] = bScrolling ? barWidth + 'px' : '0px'\r\n        }\r\n\r\n        /* Adjust the position of the header in case we loose the y-scrollbar */\r\n        divBody.scroll()\r\n\r\n        // If sorting or filtering has occurred, jump the scrolling back to the top\r\n        // only if we aren't holding the position\r\n        if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {\r\n          divBodyEl.scrollTop = 0\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Apply a given function to the display child nodes of an element array (typically\r\n       * TD children of TR rows\r\n       *  @param {function} fn Method to apply to the objects\r\n       *  @param array {nodes} an1 List of elements to look through for display children\r\n       *  @param array {nodes} an2 Another list (identical structure to the first) - optional\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnApplyToChildren (fn, an1, an2) {\r\n        var index = 0,\r\n          i = 0,\r\n          iLen = an1.length\r\n        var nNode1, nNode2\r\n\r\n        while (i < iLen) {\r\n          nNode1 = an1[i].firstChild\r\n          nNode2 = an2 ? an2[i].firstChild : null\r\n\r\n          while (nNode1) {\r\n            if (nNode1.nodeType === 1) {\r\n              if (an2) {\r\n                fn(nNode1, nNode2, index)\r\n              } else {\r\n                fn(nNode1, index)\r\n              }\r\n\r\n              index++\r\n            }\r\n\r\n            nNode1 = nNode1.nextSibling\r\n            nNode2 = an2 ? nNode2.nextSibling : null\r\n          }\r\n\r\n          i++\r\n        }\r\n      }\r\n\r\n      var __re_html_remove = /<.*?>/g\r\n\r\n      /**\r\n       * Calculate the width of columns for the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCalculateColumnWidths (oSettings) {\r\n        var table = oSettings.nTable,\r\n          columns = oSettings.aoColumns,\r\n          scroll = oSettings.oScroll,\r\n          scrollY = scroll.sY,\r\n          scrollX = scroll.sX,\r\n          scrollXInner = scroll.sXInner,\r\n          columnCount = columns.length,\r\n          visibleColumns = _fnGetColumns(oSettings, 'bVisible'),\r\n          headerCells = $('th', oSettings.nTHead),\r\n          tableWidthAttr = table.getAttribute('width'),\r\n          tableContainer = table.parentNode,\r\n          userInputs = false,\r\n          i,\r\n          column,\r\n          columnIdx,\r\n          width,\r\n          outerWidth\r\n\r\n        /* Convert any user input sizes into pixel sizes */\r\n        for (i = 0; i < visibleColumns.length; i++) {\r\n          column = columns[visibleColumns[i]]\r\n\r\n          if (column.sWidth !== null) {\r\n            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer)\r\n\r\n            userInputs = true\r\n          }\r\n        }\r\n\r\n        /* If the number of columns in the DOM equals the number that we have to\r\n         * process in DataTables, then we can use the offsets that are created by\r\n         * the web- browser. No custom sizes can be set in order for this to happen,\r\n         * nor scrolling used\r\n         */\r\n        if (\r\n          !userInputs &&\r\n          !scrollX &&\r\n          !scrollY &&\r\n          columnCount == _fnVisbleColumns(oSettings) &&\r\n          columnCount == headerCells.length\r\n        ) {\r\n          for (i = 0; i < columnCount; i++) {\r\n            columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width())\r\n          }\r\n        } else {\r\n          // Otherwise construct a single row table with the widest node in the\r\n          // data, assign any user defined widths, then insert it into the DOM and\r\n          // allow the browser to do all the hard work of calculating table widths\r\n          var tmpTable = $(table)\r\n            .clone() // don't use cloneNode - IE8 will remove events on the main table\r\n            .empty()\r\n            .css('visibility', 'hidden')\r\n            .removeAttr('id')\r\n            .append($(oSettings.nTHead).clone(false))\r\n            .append($(oSettings.nTFoot).clone(false))\r\n            .append($('<tbody><tr/></tbody>'))\r\n\r\n          // Remove any assigned widths from the footer (from scrolling)\r\n          tmpTable.find('tfoot th, tfoot td').css('width', '')\r\n\r\n          var tr = tmpTable.find('tbody tr')\r\n\r\n          // Apply custom sizing to the cloned header\r\n          headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0])\r\n\r\n          for (i = 0; i < visibleColumns.length; i++) {\r\n            column = columns[visibleColumns[i]]\r\n\r\n            headerCells[i].style.width =\r\n              column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''\r\n          }\r\n\r\n          // Find the widest cell for each column and put it into the table\r\n          if (oSettings.aoData.length) {\r\n            for (i = 0; i < visibleColumns.length; i++) {\r\n              columnIdx = visibleColumns[i]\r\n              column = columns[columnIdx]\r\n\r\n              $(_fnGetWidestNode(oSettings, columnIdx))\r\n                .clone(false)\r\n                .append(column.sContentPadding)\r\n                .appendTo(tr)\r\n            }\r\n          }\r\n\r\n          // Table has been built, attach to the document so we can work with it\r\n          tmpTable.appendTo(tableContainer)\r\n\r\n          // When scrolling (X or Y) we want to set the width of the table as\r\n          // appropriate. However, when not scrolling leave the table width as it\r\n          // is. This results in slightly different, but I think correct behaviour\r\n          if (scrollX && scrollXInner) {\r\n            tmpTable.width(scrollXInner)\r\n          } else if (scrollX) {\r\n            tmpTable.css('width', 'auto')\r\n\r\n            if (tmpTable.width() < tableContainer.offsetWidth) {\r\n              tmpTable.width(tableContainer.offsetWidth)\r\n            }\r\n          } else if (scrollY) {\r\n            tmpTable.width(tableContainer.offsetWidth)\r\n          } else if (tableWidthAttr) {\r\n            tmpTable.width(tableWidthAttr)\r\n          }\r\n\r\n          // Take into account the y scrollbar\r\n          _fnScrollingWidthAdjust(oSettings, tmpTable[0])\r\n\r\n          // Browsers need a bit of a hand when a width is assigned to any columns\r\n          // when x-scrolling as they tend to collapse the table to the min-width,\r\n          // even if we sent the column widths. So we need to keep track of what\r\n          // the table width should be by summing the user given values, and the\r\n          // automatic values\r\n          if (scrollX) {\r\n            var total = 0\r\n\r\n            for (i = 0; i < visibleColumns.length; i++) {\r\n              column = columns[visibleColumns[i]]\r\n              outerWidth = $(headerCells[i]).outerWidth()\r\n\r\n              total +=\r\n                column.sWidthOrig === null\r\n                  ? outerWidth\r\n                  : parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width()\r\n            }\r\n\r\n            tmpTable.width(_fnStringToCss(total))\r\n            table.style.width = _fnStringToCss(total)\r\n          }\r\n\r\n          // Get the width of each column in the constructed table\r\n          for (i = 0; i < visibleColumns.length; i++) {\r\n            column = columns[visibleColumns[i]]\r\n            width = $(headerCells[i]).width()\r\n\r\n            if (width) {\r\n              column.sWidth = _fnStringToCss(width)\r\n            }\r\n          }\r\n\r\n          table.style.width = _fnStringToCss(tmpTable.css('width'))\r\n\r\n          // Finished with the table - ditch it\r\n          tmpTable.remove()\r\n        }\r\n\r\n        // If there is a width attr, we want to attach an event listener which\r\n        // allows the table sizing to automatically adjust when the window is\r\n        // resized. Use the width attr rather than CSS, since we can't know if the\r\n        // CSS is a relative value or absolute - DOM read is always px.\r\n        if (tableWidthAttr) {\r\n          table.style.width = _fnStringToCss(tableWidthAttr)\r\n        }\r\n\r\n        if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {\r\n          $(window).bind(\r\n            'resize.DT-' + oSettings.sInstance,\r\n            _fnThrottle(function () {\r\n              _fnAdjustColumnSizing(oSettings)\r\n            })\r\n          )\r\n\r\n          oSettings._reszEvt = true\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Throttle the calls to a function. Arguments and context are maintained for\r\n       * the throttled function\r\n       *  @param {function} fn Function to be called\r\n       *  @param {int} [freq=200] call frequency in mS\r\n       *  @returns {function} wrapped function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnThrottle (fn, freq) {\r\n        var frequency = freq || 200,\r\n          last,\r\n          timer\r\n\r\n        return function () {\r\n          var that = this,\r\n            now = +new Date(),\r\n            args = arguments\r\n\r\n          if (last && now < last + frequency) {\r\n            clearTimeout(timer)\r\n\r\n            timer = setTimeout(function () {\r\n              last = undefined\r\n              fn.apply(that, args)\r\n            }, frequency)\r\n          } else if (last) {\r\n            last = now\r\n            fn.apply(that, args)\r\n          } else {\r\n            last = now\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Convert a CSS unit width to pixels (e.g. 2em)\r\n       *  @param {string} width width to be converted\r\n       *  @param {node} parent parent to get the with for (required for relative widths) - optional\r\n       *  @returns {int} width in pixels\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnConvertToWidth (width, parent) {\r\n        if (!width) {\r\n          return 0\r\n        }\r\n\r\n        var n = $('<div/>')\r\n          .css('width', _fnStringToCss(width))\r\n          .appendTo(parent || document.body)\r\n\r\n        var val = n[0].offsetWidth\r\n        n.remove()\r\n\r\n        return val\r\n      }\r\n\r\n      /**\r\n       * Adjust a table's width to take account of vertical scroll bar\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {node} n table node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n\r\n      function _fnScrollingWidthAdjust (settings, n) {\r\n        var scroll = settings.oScroll\r\n\r\n        if (scroll.sX || scroll.sY) {\r\n          // When y-scrolling only, we want to remove the width of the scroll bar\r\n          // so the table + scroll bar will fit into the area available, otherwise\r\n          // we fix the table at its current size with no adjustment\r\n          var correction = !scroll.sX ? scroll.iBarWidth : 0\r\n          n.style.width = _fnStringToCss($(n).outerWidth() - correction)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get the widest node\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} colIdx column of interest\r\n       *  @returns {node} widest table node\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetWidestNode (settings, colIdx) {\r\n        var idx = _fnGetMaxLenString(settings, colIdx)\r\n        if (idx < 0) {\r\n          return null\r\n        }\r\n\r\n        var data = settings.aoData[idx]\r\n        return !data.nTr // Might not have been created when deferred rendering\r\n          ? $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0]\r\n          : data.anCells[colIdx]\r\n      }\r\n\r\n      /**\r\n       * Get the maximum strlen for each data column\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} colIdx column of interest\r\n       *  @returns {string} max string length for each column\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnGetMaxLenString (settings, colIdx) {\r\n        var s,\r\n          max = -1,\r\n          maxIdx = -1\r\n\r\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n          s = _fnGetCellData(settings, i, colIdx, 'display') + ''\r\n          s = s.replace(__re_html_remove, '')\r\n\r\n          if (s.length > max) {\r\n            max = s.length\r\n            maxIdx = i\r\n          }\r\n        }\r\n\r\n        return maxIdx\r\n      }\r\n\r\n      /**\r\n       * Append a CSS unit (only if required) to a string\r\n       *  @param {string} value to css-ify\r\n       *  @returns {string} value with css unit\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnStringToCss (s) {\r\n        if (s === null) {\r\n          return '0px'\r\n        }\r\n\r\n        if (typeof s == 'number') {\r\n          return s < 0 ? '0px' : s + 'px'\r\n        }\r\n\r\n        // Check it has a unit character already\r\n        return s.match(/\\d$/) ? s + 'px' : s\r\n      }\r\n\r\n      /**\r\n       * Get the width of a scroll bar in this browser being used\r\n       *  @returns {int} width in pixels\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnScrollBarWidth () {\r\n        // On first run a static variable is set, since this is only needed once.\r\n        // Subsequent runs will just use the previously calculated value\r\n        if (!DataTable.__scrollbarWidth) {\r\n          var inner = $('<p/>').css({\r\n            width: '100%',\r\n            height: 200,\r\n            padding: 0\r\n          })[0]\r\n\r\n          var outer = $('<div/>')\r\n            .css({\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: 200,\r\n              height: 150,\r\n              padding: 0,\r\n              overflow: 'hidden',\r\n              visibility: 'hidden'\r\n            })\r\n            .append(inner)\r\n            .appendTo('body')\r\n\r\n          var w1 = inner.offsetWidth\r\n          outer.css('overflow', 'scroll')\r\n          var w2 = inner.offsetWidth\r\n\r\n          if (w1 === w2) {\r\n            w2 = outer[0].clientWidth\r\n          }\r\n\r\n          outer.remove()\r\n\r\n          DataTable.__scrollbarWidth = w1 - w2\r\n        }\r\n\r\n        return DataTable.__scrollbarWidth\r\n      }\r\n\r\n      function _fnSortFlatten (settings) {\r\n        var i,\r\n          iLen,\r\n          k,\r\n          kLen,\r\n          aSort = [],\r\n          aiOrig = [],\r\n          aoColumns = settings.aoColumns,\r\n          aDataSort,\r\n          iCol,\r\n          sType,\r\n          srcCol,\r\n          fixed = settings.aaSortingFixed,\r\n          fixedObj = $.isPlainObject(fixed),\r\n          nestedSort = [],\r\n          add = function (a) {\r\n            if (a.length && !$.isArray(a[0])) {\r\n              // 1D array\r\n              nestedSort.push(a)\r\n            } else {\r\n              // 2D array\r\n              nestedSort.push.apply(nestedSort, a)\r\n            }\r\n          }\r\n\r\n        // Build the sort array, with pre-fix and post-fix options if they have been\r\n        // specified\r\n        if ($.isArray(fixed)) {\r\n          add(fixed)\r\n        }\r\n\r\n        if (fixedObj && fixed.pre) {\r\n          add(fixed.pre)\r\n        }\r\n\r\n        add(settings.aaSorting)\r\n\r\n        if (fixedObj && fixed.post) {\r\n          add(fixed.post)\r\n        }\r\n\r\n        for (i = 0; i < nestedSort.length; i++) {\r\n          srcCol = nestedSort[i][0]\r\n          aDataSort = aoColumns[srcCol].aDataSort\r\n\r\n          for (k = 0, kLen = aDataSort.length; k < kLen; k++) {\r\n            iCol = aDataSort[k]\r\n            sType = aoColumns[iCol].sType || 'string'\r\n\r\n            aSort.push({\r\n              src: srcCol,\r\n              col: iCol,\r\n              dir: nestedSort[i][1],\r\n              index: nestedSort[i][2],\r\n              type: sType,\r\n              formatter: DataTable.ext.type.order[sType + '-pre']\r\n            })\r\n          }\r\n        }\r\n\r\n        return aSort\r\n      }\r\n\r\n      /**\r\n       * Change the order of the table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       *  @todo This really needs split up!\r\n       */\r\n      function _fnSort (oSettings) {\r\n        var i,\r\n          ien,\r\n          iLen,\r\n          j,\r\n          jLen,\r\n          k,\r\n          kLen,\r\n          sDataType,\r\n          nTh,\r\n          aiOrig = [],\r\n          oExtSort = DataTable.ext.type.order,\r\n          aoData = oSettings.aoData,\r\n          aoColumns = oSettings.aoColumns,\r\n          aDataSort,\r\n          data,\r\n          iCol,\r\n          sType,\r\n          oSort,\r\n          formatters = 0,\r\n          sortCol,\r\n          displayMaster = oSettings.aiDisplayMaster,\r\n          aSort\r\n\r\n        // Resolve any column types that are unknown due to addition or invalidation\r\n        // @todo Can this be moved into a 'data-ready' handler which is called when\r\n        //   data is going to be used in the table?\r\n        _fnColumnTypes(oSettings)\r\n\r\n        aSort = _fnSortFlatten(oSettings)\r\n\r\n        for (i = 0, ien = aSort.length; i < ien; i++) {\r\n          sortCol = aSort[i]\r\n\r\n          // Track if we can use the fast sort algorithm\r\n          if (sortCol.formatter) {\r\n            formatters++\r\n          }\r\n\r\n          // Load the data needed for the sort, for each cell\r\n          _fnSortData(oSettings, sortCol.col)\r\n        }\r\n\r\n        /* No sorting required if server-side or no sorting array */\r\n        if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {\r\n          // Create a value - key array of the current row positions such that we can use their\r\n          // current position during the sort, if values match, in order to perform stable sorting\r\n          for (i = 0, iLen = displayMaster.length; i < iLen; i++) {\r\n            aiOrig[displayMaster[i]] = i\r\n          }\r\n\r\n          /* Do the sort - here we want multi-column sorting based on a given data source (column)\r\n           * and sorting function (from oSort) in a certain direction. It's reasonably complex to\r\n           * follow on it's own, but this is what we want (example two column sorting):\r\n           *  fnLocalSorting = function(a,b){\r\n           *    var iTest;\r\n           *    iTest = oSort['string-asc']('data11', 'data12');\r\n           *      if (iTest !== 0)\r\n           *        return iTest;\r\n           *    iTest = oSort['numeric-desc']('data21', 'data22');\r\n           *    if (iTest !== 0)\r\n           *      return iTest;\r\n           *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\r\n           *  }\r\n           * Basically we have a test for each sorting column, if the data in that column is equal,\r\n           * test the next column. If all columns match, then we use a numeric sort on the row\r\n           * positions in the original data array to provide a stable sort.\r\n           *\r\n           * Note - I know it seems excessive to have two sorting methods, but the first is around\r\n           * 15% faster, so the second is only maintained for backwards compatibility with sorting\r\n           * methods which do not have a pre-sort formatting function.\r\n           */\r\n          if (formatters === aSort.length) {\r\n            // All sort types have formatting functions\r\n            displayMaster.sort(function (a, b) {\r\n              var x,\r\n                y,\r\n                k,\r\n                test,\r\n                sort,\r\n                len = aSort.length,\r\n                dataA = aoData[a]._aSortData,\r\n                dataB = aoData[b]._aSortData\r\n\r\n              for (k = 0; k < len; k++) {\r\n                sort = aSort[k]\r\n\r\n                x = dataA[sort.col]\r\n                y = dataB[sort.col]\r\n\r\n                test = x < y ? -1 : x > y ? 1 : 0\r\n                if (test !== 0) {\r\n                  return sort.dir === 'asc' ? test : -test\r\n                }\r\n              }\r\n\r\n              x = aiOrig[a]\r\n              y = aiOrig[b]\r\n              return x < y ? -1 : x > y ? 1 : 0\r\n            })\r\n          } else {\r\n            // Depreciated - remove in 1.11 (providing a plug-in option)\r\n            // Not all sort types have formatting methods, so we have to call their sorting\r\n            // methods.\r\n            displayMaster.sort(function (a, b) {\r\n              var x,\r\n                y,\r\n                k,\r\n                l,\r\n                test,\r\n                sort,\r\n                fn,\r\n                len = aSort.length,\r\n                dataA = aoData[a]._aSortData,\r\n                dataB = aoData[b]._aSortData\r\n\r\n              for (k = 0; k < len; k++) {\r\n                sort = aSort[k]\r\n\r\n                x = dataA[sort.col]\r\n                y = dataB[sort.col]\r\n\r\n                fn = oExtSort[sort.type + '-' + sort.dir] || oExtSort['string-' + sort.dir]\r\n                test = fn(x, y)\r\n                if (test !== 0) {\r\n                  return test\r\n                }\r\n              }\r\n\r\n              x = aiOrig[a]\r\n              y = aiOrig[b]\r\n              return x < y ? -1 : x > y ? 1 : 0\r\n            })\r\n          }\r\n        }\r\n\r\n        /* Tell the draw function that we have sorted the data */\r\n        oSettings.bSorted = true\r\n      }\r\n\r\n      function _fnSortAria (settings) {\r\n        var label\r\n        var nextSort\r\n        var columns = settings.aoColumns\r\n        var aSort = _fnSortFlatten(settings)\r\n        var oAria = settings.oLanguage.oAria\r\n\r\n        // ARIA attributes - need to loop all columns, to update all (removing old\r\n        // attributes as needed)\r\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\r\n          var col = columns[i]\r\n          var asSorting = col.asSorting\r\n          var sTitle = col.sTitle.replace(/<.*?>/g, '')\r\n          var th = col.nTh\r\n\r\n          // IE7 is throwing an error when setting these properties with jQuery's\r\n          // attr() and removeAttr() methods...\r\n          th.removeAttribute('aria-sort')\r\n\r\n          /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\r\n          if (col.bSortable) {\r\n            if (aSort.length > 0 && aSort[0].col == i) {\r\n              th.setAttribute('aria-sort', aSort[0].dir == 'asc' ? 'ascending' : 'descending')\r\n              nextSort = asSorting[aSort[0].index + 1] || asSorting[0]\r\n            } else {\r\n              nextSort = asSorting[0]\r\n            }\r\n\r\n            label = sTitle + (nextSort === 'asc' ? oAria.sSortAscending : oAria.sSortDescending)\r\n          } else {\r\n            label = sTitle\r\n          }\r\n\r\n          th.setAttribute('aria-label', label)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Function to run on user sort request\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {node} attachTo node to attach the handler to\r\n       *  @param {int} colIdx column sorting index\r\n       *  @param {boolean} [append=false] Append the requested sort to the existing\r\n       *    sort if true (i.e. multi-column sort)\r\n       *  @param {function} [callback] callback function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSortListener (settings, colIdx, append, callback) {\r\n        var col = settings.aoColumns[colIdx]\r\n        var sorting = settings.aaSorting\r\n        var asSorting = col.asSorting\r\n        var nextSortIdx\r\n        var next = function (a) {\r\n          var idx = a._idx\r\n          if (idx === undefined) {\r\n            idx = $.inArray(a[1], asSorting)\r\n          }\r\n\r\n          return idx + 1 >= asSorting.length ? 0 : idx + 1\r\n        }\r\n\r\n        // Convert to 2D array if needed\r\n        if (typeof sorting[0] === 'number') {\r\n          sorting = settings.aaSorting = [sorting]\r\n        }\r\n\r\n        // If appending the sort then we are multi-column sorting\r\n        if (append && settings.oFeatures.bSortMulti) {\r\n          // Are we already doing some kind of sort on this column?\r\n          var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'))\r\n\r\n          if (sortIdx !== -1) {\r\n            // Yes, modify the sort\r\n            nextSortIdx = next(sorting[sortIdx])\r\n\r\n            sorting[sortIdx][1] = asSorting[nextSortIdx]\r\n            sorting[sortIdx]._idx = nextSortIdx\r\n          } else {\r\n            // No sort on this column yet\r\n            sorting.push([colIdx, asSorting[0], 0])\r\n            sorting[sorting.length - 1]._idx = 0\r\n          }\r\n        } else if (sorting.length && sorting[0][0] == colIdx) {\r\n          // Single column - already sorting on this column, modify the sort\r\n          nextSortIdx = next(sorting[0])\r\n\r\n          sorting.length = 1\r\n          sorting[0][1] = asSorting[nextSortIdx]\r\n          sorting[0]._idx = nextSortIdx\r\n        } else {\r\n          // Single column - sort only on this column\r\n          sorting.length = 0\r\n          sorting.push([colIdx, asSorting[0]])\r\n          sorting[0]._idx = 0\r\n        }\r\n\r\n        // Run the sort by calling a full redraw\r\n        _fnReDraw(settings)\r\n\r\n        // callback used for async user interaction\r\n        if (typeof callback == 'function') {\r\n          callback(settings)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Attach a sort handler (click) to a node\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {node} attachTo node to attach the handler to\r\n       *  @param {int} colIdx column sorting index\r\n       *  @param {function} [callback] callback function\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSortAttachListener (settings, attachTo, colIdx, callback) {\r\n        var col = settings.aoColumns[colIdx]\r\n\r\n        _fnBindAction(attachTo, {}, function (e) {\r\n          /* If the column is not sortable - don't to anything */\r\n          if (col.bSortable === false) {\r\n            return\r\n          }\r\n\r\n          // If processing is enabled use a timeout to allow the processing\r\n          // display to be shown - otherwise to it synchronously\r\n          if (settings.oFeatures.bProcessing) {\r\n            _fnProcessingDisplay(settings, true)\r\n\r\n            setTimeout(function () {\r\n              _fnSortListener(settings, colIdx, e.shiftKey, callback)\r\n\r\n              // In server-side processing, the draw callback will remove the\r\n              // processing display\r\n              if (_fnDataSource(settings) !== 'ssp') {\r\n                _fnProcessingDisplay(settings, false)\r\n              }\r\n            }, 0)\r\n          } else {\r\n            _fnSortListener(settings, colIdx, e.shiftKey, callback)\r\n          }\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Set the sorting classes on table's body, Note: it is safe to call this function\r\n       * when bSort and bSortClasses are false\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSortingClasses (settings) {\r\n        var oldSort = settings.aLastSort\r\n        var sortClass = settings.oClasses.sSortColumn\r\n        var sort = _fnSortFlatten(settings)\r\n        var features = settings.oFeatures\r\n        var i, ien, colIdx\r\n\r\n        if (features.bSort && features.bSortClasses) {\r\n          // Remove old sorting classes\r\n          for (i = 0, ien = oldSort.length; i < ien; i++) {\r\n            colIdx = oldSort[i].src\r\n\r\n            // Remove column sorting\r\n            $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3))\r\n          }\r\n\r\n          // Add new column sorting\r\n          for (i = 0, ien = sort.length; i < ien; i++) {\r\n            colIdx = sort[i].src\r\n\r\n            $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3))\r\n          }\r\n        }\r\n\r\n        settings.aLastSort = sort\r\n      }\r\n\r\n      // Get the data to sort a column, be it from cache, fresh (populating the\r\n      // cache), or from a sort formatter\r\n      function _fnSortData (settings, idx) {\r\n        // Custom sorting function - provided by the sort data type\r\n        var column = settings.aoColumns[idx]\r\n        var customSort = DataTable.ext.order[column.sSortDataType]\r\n        var customData\r\n\r\n        if (customSort) {\r\n          customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx))\r\n        }\r\n\r\n        // Use / populate cache\r\n        var row, cellData\r\n        var formatter = DataTable.ext.type.order[column.sType + '-pre']\r\n\r\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n          row = settings.aoData[i]\r\n\r\n          if (!row._aSortData) {\r\n            row._aSortData = []\r\n          }\r\n\r\n          if (!row._aSortData[idx] || customSort) {\r\n            cellData = customSort\r\n              ? customData[i] // If there was a custom sort function, use data from there\r\n              : _fnGetCellData(settings, i, idx, 'sort')\r\n\r\n            row._aSortData[idx] = formatter ? formatter(cellData) : cellData\r\n          }\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Save the state of a table\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSaveState (settings) {\r\n        if (!settings.oFeatures.bStateSave || settings.bDestroying) {\r\n          return\r\n        }\r\n\r\n        /* Store the interesting variables */\r\n        var state = {\r\n          time: +new Date(),\r\n          start: settings._iDisplayStart,\r\n          length: settings._iDisplayLength,\r\n          order: $.extend(true, [], settings.aaSorting),\r\n          search: _fnSearchToCamel(settings.oPreviousSearch),\r\n          columns: $.map(settings.aoColumns, function (col, i) {\r\n            return {\r\n              visible: col.bVisible,\r\n              search: _fnSearchToCamel(settings.aoPreSearchCols[i])\r\n            }\r\n          })\r\n        }\r\n\r\n        _fnCallbackFire(settings, 'aoStateSaveParams', 'stateSaveParams', [settings, state])\r\n\r\n        settings.oSavedState = state\r\n        settings.fnStateSaveCallback.call(settings.oInstance, settings, state)\r\n      }\r\n\r\n      /**\r\n       * Attempt to load a saved table state\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {object} oInit DataTables init object so we can override settings\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnLoadState (settings, oInit) {\r\n        var i, ien\r\n        var columns = settings.aoColumns\r\n\r\n        if (!settings.oFeatures.bStateSave) {\r\n          return\r\n        }\r\n\r\n        var state = settings.fnStateLoadCallback.call(settings.oInstance, settings)\r\n        if (!state || !state.time) {\r\n          return\r\n        }\r\n\r\n        /* Allow custom and plug-in manipulation functions to alter the saved data set and\r\n         * cancelling of loading by returning false\r\n         */\r\n        var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state])\r\n        if ($.inArray(false, abStateLoad) !== -1) {\r\n          return\r\n        }\r\n\r\n        /* Reject old data */\r\n        var duration = settings.iStateDuration\r\n        if (duration > 0 && state.time < +new Date() - duration * 1000) {\r\n          return\r\n        }\r\n\r\n        // Number of columns have changed - all bets are off, no restore of settings\r\n        if (columns.length !== state.columns.length) {\r\n          return\r\n        }\r\n\r\n        // Store the saved state so it might be accessed at any time\r\n        settings.oLoadedState = $.extend(true, {}, state)\r\n\r\n        // Restore key features - todo - for 1.11 this needs to be done by\r\n        // subscribed events\r\n        settings._iDisplayStart = state.start\r\n        settings.iInitDisplayStart = state.start\r\n        settings._iDisplayLength = state.length\r\n        settings.aaSorting = []\r\n\r\n        // Order\r\n        $.each(state.order, function (i, col) {\r\n          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col)\r\n        })\r\n\r\n        // Search\r\n        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search))\r\n\r\n        // Columns\r\n        for (i = 0, ien = state.columns.length; i < ien; i++) {\r\n          var col = state.columns[i]\r\n\r\n          // Visibility\r\n          columns[i].bVisible = col.visible\r\n\r\n          // Search\r\n          $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search))\r\n        }\r\n\r\n        _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state])\r\n      }\r\n\r\n      /**\r\n       * Return the settings object for a particular table\r\n       *  @param {node} table table we are using as a dataTable\r\n       *  @returns {object} Settings object - or null if not found\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnSettingsFromNode (table) {\r\n        var settings = DataTable.settings\r\n        var idx = $.inArray(table, _pluck(settings, 'nTable'))\r\n\r\n        return idx !== -1 ? settings[idx] : null\r\n      }\r\n\r\n      /**\r\n       * Log an error message\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {int} level log error messages, or display them to the user\r\n       *  @param {string} msg error message\r\n       *  @param {int} tn Technical note id to get more information about the error.\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnLog (settings, level, msg, tn) {\r\n        msg = 'DataTables warning: ' + (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg\r\n\r\n        if (tn) {\r\n          msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn\r\n        }\r\n\r\n        if (!level) {\r\n          // Backwards compatibility pre 1.10\r\n          var ext = DataTable.ext\r\n          var type = ext.sErrMode || ext.errMode\r\n\r\n          if (type == 'alert') {\r\n            alert(msg)\r\n          } else {\r\n            throw new Error(msg)\r\n          }\r\n        } else if (window.console && console.log) {\r\n          console.log(msg)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * See if a property is defined on one object, if so assign it to the other object\r\n       *  @param {object} ret target object\r\n       *  @param {object} src source object\r\n       *  @param {string} name property\r\n       *  @param {string} [mappedName] name to map too - optional, name used if not given\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnMap (ret, src, name, mappedName) {\r\n        if ($.isArray(name)) {\r\n          $.each(name, function (i, val) {\r\n            if ($.isArray(val)) {\r\n              _fnMap(ret, src, val[0], val[1])\r\n            } else {\r\n              _fnMap(ret, src, val)\r\n            }\r\n          })\r\n\r\n          return\r\n        }\r\n\r\n        if (mappedName === undefined) {\r\n          mappedName = name\r\n        }\r\n\r\n        if (src[name] !== undefined) {\r\n          ret[mappedName] = src[name]\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Extend objects - very similar to jQuery.extend, but deep copy objects, and\r\n       * shallow copy arrays. The reason we need to do this, is that we don't want to\r\n       * deep copy array init values (such as aaSorting) since the dev wouldn't be\r\n       * able to override them, but we do want to deep copy arrays.\r\n       *  @param {object} out Object to extend\r\n       *  @param {object} extender Object from which the properties will be applied to\r\n       *      out\r\n       *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\r\n       *      independent copy with the exception of the `data` or `aaData` parameters\r\n       *      if they are present. This is so you can pass in a collection to\r\n       *      DataTables and have that used as your data source without breaking the\r\n       *      references\r\n       *  @returns {object} out Reference, just for convenience - out === the return.\r\n       *  @memberof DataTable#oApi\r\n       *  @todo This doesn't take account of arrays inside the deep copied objects.\r\n       */\r\n      function _fnExtend (out, extender, breakRefs) {\r\n        var val\r\n\r\n        for (var prop in extender) {\r\n          if (extender.hasOwnProperty(prop)) {\r\n            val = extender[prop]\r\n\r\n            if ($.isPlainObject(val)) {\r\n              if (!$.isPlainObject(out[prop])) {\r\n                out[prop] = {}\r\n              }\r\n              $.extend(true, out[prop], val)\r\n            } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {\r\n              out[prop] = val.slice()\r\n            } else {\r\n              out[prop] = val\r\n            }\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      /**\r\n       * Bind an event handers to allow a click or return key to activate the callback.\r\n       * This is good for accessibility since a return on the keyboard will have the\r\n       * same effect as a click, if the element has focus.\r\n       *  @param {element} n Element to bind the action to\r\n       *  @param {object} oData Data object to pass to the triggered function\r\n       *  @param {function} fn Callback function for when the event is triggered\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnBindAction (n, oData, fn) {\r\n        $(n)\r\n          .bind('click.DT', oData, function (e) {\r\n            n.blur() // Remove focus outline for mouse users\r\n            fn(e)\r\n          })\r\n          .bind('keypress.DT', oData, function (e) {\r\n            if (e.which === 13) {\r\n              e.preventDefault()\r\n              fn(e)\r\n            }\r\n          })\r\n          .bind('selectstart.DT', function () {\r\n            /* Take the brutal approach to cancelling text selection */\r\n            return false\r\n          })\r\n      }\r\n\r\n      /**\r\n       * Register a callback function. Easily allows a callback function to be added to\r\n       * an array store of callback functions that can then all be called together.\r\n       *  @param {object} oSettings dataTables settings object\r\n       *  @param {string} sStore Name of the array storage for the callbacks in oSettings\r\n       *  @param {function} fn Function to be called back\r\n       *  @param {string} sName Identifying name for the callback (i.e. a label)\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCallbackReg (oSettings, sStore, fn, sName) {\r\n        if (fn) {\r\n          oSettings[sStore].push({\r\n            fn: fn,\r\n            sName: sName\r\n          })\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Fire callback functions and trigger events. Note that the loop over the\r\n       * callback array store is done backwards! Further note that you do not want to\r\n       * fire off triggers in time sensitive applications (for example cell creation)\r\n       * as its slow.\r\n       *  @param {object} settings dataTables settings object\r\n       *  @param {string} callbackArr Name of the array storage for the callbacks in\r\n       *      oSettings\r\n       *  @param {string} event Name of the jQuery custom event to trigger. If null no\r\n       *      trigger is fired\r\n       *  @param {array} args Array of arguments to pass to the callback function /\r\n       *      trigger\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnCallbackFire (settings, callbackArr, e, args) {\r\n        var ret = []\r\n\r\n        if (callbackArr) {\r\n          ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {\r\n            return val.fn.apply(settings.oInstance, args)\r\n          })\r\n        }\r\n\r\n        if (e !== null) {\r\n          $(settings.nTable).trigger(e + '.dt', args)\r\n        }\r\n\r\n        return ret\r\n      }\r\n\r\n      function _fnLengthOverflow (settings) {\r\n        var start = settings._iDisplayStart,\r\n          end = settings.fnDisplayEnd(),\r\n          len = settings._iDisplayLength\r\n\r\n        /* If we have space to show extra rows (backing up from the end point - then do so */\r\n        if (end === settings.fnRecordsDisplay()) {\r\n          start = end - len\r\n        }\r\n\r\n        if (len === -1 || start < 0) {\r\n          start = 0\r\n        }\r\n\r\n        settings._iDisplayStart = start\r\n      }\r\n\r\n      function _fnRenderer (settings, type) {\r\n        var renderer = settings.renderer\r\n        var host = DataTable.ext.renderer[type]\r\n\r\n        if ($.isPlainObject(renderer) && renderer[type]) {\r\n          // Specific renderer for this type. If available use it, otherwise use\r\n          // the default.\r\n          return host[renderer[type]] || host._\r\n        } else if (typeof renderer === 'string') {\r\n          // Common renderer - if there is one available for this type use it,\r\n          // otherwise use the default\r\n          return host[renderer] || host._\r\n        }\r\n\r\n        // Use the default\r\n        return host._\r\n      }\r\n\r\n      /**\r\n       * Detect the data source being used for the table. Used to simplify the code\r\n       * a little (ajax) and to make it compress a little smaller.\r\n       *\r\n       *  @param {object} settings dataTables settings object\r\n       *  @returns {string} Data source\r\n       *  @memberof DataTable#oApi\r\n       */\r\n      function _fnDataSource (settings) {\r\n        if (settings.oFeatures.bServerSide) {\r\n          return 'ssp'\r\n        } else if (settings.ajax || settings.sAjaxSource) {\r\n          return 'ajax'\r\n        }\r\n        return 'dom'\r\n      }\r\n\r\n      DataTable = function (options) {\r\n        /**\r\n         * Perform a jQuery selector action on the table's TR elements (from the tbody) and\r\n         * return the resulting jQuery object.\r\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\r\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\r\n         *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\r\n         *    criterion (\"applied\") or all TR elements (i.e. no filter).\r\n         *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\r\n         *    Can be either 'current', whereby the current sorting of the table is used, or\r\n         *    'original' whereby the original order the data was read into the table is used.\r\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\r\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\r\n         *    'current' and filter is 'applied', regardless of what they might be given as.\r\n         *  @returns {object} jQuery object, filtered by the given selector.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Highlight every second row\r\n         *      oTable.$('tr:odd').css('backgroundColor', 'blue');\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Filter to rows with 'Webkit' in them, add a background colour and then\r\n         *      // remove the filter, thus highlighting the 'Webkit' rows only.\r\n         *      oTable.fnFilter('Webkit');\r\n         *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\r\n         *      oTable.fnFilter('');\r\n         *    } );\r\n         */\r\n        this.$ = function (sSelector, oOpts) {\r\n          return this.api(true).$(sSelector, oOpts)\r\n        }\r\n\r\n        /**\r\n         * Almost identical to $ in operation, but in this case returns the data for the matched\r\n         * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\r\n         * rather than any descendants, so the data can be obtained for the row/cell. If matching\r\n         * rows are found, the data returned is the original data array/object that was used to\r\n         * create the row (or a generated array if from a DOM source).\r\n         *\r\n         * This method is often useful in-combination with $ where both functions are given the\r\n         * same parameters and the array indexes will match identically.\r\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\r\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\r\n         *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\r\n         *    criterion (\"applied\") or all elements (i.e. no filter).\r\n         *  @param {string} [oOpts.order=current] Order of the data in the processed array.\r\n         *    Can be either 'current', whereby the current sorting of the table is used, or\r\n         *    'original' whereby the original order the data was read into the table is used.\r\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\r\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\r\n         *    'current' and filter is 'applied', regardless of what they might be given as.\r\n         *  @returns {array} Data for the matched elements. If any elements, as a result of the\r\n         *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\r\n         *    entry in the array.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Get the data from the first row in the table\r\n         *      var data = oTable._('tr:first');\r\n         *\r\n         *      // Do something useful with the data\r\n         *      alert( \"First cell is: \"+data[0] );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Filter to 'Webkit' and get all data for\r\n         *      oTable.fnFilter('Webkit');\r\n         *      var data = oTable._('tr', {\"search\": \"applied\"});\r\n         *\r\n         *      // Do something with the data\r\n         *      alert( data.length+\" rows matched the search\" );\r\n         *    } );\r\n         */\r\n        this._ = function (sSelector, oOpts) {\r\n          return this.api(true)\r\n            .rows(sSelector, oOpts)\r\n            .data()\r\n        }\r\n\r\n        /**\r\n         * Create a DataTables Api instance, with the currently selected tables for\r\n         * the Api's context.\r\n         * @param {boolean} [traditional=false] Set the API instance's context to be\r\n         *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\r\n         *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\r\n         *   or if all tables captured in the jQuery object should be used.\r\n         * @return {DataTables.Api}\r\n         */\r\n        this.api = function (traditional) {\r\n          return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this)\r\n        }\r\n\r\n        /**\r\n         * Add a single new row or multiple rows of data to the table. Please note\r\n         * that this is suitable for client-side processing only - if you are using\r\n         * server-side processing (i.e. \"bServerSide\": true), then to add data, you\r\n         * must add it to the data source, i.e. the server-side, through an Ajax call.\r\n         *  @param {array|object} data The data to be added to the table. This can be:\r\n         *    <ul>\r\n         *      <li>1D array of data - add a single row with the data provided</li>\r\n         *      <li>2D array of arrays - add multiple rows in a single call</li>\r\n         *      <li>object - data object when using <i>mData</i></li>\r\n         *      <li>array of objects - multiple data objects when using <i>mData</i></li>\r\n         *    </ul>\r\n         *  @param {bool} [redraw=true] redraw the table or not\r\n         *  @returns {array} An array of integers, representing the list of indexes in\r\n         *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\r\n         *    the table.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    // Global var for counter\r\n         *    var giCount = 2;\r\n         *\r\n         *    $(document).ready(function() {\r\n         *      $('#example').dataTable();\r\n         *    } );\r\n         *\r\n         *    function fnClickAddRow() {\r\n         *      $('#example').dataTable().fnAddData( [\r\n         *        giCount+\".1\",\r\n         *        giCount+\".2\",\r\n         *        giCount+\".3\",\r\n         *        giCount+\".4\" ]\r\n         *      );\r\n         *\r\n         *      giCount++;\r\n         *    }\r\n         */\r\n        this.fnAddData = function (data, redraw) {\r\n          var api = this.api(true)\r\n\r\n          /* Check if we want to add multiple rows or not */\r\n          var rows =\r\n            $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data)\r\n\r\n          if (redraw === undefined || redraw) {\r\n            api.draw()\r\n          }\r\n\r\n          return rows.flatten().toArray()\r\n        }\r\n\r\n        /**\r\n         * This function will make DataTables recalculate the column sizes, based on the data\r\n         * contained in the table and the sizes applied to the columns (in the DOM, CSS or\r\n         * through the sWidth parameter). This can be useful when the width of the table's\r\n         * parent element changes (for example a window resize).\r\n         *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable( {\r\n         *        \"sScrollY\": \"200px\",\r\n         *        \"bPaginate\": false\r\n         *      } );\r\n         *\r\n         *      $(window).bind('resize', function () {\r\n         *        oTable.fnAdjustColumnSizing();\r\n         *      } );\r\n         *    } );\r\n         */\r\n        this.fnAdjustColumnSizing = function (bRedraw) {\r\n          var api = this.api(true).columns.adjust()\r\n          var settings = api.settings()[0]\r\n          var scroll = settings.oScroll\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw(false)\r\n          } else if (scroll.sX !== '' || scroll.sY !== '') {\r\n            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\r\n            _fnScrollDraw(settings)\r\n          }\r\n        }\r\n\r\n        /**\r\n         * Quickly and simply clear a table\r\n         *  @param {bool} [bRedraw=true] redraw the table or not\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\r\n         *      oTable.fnClearTable();\r\n         *    } );\r\n         */\r\n        this.fnClearTable = function (bRedraw) {\r\n          var api = this.api(true).clear()\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw()\r\n          }\r\n        }\r\n\r\n        /**\r\n         * The exact opposite of 'opening' a row, this function will close any rows which\r\n         * are currently 'open'.\r\n         *  @param {node} nTr the table row to 'close'\r\n         *  @returns {int} 0 on success, or 1 if failed (can't find the row)\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable;\r\n         *\r\n         *      // 'open' an information row when a row is clicked on\r\n         *      $('#example tbody tr').click( function () {\r\n         *        if ( oTable.fnIsOpen(this) ) {\r\n         *          oTable.fnClose( this );\r\n         *        } else {\r\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\r\n         *        }\r\n         *      } );\r\n         *\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnClose = function (nTr) {\r\n          this.api(true)\r\n            .row(nTr)\r\n            .child.hide()\r\n        }\r\n\r\n        /**\r\n         * Remove a row for the table\r\n         *  @param {mixed} target The index of the row from aoData to be deleted, or\r\n         *    the TR element you want to delete\r\n         *  @param {function|null} [callBack] Callback function\r\n         *  @param {bool} [redraw=true] Redraw the table or not\r\n         *  @returns {array} The row that was deleted\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Immediately remove the first row\r\n         *      oTable.fnDeleteRow( 0 );\r\n         *    } );\r\n         */\r\n        this.fnDeleteRow = function (target, callback, redraw) {\r\n          var api = this.api(true)\r\n          var rows = api.rows(target)\r\n          var settings = rows.settings()[0]\r\n          var data = settings.aoData[rows[0][0]]\r\n\r\n          rows.remove()\r\n\r\n          if (callback) {\r\n            callback.call(this, settings, data)\r\n          }\r\n\r\n          if (redraw === undefined || redraw) {\r\n            api.draw()\r\n          }\r\n\r\n          return data\r\n        }\r\n\r\n        /**\r\n         * Restore the table to it's original state in the DOM by removing all of DataTables\r\n         * enhancements, alterations to the DOM structure of the table and event listeners.\r\n         *  @param {boolean} [remove=false] Completely remove the table from the DOM\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\r\n         *      var oTable = $('#example').dataTable();\r\n         *      oTable.fnDestroy();\r\n         *    } );\r\n         */\r\n        this.fnDestroy = function (remove) {\r\n          this.api(true).destroy(remove)\r\n        }\r\n\r\n        /**\r\n         * Redraw the table\r\n         *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\r\n         *      oTable.fnDraw();\r\n         *    } );\r\n         */\r\n        this.fnDraw = function (complete) {\r\n          // Note that this isn't an exact match to the old call to _fnDraw - it takes\r\n          // into account the new data, but can old position.\r\n          this.api(true).draw(!complete)\r\n        }\r\n\r\n        /**\r\n         * Filter the input based on data\r\n         *  @param {string} sInput String to filter the table on\r\n         *  @param {int|null} [iColumn] Column to limit filtering to\r\n         *  @param {bool} [bRegex=false] Treat as regular expression or not\r\n         *  @param {bool} [bSmart=true] Perform smart filtering or not\r\n         *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\r\n         *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Sometime later - filter...\r\n         *      oTable.fnFilter( 'test string' );\r\n         *    } );\r\n         */\r\n        this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {\r\n          var api = this.api(true)\r\n\r\n          if (iColumn === null || iColumn === undefined) {\r\n            api.search(sInput, bRegex, bSmart, bCaseInsensitive)\r\n          } else {\r\n            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive)\r\n          }\r\n\r\n          api.draw()\r\n        }\r\n\r\n        /**\r\n         * Get the data for the whole table, an individual row or an individual cell based on the\r\n         * provided parameters.\r\n         *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\r\n         *    a TR node then the data source for the whole row will be returned. If given as a\r\n         *    TD/TH cell node then iCol will be automatically calculated and the data for the\r\n         *    cell returned. If given as an integer, then this is treated as the aoData internal\r\n         *    data index for the row (see fnGetPosition) and the data for that row used.\r\n         *  @param {int} [col] Optional column index that you want the data of.\r\n         *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\r\n         *    returned. If mRow is defined, just data for that row, and is iCol is\r\n         *    defined, only data for the designated cell is returned.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    // Row data\r\n         *    $(document).ready(function() {\r\n         *      oTable = $('#example').dataTable();\r\n         *\r\n         *      oTable.$('tr').click( function () {\r\n         *        var data = oTable.fnGetData( this );\r\n         *        // ... do something with the array / object of data for the row\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Individual cell data\r\n         *    $(document).ready(function() {\r\n         *      oTable = $('#example').dataTable();\r\n         *\r\n         *      oTable.$('td').click( function () {\r\n         *        var sData = oTable.fnGetData( this );\r\n         *        alert( 'The cell clicked on had the value of '+sData );\r\n         *      } );\r\n         *    } );\r\n         */\r\n        this.fnGetData = function (src, col) {\r\n          var api = this.api(true)\r\n\r\n          if (src !== undefined) {\r\n            var type = src.nodeName ? src.nodeName.toLowerCase() : ''\r\n\r\n            return col !== undefined || type == 'td' || type == 'th'\r\n              ? api.cell(src, col).data()\r\n              : api.row(src).data() || null\r\n          }\r\n\r\n          return api.data().toArray()\r\n        }\r\n\r\n        /**\r\n         * Get an array of the TR nodes that are used in the table's body. Note that you will\r\n         * typically want to use the '$' API method in preference to this as it is more\r\n         * flexible.\r\n         *  @param {int} [iRow] Optional row index for the TR element you want\r\n         *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\r\n         *    in the table's body, or iRow is defined, just the TR element requested.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Get the nodes from the table\r\n         *      var nNodes = oTable.fnGetNodes( );\r\n         *    } );\r\n         */\r\n        this.fnGetNodes = function (iRow) {\r\n          var api = this.api(true)\r\n\r\n          return iRow !== undefined\r\n            ? api.row(iRow).node()\r\n            : api\r\n                .rows()\r\n                .nodes()\r\n                .flatten()\r\n                .toArray()\r\n        }\r\n\r\n        /**\r\n         * Get the array indexes of a particular cell from it's DOM element\r\n         * and column index including hidden columns\r\n         *  @param {node} node this can either be a TR, TD or TH in the table's body\r\n         *  @returns {int} If nNode is given as a TR, then a single index is returned, or\r\n         *    if given as a cell, an array of [row index, column index (visible),\r\n         *    column index (all)] is given.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      $('#example tbody td').click( function () {\r\n         *        // Get the position of the current data from the node\r\n         *        var aPos = oTable.fnGetPosition( this );\r\n         *\r\n         *        // Get the data array for this row\r\n         *        var aData = oTable.fnGetData( aPos[0] );\r\n         *\r\n         *        // Update the data array and return the value\r\n         *        aData[ aPos[1] ] = 'clicked';\r\n         *        this.innerHTML = 'clicked';\r\n         *      } );\r\n         *\r\n         *      // Init DataTables\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnGetPosition = function (node) {\r\n          var api = this.api(true)\r\n          var nodeName = node.nodeName.toUpperCase()\r\n\r\n          if (nodeName == 'TR') {\r\n            return api.row(node).index()\r\n          } else if (nodeName == 'TD' || nodeName == 'TH') {\r\n            var cell = api.cell(node).index()\r\n\r\n            return [cell.row, cell.columnVisible, cell.column]\r\n          }\r\n          return null\r\n        }\r\n\r\n        /**\r\n         * Check to see if a row is 'open' or not.\r\n         *  @param {node} nTr the table row to check\r\n         *  @returns {boolean} true if the row is currently open, false otherwise\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable;\r\n         *\r\n         *      // 'open' an information row when a row is clicked on\r\n         *      $('#example tbody tr').click( function () {\r\n         *        if ( oTable.fnIsOpen(this) ) {\r\n         *          oTable.fnClose( this );\r\n         *        } else {\r\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\r\n         *        }\r\n         *      } );\r\n         *\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnIsOpen = function (nTr) {\r\n          return this.api(true)\r\n            .row(nTr)\r\n            .child.isShown()\r\n        }\r\n\r\n        /**\r\n         * This function will place a new row directly after a row which is currently\r\n         * on display on the page, with the HTML contents that is passed into the\r\n         * function. This can be used, for example, to ask for confirmation that a\r\n         * particular record should be deleted.\r\n         *  @param {node} nTr The table row to 'open'\r\n         *  @param {string|node|jQuery} mHtml The HTML to put into the row\r\n         *  @param {string} sClass Class to give the new TD cell\r\n         *  @returns {node} The row opened. Note that if the table row passed in as the\r\n         *    first parameter, is not found in the table, this method will silently\r\n         *    return.\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable;\r\n         *\r\n         *      // 'open' an information row when a row is clicked on\r\n         *      $('#example tbody tr').click( function () {\r\n         *        if ( oTable.fnIsOpen(this) ) {\r\n         *          oTable.fnClose( this );\r\n         *        } else {\r\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\r\n         *        }\r\n         *      } );\r\n         *\r\n         *      oTable = $('#example').dataTable();\r\n         *    } );\r\n         */\r\n        this.fnOpen = function (nTr, mHtml, sClass) {\r\n          return this.api(true)\r\n            .row(nTr)\r\n            .child(mHtml, sClass)\r\n            .show()\r\n            .child()[0]\r\n        }\r\n\r\n        /**\r\n         * Change the pagination - provides the internal logic for pagination in a simple API\r\n         * function. With this function you can have a DataTables table go to the next,\r\n         * previous, first or last pages.\r\n         *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\r\n         *    or page number to jump to (integer), note that page 0 is the first page.\r\n         *  @param {bool} [bRedraw=true] Redraw the table or not\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      oTable.fnPageChange( 'next' );\r\n         *    } );\r\n         */\r\n        this.fnPageChange = function (mAction, bRedraw) {\r\n          var api = this.api(true).page(mAction)\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw(false)\r\n          }\r\n        }\r\n\r\n        /**\r\n         * Show a particular column\r\n         *  @param {int} iCol The column whose display should be changed\r\n         *  @param {bool} bShow Show (true) or hide (false) the column\r\n         *  @param {bool} [bRedraw=true] Redraw the table or not\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Hide the second column after initialisation\r\n         *      oTable.fnSetColumnVis( 1, false );\r\n         *    } );\r\n         */\r\n        this.fnSetColumnVis = function (iCol, bShow, bRedraw) {\r\n          var api = this.api(true)\r\n            .column(iCol)\r\n            .visible(bShow)\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.columns.adjust().draw()\r\n          }\r\n        }\r\n\r\n        /**\r\n         * Get the settings for a particular table for external manipulation\r\n         *  @returns {object} DataTables settings object. See\r\n         *    {@link DataTable.models.oSettings}\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      var oSettings = oTable.fnSettings();\r\n         *\r\n         *      // Show an example parameter from the settings\r\n         *      alert( oSettings._iDisplayStart );\r\n         *    } );\r\n         */\r\n        this.fnSettings = function () {\r\n          return _fnSettingsFromNode(this[_ext.iApiIndex])\r\n        }\r\n\r\n        /**\r\n         * Sort the table by a particular column\r\n         *  @param {int} iCol the data index to sort on. Note that this will not match the\r\n         *    'display index' if you have hidden data entries\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Sort immediately with columns 0 and 1\r\n         *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\r\n         *    } );\r\n         */\r\n        this.fnSort = function (aaSort) {\r\n          this.api(true)\r\n            .order(aaSort)\r\n            .draw()\r\n        }\r\n\r\n        /**\r\n         * Attach a sort listener to an element for a given column\r\n         *  @param {node} nNode the element to attach the sort listener to\r\n         *  @param {int} iColumn the column that a click on this node will sort on\r\n         *  @param {function} [fnCallback] callback function when sort is run\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *\r\n         *      // Sort on column 1, when 'sorter' is clicked on\r\n         *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\r\n         *    } );\r\n         */\r\n        this.fnSortListener = function (nNode, iColumn, fnCallback) {\r\n          this.api(true).order.listener(nNode, iColumn, fnCallback)\r\n        }\r\n\r\n        /**\r\n         * Update a table cell or row - this method will accept either a single value to\r\n         * update the cell with, an array of values with one element for each column or\r\n         * an object in the same format as the original data source. The function is\r\n         * self-referencing in order to make the multi column updates easier.\r\n         *  @param {object|array|string} mData Data to update the cell/row with\r\n         *  @param {node|int} mRow TR element you want to update or the aoData index\r\n         *  @param {int} [iColumn] The column to update, give as null or undefined to\r\n         *    update a whole row.\r\n         *  @param {bool} [bRedraw=true] Redraw the table or not\r\n         *  @param {bool} [bAction=true] Perform pre-draw actions or not\r\n         *  @returns {int} 0 on success, 1 on error\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\r\n         *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\r\n         *    } );\r\n         */\r\n        this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {\r\n          var api = this.api(true)\r\n\r\n          if (iColumn === undefined || iColumn === null) {\r\n            api.row(mRow).data(mData)\r\n          } else {\r\n            api.cell(mRow, iColumn).data(mData)\r\n          }\r\n\r\n          if (bAction === undefined || bAction) {\r\n            api.columns.adjust()\r\n          }\r\n\r\n          if (bRedraw === undefined || bRedraw) {\r\n            api.draw()\r\n          }\r\n          return 0\r\n        }\r\n\r\n        /**\r\n         * Provide a common method for plug-ins to check the version of DataTables being used, in order\r\n         * to ensure compatibility.\r\n         *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\r\n         *    formats \"X\" and \"X.Y\" are also acceptable.\r\n         *  @returns {boolean} true if this version of DataTables is greater or equal to the required\r\n         *    version, or false if this version of DataTales is not suitable\r\n         *  @method\r\n         *  @dtopt API\r\n         *  @deprecated Since v1.10\r\n         *\r\n         *  @example\r\n         *    $(document).ready(function() {\r\n         *      var oTable = $('#example').dataTable();\r\n         *      alert( oTable.fnVersionCheck( '1.9.0' ) );\r\n         *    } );\r\n         */\r\n        this.fnVersionCheck = _ext.fnVersionCheck\r\n\r\n        var _that = this\r\n        var emptyInit = options === undefined\r\n        var len = this.length\r\n\r\n        if (emptyInit) {\r\n          options = {}\r\n        }\r\n\r\n        this.oApi = this.internal = _ext.internal\r\n\r\n        // Extend with old style plug-in API methods\r\n        for (var fn in DataTable.ext.internal) {\r\n          if (fn) {\r\n            this[fn] = _fnExternApiFunc(fn)\r\n          }\r\n        }\r\n\r\n        this.each(function () {\r\n          // For each initialisation we want to give it a clean initialisation\r\n          // object that can be bashed around\r\n          var o = {}\r\n          var oInit =\r\n            len > 1 // optimisation for single table case\r\n              ? _fnExtend(o, options, true)\r\n              : options\r\n\r\n          /*global oInit,_that,emptyInit*/\r\n          var i = 0,\r\n            iLen,\r\n            j,\r\n            jLen,\r\n            k,\r\n            kLen\r\n          var sId = this.getAttribute('id')\r\n          var bInitHandedOff = false\r\n          var defaults = DataTable.defaults\r\n\r\n          /* Sanity check */\r\n          if (this.nodeName.toLowerCase() != 'table') {\r\n            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2)\r\n            return\r\n          }\r\n\r\n          /* Backwards compatibility for the defaults */\r\n          _fnCompatOpts(defaults)\r\n          _fnCompatCols(defaults.column)\r\n\r\n          /* Convert the camel-case defaults to Hungarian */\r\n          _fnCamelToHungarian(defaults, defaults, true)\r\n          _fnCamelToHungarian(defaults.column, defaults.column, true)\r\n\r\n          /* Setting up the initialisation object */\r\n          _fnCamelToHungarian(defaults, oInit)\r\n\r\n          /* Check to see if we are re-initialising a table */\r\n          var allSettings = DataTable.settings\r\n          for (i = 0, iLen = allSettings.length; i < iLen; i++) {\r\n            /* Base check on table node */\r\n            if (allSettings[i].nTable == this) {\r\n              var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve\r\n              var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy\r\n\r\n              if (emptyInit || bRetrieve) {\r\n                return allSettings[i].oInstance\r\n              } else if (bDestroy) {\r\n                allSettings[i].oInstance.fnDestroy()\r\n                break\r\n              } else {\r\n                _fnLog(allSettings[i], 0, 'Cannot reinitialise DataTable', 3)\r\n                return\r\n              }\r\n            }\r\n\r\n            /* If the element we are initialising has the same ID as a table which was previously\r\n             * initialised, but the table nodes don't match (from before) then we destroy the old\r\n             * instance by simply deleting it. This is under the assumption that the table has been\r\n             * destroyed by other methods. Anyone using non-id selectors will need to do this manually\r\n             */\r\n            if (allSettings[i].sTableId == this.id) {\r\n              allSettings.splice(i, 1)\r\n              break\r\n            }\r\n          }\r\n\r\n          /* Ensure the table has an ID - required for accessibility */\r\n          if (sId === null || sId === '') {\r\n            sId = 'DataTables_Table_' + DataTable.ext._unique++\r\n            this.id = sId\r\n          }\r\n\r\n          /* Create the settings object for this table and set some of the default parameters */\r\n          var oSettings = $.extend(true, {}, DataTable.models.oSettings, {\r\n            nTable: this,\r\n            oApi: _that.internal,\r\n            oInit: oInit,\r\n            sDestroyWidth: $(this)[0].style.width,\r\n            sInstance: sId,\r\n            sTableId: sId\r\n          })\r\n          allSettings.push(oSettings)\r\n\r\n          // Need to add the instance after the instance after the settings object has been added\r\n          // to the settings array, so we can self reference the table instance if more than one\r\n          oSettings.oInstance = _that.length === 1 ? _that : $(this).dataTable()\r\n\r\n          // Backwards compatibility, before we apply all the defaults\r\n          _fnCompatOpts(oInit)\r\n\r\n          if (oInit.oLanguage) {\r\n            _fnLanguageCompat(oInit.oLanguage)\r\n          }\r\n\r\n          // If the length menu is given, but the init display length is not, use the length menu\r\n          if (oInit.aLengthMenu && !oInit.iDisplayLength) {\r\n            oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0]\r\n          }\r\n\r\n          // Apply the defaults and init options to make a single init object will all\r\n          // options defined from defaults and instance options.\r\n          oInit = _fnExtend($.extend(true, {}, defaults), oInit)\r\n\r\n          // Map the initialisation options onto the settings object\r\n          _fnMap(oSettings.oFeatures, oInit, [\r\n            'bPaginate',\r\n            'bLengthChange',\r\n            'bFilter',\r\n            'bSort',\r\n            'bSortMulti',\r\n            'bInfo',\r\n            'bProcessing',\r\n            'bAutoWidth',\r\n            'bSortClasses',\r\n            'bServerSide',\r\n            'bDeferRender'\r\n          ])\r\n          _fnMap(oSettings, oInit, [\r\n            'asStripeClasses',\r\n            'ajax',\r\n            'fnServerData',\r\n            'fnFormatNumber',\r\n            'sServerMethod',\r\n            'aaSorting',\r\n            'aaSortingFixed',\r\n            'aLengthMenu',\r\n            'sPaginationType',\r\n            'sAjaxSource',\r\n            'sAjaxDataProp',\r\n            'iStateDuration',\r\n            'sDom',\r\n            'bSortCellsTop',\r\n            'iTabIndex',\r\n            'fnStateLoadCallback',\r\n            'fnStateSaveCallback',\r\n            'renderer',\r\n            ['iCookieDuration', 'iStateDuration'], // backwards compat\r\n            ['oSearch', 'oPreviousSearch'],\r\n            ['aoSearchCols', 'aoPreSearchCols'],\r\n            ['iDisplayLength', '_iDisplayLength'],\r\n            ['bJQueryUI', 'bJUI']\r\n          ])\r\n          _fnMap(oSettings.oScroll, oInit, [\r\n            ['sScrollX', 'sX'],\r\n            ['sScrollXInner', 'sXInner'],\r\n            ['sScrollY', 'sY'],\r\n            ['bScrollCollapse', 'bCollapse']\r\n          ])\r\n          _fnMap(oSettings.oLanguage, oInit, 'fnInfoCallback')\r\n\r\n          /* Callback functions which are array driven */\r\n          _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user')\r\n          _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user')\r\n          _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user')\r\n          _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user')\r\n          _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user')\r\n          _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user')\r\n          _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user')\r\n          _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user')\r\n\r\n          var oClasses = oSettings.oClasses\r\n\r\n          // @todo Remove in 1.11\r\n          if (oInit.bJQueryUI) {\r\n            /* Use the JUI classes object for display. You could clone the oStdClasses object if\r\n             * you want to have multiple tables with multiple independent classes\r\n             */\r\n            $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses)\r\n\r\n            if (oInit.sDom === defaults.sDom && defaults.sDom === 'lfrtip') {\r\n              /* Set the DOM to use a layout suitable for jQuery UI's theming */\r\n              oSettings.sDom = '<\"H\"lfr>t<\"F\"ip>'\r\n            }\r\n\r\n            if (!oSettings.renderer) {\r\n              oSettings.renderer = 'jqueryui'\r\n            } else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {\r\n              oSettings.renderer.header = 'jqueryui'\r\n            }\r\n          } else {\r\n            $.extend(oClasses, DataTable.ext.classes, oInit.oClasses)\r\n          }\r\n          $(this).addClass(oClasses.sTable)\r\n\r\n          /* Calculate the scroll bar width and cache it for use later on */\r\n          if (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '') {\r\n            oSettings.oScroll.iBarWidth = _fnScrollBarWidth()\r\n          }\r\n          if (oSettings.oScroll.sX === true) {\r\n            // Easy initialisation of x-scrolling\r\n            oSettings.oScroll.sX = '100%'\r\n          }\r\n\r\n          if (oSettings.iInitDisplayStart === undefined) {\r\n            /* Display start point, taking into account the save saving */\r\n            oSettings.iInitDisplayStart = oInit.iDisplayStart\r\n            oSettings._iDisplayStart = oInit.iDisplayStart\r\n          }\r\n\r\n          if (oInit.iDeferLoading !== null) {\r\n            oSettings.bDeferLoading = true\r\n            var tmp = $.isArray(oInit.iDeferLoading)\r\n            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading\r\n            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading\r\n          }\r\n\r\n          /* Language definitions */\r\n          if (oInit.oLanguage.sUrl !== '') {\r\n            /* Get the language definitions from a file - because this Ajax call makes the language\r\n             * get async to the remainder of this function we use bInitHandedOff to indicate that\r\n             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\r\n             */\r\n            oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl\r\n            $.getJSON(oSettings.oLanguage.sUrl, null, function (json) {\r\n              _fnLanguageCompat(json)\r\n              _fnCamelToHungarian(defaults.oLanguage, json)\r\n              $.extend(true, oSettings.oLanguage, oInit.oLanguage, json)\r\n              _fnInitialise(oSettings)\r\n            })\r\n            bInitHandedOff = true\r\n          } else {\r\n            $.extend(true, oSettings.oLanguage, oInit.oLanguage)\r\n          }\r\n\r\n          /*\r\n           * Stripes\r\n           */\r\n          if (oInit.asStripeClasses === null) {\r\n            oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven]\r\n          }\r\n\r\n          /* Remove row stripe classes if they are already on the table row */\r\n          var stripeClasses = oSettings.asStripeClasses\r\n          var rowOne = $('tbody tr:eq(0)', this)\r\n          if (\r\n            $.inArray(\r\n              true,\r\n              $.map(stripeClasses, function (el, i) {\r\n                return rowOne.hasClass(el)\r\n              })\r\n            ) !== -1\r\n          ) {\r\n            $('tbody tr', this).removeClass(stripeClasses.join(' '))\r\n            oSettings.asDestroyStripes = stripeClasses.slice()\r\n          }\r\n\r\n          /*\r\n           * Columns\r\n           * See if we should load columns automatically or use defined ones\r\n           */\r\n          var anThs = []\r\n          var aoColumnsInit\r\n          var nThead = this.getElementsByTagName('thead')\r\n          if (nThead.length !== 0) {\r\n            _fnDetectHeader(oSettings.aoHeader, nThead[0])\r\n            anThs = _fnGetUniqueThs(oSettings)\r\n          }\r\n\r\n          /* If not given a column array, generate one with nulls */\r\n          if (oInit.aoColumns === null) {\r\n            aoColumnsInit = []\r\n            for (i = 0, iLen = anThs.length; i < iLen; i++) {\r\n              aoColumnsInit.push(null)\r\n            }\r\n          } else {\r\n            aoColumnsInit = oInit.aoColumns\r\n          }\r\n\r\n          /* Add the columns */\r\n          for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {\r\n            _fnAddColumn(oSettings, anThs ? anThs[i] : null)\r\n          }\r\n\r\n          /* Apply the column definitions */\r\n          _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\r\n            _fnColumnOptions(oSettings, iCol, oDef)\r\n          })\r\n\r\n          /* HTML5 attribute detection - build an mData object automatically if the\r\n           * attributes are found\r\n           */\r\n          if (rowOne.length) {\r\n            var a = function (cell, name) {\r\n              return cell.getAttribute('data-' + name) ? name : null\r\n            }\r\n\r\n            $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {\r\n              var col = oSettings.aoColumns[i]\r\n\r\n              if (col.mData === i) {\r\n                var sort = a(cell, 'sort') || a(cell, 'order')\r\n                var filter = a(cell, 'filter') || a(cell, 'search')\r\n\r\n                if (sort !== null || filter !== null) {\r\n                  col.mData = {\r\n                    _: i + '.display',\r\n                    sort: sort !== null ? i + '.@data-' + sort : undefined,\r\n                    type: sort !== null ? i + '.@data-' + sort : undefined,\r\n                    filter: filter !== null ? i + '.@data-' + filter : undefined\r\n                  }\r\n\r\n                  _fnColumnOptions(oSettings, i)\r\n                }\r\n              }\r\n            })\r\n          }\r\n\r\n          var features = oSettings.oFeatures\r\n\r\n          /* Must be done after everything which can be overridden by the state saving! */\r\n          if (oInit.bStateSave) {\r\n            features.bStateSave = true\r\n            _fnLoadState(oSettings, oInit)\r\n            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save')\r\n          }\r\n\r\n          /*\r\n           * Sorting\r\n           * @todo For modularisation (1.11) this needs to do into a sort start up handler\r\n           */\r\n\r\n          // If aaSorting is not defined, then we use the first indicator in asSorting\r\n          // in case that has been altered, so the default sort reflects that option\r\n          if (oInit.aaSorting === undefined) {\r\n            var sorting = oSettings.aaSorting\r\n            for (i = 0, iLen = sorting.length; i < iLen; i++) {\r\n              sorting[i][1] = oSettings.aoColumns[i].asSorting[0]\r\n            }\r\n          }\r\n\r\n          /* Do a first pass on the sorting classes (allows any size changes to be taken into\r\n           * account, and also will apply sorting disabled classes if disabled\r\n           */\r\n          _fnSortingClasses(oSettings)\r\n\r\n          if (features.bSort) {\r\n            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {\r\n              if (oSettings.bSorted) {\r\n                var aSort = _fnSortFlatten(oSettings)\r\n                var sortedColumns = {}\r\n\r\n                $.each(aSort, function (i, val) {\r\n                  sortedColumns[val.src] = val.dir\r\n                })\r\n\r\n                _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns])\r\n                _fnSortAria(oSettings)\r\n              }\r\n            })\r\n          }\r\n\r\n          _fnCallbackReg(\r\n            oSettings,\r\n            'aoDrawCallback',\r\n            function () {\r\n              if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {\r\n                _fnSortingClasses(oSettings)\r\n              }\r\n            },\r\n            'sc'\r\n          )\r\n\r\n          /*\r\n           * Final init\r\n           * Cache the header, body and footer as required, creating them if needed\r\n           */\r\n\r\n          /* Browser support detection */\r\n          _fnBrowserDetect(oSettings)\r\n\r\n          // Work around for Webkit bug 83867 - store the caption-side before removing from doc\r\n          var captions = $(this)\r\n            .children('caption')\r\n            .each(function () {\r\n              this._captionSide = $(this).css('caption-side')\r\n            })\r\n\r\n          var thead = $(this).children('thead')\r\n          if (thead.length === 0) {\r\n            thead = $('<thead/>').appendTo(this)\r\n          }\r\n          oSettings.nTHead = thead[0]\r\n\r\n          var tbody = $(this).children('tbody')\r\n          if (tbody.length === 0) {\r\n            tbody = $('<tbody/>').appendTo(this)\r\n          }\r\n          oSettings.nTBody = tbody[0]\r\n\r\n          var tfoot = $(this).children('tfoot')\r\n          if (\r\n            tfoot.length === 0 &&\r\n            captions.length > 0 &&\r\n            (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '')\r\n          ) {\r\n            // If we are a scrolling table, and no footer has been given, then we need to create\r\n            // a tfoot element for the caption element to be appended to\r\n            tfoot = $('<tfoot/>').appendTo(this)\r\n          }\r\n\r\n          if (tfoot.length === 0 || tfoot.children().length === 0) {\r\n            $(this).addClass(oClasses.sNoFooter)\r\n          } else if (tfoot.length > 0) {\r\n            oSettings.nTFoot = tfoot[0]\r\n            _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot)\r\n          }\r\n\r\n          /* Check if there is data passing into the constructor */\r\n          if (oInit.aaData) {\r\n            for (i = 0; i < oInit.aaData.length; i++) {\r\n              _fnAddData(oSettings, oInit.aaData[i])\r\n            }\r\n          } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {\r\n            /* Grab the data from the page - only do this when deferred loading or no Ajax\r\n             * source since there is no point in reading the DOM data if we are then going\r\n             * to replace it with Ajax data\r\n             */\r\n            _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'))\r\n          }\r\n\r\n          /* Copy the data index array */\r\n          oSettings.aiDisplay = oSettings.aiDisplayMaster.slice()\r\n\r\n          /* Initialisation complete - table can be drawn */\r\n          oSettings.bInitialised = true\r\n\r\n          /* Check if we need to initialise the table (it might not have been handed off to the\r\n           * language processor)\r\n           */\r\n          if (bInitHandedOff === false) {\r\n            _fnInitialise(oSettings)\r\n          }\r\n        })\r\n        _that = null\r\n        return this\r\n      }\r\n\r\n      /**\r\n       * Computed structure of the DataTables API, defined by the options passed to\r\n       * `DataTable.Api.register()` when building the API.\r\n       *\r\n       * The structure is built in order to speed creation and extension of the Api\r\n       * objects since the extensions are effectively pre-parsed.\r\n       *\r\n       * The array is an array of objects with the following structure, where this\r\n       * base array represents the Api prototype base:\r\n       *\r\n       *     [\r\n       *       {\r\n       *         name:      'data'                -- string   - Property name\r\n       *         val:       function () {},       -- function - Api method (or undefined if just an object\r\n       *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\r\n       *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\r\n       *       },\r\n       *       {\r\n       *         name:     'row'\r\n       *         val:       {},\r\n       *         methodExt: [ ... ],\r\n       *         propExt:   [\r\n       *           {\r\n       *             name:      'data'\r\n       *             val:       function () {},\r\n       *             methodExt: [ ... ],\r\n       *             propExt:   [ ... ]\r\n       *           },\r\n       *           ...\r\n       *         ]\r\n       *       }\r\n       *     ]\r\n       *\r\n       * @type {Array}\r\n       * @ignore\r\n       */\r\n      var __apiStruct = []\r\n\r\n      /**\r\n       * `Array.prototype` reference.\r\n       *\r\n       * @type object\r\n       * @ignore\r\n       */\r\n      var __arrayProto = Array.prototype\r\n\r\n      /**\r\n       * Abstraction for `context` parameter of the `Api` constructor to allow it to\r\n       * take several different forms for ease of use.\r\n       *\r\n       * Each of the input parameter types will be converted to a DataTables settings\r\n       * object where possible.\r\n       *\r\n       * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\r\n       *   of:\r\n       *\r\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\r\n       *     with be found and used.\r\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\r\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\r\n       *   * `object` - DataTables settings object\r\n       *   * `DataTables.Api` - API instance\r\n       * @return {array|null} Matching DataTables settings objects. `null` or\r\n       *   `undefined` is returned if no matching DataTable is found.\r\n       * @ignore\r\n       */\r\n      var _toSettings = function (mixed) {\r\n        var idx, jq\r\n        var settings = DataTable.settings\r\n        var tables = $.map(settings, function (el, i) {\r\n          return el.nTable\r\n        })\r\n\r\n        if (!mixed) {\r\n          return []\r\n        } else if (mixed.nTable && mixed.oApi) {\r\n          // DataTables settings object\r\n          return [mixed]\r\n        } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {\r\n          // Table node\r\n          idx = $.inArray(mixed, tables)\r\n          return idx !== -1 ? [settings[idx]] : null\r\n        } else if (mixed && typeof mixed.settings === 'function') {\r\n          return mixed.settings().toArray()\r\n        } else if (typeof mixed === 'string') {\r\n          // jQuery selector\r\n          jq = $(mixed)\r\n        } else if (mixed instanceof $) {\r\n          // jQuery object (also DataTables instance)\r\n          jq = mixed\r\n        }\r\n\r\n        if (jq) {\r\n          return jq\r\n            .map(function (i) {\r\n              idx = $.inArray(this, tables)\r\n              return idx !== -1 ? settings[idx] : null\r\n            })\r\n            .toArray()\r\n        }\r\n      }\r\n\r\n      /**\r\n       * DataTables API class - used to control and interface with  one or more\r\n       * DataTables enhanced tables.\r\n       *\r\n       * The API class is heavily based on jQuery, presenting a chainable interface\r\n       * that you can use to interact with tables. Each instance of the API class has\r\n       * a \"context\" - i.e. the tables that it will operate on. This could be a single\r\n       * table, all tables on a page or a sub-set thereof.\r\n       *\r\n       * Additionally the API is designed to allow you to easily work with the data in\r\n       * the tables, retrieving and manipulating it as required. This is done by\r\n       * presenting the API class as an array like interface. The contents of the\r\n       * array depend upon the actions requested by each method (for example\r\n       * `rows().nodes()` will return an array of nodes, while `rows().data()` will\r\n       * return an array of objects or arrays depending upon your table's\r\n       * configuration). The API object has a number of array like methods (`push`,\r\n       * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\r\n       * `unique` etc) to assist your working with the data held in a table.\r\n       *\r\n       * Most methods (those which return an Api instance) are chainable, which means\r\n       * the return from a method call also has all of the methods available that the\r\n       * top level object had. For example, these two calls are equivalent:\r\n       *\r\n       *     // Not chained\r\n       *     api.row.add( {...} );\r\n       *     api.draw();\r\n       *\r\n       *     // Chained\r\n       *     api.row.add( {...} ).draw();\r\n       *\r\n       * @class DataTable.Api\r\n       * @param {array|object|string|jQuery} context DataTable identifier. This is\r\n       *   used to define which DataTables enhanced tables this API will operate on.\r\n       *   Can be one of:\r\n       *\r\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\r\n       *     with be found and used.\r\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\r\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\r\n       *   * `object` - DataTables settings object\r\n       * @param {array} [data] Data to initialise the Api instance with.\r\n       *\r\n       * @example\r\n       *   // Direct initialisation during DataTables construction\r\n       *   var api = $('#example').DataTable();\r\n       *\r\n       * @example\r\n       *   // Initialisation using a DataTables jQuery object\r\n       *   var api = $('#example').dataTable().api();\r\n       *\r\n       * @example\r\n       *   // Initialisation as a constructor\r\n       *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\r\n       */\r\n      _Api = function (context, data) {\r\n        if (!this instanceof _Api) {\r\n          throw 'DT API must be constructed as a new object'\r\n          // or should it do the 'new' for the caller?\r\n          // return new _Api.apply( this, arguments );\r\n        }\r\n\r\n        var settings = []\r\n        var ctxSettings = function (o) {\r\n          var a = _toSettings(o)\r\n          if (a) {\r\n            settings.push.apply(settings, a)\r\n          }\r\n        }\r\n\r\n        if ($.isArray(context)) {\r\n          for (var i = 0, ien = context.length; i < ien; i++) {\r\n            ctxSettings(context[i])\r\n          }\r\n        } else {\r\n          ctxSettings(context)\r\n        }\r\n\r\n        // Remove duplicates\r\n        this.context = _unique(settings)\r\n\r\n        // Initial data\r\n        if (data) {\r\n          this.push.apply(this, data.toArray ? data.toArray() : data)\r\n        }\r\n\r\n        // selector\r\n        this.selector = {\r\n          rows: null,\r\n          cols: null,\r\n          opts: null\r\n        }\r\n\r\n        _Api.extend(this, this, __apiStruct)\r\n      }\r\n\r\n      DataTable.Api = _Api\r\n\r\n      _Api.prototype = /** @lends DataTables.Api */ {\r\n        /**\r\n         * Return a new Api instance, comprised of the data held in the current\r\n         * instance, join with the other array(s) and/or value(s).\r\n         *\r\n         * An alias for `Array.prototype.concat`.\r\n         *\r\n         * @type method\r\n         * @param {*} value1 Arrays and/or values to concatenate.\r\n         * @param {*} [...] Additional arrays and/or values to concatenate.\r\n         * @returns {DataTables.Api} New API instance, comprising of the combined\r\n         *   array.\r\n         */\r\n        concat: __arrayProto.concat,\r\n\r\n        context: [], // array of table settings objects\r\n\r\n        each: function (fn) {\r\n          for (var i = 0, ien = this.length; i < ien; i++) {\r\n            fn.call(this, this[i], i, this)\r\n          }\r\n\r\n          return this\r\n        },\r\n\r\n        eq: function (idx) {\r\n          var ctx = this.context\r\n\r\n          return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null\r\n        },\r\n\r\n        filter: function (fn) {\r\n          var a = []\r\n\r\n          if (__arrayProto.filter) {\r\n            a = __arrayProto.filter.call(this, fn, this)\r\n          } else {\r\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\r\n            for (var i = 0, ien = this.length; i < ien; i++) {\r\n              if (fn.call(this, this[i], i, this)) {\r\n                a.push(this[i])\r\n              }\r\n            }\r\n          }\r\n\r\n          return new _Api(this.context, a)\r\n        },\r\n\r\n        flatten: function () {\r\n          var a = []\r\n          return new _Api(this.context, a.concat.apply(a, this.toArray()))\r\n        },\r\n\r\n        join: __arrayProto.join,\r\n\r\n        indexOf:\r\n          __arrayProto.indexOf ||\r\n          function (obj, start) {\r\n            for (var i = start || 0, ien = this.length; i < ien; i++) {\r\n              if (this[i] === obj) {\r\n                return i\r\n              }\r\n            }\r\n            return -1\r\n          },\r\n\r\n        // Internal only at the moment - relax?\r\n        iterator: function (flatten, type, fn) {\r\n          var a = [],\r\n            ret,\r\n            i,\r\n            ien,\r\n            j,\r\n            jen,\r\n            context = this.context,\r\n            rows,\r\n            items,\r\n            item,\r\n            selector = this.selector\r\n\r\n          // Argument shifting\r\n          if (typeof flatten === 'string') {\r\n            fn = type\r\n            type = flatten\r\n            flatten = false\r\n          }\r\n\r\n          for (i = 0, ien = context.length; i < ien; i++) {\r\n            if (type === 'table') {\r\n              ret = fn(context[i], i)\r\n\r\n              if (ret !== undefined) {\r\n                a.push(ret)\r\n              }\r\n            } else if (type === 'columns' || type === 'rows') {\r\n              // this has same length as context - one entry for each table\r\n              ret = fn(context[i], this[i], i)\r\n\r\n              if (ret !== undefined) {\r\n                a.push(ret)\r\n              }\r\n            } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {\r\n              // columns and rows share the same structure.\r\n              // 'this' is an array of column indexes for each context\r\n              items = this[i]\r\n\r\n              if (type === 'column-rows') {\r\n                rows = _selector_row_indexes(context[i], selector.opts)\r\n              }\r\n\r\n              for (j = 0, jen = items.length; j < jen; j++) {\r\n                item = items[j]\r\n\r\n                if (type === 'cell') {\r\n                  ret = fn(context[i], item.row, item.column, i, j)\r\n                } else {\r\n                  ret = fn(context[i], item, i, j, rows)\r\n                }\r\n\r\n                if (ret !== undefined) {\r\n                  a.push(ret)\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (a.length) {\r\n            var api = new _Api(context, flatten ? a.concat.apply([], a) : a)\r\n            var apiSelector = api.selector\r\n            apiSelector.rows = selector.rows\r\n            apiSelector.cols = selector.cols\r\n            apiSelector.opts = selector.opts\r\n            return api\r\n          }\r\n          return this\r\n        },\r\n\r\n        lastIndexOf:\r\n          __arrayProto.lastIndexOf ||\r\n          function (obj, start) {\r\n            // Bit cheeky...\r\n            return this.indexOf.apply(this.toArray.reverse(), arguments)\r\n          },\r\n\r\n        length: 0,\r\n\r\n        map: function (fn) {\r\n          var a = []\r\n\r\n          if (__arrayProto.map) {\r\n            a = __arrayProto.map.call(this, fn, this)\r\n          } else {\r\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\r\n            for (var i = 0, ien = this.length; i < ien; i++) {\r\n              a.push(fn.call(this, this[i], i))\r\n            }\r\n          }\r\n\r\n          return new _Api(this.context, a)\r\n        },\r\n\r\n        pluck: function (prop) {\r\n          return this.map(function (el) {\r\n            return el[prop]\r\n          })\r\n        },\r\n\r\n        pop: __arrayProto.pop,\r\n\r\n        push: __arrayProto.push,\r\n\r\n        // Does not return an API instance\r\n        reduce:\r\n          __arrayProto.reduce ||\r\n          function (fn, init) {\r\n            return _fnReduce(this, fn, init, 0, this.length, 1)\r\n          },\r\n\r\n        reduceRight:\r\n          __arrayProto.reduceRight ||\r\n          function (fn, init) {\r\n            return _fnReduce(this, fn, init, this.length - 1, -1, -1)\r\n          },\r\n\r\n        reverse: __arrayProto.reverse,\r\n\r\n        // Object with rows, columns and opts\r\n        selector: null,\r\n\r\n        shift: __arrayProto.shift,\r\n\r\n        sort: __arrayProto.sort, // ? name - order?\r\n\r\n        splice: __arrayProto.splice,\r\n\r\n        toArray: function () {\r\n          return __arrayProto.slice.call(this)\r\n        },\r\n\r\n        to$: function () {\r\n          return $(this)\r\n        },\r\n\r\n        toJQuery: function () {\r\n          return $(this)\r\n        },\r\n\r\n        unique: function () {\r\n          return new _Api(this.context, _unique(this))\r\n        },\r\n\r\n        unshift: __arrayProto.unshift\r\n      }\r\n\r\n      _Api.extend = function (scope, obj, ext) {\r\n        // Only extend API instances and static properties of the API\r\n        if (!obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {\r\n          return\r\n        }\r\n\r\n        var i,\r\n          ien,\r\n          j,\r\n          jen,\r\n          struct,\r\n          inner,\r\n          methodScoping = function (scope, fn, struc) {\r\n            return function () {\r\n              var ret = fn.apply(scope, arguments)\r\n\r\n              // Method extension\r\n              _Api.extend(ret, ret, struc.methodExt)\r\n              return ret\r\n            }\r\n          }\r\n\r\n        for (i = 0, ien = ext.length; i < ien; i++) {\r\n          struct = ext[i]\r\n\r\n          // Value\r\n          obj[struct.name] =\r\n            typeof struct.val === 'function'\r\n              ? methodScoping(scope, struct.val, struct)\r\n              : $.isPlainObject(struct.val)\r\n              ? {}\r\n              : struct.val\r\n\r\n          obj[struct.name].__dt_wrapper = true\r\n\r\n          // Property extension\r\n          _Api.extend(scope, obj[struct.name], struct.propExt)\r\n        }\r\n      }\r\n\r\n      // @todo - Is there need for an augment function?\r\n      // _Api.augment = function ( inst, name )\r\n      // {\r\n      // \t// Find src object in the structure from the name\r\n      // \tvar parts = name.split('.');\r\n\r\n      // \t_Api.extend( inst, obj );\r\n      // };\r\n\r\n      //     [\r\n      //       {\r\n      //         name:      'data'                -- string   - Property name\r\n      //         val:       function () {},       -- function - Api method (or undefined if just an object\r\n      //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\r\n      //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\r\n      //       },\r\n      //       {\r\n      //         name:     'row'\r\n      //         val:       {},\r\n      //         methodExt: [ ... ],\r\n      //         propExt:   [\r\n      //           {\r\n      //             name:      'data'\r\n      //             val:       function () {},\r\n      //             methodExt: [ ... ],\r\n      //             propExt:   [ ... ]\r\n      //           },\r\n      //           ...\r\n      //         ]\r\n      //       }\r\n      //     ]\r\n\r\n      _Api.register = _api_register = function (name, val) {\r\n        if ($.isArray(name)) {\r\n          for (var j = 0, jen = name.length; j < jen; j++) {\r\n            _Api.register(name[j], val)\r\n          }\r\n          return\r\n        }\r\n\r\n        var i,\r\n          ien,\r\n          heir = name.split('.'),\r\n          struct = __apiStruct,\r\n          key,\r\n          method\r\n\r\n        var find = function (src, name) {\r\n          for (var i = 0, ien = src.length; i < ien; i++) {\r\n            if (src[i].name === name) {\r\n              return src[i]\r\n            }\r\n          }\r\n          return null\r\n        }\r\n\r\n        for (i = 0, ien = heir.length; i < ien; i++) {\r\n          method = heir[i].indexOf('()') !== -1\r\n          key = method ? heir[i].replace('()', '') : heir[i]\r\n\r\n          var src = find(struct, key)\r\n          if (!src) {\r\n            src = {\r\n              name: key,\r\n              val: {},\r\n              methodExt: [],\r\n              propExt: []\r\n            }\r\n            struct.push(src)\r\n          }\r\n\r\n          if (i === ien - 1) {\r\n            src.val = val\r\n          } else {\r\n            struct = method ? src.methodExt : src.propExt\r\n          }\r\n        }\r\n      }\r\n\r\n      _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {\r\n        _Api.register(pluralName, val)\r\n\r\n        _Api.register(singularName, function () {\r\n          var ret = val.apply(this, arguments)\r\n\r\n          if (ret === this) {\r\n            // Returned item is the API instance that was passed in, return it\r\n            return this\r\n          } else if (ret instanceof _Api) {\r\n            // New API instance returned, want the value from the first item\r\n            // in the returned array for the singular result.\r\n            return ret.length\r\n              ? $.isArray(ret[0])\r\n                ? new _Api(ret.context, ret[0]) // Array results are 'enhanced'\r\n                : ret[0]\r\n              : undefined\r\n          }\r\n\r\n          // Non-API return - just fire it back\r\n          return ret\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Selector for HTML tables. Apply the given selector to the give array of\r\n       * DataTables settings objects.\r\n       *\r\n       * @param {string|integer} [selector] jQuery selector string or integer\r\n       * @param  {array} Array of DataTables settings objects to be filtered\r\n       * @return {array}\r\n       * @ignore\r\n       */\r\n      var __table_selector = function (selector, a) {\r\n        // Integer is used to pick out a table by index\r\n        if (typeof selector === 'number') {\r\n          return [a[selector]]\r\n        }\r\n\r\n        // Perform a jQuery selector on the table nodes\r\n        var nodes = $.map(a, function (el, i) {\r\n          return el.nTable\r\n        })\r\n\r\n        return $(nodes)\r\n          .filter(selector)\r\n          .map(function (i) {\r\n            // Need to translate back from the table node to the settings\r\n            var idx = $.inArray(this, nodes)\r\n            return a[idx]\r\n          })\r\n          .toArray()\r\n      }\r\n\r\n      /**\r\n       * Context selector for the API's context (i.e. the tables the API instance\r\n       * refers to.\r\n       *\r\n       * @name    DataTable.Api#tables\r\n       * @param {string|integer} [selector] Selector to pick which tables the iterator\r\n       *   should operate on. If not given, all tables in the current context are\r\n       *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\r\n       *   select multiple tables or as an integer to select a single table.\r\n       * @returns {DataTable.Api} Returns a new API instance if a selector is given.\r\n       */\r\n      _api_register('tables()', function (selector) {\r\n        // A new instance is created if there was a selector specified\r\n        return selector ? new _Api(__table_selector(selector, this.context)) : this\r\n      })\r\n\r\n      _api_register('table()', function (selector) {\r\n        var tables = this.tables(selector)\r\n        var ctx = tables.context\r\n\r\n        // Truncate to the first matched table\r\n        return ctx.length ? new _Api(ctx[0]) : tables\r\n      })\r\n\r\n      _api_registerPlural('tables().nodes()', 'table().node()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTable\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().body()', 'table().body()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTBody\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().header()', 'table().header()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTHead\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().footer()', 'table().footer()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTFoot\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('tables().containers()', 'table().container()', function () {\r\n        return this.iterator('table', function (ctx) {\r\n          return ctx.nTableWrapper\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Redraw the tables in the current context.\r\n       *\r\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\r\n       *   position. A full re-sort and re-filter is performed when this method is\r\n       *   called, which is why the pagination reset is the default action.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('draw()', function (resetPaging) {\r\n        return this.iterator('table', function (settings) {\r\n          _fnReDraw(settings, resetPaging === false)\r\n        })\r\n      })\r\n      /**\r\n       * Set the current page.\r\n       *\r\n       * Note that if you attempt to show a page which does not exist, DataTables will\r\n       * not throw an error, but rather reset the paging.\r\n       *\r\n       * @param {integer|string} action The paging action to take. This can be one of:\r\n       *  * `integer` - The page index to jump to\r\n       *  * `string` - An action to take:\r\n       *    * `first` - Jump to first page.\r\n       *    * `next` - Jump to the next page\r\n       *    * `previous` - Jump to previous page\r\n       *    * `last` - Jump to the last page.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get the current page index.\r\n       *\r\n       * @return {integer} Current page index (zero based)\r\n       */ _api_register('page()', function (action) {\r\n        if (action === undefined) {\r\n          return this.page.info().page // not an expensive call\r\n        }\r\n\r\n        // else, have an action to take on all tables\r\n        return this.iterator('table', function (settings) {\r\n          _fnPageChange(settings, action)\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Paging information for the first table in the current context.\r\n       *\r\n       * If you require paging information for another table, use the `table()` method\r\n       * with a suitable selector.\r\n       *\r\n       * @return {object} Object with the following properties set:\r\n       *  * `page` - Current page index (zero based - i.e. the first page is `0`)\r\n       *  * `pages` - Total number of pages\r\n       *  * `start` - Display index for the first record shown on the current page\r\n       *  * `end` - Display index for the last record shown on the current page\r\n       *  * `length` - Display length (number of records). Note that generally `start\r\n       *    + length = end`, but this is not always true, for example if there are\r\n       *    only 2 records to show on the final page, with a length of 10.\r\n       *  * `recordsTotal` - Full data set length\r\n       *  * `recordsDisplay` - Data set length once the current filtering criterion\r\n       *    are applied.\r\n       */\r\n      _api_register('page.info()', function (action) {\r\n        if (this.context.length === 0) {\r\n          return undefined\r\n        }\r\n\r\n        var settings = this.context[0],\r\n          start = settings._iDisplayStart,\r\n          len = settings._iDisplayLength,\r\n          visRecords = settings.fnRecordsDisplay(),\r\n          all = len === -1\r\n\r\n        return {\r\n          page: all ? 0 : Math.floor(start / len),\r\n          pages: all ? 1 : Math.ceil(visRecords / len),\r\n          start: start,\r\n          end: settings.fnDisplayEnd(),\r\n          length: len,\r\n          recordsTotal: settings.fnRecordsTotal(),\r\n          recordsDisplay: visRecords\r\n        }\r\n      })\r\n      /**\r\n       * Set the current page length.\r\n       *\r\n       * @param {integer} Page length to set. Use `-1` to show all records.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get the current page length.\r\n       *\r\n       * @return {integer} Current page length. Note `-1` indicates that all records\r\n       *   are to be shown.\r\n       */ _api_register('page.len()', function (len) {\r\n        // Note that we can't call this function 'length()' because `length`\r\n        // is a Javascript property of functions which defines how many arguments\r\n        // the function expects.\r\n        if (len === undefined) {\r\n          return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined\r\n        }\r\n\r\n        // else, set the page length\r\n        return this.iterator('table', function (settings) {\r\n          _fnLengthChange(settings, len)\r\n        })\r\n      })\r\n\r\n      var __reload = function (settings, holdPosition, callback) {\r\n        if (_fnDataSource(settings) == 'ssp') {\r\n          _fnReDraw(settings, holdPosition)\r\n        } else {\r\n          // Trigger xhr\r\n          _fnProcessingDisplay(settings, true)\r\n\r\n          _fnBuildAjax(settings, [], function (json) {\r\n            _fnClearTable(settings)\r\n\r\n            var data = _fnAjaxDataSrc(settings, json)\r\n            for (var i = 0, ien = data.length; i < ien; i++) {\r\n              _fnAddData(settings, data[i])\r\n            }\r\n\r\n            _fnReDraw(settings, holdPosition)\r\n            _fnProcessingDisplay(settings, false)\r\n          })\r\n        }\r\n\r\n        // Use the draw event to trigger a callback, regardless of if it is an async\r\n        // or sync draw\r\n        if (callback) {\r\n          var api = new _Api(settings)\r\n\r\n          api.one('draw', function () {\r\n            callback(api.ajax.json())\r\n          })\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Get the JSON response from the last Ajax request that DataTables made to the\r\n       * server. Note that this returns the JSON from the first table in the current\r\n       * context.\r\n       *\r\n       * @return {object} JSON received from the server.\r\n       */\r\n      _api_register('ajax.json()', function () {\r\n        var ctx = this.context\r\n\r\n        if (ctx.length > 0) {\r\n          return ctx[0].json\r\n        }\r\n\r\n        // else return undefined;\r\n      })\r\n\r\n      /**\r\n       * Get the data submitted in the last Ajax request\r\n       */\r\n      _api_register('ajax.params()', function () {\r\n        var ctx = this.context\r\n\r\n        if (ctx.length > 0) {\r\n          return ctx[0].oAjaxData\r\n        }\r\n\r\n        // else return undefined;\r\n      })\r\n\r\n      /**\r\n       * Reload tables from the Ajax data source. Note that this function will\r\n       * automatically re-draw the table when the remote data has been loaded.\r\n       *\r\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\r\n       *   position. A full re-sort and re-filter is performed when this method is\r\n       *   called, which is why the pagination reset is the default action.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('ajax.reload()', function (callback, resetPaging) {\r\n        return this.iterator('table', function (settings) {\r\n          __reload(settings, resetPaging === false, callback)\r\n        })\r\n      })\r\n      /**\r\n       * Set the Ajax URL. Note that this will set the URL for all tables in the\r\n       * current context.\r\n       *\r\n       * @param {string} url URL to set.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get the current Ajax URL. Note that this returns the URL from the first\r\n       * table in the current context.\r\n       *\r\n       * @return {string} Current Ajax source URL\r\n       */ _api_register('ajax.url()', function (url) {\r\n        var ctx = this.context\r\n\r\n        if (url === undefined) {\r\n          // get\r\n          if (ctx.length === 0) {\r\n            return undefined\r\n          }\r\n          ctx = ctx[0]\r\n\r\n          return ctx.ajax ? ($.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax) : ctx.sAjaxSource\r\n        }\r\n\r\n        // set\r\n        return this.iterator('table', function (settings) {\r\n          if ($.isPlainObject(settings.ajax)) {\r\n            settings.ajax.url = url\r\n          } else {\r\n            settings.ajax = url\r\n          }\r\n          // No need to consider sAjaxSource here since DataTables gives priority\r\n          // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\r\n          // value of `sAjaxSource` redundant.\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Load data from the newly set Ajax URL. Note that this method is only\r\n       * available when `ajax.url()` is used to set a URL. Additionally, this method\r\n       * has the same effect as calling `ajax.reload()` but is provided for\r\n       * convenience when setting a new URL. Like `ajax.reload()` it will\r\n       * automatically redraw the table once the remote data has been loaded.\r\n       *\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('ajax.url().load()', function (callback, resetPaging) {\r\n        // Same as a reload, but makes sense to present it for easy access after a\r\n        // url change\r\n        return this.iterator('table', function (ctx) {\r\n          __reload(ctx, resetPaging === false, callback)\r\n        })\r\n      })\r\n\r\n      var _selector_run = function (selector, select) {\r\n        var out = [],\r\n          res,\r\n          a,\r\n          i,\r\n          ien,\r\n          j,\r\n          jen\r\n\r\n        // Can't just check for isArray here, as an API or jQuery instance might be\r\n        // given with their array like look\r\n        if (!selector || typeof selector === 'string' || selector.length === undefined) {\r\n          selector = [selector]\r\n        }\r\n\r\n        for (i = 0, ien = selector.length; i < ien; i++) {\r\n          a = selector[i] && selector[i].split ? selector[i].split(',') : [selector[i]]\r\n\r\n          for (j = 0, jen = a.length; j < jen; j++) {\r\n            res = select(typeof a[j] === 'string' ? $.trim(a[j]) : a[j])\r\n\r\n            if (res && res.length) {\r\n              out.push.apply(out, res)\r\n            }\r\n          }\r\n        }\r\n\r\n        return out\r\n      }\r\n\r\n      var _selector_opts = function (opts) {\r\n        if (!opts) {\r\n          opts = {}\r\n        }\r\n\r\n        // Backwards compatibility for 1.9- which used the terminology filter rather\r\n        // than search\r\n        if (opts.filter && !opts.search) {\r\n          opts.search = opts.filter\r\n        }\r\n\r\n        return {\r\n          search: opts.search || 'none',\r\n          order: opts.order || 'current',\r\n          page: opts.page || 'all'\r\n        }\r\n      }\r\n\r\n      var _selector_first = function (inst) {\r\n        // Reduce the API instance to the first item found\r\n        for (var i = 0, ien = inst.length; i < ien; i++) {\r\n          if (inst[i].length > 0) {\r\n            // Assign the first element to the first item in the instance\r\n            // and truncate the instance and context\r\n            inst[0] = inst[i]\r\n            inst.length = 1\r\n            inst.context = [inst.context[i]]\r\n\r\n            return inst\r\n          }\r\n        }\r\n\r\n        // Not found - return an empty instance\r\n        inst.length = 0\r\n        return inst\r\n      }\r\n\r\n      var _selector_row_indexes = function (settings, opts) {\r\n        var i,\r\n          ien,\r\n          tmp,\r\n          a = [],\r\n          displayFiltered = settings.aiDisplay,\r\n          displayMaster = settings.aiDisplayMaster\r\n\r\n        var search = opts.search, // none, applied, removed\r\n          order = opts.order, // applied, current, index (original - compatibility with 1.9)\r\n          page = opts.page // all, current\r\n\r\n        if (_fnDataSource(settings) == 'ssp') {\r\n          // In server-side processing mode, most options are irrelevant since\r\n          // rows not shown don't exist and the index order is the applied order\r\n          // Removed is a special case - for consistency just return an empty\r\n          // array\r\n          return search === 'removed' ? [] : _range(0, displayMaster.length)\r\n        } else if (page == 'current') {\r\n          // Current page implies that order=current and fitler=applied, since it is\r\n          // fairly senseless otherwise, regardless of what order and search actually\r\n          // are\r\n          for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {\r\n            a.push(displayFiltered[i])\r\n          }\r\n        } else if (order == 'current' || order == 'applied') {\r\n          a =\r\n            search == 'none'\r\n              ? displayMaster.slice() // no search\r\n              : search == 'applied'\r\n              ? displayFiltered.slice() // applied search\r\n              : $.map(displayMaster, function (el, i) {\r\n                  // removed search\r\n                  return $.inArray(el, displayFiltered) === -1 ? el : null\r\n                })\r\n        } else if (order == 'index' || order == 'original') {\r\n          for (i = 0, ien = settings.aoData.length; i < ien; i++) {\r\n            if (search == 'none') {\r\n              a.push(i)\r\n            } else {\r\n              // applied | removed\r\n              tmp = $.inArray(i, displayFiltered)\r\n\r\n              if ((tmp === -1 && search == 'removed') || (tmp >= 0 && search == 'applied')) {\r\n                a.push(i)\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        return a\r\n      }\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Rows\r\n       *\r\n       * {}          - no selector - use all available rows\r\n       * {integer}   - row aoData index\r\n       * {node}      - TR node\r\n       * {string}    - jQuery selector to apply to the TR elements\r\n       * {array}     - jQuery array of nodes, or simply an array of TR nodes\r\n       *\r\n       */\r\n\r\n      var __row_selector = function (settings, selector, opts) {\r\n        return _selector_run(selector, function (sel) {\r\n          var selInt = _intVal(sel)\r\n\r\n          // Short cut - selector is a number and no options provided (default is\r\n          // all records, so no need to check if the index is in there, since it\r\n          // must be - dev error if the index doesn't exist).\r\n          if (selInt !== null && !opts) {\r\n            return [selInt]\r\n          }\r\n\r\n          var rows = _selector_row_indexes(settings, opts)\r\n\r\n          if (selInt !== null && $.inArray(selInt, rows) !== -1) {\r\n            // Selector - integer\r\n            return [selInt]\r\n          } else if (!sel) {\r\n            // Selector - none\r\n            return rows\r\n          }\r\n\r\n          // Get nodes in the order from the `rows` array (can't use `pluck`) @todo - use pluck_order\r\n          var nodes = []\r\n          for (var i = 0, ien = rows.length; i < ien; i++) {\r\n            nodes.push(settings.aoData[rows[i]].nTr)\r\n          }\r\n\r\n          if (sel.nodeName) {\r\n            // Selector - node\r\n            if ($.inArray(sel, nodes) !== -1) {\r\n              return [sel._DT_RowIndex] // sel is a TR node that is in the table\r\n              // and DataTables adds a prop for fast lookup\r\n            }\r\n          }\r\n\r\n          // Selector - jQuery selector string, array of nodes or jQuery object/\r\n          // As jQuery's .filter() allows jQuery objects to be passed in filter,\r\n          // it also allows arrays, so this will cope with all three options\r\n          return $(nodes)\r\n            .filter(sel)\r\n            .map(function () {\r\n              return this._DT_RowIndex\r\n            })\r\n            .toArray()\r\n        })\r\n      }\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('rows()', function (selector, opts) {\r\n        // argument shifting\r\n        if (selector === undefined) {\r\n          selector = ''\r\n        } else if ($.isPlainObject(selector)) {\r\n          opts = selector\r\n          selector = ''\r\n        }\r\n\r\n        opts = _selector_opts(opts)\r\n\r\n        var inst = this.iterator('table', function (settings) {\r\n          return __row_selector(settings, selector, opts)\r\n        })\r\n\r\n        // Want argument shifting here and in __row_selector?\r\n        inst.selector.rows = selector\r\n        inst.selector.opts = opts\r\n\r\n        return inst\r\n      })\r\n\r\n      _api_register('rows().nodes()', function () {\r\n        return this.iterator('row', function (settings, row) {\r\n          return settings.aoData[row].nTr || undefined\r\n        })\r\n      })\r\n\r\n      _api_register('rows().data()', function () {\r\n        return this.iterator(true, 'rows', function (settings, rows) {\r\n          return _pluck_order(settings.aoData, rows, '_aData')\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().cache()', 'row().cache()', function (type) {\r\n        return this.iterator('row', function (settings, row) {\r\n          var r = settings.aoData[row]\r\n          return type === 'search' ? r._aFilterData : r._aSortData\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {\r\n        return this.iterator('row', function (settings, row) {\r\n          _fnInvalidateRow(settings, row, src)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().indexes()', 'row().index()', function () {\r\n        return this.iterator('row', function (settings, row) {\r\n          return row\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('rows().remove()', 'row().remove()', function () {\r\n        var that = this\r\n\r\n        return this.iterator('row', function (settings, row, thatIdx) {\r\n          var data = settings.aoData\r\n\r\n          data.splice(row, 1)\r\n\r\n          // Update the _DT_RowIndex parameter on all rows in the table\r\n          for (var i = 0, ien = data.length; i < ien; i++) {\r\n            if (data[i].nTr !== null) {\r\n              data[i].nTr._DT_RowIndex = i\r\n            }\r\n          }\r\n\r\n          // Remove the target row from the search array\r\n          var displayIndex = $.inArray(row, settings.aiDisplay)\r\n\r\n          // Delete from the display arrays\r\n          _fnDeleteIndex(settings.aiDisplayMaster, row)\r\n          _fnDeleteIndex(settings.aiDisplay, row)\r\n          _fnDeleteIndex(that[thatIdx], row, false) // maintain local indexes\r\n\r\n          // Check for an 'overflow' they case for displaying the table\r\n          _fnLengthOverflow(settings)\r\n        })\r\n      })\r\n\r\n      _api_register('rows.add()', function (rows) {\r\n        var newRows = this.iterator('table', function (settings) {\r\n          var row, i, ien\r\n          var out = []\r\n\r\n          for (i = 0, ien = rows.length; i < ien; i++) {\r\n            row = rows[i]\r\n\r\n            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\r\n              out.push(_fnAddTr(settings, row)[0])\r\n            } else {\r\n              out.push(_fnAddData(settings, row))\r\n            }\r\n          }\r\n\r\n          return out\r\n        })\r\n\r\n        // Return an Api.rows() extended instance, so rows().nodes() etc can be used\r\n        var modRows = this.rows(-1)\r\n        modRows.pop()\r\n        modRows.push.apply(modRows, newRows.toArray())\r\n\r\n        return modRows\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('row()', function (selector, opts) {\r\n        return _selector_first(this.rows(selector, opts))\r\n      })\r\n\r\n      _api_register('row().data()', function (data) {\r\n        var ctx = this.context\r\n\r\n        if (data === undefined) {\r\n          // Get\r\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined\r\n        }\r\n\r\n        // Set\r\n        ctx[0].aoData[this[0]]._aData = data\r\n\r\n        // Automatically invalidate\r\n        _fnInvalidateRow(ctx[0], this[0], 'data')\r\n\r\n        return this\r\n      })\r\n\r\n      _api_register('row().node()', function () {\r\n        var ctx = this.context\r\n\r\n        return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null\r\n      })\r\n\r\n      _api_register('row.add()', function (row) {\r\n        // Allow a jQuery object to be passed in - only a single row is added from\r\n        // it though - the first element in the set\r\n        if (row instanceof $ && row.length) {\r\n          row = row[0]\r\n        }\r\n\r\n        var rows = this.iterator('table', function (settings) {\r\n          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\r\n            return _fnAddTr(settings, row)[0]\r\n          }\r\n          return _fnAddData(settings, row)\r\n        })\r\n\r\n        // Return an Api.rows() extended instance, with the newly added row selected\r\n        return this.row(rows[0])\r\n      })\r\n\r\n      var __details_add = function (ctx, row, data, klass) {\r\n        // Convert to array of TR elements\r\n        var rows = []\r\n        var addRow = function (r, k) {\r\n          // If we get a TR element, then just add it directly - up to the dev\r\n          // to add the correct number of columns etc\r\n          if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {\r\n            rows.push(r)\r\n          } else {\r\n            // Otherwise create a row with a wrapper\r\n            var created = $('<tr><td/></tr>').addClass(k)\r\n            $('td', created)\r\n              .addClass(k)\r\n              .html(r)[0].colSpan = _fnVisbleColumns(ctx)\r\n\r\n            rows.push(created[0])\r\n          }\r\n        }\r\n\r\n        if ($.isArray(data) || data instanceof $) {\r\n          for (var i = 0, ien = data.length; i < ien; i++) {\r\n            addRow(data[i], klass)\r\n          }\r\n        } else {\r\n          addRow(data, klass)\r\n        }\r\n\r\n        if (row._details) {\r\n          row._details.remove()\r\n        }\r\n\r\n        row._details = $(rows)\r\n\r\n        // If the children were already shown, that state should be retained\r\n        if (row._detailsShow) {\r\n          row._details.insertAfter(row.nTr)\r\n        }\r\n      }\r\n\r\n      var __details_remove = function (api) {\r\n        var ctx = api.context\r\n\r\n        if (ctx.length && api.length) {\r\n          var row = ctx[0].aoData[api[0]]\r\n\r\n          if (row._details) {\r\n            row._details.remove()\r\n\r\n            row._detailsShow = undefined\r\n            row._details = undefined\r\n          }\r\n        }\r\n      }\r\n\r\n      var __details_display = function (api, show) {\r\n        var ctx = api.context\r\n\r\n        if (ctx.length && api.length) {\r\n          var row = ctx[0].aoData[api[0]]\r\n\r\n          if (row._details) {\r\n            row._detailsShow = show\r\n\r\n            if (show) {\r\n              row._details.insertAfter(row.nTr)\r\n            } else {\r\n              row._details.detach()\r\n            }\r\n\r\n            __details_events(ctx[0])\r\n          }\r\n        }\r\n      }\r\n\r\n      var __details_events = function (settings) {\r\n        var api = new _Api(settings)\r\n        var namespace = '.dt.DT_details'\r\n        var drawEvent = 'draw' + namespace\r\n        var colvisEvent = 'column-visibility' + namespace\r\n        var destroyEvent = 'destroy' + namespace\r\n        var data = settings.aoData\r\n\r\n        api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent)\r\n\r\n        if (_pluck(data, '_details').length > 0) {\r\n          // On each draw, insert the required elements into the document\r\n          api.on(drawEvent, function (e, ctx) {\r\n            if (settings !== ctx) {\r\n              return\r\n            }\r\n\r\n            api\r\n              .rows({ page: 'current' })\r\n              .eq(0)\r\n              .each(function (idx) {\r\n                // Internal data grab\r\n                var row = data[idx]\r\n\r\n                if (row._detailsShow) {\r\n                  row._details.insertAfter(row.nTr)\r\n                }\r\n              })\r\n          })\r\n\r\n          // Column visibility change - update the colspan\r\n          api.on(colvisEvent, function (e, ctx, idx, vis) {\r\n            if (settings !== ctx) {\r\n              return\r\n            }\r\n\r\n            // Update the colspan for the details rows (note, only if it already has\r\n            // a colspan)\r\n            var row,\r\n              visible = _fnVisbleColumns(ctx)\r\n\r\n            for (var i = 0, ien = data.length; i < ien; i++) {\r\n              row = data[i]\r\n\r\n              if (row._details) {\r\n                row._details.children('td[colspan]').attr('colspan', visible)\r\n              }\r\n            }\r\n          })\r\n\r\n          // Table destroyed - nuke any child rows\r\n          api.on(destroyEvent, function (e, ctx) {\r\n            if (settings !== ctx) {\r\n              return\r\n            }\r\n\r\n            for (var i = 0, ien = data.length; i < ien; i++) {\r\n              if (data[i]._details) {\r\n                __details_remove(data[i])\r\n              }\r\n            }\r\n          })\r\n        }\r\n      }\r\n\r\n      // Strings for the method names to help minification\r\n      var _emp = ''\r\n      var _child_obj = _emp + 'row().child'\r\n      var _child_mth = _child_obj + '()'\r\n\r\n      // data can be:\r\n      //  tr\r\n      //  string\r\n      //  jQuery or array of any of the above\r\n      _api_register(_child_mth, function (data, klass) {\r\n        var ctx = this.context\r\n\r\n        if (data === undefined) {\r\n          // get\r\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined\r\n        } else if (data === true) {\r\n          // show\r\n          this.child.show()\r\n        } else if (data === false) {\r\n          // remove\r\n          __details_remove(this)\r\n        } else if (ctx.length && this.length) {\r\n          // set\r\n          __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass)\r\n        }\r\n\r\n        return this\r\n      })\r\n\r\n      _api_register(\r\n        [\r\n          _child_obj + '.show()',\r\n          _child_mth + '.show()' // only when `child()` was called with parameters (without\r\n        ],\r\n        function (show) {\r\n          // it returns an object and this method is not executed)\r\n          __details_display(this, true)\r\n          return this\r\n        }\r\n      )\r\n\r\n      _api_register(\r\n        [\r\n          _child_obj + '.hide()',\r\n          _child_mth + '.hide()' // only when `child()` was called with parameters (without\r\n        ],\r\n        function () {\r\n          // it returns an object and this method is not executed)\r\n          __details_display(this, false)\r\n          return this\r\n        }\r\n      )\r\n\r\n      _api_register(\r\n        [\r\n          _child_obj + '.remove()',\r\n          _child_mth + '.remove()' // only when `child()` was called with parameters (without\r\n        ],\r\n        function () {\r\n          // it returns an object and this method is not executed)\r\n          __details_remove(this)\r\n          return this\r\n        }\r\n      )\r\n\r\n      _api_register(_child_obj + '.isShown()', function () {\r\n        var ctx = this.context\r\n\r\n        if (ctx.length && this.length) {\r\n          // _detailsShown as false or undefined will fall through to return false\r\n          return ctx[0].aoData[this[0]]._detailsShow || false\r\n        }\r\n        return false\r\n      })\r\n\r\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\r\n       * Columns\r\n       *\r\n       * {integer}           - column index (>=0 count from left, <0 count from right)\r\n       * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\r\n       * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\r\n       * \"{string}:name\"     - column name\r\n       * \"{string}\"          - jQuery selector on column header nodes\r\n       *\r\n       */\r\n\r\n      // can be an array of these items, comma separated list, or an array of comma\r\n      // separated lists\r\n\r\n      var __re_column_selector = /^(.+):(name|visIdx|visible)$/\r\n\r\n      var __column_selector = function (settings, selector, opts) {\r\n        var columns = settings.aoColumns,\r\n          names = _pluck(columns, 'sName'),\r\n          nodes = _pluck(columns, 'nTh')\r\n\r\n        return _selector_run(selector, function (s) {\r\n          var selInt = _intVal(s)\r\n\r\n          if (s === '') {\r\n            // All columns\r\n            return _range(columns.length)\r\n          } else if (selInt !== null) {\r\n            // Integer selector\r\n            return [\r\n              selInt >= 0\r\n                ? selInt // Count from left\r\n                : columns.length + selInt // Count from right (+ because its a negative value)\r\n            ]\r\n          } else {\r\n            var match = typeof s === 'string' ? s.match(__re_column_selector) : ''\r\n\r\n            if (match) {\r\n              switch (match[2]) {\r\n                case 'visIdx':\r\n                case 'visible':\r\n                  var idx = parseInt(match[1], 10)\r\n                  // Visible index given, convert to column index\r\n                  if (idx < 0) {\r\n                    // Counting from the right\r\n                    var visColumns = $.map(columns, function (col, i) {\r\n                      return col.bVisible ? i : null\r\n                    })\r\n                    return [visColumns[visColumns.length + idx]]\r\n                  }\r\n                  // Counting from the left\r\n                  return [_fnVisibleToColumnIndex(settings, idx)]\r\n\r\n                case 'name':\r\n                  // match by name. `names` is column index complete and in order\r\n                  return $.map(names, function (name, i) {\r\n                    return name === match[1] ? i : null\r\n                  })\r\n              }\r\n            } else {\r\n              // jQuery selector on the TH elements for the columns\r\n              return $(nodes)\r\n                .filter(s)\r\n                .map(function () {\r\n                  return $.inArray(this, nodes) // `nodes` is column index complete and in order\r\n                })\r\n                .toArray()\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      var __setColumnVis = function (settings, column, vis, recalc) {\r\n        var cols = settings.aoColumns,\r\n          col = cols[column],\r\n          data = settings.aoData,\r\n          row,\r\n          cells,\r\n          i,\r\n          ien,\r\n          tr\r\n\r\n        // Get\r\n        if (vis === undefined) {\r\n          return col.bVisible\r\n        }\r\n\r\n        // Set\r\n        // No change\r\n        if (col.bVisible === vis) {\r\n          return\r\n        }\r\n\r\n        if (vis) {\r\n          // Insert column\r\n          // Need to decide if we should use appendChild or insertBefore\r\n          var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1)\r\n\r\n          for (i = 0, ien = data.length; i < ien; i++) {\r\n            tr = data[i].nTr\r\n            cells = data[i].anCells\r\n\r\n            if (tr) {\r\n              // insertBefore can act like appendChild if 2nd arg is null\r\n              tr.insertBefore(cells[column], cells[insertBefore] || null)\r\n            }\r\n          }\r\n        } else {\r\n          // Remove column\r\n          $(_pluck(settings.aoData, 'anCells', column)).detach()\r\n        }\r\n\r\n        // Common actions\r\n        col.bVisible = vis\r\n        _fnDrawHead(settings, settings.aoHeader)\r\n        _fnDrawHead(settings, settings.aoFooter)\r\n\r\n        if (recalc === undefined || recalc) {\r\n          // Automatically adjust column sizing\r\n          _fnAdjustColumnSizing(settings)\r\n\r\n          // Realign columns for scrolling\r\n          if (settings.oScroll.sX || settings.oScroll.sY) {\r\n            _fnScrollDraw(settings)\r\n          }\r\n        }\r\n\r\n        _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis])\r\n\r\n        _fnSaveState(settings)\r\n      }\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('columns()', function (selector, opts) {\r\n        // argument shifting\r\n        if (selector === undefined) {\r\n          selector = ''\r\n        } else if ($.isPlainObject(selector)) {\r\n          opts = selector\r\n          selector = ''\r\n        }\r\n\r\n        opts = _selector_opts(opts)\r\n\r\n        var inst = this.iterator('table', function (settings) {\r\n          return __column_selector(settings, selector, opts)\r\n        })\r\n\r\n        // Want argument shifting here and in _row_selector?\r\n        inst.selector.cols = selector\r\n        inst.selector.opts = opts\r\n\r\n        return inst\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return settings.aoColumns[column].nTh\r\n        })\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return settings.aoColumns[column].nTf\r\n        })\r\n      })\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_registerPlural('columns().data()', 'column().data()', function () {\r\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\r\n          var a = []\r\n          for (var row = 0, ien = rows.length; row < ien; row++) {\r\n            a.push(_fnGetCellData(settings, rows[row], column, ''))\r\n          }\r\n          return a\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().cache()', 'column().cache()', function (type) {\r\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\r\n          return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().nodes()', 'column().nodes()', function () {\r\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\r\n          return _pluck_order(settings.aoData, rows, 'anCells', column)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return vis === undefined ? settings.aoColumns[column].bVisible : __setColumnVis(settings, column, vis, calc)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().indexes()', 'column().index()', function (type) {\r\n        return this.iterator('column', function (settings, column) {\r\n          return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column\r\n        })\r\n      })\r\n\r\n      // _api_register( 'columns().show()', function () {\r\n      // \tvar selector = this.selector;\r\n      // \treturn this.columns( selector.cols, selector.opts ).visible( true );\r\n      // } );\r\n\r\n      // _api_register( 'columns().hide()', function () {\r\n      // \tvar selector = this.selector;\r\n      // \treturn this.columns( selector.cols, selector.opts ).visible( false );\r\n      // } );\r\n\r\n      _api_register('columns.adjust()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          _fnAdjustColumnSizing(settings)\r\n        })\r\n      })\r\n\r\n      // Convert from one column index type, to another type\r\n      _api_register('column.index()', function (type, idx) {\r\n        if (this.context.length !== 0) {\r\n          var ctx = this.context[0]\r\n\r\n          if (type === 'fromVisible' || type === 'toData') {\r\n            return _fnVisibleToColumnIndex(ctx, idx)\r\n          } else if (type === 'fromData' || type === 'toVisible') {\r\n            return _fnColumnIndexToVisible(ctx, idx)\r\n          }\r\n        }\r\n      })\r\n\r\n      _api_register('column()', function (selector, opts) {\r\n        return _selector_first(this.columns(selector, opts))\r\n      })\r\n\r\n      var __cell_selector = function (settings, selector, opts) {\r\n        var data = settings.aoData\r\n        var rows = _selector_row_indexes(settings, opts)\r\n        var cells = _pluck_order(data, rows, 'anCells')\r\n        var allCells = $([].concat.apply([], cells))\r\n        var row\r\n        var columns = settings.aoColumns.length\r\n        var a, i, ien, j\r\n\r\n        return _selector_run(selector, function (s) {\r\n          if (s === null || s === undefined) {\r\n            // All cells\r\n            a = []\r\n\r\n            for (i = 0, ien = rows.length; i < ien; i++) {\r\n              row = rows[i]\r\n\r\n              for (j = 0; j < columns; j++) {\r\n                a.push({\r\n                  row: row,\r\n                  column: j\r\n                })\r\n              }\r\n            }\r\n\r\n            return a\r\n          } else if ($.isPlainObject(s)) {\r\n            return [s]\r\n          }\r\n\r\n          // jQuery filtered cells\r\n          return allCells\r\n            .filter(s)\r\n            .map(function (i, el) {\r\n              row = el.parentNode._DT_RowIndex\r\n\r\n              return {\r\n                row: row,\r\n                column: $.inArray(el, data[row].anCells)\r\n              }\r\n            })\r\n            .toArray()\r\n        })\r\n      }\r\n\r\n      _api_register('cells()', function (rowSelector, columnSelector, opts) {\r\n        // Argument shifting\r\n        if ($.isPlainObject(rowSelector)) {\r\n          // Indexes\r\n          if (typeof rowSelector.row !== undefined) {\r\n            opts = columnSelector\r\n            columnSelector = null\r\n          } else {\r\n            opts = rowSelector\r\n            rowSelector = null\r\n          }\r\n        }\r\n        if ($.isPlainObject(columnSelector)) {\r\n          opts = columnSelector\r\n          columnSelector = null\r\n        }\r\n\r\n        // Cell selector\r\n        if (columnSelector === null || columnSelector === undefined) {\r\n          return this.iterator('table', function (settings) {\r\n            return __cell_selector(settings, rowSelector, _selector_opts(opts))\r\n          })\r\n        }\r\n\r\n        // Row + column selector\r\n        var columns = this.columns(columnSelector, opts)\r\n        var rows = this.rows(rowSelector, opts)\r\n        var a, i, ien, j, jen\r\n\r\n        var cells = this.iterator('table', function (settings, idx) {\r\n          a = []\r\n\r\n          for (i = 0, ien = rows[idx].length; i < ien; i++) {\r\n            for (j = 0, jen = columns[idx].length; j < jen; j++) {\r\n              a.push({\r\n                row: rows[idx][i],\r\n                column: columns[idx][j]\r\n              })\r\n            }\r\n          }\r\n\r\n          return a\r\n        })\r\n\r\n        $.extend(cells.selector, {\r\n          cols: columnSelector,\r\n          rows: rowSelector,\r\n          opts: opts\r\n        })\r\n\r\n        return cells\r\n      })\r\n\r\n      _api_registerPlural('cells().nodes()', 'cell().node()', function () {\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return settings.aoData[row].anCells[column]\r\n        })\r\n      })\r\n\r\n      _api_register('cells().data()', function () {\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return _fnGetCellData(settings, row, column)\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {\r\n        type = type === 'search' ? '_aFilterData' : '_aSortData'\r\n\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return settings.aoData[row][type][column]\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('cells().indexes()', 'cell().index()', function () {\r\n        return this.iterator('cell', function (settings, row, column) {\r\n          return {\r\n            row: row,\r\n            column: column,\r\n            columnVisible: _fnColumnIndexToVisible(settings, column)\r\n          }\r\n        })\r\n      })\r\n\r\n      _api_register(['cells().invalidate()', 'cell().invalidate()'], function (src) {\r\n        var selector = this.selector\r\n\r\n        // Use the rows method of the instance to perform the invalidation, rather\r\n        // than doing it here. This avoids needing to handle duplicate rows from\r\n        // the cells.\r\n        this.rows(selector.rows, selector.opts).invalidate(src)\r\n\r\n        return this\r\n      })\r\n\r\n      _api_register('cell()', function (rowSelector, columnSelector, opts) {\r\n        return _selector_first(this.cells(rowSelector, columnSelector, opts))\r\n      })\r\n\r\n      _api_register('cell().data()', function (data) {\r\n        var ctx = this.context\r\n        var cell = this[0]\r\n\r\n        if (data === undefined) {\r\n          // Get\r\n          return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined\r\n        }\r\n\r\n        // Set\r\n        _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data)\r\n        _fnInvalidateRow(ctx[0], cell[0].row, 'data', cell[0].column)\r\n\r\n        return this\r\n      })\r\n      /**\r\n       * Set the ordering for the table.\r\n       *\r\n       * @param {array} order 2D array of sorting information to be applied.\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      /**\r\n       * Set the ordering for the table.\r\n       *\r\n       * @param {integer} order Column index to sort upon.\r\n       * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      /**\r\n       * Set the ordering for the table.\r\n       *\r\n       * @param {array} order 1D array of sorting information to be applied.\r\n       * @param {array} [...] Optional additional sorting conditions\r\n       * @returns {DataTables.Api} this\r\n       */\r\n\r\n      /**\r\n       * Get current ordering (sorting) that has been applied to the table.\r\n       *\r\n       * @returns {array} 2D array containing the sorting information for the first\r\n       *   table in the current context. Each element in the parent array represents\r\n       *   a column being sorted upon (i.e. multi-sorting with two columns would have\r\n       *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\r\n       *   the column index that the sorting condition applies to, the second is the\r\n       *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\r\n       *   index of the sorting order from the `column.sorting` initialisation array.\r\n       */ _api_register('order()', function (order, dir) {\r\n        var ctx = this.context\r\n\r\n        if (order === undefined) {\r\n          // get\r\n          return ctx.length !== 0 ? ctx[0].aaSorting : undefined\r\n        }\r\n\r\n        // set\r\n        if (typeof order === 'number') {\r\n          // Simple column / direction passed in\r\n          order = [[order, dir]]\r\n        } else if (!$.isArray(order[0])) {\r\n          // Arguments passed in (list of 1D arrays)\r\n          order = Array.prototype.slice.call(arguments)\r\n        }\r\n        // otherwise a 2D array was passed in\r\n\r\n        return this.iterator('table', function (settings) {\r\n          settings.aaSorting = order.slice()\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Attach a sort listener to an element for a given column\r\n       *\r\n       * @param {node|jQuery|string} node Identifier for the element(s) to attach the\r\n       *   listener to. This can take the form of a single DOM node, a jQuery\r\n       *   collection of nodes or a jQuery selector which will identify the node(s).\r\n       * @param {integer} column the column that a click on this node will sort on\r\n       * @param {function} [callback] callback function when sort is run\r\n       * @returns {DataTables.Api} this\r\n       */\r\n      _api_register('order.listener()', function (node, column, callback) {\r\n        return this.iterator('table', function (settings) {\r\n          _fnSortAttachListener(settings, node, column, callback)\r\n        })\r\n      })\r\n\r\n      // Order by the selected column(s)\r\n      _api_register(['columns().order()', 'column().order()'], function (dir) {\r\n        var that = this\r\n\r\n        return this.iterator('table', function (settings, i) {\r\n          var sort = []\r\n\r\n          $.each(that[i], function (j, col) {\r\n            sort.push([col, dir])\r\n          })\r\n\r\n          settings.aaSorting = sort\r\n        })\r\n      })\r\n\r\n      _api_register('search()', function (input, regex, smart, caseInsen) {\r\n        var ctx = this.context\r\n\r\n        if (input === undefined) {\r\n          // get\r\n          return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined\r\n        }\r\n\r\n        // set\r\n        return this.iterator('table', function (settings) {\r\n          if (!settings.oFeatures.bFilter) {\r\n            return\r\n          }\r\n\r\n          _fnFilterComplete(\r\n            settings,\r\n            $.extend({}, settings.oPreviousSearch, {\r\n              sSearch: input + '',\r\n              bRegex: regex === null ? false : regex,\r\n              bSmart: smart === null ? true : smart,\r\n              bCaseInsensitive: caseInsen === null ? true : caseInsen\r\n            }),\r\n            1\r\n          )\r\n        })\r\n      })\r\n\r\n      _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {\r\n        return this.iterator('column', function (settings, column) {\r\n          var preSearch = settings.aoPreSearchCols\r\n\r\n          if (input === undefined) {\r\n            // get\r\n            return preSearch[column].sSearch\r\n          }\r\n\r\n          // set\r\n          if (!settings.oFeatures.bFilter) {\r\n            return\r\n          }\r\n\r\n          $.extend(preSearch[column], {\r\n            sSearch: input + '',\r\n            bRegex: regex === null ? false : regex,\r\n            bSmart: smart === null ? true : smart,\r\n            bCaseInsensitive: caseInsen === null ? true : caseInsen\r\n          })\r\n\r\n          _fnFilterComplete(settings, settings.oPreviousSearch, 1)\r\n        })\r\n      })\r\n\r\n      /*\r\n       * State API methods\r\n       */\r\n\r\n      _api_register('state()', function () {\r\n        return this.context.length ? this.context[0].oSavedState : null\r\n      })\r\n\r\n      _api_register('state.clear()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          // Save an empty object\r\n          settings.fnStateSaveCallback.call(settings.oInstance, settings, {})\r\n        })\r\n      })\r\n\r\n      _api_register('state.loaded()', function () {\r\n        return this.context.length ? this.context[0].oLoadedState : null\r\n      })\r\n\r\n      _api_register('state.save()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          _fnSaveState(settings)\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Provide a common method for plug-ins to check the version of DataTables being\r\n       * used, in order to ensure compatibility.\r\n       *\r\n       *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\r\n       *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\r\n       *  @returns {boolean} true if this version of DataTables is greater or equal to\r\n       *    the required version, or false if this version of DataTales is not\r\n       *    suitable\r\n       *  @static\r\n       *  @dtopt API-Static\r\n       *\r\n       *  @example\r\n       *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\r\n       */\r\n      DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {\r\n        var aThis = DataTable.version.split('.')\r\n        var aThat = version.split('.')\r\n        var iThis, iThat\r\n\r\n        for (var i = 0, iLen = aThat.length; i < iLen; i++) {\r\n          iThis = parseInt(aThis[i], 10) || 0\r\n          iThat = parseInt(aThat[i], 10) || 0\r\n\r\n          // Parts are the same, keep comparing\r\n          if (iThis === iThat) {\r\n            continue\r\n          }\r\n\r\n          // Parts are different, return immediately\r\n          return iThis > iThat\r\n        }\r\n\r\n        return true\r\n      }\r\n\r\n      /**\r\n       * Check if a `<table>` node is a DataTable table already or not.\r\n       *\r\n       *  @param {node|jquery|string} table Table node, jQuery object or jQuery\r\n       *      selector for the table to test. Note that if more than more than one\r\n       *      table is passed on, only the first will be checked\r\n       *  @returns {boolean} true the table given is a DataTable, or false otherwise\r\n       *  @static\r\n       *  @dtopt API-Static\r\n       *\r\n       *  @example\r\n       *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\r\n       *      $('#example').dataTable();\r\n       *    }\r\n       */\r\n      DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {\r\n        var t = $(table).get(0)\r\n        var is = false\r\n\r\n        $.each(DataTable.settings, function (i, o) {\r\n          if (o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t) {\r\n            is = true\r\n          }\r\n        })\r\n\r\n        return is\r\n      }\r\n\r\n      /**\r\n       * Get all DataTable tables that have been initialised - optionally you can\r\n       * select to get only currently visible tables.\r\n       *\r\n       *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\r\n       *    or visible tables only.\r\n       *  @returns {array} Array of `table` nodes (not DataTable instances) which are\r\n       *    DataTables\r\n       *  @static\r\n       *  @dtopt API-Static\r\n       *\r\n       *  @example\r\n       *    $.each( $.fn.dataTable.tables(true), function () {\r\n       *      $(table).DataTable().columns.adjust();\r\n       *    } );\r\n       */\r\n      DataTable.tables = DataTable.fnTables = function (visible) {\r\n        return jQuery.map(DataTable.settings, function (o) {\r\n          if (!visible || (visible && $(o.nTable).is(':visible'))) {\r\n            return o.nTable\r\n          }\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Convert from camel case parameters to Hungarian notation. This is made public\r\n       * for the extensions to provide the same ability as DataTables core to accept\r\n       * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\r\n       * parameters.\r\n       *\r\n       *  @param {object} src The model object which holds all parameters that can be\r\n       *    mapped.\r\n       *  @param {object} user The object to convert from camel case to Hungarian.\r\n       *  @param {boolean} force When set to `true`, properties which already have a\r\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\r\n       *    won't be.\r\n       */\r\n      DataTable.camelToHungarian = _fnCamelToHungarian\r\n\r\n      /**\r\n       *\r\n       */\r\n      _api_register('$()', function (selector, opts) {\r\n        var rows = this.rows(opts).nodes(), // Get all rows\r\n          jqRows = $(rows)\r\n\r\n        return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()))\r\n      })\r\n\r\n      // jQuery functions to operate on the tables\r\n      $.each(['on', 'one', 'off'], function (i, key) {\r\n        _api_register(key + '()', function (/* event, handler */) {\r\n          var args = Array.prototype.slice.call(arguments)\r\n\r\n          // Add the `dt` namespace automatically if it isn't already present\r\n          if (!args[0].match(/\\.dt\\b/)) {\r\n            args[0] += '.dt'\r\n          }\r\n\r\n          var inst = $(this.tables().nodes())\r\n          inst[key].apply(inst, args)\r\n          return this\r\n        })\r\n      })\r\n\r\n      _api_register('clear()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          _fnClearTable(settings)\r\n        })\r\n      })\r\n\r\n      _api_register('settings()', function () {\r\n        return new _Api(this.context, this.context)\r\n      })\r\n\r\n      _api_register('data()', function () {\r\n        return this.iterator('table', function (settings) {\r\n          return _pluck(settings.aoData, '_aData')\r\n        }).flatten()\r\n      })\r\n\r\n      _api_register('destroy()', function (remove) {\r\n        remove = remove || false\r\n\r\n        return this.iterator('table', function (settings) {\r\n          var orig = settings.nTableWrapper.parentNode\r\n          var classes = settings.oClasses\r\n          var table = settings.nTable\r\n          var tbody = settings.nTBody\r\n          var thead = settings.nTHead\r\n          var tfoot = settings.nTFoot\r\n          var jqTable = $(table)\r\n          var jqTbody = $(tbody)\r\n          var jqWrapper = $(settings.nTableWrapper)\r\n          var rows = $.map(settings.aoData, function (r) {\r\n            return r.nTr\r\n          })\r\n          var i, ien\r\n\r\n          // Flag to note that the table is currently being destroyed - no action\r\n          // should be taken\r\n          settings.bDestroying = true\r\n\r\n          // Fire off the destroy callbacks for plug-ins etc\r\n          _fnCallbackFire(settings, 'aoDestroyCallback', 'destroy', [settings])\r\n\r\n          // If not being removed from the document, make all columns visible\r\n          if (!remove) {\r\n            new _Api(settings).columns().visible(true)\r\n          }\r\n\r\n          // Blitz all `DT` namespaced events (these are internal events, the\r\n          // lowercase, `dt` events are user subscribed and they are responsible\r\n          // for removing them\r\n          jqWrapper\r\n            .unbind('.DT')\r\n            .find(':not(tbody *)')\r\n            .unbind('.DT')\r\n          $(window).unbind('.DT-' + settings.sInstance)\r\n\r\n          // When scrolling we had to break the table up - restore it\r\n          if (table != thead.parentNode) {\r\n            jqTable.children('thead').detach()\r\n            jqTable.append(thead)\r\n          }\r\n\r\n          if (tfoot && table != tfoot.parentNode) {\r\n            jqTable.children('tfoot').detach()\r\n            jqTable.append(tfoot)\r\n          }\r\n\r\n          // Remove the DataTables generated nodes, events and classes\r\n          jqTable.detach()\r\n          jqWrapper.detach()\r\n\r\n          settings.aaSorting = []\r\n          settings.aaSortingFixed = []\r\n          _fnSortingClasses(settings)\r\n\r\n          $(rows).removeClass(settings.asStripeClasses.join(' '))\r\n\r\n          $('th, td', thead).removeClass(\r\n            classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone\r\n          )\r\n\r\n          if (settings.bJUI) {\r\n            $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach()\r\n            $('th, td', thead).each(function () {\r\n              var wrapper = $('div.' + classes.sSortJUIWrapper, this)\r\n              $(this).append(wrapper.contents())\r\n              wrapper.detach()\r\n            })\r\n          }\r\n\r\n          if (!remove && orig) {\r\n            // insertBefore acts like appendChild if !arg[1]\r\n            orig.insertBefore(table, settings.nTableReinsertBefore)\r\n          }\r\n\r\n          // Add the TR elements back into the table in their original order\r\n          jqTbody.children().detach()\r\n          jqTbody.append(rows)\r\n\r\n          // Restore the width of the original table - was read from the style property,\r\n          // so we can restore directly to that\r\n          jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable)\r\n\r\n          // If the were originally stripe classes - then we add them back here.\r\n          // Note this is not fool proof (for example if not all rows had stripe\r\n          // classes - but it's a good effort without getting carried away\r\n          ien = settings.asDestroyStripes.length\r\n\r\n          if (ien) {\r\n            jqTbody.children().each(function (i) {\r\n              $(this).addClass(settings.asDestroyStripes[i % ien])\r\n            })\r\n          }\r\n\r\n          /* Remove the settings object from the settings array */\r\n          var idx = $.inArray(settings, DataTable.settings)\r\n          if (idx !== -1) {\r\n            DataTable.settings.splice(idx, 1)\r\n          }\r\n        })\r\n      })\r\n\r\n      /**\r\n       * Version string for plug-ins to check compatibility. Allowed format is\r\n       * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\r\n       * only for non-release builds. See http://semver.org/ for more information.\r\n       *  @member\r\n       *  @type string\r\n       *  @default Version number\r\n       */\r\n      DataTable.version = '1.10.2'\r\n\r\n      /**\r\n       * Private data store, containing all of the settings objects that are\r\n       * created for the tables on a given page.\r\n       *\r\n       * Note that the `DataTable.settings` object is aliased to\r\n       * `jQuery.fn.dataTableExt` through which it may be accessed and\r\n       * manipulated, or `jQuery.fn.dataTable.settings`.\r\n       *  @member\r\n       *  @type array\r\n       *  @default []\r\n       *  @private\r\n       */\r\n      DataTable.settings = []\r\n\r\n      /**\r\n       * Object models container, for the various models that DataTables has\r\n       * available to it. These models define the objects that are used to hold\r\n       * the active state and configuration of the table.\r\n       *  @namespace\r\n       */\r\n      DataTable.models = {}\r\n\r\n      /**\r\n       * Template object for the way in which DataTables holds information about\r\n       * search information for the global filter and individual column filters.\r\n       *  @namespace\r\n       */\r\n      DataTable.models.oSearch = {\r\n        /**\r\n         * Flag to indicate if the filtering should be case insensitive or not\r\n         *  @type boolean\r\n         *  @default true\r\n         */\r\n        bCaseInsensitive: true,\r\n\r\n        /**\r\n         * Applied search term\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         */\r\n        sSearch: '',\r\n\r\n        /**\r\n         * Flag to indicate if the search term should be interpreted as a\r\n         * regular expression (true) or not (false) and therefore and special\r\n         * regex characters escaped.\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bRegex: false,\r\n\r\n        /**\r\n         * Flag to indicate if DataTables is to use its smart filtering or not.\r\n         *  @type boolean\r\n         *  @default true\r\n         */\r\n        bSmart: true\r\n      }\r\n\r\n      /**\r\n       * Template object for the way in which DataTables holds information about\r\n       * each individual row. This is the object format used for the settings\r\n       * aoData array.\r\n       *  @namespace\r\n       */\r\n      DataTable.models.oRow = {\r\n        /**\r\n         * TR element for the row\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTr: null,\r\n\r\n        /**\r\n         * Array of TD elements for each row. This is null until the row has been\r\n         * created.\r\n         *  @type array nodes\r\n         *  @default []\r\n         */\r\n        anCells: null,\r\n\r\n        /**\r\n         * Data object from the original data source for the row. This is either\r\n         * an array if using the traditional form of DataTables, or an object if\r\n         * using mData options. The exact type will depend on the passed in\r\n         * data from the data source, or will be an array if using DOM a data\r\n         * source.\r\n         *  @type array|object\r\n         *  @default []\r\n         */\r\n        _aData: [],\r\n\r\n        /**\r\n         * Sorting data cache - this array is ostensibly the same length as the\r\n         * number of columns (although each index is generated only as it is\r\n         * needed), and holds the data that is used for sorting each column in the\r\n         * row. We do this cache generation at the start of the sort in order that\r\n         * the formatting of the sort data need be done only once for each cell\r\n         * per sort. This array should not be read from or written to by anything\r\n         * other than the master sorting methods.\r\n         *  @type array\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _aSortData: null,\r\n\r\n        /**\r\n         * Per cell filtering data cache. As per the sort data cache, used to\r\n         * increase the performance of the filtering in DataTables\r\n         *  @type array\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _aFilterData: null,\r\n\r\n        /**\r\n         * Filtering data cache. This is the same as the cell filtering cache, but\r\n         * in this case a string rather than an array. This is easily computed with\r\n         * a join on `_aFilterData`, but is provided as a cache so the join isn't\r\n         * needed on every search (memory traded for performance)\r\n         *  @type array\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _sFilterRow: null,\r\n\r\n        /**\r\n         * Cache of the class name that DataTables has applied to the row, so we\r\n         * can quickly look at this variable rather than needing to do a DOM check\r\n         * on className for the nTr property.\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         *  @private\r\n         */\r\n        _sRowStripe: '',\r\n\r\n        /**\r\n         * Denote if the original data source was from the DOM, or the data source\r\n         * object. This is used for invalidating data, so DataTables can\r\n         * automatically read data from the original source, unless uninstructed\r\n         * otherwise.\r\n         *  @type string\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        src: null\r\n      }\r\n\r\n      /**\r\n       * Template object for the column information object in DataTables. This object\r\n       * is held in the settings aoColumns array and contains all the information that\r\n       * DataTables needs about each individual column.\r\n       *\r\n       * Note that this object is related to {@link DataTable.defaults.column}\r\n       * but this one is the internal data store for DataTables's cache of columns.\r\n       * It should NOT be manipulated outside of DataTables. Any configuration should\r\n       * be done through the initialisation options.\r\n       *  @namespace\r\n       */\r\n      DataTable.models.oColumn = {\r\n        /**\r\n         * Column index. This could be worked out on-the-fly with $.inArray, but it\r\n         * is faster to just hold it as a variable\r\n         *  @type integer\r\n         *  @default null\r\n         */\r\n        idx: null,\r\n\r\n        /**\r\n         * A list of the columns that sorting should occur on when this column\r\n         * is sorted. That this property is an array allows multi-column sorting\r\n         * to be defined for a column (for example first name / last name columns\r\n         * would benefit from this). The values are integers pointing to the\r\n         * columns to be sorted on (typically it will be a single integer pointing\r\n         * at itself, but that doesn't need to be the case).\r\n         *  @type array\r\n         */\r\n        aDataSort: null,\r\n\r\n        /**\r\n         * Define the sorting directions that are applied to the column, in sequence\r\n         * as the column is repeatedly sorted upon - i.e. the first value is used\r\n         * as the sorting direction when the column if first sorted (clicked on).\r\n         * Sort it again (click again) and it will move on to the next index.\r\n         * Repeat until loop.\r\n         *  @type array\r\n         */\r\n        asSorting: null,\r\n\r\n        /**\r\n         * Flag to indicate if the column is searchable, and thus should be included\r\n         * in the filtering or not.\r\n         *  @type boolean\r\n         */\r\n        bSearchable: null,\r\n\r\n        /**\r\n         * Flag to indicate if the column is sortable or not.\r\n         *  @type boolean\r\n         */\r\n        bSortable: null,\r\n\r\n        /**\r\n         * Flag to indicate if the column is currently visible in the table or not\r\n         *  @type boolean\r\n         */\r\n        bVisible: null,\r\n\r\n        /**\r\n         * Store for manual type assignment using the `column.type` option. This\r\n         * is held in store so we can manipulate the column's `sType` property.\r\n         *  @type string\r\n         *  @default null\r\n         *  @private\r\n         */\r\n        _sManualType: null,\r\n\r\n        /**\r\n         * Flag to indicate if HTML5 data attributes should be used as the data\r\n         * source for filtering or sorting. True is either are.\r\n         *  @type boolean\r\n         *  @default false\r\n         *  @private\r\n         */\r\n        _bAttrSrc: false,\r\n\r\n        /**\r\n         * Developer definable function that is called whenever a cell is created (Ajax source,\r\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\r\n         * allowing you to modify the DOM element (add background colour for example) when the\r\n         * element is available.\r\n         *  @type function\r\n         *  @param {element} nTd The TD node that has been created\r\n         *  @param {*} sData The Data for the cell\r\n         *  @param {array|object} oData The data for the whole row\r\n         *  @param {int} iRow The row index for the aoData data store\r\n         *  @default null\r\n         */\r\n        fnCreatedCell: null,\r\n\r\n        /**\r\n         * Function to get data from a cell in a column. You should <b>never</b>\r\n         * access data directly through _aData internally in DataTables - always use\r\n         * the method attached to this property. It allows mData to function as\r\n         * required. This function is automatically assigned by the column\r\n         * initialisation method\r\n         *  @type function\r\n         *  @param {array|object} oData The data array/object for the array\r\n         *    (i.e. aoData[]._aData)\r\n         *  @param {string} sSpecific The specific data type you want to get -\r\n         *    'display', 'type' 'filter' 'sort'\r\n         *  @returns {*} The data for the cell from the given row's data\r\n         *  @default null\r\n         */\r\n        fnGetData: null,\r\n\r\n        /**\r\n         * Function to set data for a cell in the column. You should <b>never</b>\r\n         * set the data directly to _aData internally in DataTables - always use\r\n         * this method. It allows mData to function as required. This function\r\n         * is automatically assigned by the column initialisation method\r\n         *  @type function\r\n         *  @param {array|object} oData The data array/object for the array\r\n         *    (i.e. aoData[]._aData)\r\n         *  @param {*} sValue Value to set\r\n         *  @default null\r\n         */\r\n        fnSetData: null,\r\n\r\n        /**\r\n         * Property to read the value for the cells in the column from the data\r\n         * source array / object. If null, then the default content is used, if a\r\n         * function is given then the return from the function is used.\r\n         *  @type function|int|string|null\r\n         *  @default null\r\n         */\r\n        mData: null,\r\n\r\n        /**\r\n         * Partner property to mData which is used (only when defined) to get\r\n         * the data - i.e. it is basically the same as mData, but without the\r\n         * 'set' option, and also the data fed to it is the result from mData.\r\n         * This is the rendering method to match the data method of mData.\r\n         *  @type function|int|string|null\r\n         *  @default null\r\n         */\r\n        mRender: null,\r\n\r\n        /**\r\n         * Unique header TH/TD element for this column - this is what the sorting\r\n         * listener is attached to (if sorting is enabled.)\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTh: null,\r\n\r\n        /**\r\n         * Unique footer TH/TD element for this column (if there is one). Not used\r\n         * in DataTables as such, but can be used for plug-ins to reference the\r\n         * footer for each column.\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTf: null,\r\n\r\n        /**\r\n         * The class to apply to all TD elements in the table's TBODY for the column\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sClass: null,\r\n\r\n        /**\r\n         * When DataTables calculates the column widths to assign to each column,\r\n         * it finds the longest string in each column and then constructs a\r\n         * temporary table and reads the widths from that. The problem with this\r\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\r\n         * string - thus the calculation can go wrong (doing it properly and putting\r\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\r\n         * a \"work around\" we provide this option. It will append its value to the\r\n         * text that is found to be the longest string for the column - i.e. padding.\r\n         *  @type string\r\n         */\r\n        sContentPadding: null,\r\n\r\n        /**\r\n         * Allows a default value to be given for a column's data, and will be used\r\n         * whenever a null data source is encountered (this can be because mData\r\n         * is set to null, or because the data source itself is null).\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sDefaultContent: null,\r\n\r\n        /**\r\n         * Name for the column, allowing reference to the column by name as well as\r\n         * by index (needs a lookup to work by name).\r\n         *  @type string\r\n         */\r\n        sName: null,\r\n\r\n        /**\r\n         * Custom sorting data type - defines which of the available plug-ins in\r\n         * afnSortData the custom sorting will use - if any is defined.\r\n         *  @type string\r\n         *  @default std\r\n         */\r\n        sSortDataType: 'std',\r\n\r\n        /**\r\n         * Class to be applied to the header element when sorting on this column\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sSortingClass: null,\r\n\r\n        /**\r\n         * Class to be applied to the header element when sorting on this column -\r\n         * when jQuery UI theming is used.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sSortingClassJUI: null,\r\n\r\n        /**\r\n         * Title of the column - what is seen in the TH element (nTh).\r\n         *  @type string\r\n         */\r\n        sTitle: null,\r\n\r\n        /**\r\n         * Column sorting and filtering type\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sType: null,\r\n\r\n        /**\r\n         * Width of the column\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sWidth: null,\r\n\r\n        /**\r\n         * Width of the column when it was first \"encountered\"\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sWidthOrig: null\r\n      }\r\n\r\n      /*\r\n       * Developer note: The properties of the object below are given in Hungarian\r\n       * notation, that was used as the interface for DataTables prior to v1.10, however\r\n       * from v1.10 onwards the primary interface is camel case. In order to avoid\r\n       * breaking backwards compatibility utterly with this change, the Hungarian\r\n       * version is still, internally the primary interface, but is is not documented\r\n       * - hence the @name tags in each doc comment. This allows a Javascript function\r\n       * to create a map from Hungarian notation to camel case (going the other direction\r\n       * would require each property to be listed, which would at around 3K to the size\r\n       * of DataTables, while this method is about a 0.5K hit.\r\n       *\r\n       * Ultimately this does pave the way for Hungarian notation to be dropped\r\n       * completely, but that is a massive amount of work and will break current\r\n       * installs (therefore is on-hold until v2).\r\n       */\r\n\r\n      /**\r\n       * Initialisation options that can be given to DataTables at initialisation\r\n       * time.\r\n       *  @namespace\r\n       */\r\n      DataTable.defaults = {\r\n        /**\r\n         * An array of data to use for the table, passed in at initialisation which\r\n         * will be used in preference to any data which is already in the DOM. This is\r\n         * particularly useful for constructing tables purely in Javascript, for\r\n         * example with a custom Ajax call.\r\n         *  @type array\r\n         *  @default null\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.data\r\n         *\r\n         *  @example\r\n         *    // Using a 2D array data source\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"data\": [\r\n         *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\r\n         *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\r\n         *        ],\r\n         *        \"columns\": [\r\n         *          { \"title\": \"Engine\" },\r\n         *          { \"title\": \"Browser\" },\r\n         *          { \"title\": \"Platform\" },\r\n         *          { \"title\": \"Version\" },\r\n         *          { \"title\": \"Grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using an array of objects as a data source (`data`)\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"data\": [\r\n         *          {\r\n         *            \"engine\":   \"Trident\",\r\n         *            \"browser\":  \"Internet Explorer 4.0\",\r\n         *            \"platform\": \"Win 95+\",\r\n         *            \"version\":  4,\r\n         *            \"grade\":    \"X\"\r\n         *          },\r\n         *          {\r\n         *            \"engine\":   \"Trident\",\r\n         *            \"browser\":  \"Internet Explorer 5.0\",\r\n         *            \"platform\": \"Win 95+\",\r\n         *            \"version\":  5,\r\n         *            \"grade\":    \"C\"\r\n         *          }\r\n         *        ],\r\n         *        \"columns\": [\r\n         *          { \"title\": \"Engine\",   \"data\": \"engine\" },\r\n         *          { \"title\": \"Browser\",  \"data\": \"browser\" },\r\n         *          { \"title\": \"Platform\", \"data\": \"platform\" },\r\n         *          { \"title\": \"Version\",  \"data\": \"version\" },\r\n         *          { \"title\": \"Grade\",    \"data\": \"grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aaData: null,\r\n\r\n        /**\r\n         * If ordering is enabled, then DataTables will perform a first pass sort on\r\n         * initialisation. You can define which column(s) the sort is performed\r\n         * upon, and the sorting direction, with this variable. The `sorting` array\r\n         * should contain an array for each column to be sorted initially containing\r\n         * the column's index and a direction string ('asc' or 'desc').\r\n         *  @type array\r\n         *  @default [[0,'asc']]\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.order\r\n         *\r\n         *  @example\r\n         *    // Sort by 3rd column first, and then 4th column\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"order\": [[2,'asc'], [3,'desc']]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *    // No initial sorting\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"order\": []\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aaSorting: [[0, 'asc']],\r\n\r\n        /**\r\n         * This parameter is basically identical to the `sorting` parameter, but\r\n         * cannot be overridden by user interaction with the table. What this means\r\n         * is that you could have a column (visible or hidden) which the sorting\r\n         * will always be forced on first - any sorting after that (from the user)\r\n         * will then be performed as required. This can be useful for grouping rows\r\n         * together.\r\n         *  @type array\r\n         *  @default null\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.orderFixed\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderFixed\": [[0,'asc']]\r\n         *      } );\r\n         *    } )\r\n         */\r\n        aaSortingFixed: [],\r\n\r\n        /**\r\n         * DataTables can be instructed to load data to display in the table from a\r\n         * Ajax source. This option defines how that Ajax call is made and where to.\r\n         *\r\n         * The `ajax` property has three different modes of operation, depending on\r\n         * how it is defined. These are:\r\n         *\r\n         * * `string` - Set the URL from where the data should be loaded from.\r\n         * * `object` - Define properties for `jQuery.ajax`.\r\n         * * `function` - Custom data get function\r\n         *\r\n         * `string`\r\n         * --------\r\n         *\r\n         * As a string, the `ajax` property simply defines the URL from which\r\n         * DataTables will load data.\r\n         *\r\n         * `object`\r\n         * --------\r\n         *\r\n         * As an object, the parameters in the object are passed to\r\n         * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\r\n         * of the Ajax request. DataTables has a number of default parameters which\r\n         * you can override using this option. Please refer to the jQuery\r\n         * documentation for a full description of the options available, although\r\n         * the following parameters provide additional options in DataTables or\r\n         * require special consideration:\r\n         *\r\n         * * `data` - As with jQuery, `data` can be provided as an object, but it\r\n         *   can also be used as a function to manipulate the data DataTables sends\r\n         *   to the server. The function takes a single parameter, an object of\r\n         *   parameters with the values that DataTables has readied for sending. An\r\n         *   object may be returned which will be merged into the DataTables\r\n         *   defaults, or you can add the items to the object that was passed in and\r\n         *   not return anything from the function. This supersedes `fnServerParams`\r\n         *   from DataTables 1.9-.\r\n         *\r\n         * * `dataSrc` - By default DataTables will look for the property `data` (or\r\n         *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\r\n         *   from an Ajax source or for server-side processing - this parameter\r\n         *   allows that property to be changed. You can use Javascript dotted\r\n         *   object notation to get a data source for multiple levels of nesting, or\r\n         *   it my be used as a function. As a function it takes a single parameter,\r\n         *   the JSON returned from the server, which can be manipulated as\r\n         *   required, with the returned value being that used by DataTables as the\r\n         *   data source for the table. This supersedes `sAjaxDataProp` from\r\n         *   DataTables 1.9-.\r\n         *\r\n         * * `success` - Should not be overridden it is used internally in\r\n         *   DataTables. To manipulate / transform the data returned by the server\r\n         *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\r\n         *\r\n         * `function`\r\n         * ----------\r\n         *\r\n         * As a function, making the Ajax call is left up to yourself allowing\r\n         * complete control of the Ajax request. Indeed, if desired, a method other\r\n         * than Ajax could be used to obtain the required data, such as Web storage\r\n         * or an AIR database.\r\n         *\r\n         * The function is given four parameters and no return is required. The\r\n         * parameters are:\r\n         *\r\n         * 1. _object_ - Data to send to the server\r\n         * 2. _function_ - Callback function that must be executed when the required\r\n         *    data has been obtained. That data should be passed into the callback\r\n         *    as the only parameter\r\n         * 3. _object_ - DataTables settings object for the table\r\n         *\r\n         * Note that this supersedes `fnServerData` from DataTables 1.9-.\r\n         *\r\n         *  @type string|object|function\r\n         *  @default null\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.ajax\r\n         *  @since 1.10.0\r\n         *\r\n         * @example\r\n         *   // Get JSON data from a file via Ajax.\r\n         *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": \"data.json\"\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to change\r\n         *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"dataSrc\": \"tableData\"\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\r\n         *   // from a plain array rather than an array in an object\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"dataSrc\": \"\"\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Manipulate the data returned from the server - add a link to data\r\n         *   // (note this can, should, be done using `render` for the column - this\r\n         *   // is just a simple example of how the data can be manipulated).\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"dataSrc\": function ( json ) {\r\n         *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\r\n         *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\r\n         *         }\r\n         *         return json;\r\n         *       }\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Add data to the request\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"data\": function ( d ) {\r\n         *         return {\r\n         *           \"extra_search\": $('#extra').val()\r\n         *         };\r\n         *       }\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Send request as POST\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": {\r\n         *       \"url\": \"data.json\",\r\n         *       \"type\": \"POST\"\r\n         *     }\r\n         *   } );\r\n         *\r\n         * @example\r\n         *   // Get the data from localStorage (could interface with a form for\r\n         *   // adding, editing and removing rows).\r\n         *   $('#example').dataTable( {\r\n         *     \"ajax\": function (data, callback, settings) {\r\n         *       callback(\r\n         *         JSON.parse( localStorage.getItem('dataTablesData') )\r\n         *       );\r\n         *     }\r\n         *   } );\r\n         */\r\n        ajax: null,\r\n\r\n        /**\r\n         * This parameter allows you to readily specify the entries in the length drop\r\n         * down menu that DataTables shows when pagination is enabled. It can be\r\n         * either a 1D array of options which will be used for both the displayed\r\n         * option and the value, or a 2D array which will use the array in the first\r\n         * position as the value, and the array in the second position as the\r\n         * displayed options (useful for language strings such as 'All').\r\n         *\r\n         * Note that the `pageLength` property will be automatically set to the\r\n         * first value given in this array, unless `pageLength` is also provided.\r\n         *  @type array\r\n         *  @default [ 10, 25, 50, 100 ]\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.lengthMenu\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aLengthMenu: [10, 25, 50, 100],\r\n\r\n        /**\r\n         * The `columns` option in the initialisation parameter allows you to define\r\n         * details about the way individual columns behave. For a full list of\r\n         * column options that can be set, please see\r\n         * {@link DataTable.defaults.column}. Note that if you use `columns` to\r\n         * define your columns, you must have an entry in the array for every single\r\n         * column that you have in your table (these can be null if you don't which\r\n         * to specify any options).\r\n         *  @member\r\n         *\r\n         *  @name DataTable.defaults.column\r\n         */\r\n        aoColumns: null,\r\n\r\n        /**\r\n         * Very similar to `columns`, `columnDefs` allows you to target a specific\r\n         * column, multiple columns, or all columns, using the `targets` property of\r\n         * each object in the array. This allows great flexibility when creating\r\n         * tables, as the `columnDefs` arrays can be of any length, targeting the\r\n         * columns you specifically want. `columnDefs` may use any of the column\r\n         * options available: {@link DataTable.defaults.column}, but it _must_\r\n         * have `targets` defined in each object in the array. Values in the `targets`\r\n         * array may be:\r\n         *   <ul>\r\n         *     <li>a string - class name will be matched on the TH for the column</li>\r\n         *     <li>0 or a positive integer - column index counting from the left</li>\r\n         *     <li>a negative integer - column index counting from the right</li>\r\n         *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\r\n         *   </ul>\r\n         *  @member\r\n         *\r\n         *  @name DataTable.defaults.columnDefs\r\n         */\r\n        aoColumnDefs: null,\r\n\r\n        /**\r\n         * Basically the same as `search`, this parameter defines the individual column\r\n         * filtering state at initialisation time. The array must be of the same size\r\n         * as the number of columns, and each element be an object with the parameters\r\n         * `search` and `escapeRegex` (the latter is optional). 'null' is also\r\n         * accepted and the default will be used.\r\n         *  @type array\r\n         *  @default []\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.searchCols\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"searchCols\": [\r\n         *          null,\r\n         *          { \"search\": \"My filter\" },\r\n         *          null,\r\n         *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\r\n         *        ]\r\n         *      } );\r\n         *    } )\r\n         */\r\n        aoSearchCols: [],\r\n\r\n        /**\r\n         * An array of CSS classes that should be applied to displayed rows. This\r\n         * array may be of any length, and DataTables will apply each class\r\n         * sequentially, looping when required.\r\n         *  @type array\r\n         *  @default null <i>Will take the values determined by the `oClasses.stripe*`\r\n         *    options</i>\r\n         *\r\n         *  @dtopt Option\r\n         *  @name DataTable.defaults.stripeClasses\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\r\n         *      } );\r\n         *    } )\r\n         */\r\n        asStripeClasses: null,\r\n\r\n        /**\r\n         * Enable or disable automatic column width calculation. This can be disabled\r\n         * as an optimisation (it takes some time to calculate the widths) if the\r\n         * tables widths are passed in using `columns`.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.autoWidth\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"autoWidth\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bAutoWidth: true,\r\n\r\n        /**\r\n         * Deferred rendering can provide DataTables with a huge speed boost when you\r\n         * are using an Ajax or JS data source for the table. This option, when set to\r\n         * true, will cause DataTables to defer the creation of the table elements for\r\n         * each row until they are needed for a draw - saving a significant amount of\r\n         * time.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.deferRender\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajax\": \"sources/arrays.txt\",\r\n         *        \"deferRender\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bDeferRender: false,\r\n\r\n        /**\r\n         * Replace a DataTable which matches the given selector and replace it with\r\n         * one which has the properties of the new initialisation object passed. If no\r\n         * table matches the selector, then the new DataTable will be constructed as\r\n         * per normal.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.destroy\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"srollY\": \"200px\",\r\n         *        \"paginate\": false\r\n         *      } );\r\n         *\r\n         *      // Some time later....\r\n         *      $('#example').dataTable( {\r\n         *        \"filter\": false,\r\n         *        \"destroy\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bDestroy: false,\r\n\r\n        /**\r\n         * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\r\n         * that it allows the end user to input multiple words (space separated) and\r\n         * will match a row containing those words, even if not in the order that was\r\n         * specified (this allow matching across multiple columns). Note that if you\r\n         * wish to use filtering in DataTables this must remain 'true' - to remove the\r\n         * default filtering input box and retain filtering abilities, please use\r\n         * {@link DataTable.defaults.dom}.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.searching\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"searching\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bFilter: true,\r\n\r\n        /**\r\n         * Enable or disable the table information display. This shows information\r\n         * about the data that is currently visible on the page, including information\r\n         * about filtered data if that action is being performed.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.info\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"info\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bInfo: true,\r\n\r\n        /**\r\n         * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some\r\n         * slightly different and additional mark-up from what DataTables has\r\n         * traditionally used).\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.jQueryUI\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"jQueryUI\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bJQueryUI: false,\r\n\r\n        /**\r\n         * Allows the end user to select the size of a formatted page from a select\r\n         * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.lengthChange\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"lengthChange\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bLengthChange: true,\r\n\r\n        /**\r\n         * Enable or disable pagination.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.paging\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"paging\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bPaginate: true,\r\n\r\n        /**\r\n         * Enable or disable the display of a 'processing' indicator when the table is\r\n         * being processed (e.g. a sort). This is particularly useful for tables with\r\n         * large amounts of data where it can take a noticeable amount of time to sort\r\n         * the entries.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.processing\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"processing\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bProcessing: false,\r\n\r\n        /**\r\n         * Retrieve the DataTables object for the given selector. Note that if the\r\n         * table has already been initialised, this parameter will cause DataTables\r\n         * to simply return the object that has already been set up - it will not take\r\n         * account of any changes you might have made to the initialisation object\r\n         * passed to DataTables (setting this parameter to true is an acknowledgement\r\n         * that you understand this). `destroy` can be used to reinitialise a table if\r\n         * you need.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.retrieve\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      initTable();\r\n         *      tableActions();\r\n         *    } );\r\n         *\r\n         *    function initTable ()\r\n         *    {\r\n         *      return $('#example').dataTable( {\r\n         *        \"scrollY\": \"200px\",\r\n         *        \"paginate\": false,\r\n         *        \"retrieve\": true\r\n         *      } );\r\n         *    }\r\n         *\r\n         *    function tableActions ()\r\n         *    {\r\n         *      var table = initTable();\r\n         *      // perform API operations with oTable\r\n         *    }\r\n         */\r\n        bRetrieve: false,\r\n\r\n        /**\r\n         * When vertical (y) scrolling is enabled, DataTables will force the height of\r\n         * the table's viewport to the given height at all times (useful for layout).\r\n         * However, this can look odd when filtering data down to a small data set,\r\n         * and the footer is left \"floating\" further down. This parameter (when\r\n         * enabled) will cause DataTables to collapse the table's viewport down when\r\n         * the result set will fit within the given Y height.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.scrollCollapse\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollY\": \"200\",\r\n         *        \"scrollCollapse\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bScrollCollapse: false,\r\n\r\n        /**\r\n         * Configure DataTables to use server-side processing. Note that the\r\n         * `ajax` parameter must also be given in order to give DataTables a\r\n         * source to obtain the required data for each draw.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverSide\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"serverSide\": true,\r\n         *        \"ajax\": \"xhr.php\"\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bServerSide: false,\r\n\r\n        /**\r\n         * Enable or disable sorting of columns. Sorting of individual columns can be\r\n         * disabled by the `sortable` option for each column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.ordering\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"ordering\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSort: true,\r\n\r\n        /**\r\n         * Enable or display DataTables' ability to sort multiple columns at the\r\n         * same time (activated by shift-click by the user).\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.orderMulti\r\n         *\r\n         *  @example\r\n         *    // Disable multiple column sorting ability\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderMulti\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSortMulti: true,\r\n\r\n        /**\r\n         * Allows control over whether DataTables should use the top (true) unique\r\n         * cell that is found for a single column, or the bottom (false - default).\r\n         * This is useful when using complex headers.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.orderCellsTop\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderCellsTop\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSortCellsTop: false,\r\n\r\n        /**\r\n         * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\r\n         * `sorting\\_3` to the columns which are currently being sorted on. This is\r\n         * presented as a feature switch as it can increase processing time (while\r\n         * classes are removed and added) so for large data sets you might want to\r\n         * turn this off.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.orderClasses\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"orderClasses\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bSortClasses: true,\r\n\r\n        /**\r\n         * Enable or disable state saving. When enabled HTML5 `localStorage` will be\r\n         * used to save table display information such as pagination information,\r\n         * display length, filtering and sorting. As such when the end user reloads\r\n         * the page the display display will match what thy had previously set up.\r\n         *\r\n         * Due to the use of `localStorage` the default state saving is not supported\r\n         * in IE6 or 7. If state saving is required in those browsers, use\r\n         * `stateSaveCallback` to provide a storage solution such as cookies.\r\n         *  @type boolean\r\n         *  @default false\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.stateSave\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function () {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        bStateSave: false,\r\n\r\n        /**\r\n         * This function is called when a TR element is created (and all TD child\r\n         * elements have been inserted), or registered if using a DOM source, allowing\r\n         * manipulation of the TR element (adding classes etc).\r\n         *  @type function\r\n         *  @param {node} row \"TR\" element for the current row\r\n         *  @param {array} data Raw data array for this row\r\n         *  @param {int} dataIndex The index of this row in the internal aoData array\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.createdRow\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"createdRow\": function( row, data, dataIndex ) {\r\n         *          // Bold the grade for all 'A' grade browsers\r\n         *          if ( data[4] == \"A\" )\r\n         *          {\r\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\r\n         *          }\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnCreatedRow: null,\r\n\r\n        /**\r\n         * This function is called on every 'draw' event, and allows you to\r\n         * dynamically modify any aspect you want about the created DOM.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.drawCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"drawCallback\": function( settings ) {\r\n         *          alert( 'DataTables has redrawn the table' );\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnDrawCallback: null,\r\n\r\n        /**\r\n         * Identical to fnHeaderCallback() but for the table footer this function\r\n         * allows you to modify the table footer on every 'draw' event.\r\n         *  @type function\r\n         *  @param {node} foot \"TR\" element for the footer\r\n         *  @param {array} data Full table data (as derived from the original HTML)\r\n         *  @param {int} start Index for the current display starting point in the\r\n         *    display array\r\n         *  @param {int} end Index for the current display ending point in the\r\n         *    display array\r\n         *  @param {array int} display Index array to translate the visual position\r\n         *    to the full data array\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.footerCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"footerCallback\": function( tfoot, data, start, end, display ) {\r\n         *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\r\n         *        }\r\n         *      } );\r\n         *    } )\r\n         */\r\n        fnFooterCallback: null,\r\n\r\n        /**\r\n         * When rendering large numbers in the information element for the table\r\n         * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\r\n         * to have a comma separator for the 'thousands' units (e.g. 1 million is\r\n         * rendered as \"1,000,000\") to help readability for the end user. This\r\n         * function will override the default method DataTables uses.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {int} toFormat number to be formatted\r\n         *  @returns {string} formatted string for DataTables to show the number\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.formatNumber\r\n         *\r\n         *  @example\r\n         *    // Format a number using a single quote for the separator (note that\r\n         *    // this can also be done with the language.thousands option)\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"formatNumber\": function ( toFormat ) {\r\n         *          return toFormat.toString().replace(\r\n         *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\r\n         *          );\r\n         *        };\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnFormatNumber: function (toFormat) {\r\n          return toFormat.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.oLanguage.sThousands)\r\n        },\r\n\r\n        /**\r\n         * This function is called on every 'draw' event, and allows you to\r\n         * dynamically modify the header row. This can be used to calculate and\r\n         * display useful information about the table.\r\n         *  @type function\r\n         *  @param {node} head \"TR\" element for the header\r\n         *  @param {array} data Full table data (as derived from the original HTML)\r\n         *  @param {int} start Index for the current display starting point in the\r\n         *    display array\r\n         *  @param {int} end Index for the current display ending point in the\r\n         *    display array\r\n         *  @param {array int} display Index array to translate the visual position\r\n         *    to the full data array\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.headerCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"fheaderCallback\": function( head, data, start, end, display ) {\r\n         *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\r\n         *        }\r\n         *      } );\r\n         *    } )\r\n         */\r\n        fnHeaderCallback: null,\r\n\r\n        /**\r\n         * The information element can be used to convey information about the current\r\n         * state of the table. Although the internationalisation options presented by\r\n         * DataTables are quite capable of dealing with most customisations, there may\r\n         * be times where you wish to customise the string further. This callback\r\n         * allows you to do exactly that.\r\n         *  @type function\r\n         *  @param {object} oSettings DataTables settings object\r\n         *  @param {int} start Starting position in data for the draw\r\n         *  @param {int} end End position in data for the draw\r\n         *  @param {int} max Total number of rows in the table (regardless of\r\n         *    filtering)\r\n         *  @param {int} total Total number of rows in the data set, after filtering\r\n         *  @param {string} pre The string that DataTables has formatted using it's\r\n         *    own rules\r\n         *  @returns {string} The string to be displayed in the information element.\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.infoCallback\r\n         *\r\n         *  @example\r\n         *    $('#example').dataTable( {\r\n         *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\r\n         *        return start +\" to \"+ end;\r\n         *      }\r\n         *    } );\r\n         */\r\n        fnInfoCallback: null,\r\n\r\n        /**\r\n         * Called when the table has been initialised. Normally DataTables will\r\n         * initialise sequentially and there will be no need for this function,\r\n         * however, this does not hold true when using external language information\r\n         * since that is obtained using an async XHR call.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} json The JSON object request from the server - only\r\n         *    present if client-side Ajax sourced data is used\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.initComplete\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"initComplete\": function(settings, json) {\r\n         *          alert( 'DataTables has finished its initialisation.' );\r\n         *        }\r\n         *      } );\r\n         *    } )\r\n         */\r\n        fnInitComplete: null,\r\n\r\n        /**\r\n         * Called at the very start of each table draw and can be used to cancel the\r\n         * draw by returning false, any other return (including undefined) results in\r\n         * the full draw occurring).\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @returns {boolean} False will cancel the draw, anything else (including no\r\n         *    return) will allow it to complete.\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.preDrawCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"preDrawCallback\": function( settings ) {\r\n         *          if ( $('#test').val() == 1 ) {\r\n         *            return false;\r\n         *          }\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnPreDrawCallback: null,\r\n\r\n        /**\r\n         * This function allows you to 'post process' each row after it have been\r\n         * generated for each table draw, but before it is rendered on screen. This\r\n         * function might be used for setting the row class name etc.\r\n         *  @type function\r\n         *  @param {node} row \"TR\" element for the current row\r\n         *  @param {array} data Raw data array for this row\r\n         *  @param {int} displayIndex The display index for the current table draw\r\n         *  @param {int} displayIndexFull The index of the data in the full list of\r\n         *    rows (after filtering)\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.rowCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\r\n         *          // Bold the grade for all 'A' grade browsers\r\n         *          if ( data[4] == \"A\" ) {\r\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\r\n         *          }\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnRowCallback: null,\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * This parameter allows you to override the default function which obtains\r\n         * the data from the server so something more suitable for your application.\r\n         * For example you could use POST data, or pull information from a Gears or\r\n         * AIR database.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {string} source HTTP source to obtain the data from (`ajax`)\r\n         *  @param {array} data A key/value pair object containing the data to send\r\n         *    to the server\r\n         *  @param {function} callback to be called on completion of the data get\r\n         *    process that will draw the data on the page.\r\n         *  @param {object} settings DataTables settings object\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverData\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        fnServerData: null,\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         *  It is often useful to send extra data to the server when making an Ajax\r\n         * request - for example custom filtering information, and this callback\r\n         * function makes it trivial to send extra information to the server. The\r\n         * passed in parameter is the data set that has been constructed by\r\n         * DataTables, and you can add to this or modify it as you require.\r\n         *  @type function\r\n         *  @param {array} data Data array (array of objects which are name/value\r\n         *    pairs) that has been constructed by DataTables and will be sent to the\r\n         *    server. In the case of Ajax sourced data with server-side processing\r\n         *    this will be an empty array, for server-side processing there will be a\r\n         *    significant number of parameters!\r\n         *  @returns {undefined} Ensure that you modify the data array passed in,\r\n         *    as this is passed by reference.\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverParams\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        fnServerParams: null,\r\n\r\n        /**\r\n         * Load the table state. With this function you can define from where, and how, the\r\n         * state of a table is loaded. By default DataTables will load from `localStorage`\r\n         * but you might wish to use a server-side database or cookies.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {object} settings DataTables settings object\r\n         *  @return {object} The DataTables state object to be loaded\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateLoadCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoadCallback\": function (settings) {\r\n         *          var o;\r\n         *\r\n         *          // Send an Ajax request to the server to get the data. Note that\r\n         *          // this is a synchronous request.\r\n         *          $.ajax( {\r\n         *            \"url\": \"/state_load\",\r\n         *            \"async\": false,\r\n         *            \"dataType\": \"json\",\r\n         *            \"success\": function (json) {\r\n         *              o = json;\r\n         *            }\r\n         *          } );\r\n         *\r\n         *          return o;\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateLoadCallback: function (settings) {\r\n          try {\r\n            return JSON.parse(\r\n              (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\r\n                'DataTables_' + settings.sInstance + '_' + location.pathname\r\n              )\r\n            )\r\n          } catch (e) {}\r\n        },\r\n\r\n        /**\r\n         * Callback which allows modification of the saved state prior to loading that state.\r\n         * This callback is called when the table is loading state from the stored data, but\r\n         * prior to the settings object being modified by the saved state. Note that for\r\n         * plug-in authors, you should use the `stateLoadParams` event to load parameters for\r\n         * a plug-in.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object that is to be loaded\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateLoadParams\r\n         *\r\n         *  @example\r\n         *    // Remove a saved filter, so filtering is never loaded\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoadParams\": function (settings, data) {\r\n         *          data.oSearch.sSearch = \"\";\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Disallow state loading by returning false\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoadParams\": function (settings, data) {\r\n         *          return false;\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateLoadParams: null,\r\n\r\n        /**\r\n         * Callback that is called when the state has been loaded from the state saving method\r\n         * and the DataTables settings object has been modified as a result of the loaded state.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object that was loaded\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateLoaded\r\n         *\r\n         *  @example\r\n         *    // Show an alert with the filtering value that was saved\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateLoaded\": function (settings, data) {\r\n         *          alert( 'Saved filter was: '+data.oSearch.sSearch );\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateLoaded: null,\r\n\r\n        /**\r\n         * Save the table state. This function allows you to define where and how the state\r\n         * information for the table is stored By default DataTables will use `localStorage`\r\n         * but you might wish to use a server-side database or cookies.\r\n         *  @type function\r\n         *  @member\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object to be saved\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateSaveCallback\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateSaveCallback\": function (settings, data) {\r\n         *          // Send an Ajax request to the server with the state object\r\n         *          $.ajax( {\r\n         *            \"url\": \"/state_save\",\r\n         *            \"data\": data,\r\n         *            \"dataType\": \"json\",\r\n         *            \"method\": \"POST\"\r\n         *            \"success\": function () {}\r\n         *          } );\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateSaveCallback: function (settings, data) {\r\n          try {\r\n            ;(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\r\n              'DataTables_' + settings.sInstance + '_' + location.pathname,\r\n              JSON.stringify(data)\r\n            )\r\n          } catch (e) {}\r\n        },\r\n\r\n        /**\r\n         * Callback which allows modification of the state to be saved. Called when the table\r\n         * has changed state a new state save is required. This method allows modification of\r\n         * the state saving object prior to actually doing the save, including addition or\r\n         * other state properties or modification. Note that for plug-in authors, you should\r\n         * use the `stateSaveParams` event to save parameters for a plug-in.\r\n         *  @type function\r\n         *  @param {object} settings DataTables settings object\r\n         *  @param {object} data The state object to be saved\r\n         *\r\n         *  @dtopt Callbacks\r\n         *  @name DataTable.defaults.stateSaveParams\r\n         *\r\n         *  @example\r\n         *    // Remove a saved filter, so filtering is never saved\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateSave\": true,\r\n         *        \"stateSaveParams\": function (settings, data) {\r\n         *          data.oSearch.sSearch = \"\";\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        fnStateSaveParams: null,\r\n\r\n        /**\r\n         * Duration for which the saved state information is considered valid. After this period\r\n         * has elapsed the state will be returned to the default.\r\n         * Value is given in seconds.\r\n         *  @type int\r\n         *  @default 7200 <i>(2 hours)</i>\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.stateDuration\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"stateDuration\": 60*60*24; // 1 day\r\n         *      } );\r\n         *    } )\r\n         */\r\n        iStateDuration: 7200,\r\n\r\n        /**\r\n         * When enabled DataTables will not make a request to the server for the first\r\n         * page draw - rather it will use the data already on the page (no sorting etc\r\n         * will be applied to it), thus saving on an XHR at load time. `deferLoading`\r\n         * is used to indicate that deferred loading is required, but it is also used\r\n         * to tell DataTables how many records there are in the full table (allowing\r\n         * the information element and pagination to be displayed correctly). In the case\r\n         * where a filtering is applied to the table on initial load, this can be\r\n         * indicated by giving the parameter as an array, where the first element is\r\n         * the number of records available after filtering and the second element is the\r\n         * number of records without filtering (allowing the table information element\r\n         * to be shown correctly).\r\n         *  @type int | array\r\n         *  @default null\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.deferLoading\r\n         *\r\n         *  @example\r\n         *    // 57 records available in the table, no filtering applied\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"serverSide\": true,\r\n         *        \"ajax\": \"scripts/server_processing.php\",\r\n         *        \"deferLoading\": 57\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // 57 records after filtering, 100 without filtering (an initial filter applied)\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"serverSide\": true,\r\n         *        \"ajax\": \"scripts/server_processing.php\",\r\n         *        \"deferLoading\": [ 57, 100 ],\r\n         *        \"search\": {\r\n         *          \"search\": \"my_filter\"\r\n         *        }\r\n         *      } );\r\n         *    } );\r\n         */\r\n        iDeferLoading: null,\r\n\r\n        /**\r\n         * Number of rows to display on a single page when using pagination. If\r\n         * feature enabled (`lengthChange`) then the end user will be able to override\r\n         * this to a custom setting using a pop-up menu.\r\n         *  @type int\r\n         *  @default 10\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.pageLength\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"pageLength\": 50\r\n         *      } );\r\n         *    } )\r\n         */\r\n        iDisplayLength: 10,\r\n\r\n        /**\r\n         * Define the starting point for data display when using DataTables with\r\n         * pagination. Note that this parameter is the number of records, rather than\r\n         * the page number, so if you have 10 records per page and want to start on\r\n         * the third page, it should be \"20\".\r\n         *  @type int\r\n         *  @default 0\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.displayStart\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"displayStart\": 20\r\n         *      } );\r\n         *    } )\r\n         */\r\n        iDisplayStart: 0,\r\n\r\n        /**\r\n         * By default DataTables allows keyboard navigation of the table (sorting, paging,\r\n         * and filtering) by adding a `tabindex` attribute to the required elements. This\r\n         * allows you to tab through the controls and press the enter key to activate them.\r\n         * The tabindex is default 0, meaning that the tab follows the flow of the document.\r\n         * You can overrule this using this parameter if you wish. Use a value of -1 to\r\n         * disable built-in keyboard navigation.\r\n         *  @type int\r\n         *  @default 0\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.tabIndex\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"tabIndex\": 1\r\n         *      } );\r\n         *    } );\r\n         */\r\n        iTabIndex: 0,\r\n\r\n        /**\r\n         * Classes that DataTables assigns to the various components and features\r\n         * that it adds to the HTML table. This allows classes to be configured\r\n         * during initialisation in addition to through the static\r\n         * {@link DataTable.ext.oStdClasses} object).\r\n         *  @namespace\r\n         *  @name DataTable.defaults.classes\r\n         */\r\n        oClasses: {},\r\n\r\n        /**\r\n         * All strings that DataTables uses in the user interface that it creates\r\n         * are defined in this object, allowing you to modified them individually or\r\n         * completely replace them all as required.\r\n         *  @namespace\r\n         *  @name DataTable.defaults.language\r\n         */\r\n        oLanguage: {\r\n          /**\r\n           * Strings that are used for WAI-ARIA labels and controls only (these are not\r\n           * actually visible on the page, but will be read by screenreaders, and thus\r\n           * must be internationalised as well).\r\n           *  @namespace\r\n           *  @name DataTable.defaults.language.aria\r\n           */\r\n          oAria: {\r\n            /**\r\n             * ARIA label that is added to the table headers when the column may be\r\n             * sorted ascending by activing the column (click or return when focused).\r\n             * Note that the column header is prefixed to this string.\r\n             *  @type string\r\n             *  @default : activate to sort column ascending\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.aria.sortAscending\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"aria\": {\r\n             *            \"sortAscending\": \" - click/return to sort ascending\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sSortAscending: ': activate to sort column ascending',\r\n\r\n            /**\r\n             * ARIA label that is added to the table headers when the column may be\r\n             * sorted descending by activing the column (click or return when focused).\r\n             * Note that the column header is prefixed to this string.\r\n             *  @type string\r\n             *  @default : activate to sort column ascending\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.aria.sortDescending\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"aria\": {\r\n             *            \"sortDescending\": \" - click/return to sort descending\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sSortDescending: ': activate to sort column descending'\r\n          },\r\n\r\n          /**\r\n           * Pagination string used by DataTables for the built-in pagination\r\n           * control types.\r\n           *  @namespace\r\n           *  @name DataTable.defaults.language.paginate\r\n           */\r\n          oPaginate: {\r\n            /**\r\n             * Text to use when using the 'full_numbers' type of pagination for the\r\n             * button to take the user to the first page.\r\n             *  @type string\r\n             *  @default First\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.first\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"first\": \"First page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sFirst: 'First',\r\n\r\n            /**\r\n             * Text to use when using the 'full_numbers' type of pagination for the\r\n             * button to take the user to the last page.\r\n             *  @type string\r\n             *  @default Last\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.last\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"last\": \"Last page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sLast: 'Last',\r\n\r\n            /**\r\n             * Text to use for the 'next' pagination button (to take the user to the\r\n             * next page).\r\n             *  @type string\r\n             *  @default Next\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.next\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"next\": \"Next page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sNext: 'Next',\r\n\r\n            /**\r\n             * Text to use for the 'previous' pagination button (to take the user to\r\n             * the previous page).\r\n             *  @type string\r\n             *  @default Previous\r\n             *\r\n             *  @dtopt Language\r\n             *  @name DataTable.defaults.language.paginate.previous\r\n             *\r\n             *  @example\r\n             *    $(document).ready( function() {\r\n             *      $('#example').dataTable( {\r\n             *        \"language\": {\r\n             *          \"paginate\": {\r\n             *            \"previous\": \"Previous page\"\r\n             *          }\r\n             *        }\r\n             *      } );\r\n             *    } );\r\n             */\r\n            sPrevious: 'Previous'\r\n          },\r\n\r\n          /**\r\n           * This string is shown in preference to `zeroRecords` when the table is\r\n           * empty of data (regardless of filtering). Note that this is an optional\r\n           * parameter - if it is not given, the value of `zeroRecords` will be used\r\n           * instead (either the default or given value).\r\n           *  @type string\r\n           *  @default No data available in table\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.emptyTable\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"emptyTable\": \"No data available in table\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sEmptyTable: 'No data available in table',\r\n\r\n          /**\r\n           * This string gives information to the end user about the information\r\n           * that is current on display on the page. The following tokens can be\r\n           * used in the string and will be dynamically replaced as the table\r\n           * display updates. This tokens can be placed anywhere in the string, or\r\n           * removed as needed by the language requires:\r\n           *\r\n           * * `\\_START\\_` - Display index of the first record on the current page\r\n           * * `\\_END\\_` - Display index of the last record on the current page\r\n           * * `\\_TOTAL\\_` - Number of records in the table after filtering\r\n           * * `\\_MAX\\_` - Number of records in the table without filtering\r\n           * * `\\_PAGE\\_` - Current page number\r\n           * * `\\_PAGES\\_` - Total number of pages of data in the table\r\n           *\r\n           *  @type string\r\n           *  @default Showing _START_ to _END_ of _TOTAL_ entries\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.info\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfo: 'Showing _START_ to _END_ of _TOTAL_ entries',\r\n\r\n          /**\r\n           * Display information string for when the table is empty. Typically the\r\n           * format of this string should match `info`.\r\n           *  @type string\r\n           *  @default Showing 0 to 0 of 0 entries\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.infoEmpty\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"infoEmpty\": \"No entries to show\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfoEmpty: 'Showing 0 to 0 of 0 entries',\r\n\r\n          /**\r\n           * When a user filters the information in a table, this string is appended\r\n           * to the information (`info`) to give an idea of how strong the filtering\r\n           * is. The variable _MAX_ is dynamically updated.\r\n           *  @type string\r\n           *  @default (filtered from _MAX_ total entries)\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.infoFiltered\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"infoFiltered\": \" - filtering from _MAX_ records\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfoFiltered: '(filtered from _MAX_ total entries)',\r\n\r\n          /**\r\n           * If can be useful to append extra information to the info string at times,\r\n           * and this variable does exactly that. This information will be appended to\r\n           * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\r\n           * being used) at all times.\r\n           *  @type string\r\n           *  @default <i>Empty string</i>\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.infoPostFix\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"infoPostFix\": \"All records shown are derived from real information.\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sInfoPostFix: '',\r\n\r\n          /**\r\n           * This decimal place operator is a little different from the other\r\n           * language options since DataTables doesn't output floating point\r\n           * numbers, so it won't ever use this for display of a number. Rather,\r\n           * what this parameter does is modify the sort methods of the table so\r\n           * that numbers which are in a format which has a character other than\r\n           * a period (`.`) as a decimal place will be sorted numerically.\r\n           *\r\n           * Note that numbers with different decimal places cannot be shown in\r\n           * the same table and still be sortable, the table must be consistent.\r\n           * However, multiple different tables on the page can use different\r\n           * decimal place characters.\r\n           *  @type string\r\n           *  @default\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.decimal\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"decimal\": \",\"\r\n           *          \"thousands\": \".\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sDecimal: '',\r\n\r\n          /**\r\n           * DataTables has a build in number formatter (`formatNumber`) which is\r\n           * used to format large numbers that are used in the table information.\r\n           * By default a comma is used, but this can be trivially changed to any\r\n           * character you wish with this parameter.\r\n           *  @type string\r\n           *  @default ,\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.thousands\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"thousands\": \"'\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sThousands: ',',\r\n\r\n          /**\r\n           * Detail the action that will be taken when the drop down menu for the\r\n           * pagination length option is changed. The '_MENU_' variable is replaced\r\n           * with a default select list of 10, 25, 50 and 100, and can be replaced\r\n           * with a custom select box if required.\r\n           *  @type string\r\n           *  @default Show _MENU_ entries\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.lengthMenu\r\n           *\r\n           *  @example\r\n           *    // Language change only\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"lengthMenu\": \"Display _MENU_ records\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           *\r\n           *  @example\r\n           *    // Language and options change\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"lengthMenu\": 'Display <select>'+\r\n           *            '<option value=\"10\">10</option>'+\r\n           *            '<option value=\"20\">20</option>'+\r\n           *            '<option value=\"30\">30</option>'+\r\n           *            '<option value=\"40\">40</option>'+\r\n           *            '<option value=\"50\">50</option>'+\r\n           *            '<option value=\"-1\">All</option>'+\r\n           *            '</select> records'\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sLengthMenu: 'Show _MENU_ entries',\r\n\r\n          /**\r\n           * When using Ajax sourced data and during the first draw when DataTables is\r\n           * gathering the data, this message is shown in an empty row in the table to\r\n           * indicate to the end user the the data is being loaded. Note that this\r\n           * parameter is not used when loading data by server-side processing, just\r\n           * Ajax sourced data with client-side processing.\r\n           *  @type string\r\n           *  @default Loading...\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.loadingRecords\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"loadingRecords\": \"Please wait - loading...\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sLoadingRecords: 'Loading...',\r\n\r\n          /**\r\n           * Text which is displayed when the table is processing a user action\r\n           * (usually a sort command or similar).\r\n           *  @type string\r\n           *  @default Processing...\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.processing\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"processing\": \"DataTables is currently busy\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sProcessing: 'Processing...',\r\n\r\n          /**\r\n           * Details the actions that will be taken when the user types into the\r\n           * filtering input text box. The variable \"_INPUT_\", if used in the string,\r\n           * is replaced with the HTML text box for the filtering input allowing\r\n           * control over where it appears in the string. If \"_INPUT_\" is not given\r\n           * then the input box is appended to the string automatically.\r\n           *  @type string\r\n           *  @default Search:\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.search\r\n           *\r\n           *  @example\r\n           *    // Input text box will be appended at the end automatically\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"search\": \"Filter records:\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           *\r\n           *  @example\r\n           *    // Specify where the filter should appear\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"search\": \"Apply filter _INPUT_ to table\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sSearch: 'Search:',\r\n\r\n          /**\r\n           * Assign a `placeholder` attribute to the search `input` element\r\n           *  @type string\r\n           *  @default\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.searchPlaceholder\r\n           */\r\n          sSearchPlaceholder: '',\r\n\r\n          /**\r\n           * All of the language information can be stored in a file on the\r\n           * server-side, which DataTables will look up if this parameter is passed.\r\n           * It must store the URL of the language file, which is in a JSON format,\r\n           * and the object has the same properties as the oLanguage object in the\r\n           * initialiser object (i.e. the above parameters). Please refer to one of\r\n           * the example language files to see how this works in action.\r\n           *  @type string\r\n           *  @default <i>Empty string - i.e. disabled</i>\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.url\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sUrl: '',\r\n\r\n          /**\r\n           * Text shown inside the table records when the is no information to be\r\n           * displayed after filtering. `emptyTable` is shown when there is simply no\r\n           * information in the table at all (regardless of filtering).\r\n           *  @type string\r\n           *  @default No matching records found\r\n           *\r\n           *  @dtopt Language\r\n           *  @name DataTable.defaults.language.zeroRecords\r\n           *\r\n           *  @example\r\n           *    $(document).ready( function() {\r\n           *      $('#example').dataTable( {\r\n           *        \"language\": {\r\n           *          \"zeroRecords\": \"No records to display\"\r\n           *        }\r\n           *      } );\r\n           *    } );\r\n           */\r\n          sZeroRecords: 'No matching records found'\r\n        },\r\n\r\n        /**\r\n         * This parameter allows you to have define the global filtering state at\r\n         * initialisation time. As an object the `search` parameter must be\r\n         * defined, but all other parameters are optional. When `regex` is true,\r\n         * the search string will be treated as a regular expression, when false\r\n         * (default) it will be treated as a straight string. When `smart`\r\n         * DataTables will use it's smart filtering methods (to word match at\r\n         * any point in the data), when false this will not be done.\r\n         *  @namespace\r\n         *  @extends DataTable.models.oSearch\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.search\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"search\": {\"search\": \"Initial search\"}\r\n         *      } );\r\n         *    } )\r\n         */\r\n        oSearch: $.extend({}, DataTable.models.oSearch),\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * By default DataTables will look for the property `data` (or `aaData` for\r\n         * compatibility with DataTables 1.9-) when obtaining data from an Ajax\r\n         * source or for server-side processing - this parameter allows that\r\n         * property to be changed. You can use Javascript dotted object notation to\r\n         * get a data source for multiple levels of nesting.\r\n         *  @type string\r\n         *  @default data\r\n         *\r\n         *  @dtopt Options\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.ajaxDataProp\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        sAjaxDataProp: 'data',\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * You can instruct DataTables to load data from an external\r\n         * source using this parameter (use aData if you want to pass data in you\r\n         * already have). Simply provide a url a JSON object can be obtained from.\r\n         *  @type string\r\n         *  @default null\r\n         *\r\n         *  @dtopt Options\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.ajaxSource\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        sAjaxSource: null,\r\n\r\n        /**\r\n         * This initialisation variable allows you to specify exactly where in the\r\n         * DOM you want DataTables to inject the various controls it adds to the page\r\n         * (for example you might want the pagination controls at the top of the\r\n         * table). DIV elements (with or without a custom class) can also be added to\r\n         * aid styling. The follow syntax is used:\r\n         *   <ul>\r\n         *     <li>The following options are allowed:\r\n         *       <ul>\r\n         *         <li>'l' - Length changing</li>\r\n         *         <li>'f' - Filtering input</li>\r\n         *         <li>'t' - The table!</li>\r\n         *         <li>'i' - Information</li>\r\n         *         <li>'p' - Pagination</li>\r\n         *         <li>'r' - pRocessing</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *     <li>The following constants are allowed:\r\n         *       <ul>\r\n         *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\r\n         *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *     <li>The following syntax is expected:\r\n         *       <ul>\r\n         *         <li>'&lt;' and '&gt;' - div elements</li>\r\n         *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\r\n         *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *     <li>Examples:\r\n         *       <ul>\r\n         *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\r\n         *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\r\n         *       </ul>\r\n         *     </li>\r\n         *   </ul>\r\n         *  @type string\r\n         *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\r\n         *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.dom\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sDom: 'lfrtip',\r\n\r\n        /**\r\n         * DataTables features four different built-in options for the buttons to\r\n         * display for pagination control:\r\n         *\r\n         * * `simple` - 'Previous' and 'Next' buttons only\r\n         * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\r\n         * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\r\n         * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus\r\n         *   page numbers\r\n         *\r\n         * Further methods can be added using {@link DataTable.ext.oPagination}.\r\n         *  @type string\r\n         *  @default simple_numbers\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.pagingType\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"pagingType\": \"full_numbers\"\r\n         *      } );\r\n         *    } )\r\n         */\r\n        sPaginationType: 'simple_numbers',\r\n\r\n        /**\r\n         * Enable horizontal scrolling. When a table is too wide to fit into a\r\n         * certain layout, or you have a large number of columns in the table, you\r\n         * can enable x-scrolling to show the table in a viewport, which can be\r\n         * scrolled. This property can be `true` which will allow the table to\r\n         * scroll horizontally when needed, or any CSS unit, or a number (in which\r\n         * case it will be treated as a pixel measurement). Setting as simply `true`\r\n         * is recommended.\r\n         *  @type boolean|string\r\n         *  @default <i>blank string - i.e. disabled</i>\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.scrollX\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollX\": true,\r\n         *        \"scrollCollapse\": true\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sScrollX: '',\r\n\r\n        /**\r\n         * This property can be used to force a DataTable to use more width than it\r\n         * might otherwise do when x-scrolling is enabled. For example if you have a\r\n         * table which requires to be well spaced, this parameter is useful for\r\n         * \"over-sizing\" the table, and thus forcing scrolling. This property can by\r\n         * any CSS unit, or a number (in which case it will be treated as a pixel\r\n         * measurement).\r\n         *  @type string\r\n         *  @default <i>blank string - i.e. disabled</i>\r\n         *\r\n         *  @dtopt Options\r\n         *  @name DataTable.defaults.scrollXInner\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollX\": \"100%\",\r\n         *        \"scrollXInner\": \"110%\"\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sScrollXInner: '',\r\n\r\n        /**\r\n         * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\r\n         * to the given height, and enable scrolling for any data which overflows the\r\n         * current viewport. This can be used as an alternative to paging to display\r\n         * a lot of data in a small area (although paging and scrolling can both be\r\n         * enabled at the same time). This property can be any CSS unit, or a number\r\n         * (in which case it will be treated as a pixel measurement).\r\n         *  @type string\r\n         *  @default <i>blank string - i.e. disabled</i>\r\n         *\r\n         *  @dtopt Features\r\n         *  @name DataTable.defaults.scrollY\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"scrollY\": \"200px\",\r\n         *        \"paginate\": false\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sScrollY: '',\r\n\r\n        /**\r\n         * __Deprecated__ The functionality provided by this parameter has now been\r\n         * superseded by that provided through `ajax`, which should be used instead.\r\n         *\r\n         * Set the HTTP method that is used to make the Ajax call for server-side\r\n         * processing or Ajax sourced data.\r\n         *  @type string\r\n         *  @default GET\r\n         *\r\n         *  @dtopt Options\r\n         *  @dtopt Server-side\r\n         *  @name DataTable.defaults.serverMethod\r\n         *\r\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\r\n         */\r\n        sServerMethod: 'GET',\r\n\r\n        /**\r\n         * DataTables makes use of renderers when displaying HTML elements for\r\n         * a table. These renderers can be added or modified by plug-ins to\r\n         * generate suitable mark-up for a site. For example the Bootstrap\r\n         * integration plug-in for DataTables uses a paging button renderer to\r\n         * display pagination buttons in the mark-up required by Bootstrap.\r\n         *\r\n         * For further information about the renderers available see\r\n         * DataTable.ext.renderer\r\n         *  @type string|object\r\n         *  @default null\r\n         *\r\n         *  @name DataTable.defaults.renderer\r\n         *\r\n         */\r\n        renderer: null\r\n      }\r\n\r\n      _fnHungarianMap(DataTable.defaults)\r\n\r\n      /*\r\n       * Developer note - See note in model.defaults.js about the use of Hungarian\r\n       * notation and camel case.\r\n       */\r\n\r\n      /**\r\n       * Column options that can be given to DataTables at initialisation time.\r\n       *  @namespace\r\n       */\r\n      DataTable.defaults.column = {\r\n        /**\r\n         * Define which column(s) an order will occur on for this column. This\r\n         * allows a column's ordering to take multiple columns into account when\r\n         * doing a sort or use the data from a different column. For example first\r\n         * name / last name columns make sense to do a multi-column sort over the\r\n         * two columns.\r\n         *  @type array|int\r\n         *  @default null <i>Takes the value of the column index automatically</i>\r\n         *\r\n         *  @name DataTable.defaults.column.orderData\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\r\n         *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\r\n         *          { \"orderData\": 2, \"targets\": [ 2 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"orderData\": [ 0, 1 ] },\r\n         *          { \"orderData\": [ 1, 0 ] },\r\n         *          { \"orderData\": 2 },\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        aDataSort: null,\r\n        iDataSort: -1,\r\n\r\n        /**\r\n         * You can control the default ordering direction, and even alter the\r\n         * behaviour of the sort handler (i.e. only allow ascending ordering etc)\r\n         * using this parameter.\r\n         *  @type array\r\n         *  @default [ 'asc', 'desc' ]\r\n         *\r\n         *  @name DataTable.defaults.column.orderSequence\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\r\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\r\n         *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          { \"orderSequence\": [ \"asc\" ] },\r\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\r\n         *          { \"orderSequence\": [ \"desc\" ] },\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        asSorting: ['asc', 'desc'],\r\n\r\n        /**\r\n         * Enable or disable filtering on the data in this column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @name DataTable.defaults.column.searchable\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"searchable\": false, \"targets\": [ 0 ] }\r\n         *        ] } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"searchable\": false },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ] } );\r\n         *    } );\r\n         */\r\n        bSearchable: true,\r\n\r\n        /**\r\n         * Enable or disable ordering on this column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @name DataTable.defaults.column.orderable\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderable\": false, \"targets\": [ 0 ] }\r\n         *        ] } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"orderable\": false },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ] } );\r\n         *    } );\r\n         */\r\n        bSortable: true,\r\n\r\n        /**\r\n         * Enable or disable the display of this column.\r\n         *  @type boolean\r\n         *  @default true\r\n         *\r\n         *  @name DataTable.defaults.column.visible\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"visible\": false, \"targets\": [ 0 ] }\r\n         *        ] } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"visible\": false },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ] } );\r\n         *    } );\r\n         */\r\n        bVisible: true,\r\n\r\n        /**\r\n         * Developer definable function that is called whenever a cell is created (Ajax source,\r\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\r\n         * allowing you to modify the DOM element (add background colour for example) when the\r\n         * element is available.\r\n         *  @type function\r\n         *  @param {element} td The TD node that has been created\r\n         *  @param {*} cellData The Data for the cell\r\n         *  @param {array|object} rowData The data for the whole row\r\n         *  @param {int} row The row index for the aoData data store\r\n         *  @param {int} col The column index for aoColumns\r\n         *\r\n         *  @name DataTable.defaults.column.createdCell\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [3],\r\n         *          \"createdCell\": function (td, cellData, rowData, row, col) {\r\n         *            if ( cellData == \"1.7\" ) {\r\n         *              $(td).css('color', 'blue')\r\n         *            }\r\n         *          }\r\n         *        } ]\r\n         *      });\r\n         *    } );\r\n         */\r\n        fnCreatedCell: null,\r\n\r\n        /**\r\n         * This parameter has been replaced by `data` in DataTables to ensure naming\r\n         * consistency. `dataProp` can still be used, as there is backwards\r\n         * compatibility in DataTables for this option, but it is strongly\r\n         * recommended that you use `data` in preference to `dataProp`.\r\n         *  @name DataTable.defaults.column.dataProp\r\n         */\r\n\r\n        /**\r\n         * This property can be used to read data from any data source property,\r\n         * including deeply nested objects / properties. `data` can be given in a\r\n         * number of different ways which effect its behaviour:\r\n         *\r\n         * * `integer` - treated as an array index for the data source. This is the\r\n         *   default that DataTables uses (incrementally increased for each column).\r\n         * * `string` - read an object property from the data source. There are\r\n         *   three 'special' options that can be used in the string to alter how\r\n         *   DataTables reads the data from the source object:\r\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\r\n         *      Javascript to read from nested objects, so to can the options\r\n         *      specified in `data`. For example: `browser.version` or\r\n         *      `browser.name`. If your object parameter name contains a period, use\r\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\r\n         *    * `[]` - Array notation. DataTables can automatically combine data\r\n         *      from and array source, joining the data with the characters provided\r\n         *      between the two brackets. For example: `name[, ]` would provide a\r\n         *      comma-space separated list from the source array. If no characters\r\n         *      are provided between the brackets, the original array source is\r\n         *      returned.\r\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\r\n         *      execute a function of the name given. For example: `browser()` for a\r\n         *      simple function on the data source, `browser.version()` for a\r\n         *      function in a nested property or even `browser().version` to get an\r\n         *      object property if the function called returns an object. Note that\r\n         *      function notation is recommended for use in `render` rather than\r\n         *      `data` as it is much simpler to use as a renderer.\r\n         * * `null` - use the original data source for the row rather than plucking\r\n         *   data directly from it. This action has effects on two other\r\n         *   initialisation options:\r\n         *    * `defaultContent` - When null is given as the `data` option and\r\n         *      `defaultContent` is specified for the column, the value defined by\r\n         *      `defaultContent` will be used for the cell.\r\n         *    * `render` - When null is used for the `data` option and the `render`\r\n         *      option is specified for the column, the whole data source for the\r\n         *      row is used for the renderer.\r\n         * * `function` - the function given will be executed whenever DataTables\r\n         *   needs to set or get the data for a cell in the column. The function\r\n         *   takes three parameters:\r\n         *    * Parameters:\r\n         *      * `{array|object}` The data source for the row\r\n         *      * `{string}` The type call data requested - this will be 'set' when\r\n         *        setting data or 'filter', 'display', 'type', 'sort' or undefined\r\n         *        when gathering data. Note that when `undefined` is given for the\r\n         *        type DataTables expects to get the raw data for the object back<\r\n         *      * `{*}` Data to set when the second parameter is 'set'.\r\n         *    * Return:\r\n         *      * The return value from the function is not required when 'set' is\r\n         *        the type of call, but otherwise the return is what will be used\r\n         *        for the data requested.\r\n         *\r\n         * Note that `data` is a getter and setter option. If you just require\r\n         * formatting of data for output, you will likely want to use `render` which\r\n         * is simply a getter and thus simpler to use.\r\n         *\r\n         * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\r\n         * name change reflects the flexibility of this property and is consistent\r\n         * with the naming of mRender. If 'mDataProp' is given, then it will still\r\n         * be used by DataTables, as it automatically maps the old name to the new\r\n         * if required.\r\n         *\r\n         *  @type string|int|function|null\r\n         *  @default null <i>Use automatically calculated column index</i>\r\n         *\r\n         *  @name DataTable.defaults.column.data\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Read table data from objects\r\n         *    // JSON structure for each row:\r\n         *    //   {\r\n         *    //      \"engine\": {value},\r\n         *    //      \"browser\": {value},\r\n         *    //      \"platform\": {value},\r\n         *    //      \"version\": {value},\r\n         *    //      \"grade\": {value}\r\n         *    //   }\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajaxSource\": \"sources/objects.txt\",\r\n         *        \"columns\": [\r\n         *          { \"data\": \"engine\" },\r\n         *          { \"data\": \"browser\" },\r\n         *          { \"data\": \"platform\" },\r\n         *          { \"data\": \"version\" },\r\n         *          { \"data\": \"grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Read information from deeply nested objects\r\n         *    // JSON structure for each row:\r\n         *    //   {\r\n         *    //      \"engine\": {value},\r\n         *    //      \"browser\": {value},\r\n         *    //      \"platform\": {\r\n         *    //         \"inner\": {value}\r\n         *    //      },\r\n         *    //      \"details\": [\r\n         *    //         {value}, {value}\r\n         *    //      ]\r\n         *    //   }\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajaxSource\": \"sources/deep.txt\",\r\n         *        \"columns\": [\r\n         *          { \"data\": \"engine\" },\r\n         *          { \"data\": \"browser\" },\r\n         *          { \"data\": \"platform.inner\" },\r\n         *          { \"data\": \"platform.details.0\" },\r\n         *          { \"data\": \"platform.details.1\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `data` as a function to provide different information for\r\n         *    // sorting, filtering and display. In this case, currency (price)\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": function ( source, type, val ) {\r\n         *            if (type === 'set') {\r\n         *              source.price = val;\r\n         *              // Store the computed dislay and filter values for efficiency\r\n         *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\r\n         *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\r\n         *              return;\r\n         *            }\r\n         *            else if (type === 'display') {\r\n         *              return source.price_display;\r\n         *            }\r\n         *            else if (type === 'filter') {\r\n         *              return source.price_filter;\r\n         *            }\r\n         *            // 'sort', 'type' and undefined all just use the integer\r\n         *            return source.price;\r\n         *          }\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using default content\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": null,\r\n         *          \"defaultContent\": \"Click to edit\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using array notation - outputting a list from an array\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": \"name[, ]\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         */\r\n        mData: null,\r\n\r\n        /**\r\n         * This property is the rendering partner to `data` and it is suggested that\r\n         * when you want to manipulate data for display (including filtering,\r\n         * sorting etc) without altering the underlying data for the table, use this\r\n         * property. `render` can be considered to be the the read only companion to\r\n         * `data` which is read / write (then as such more complex). Like `data`\r\n         * this option can be given in a number of different ways to effect its\r\n         * behaviour:\r\n         *\r\n         * * `integer` - treated as an array index for the data source. This is the\r\n         *   default that DataTables uses (incrementally increased for each column).\r\n         * * `string` - read an object property from the data source. There are\r\n         *   three 'special' options that can be used in the string to alter how\r\n         *   DataTables reads the data from the source object:\r\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\r\n         *      Javascript to read from nested objects, so to can the options\r\n         *      specified in `data`. For example: `browser.version` or\r\n         *      `browser.name`. If your object parameter name contains a period, use\r\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\r\n         *    * `[]` - Array notation. DataTables can automatically combine data\r\n         *      from and array source, joining the data with the characters provided\r\n         *      between the two brackets. For example: `name[, ]` would provide a\r\n         *      comma-space separated list from the source array. If no characters\r\n         *      are provided between the brackets, the original array source is\r\n         *      returned.\r\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\r\n         *      execute a function of the name given. For example: `browser()` for a\r\n         *      simple function on the data source, `browser.version()` for a\r\n         *      function in a nested property or even `browser().version` to get an\r\n         *      object property if the function called returns an object.\r\n         * * `object` - use different data for the different data types requested by\r\n         *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\r\n         *   of the object is the data type the property refers to and the value can\r\n         *   defined using an integer, string or function using the same rules as\r\n         *   `render` normally does. Note that an `_` option _must_ be specified.\r\n         *   This is the default value to use if you haven't specified a value for\r\n         *   the data type requested by DataTables.\r\n         * * `function` - the function given will be executed whenever DataTables\r\n         *   needs to set or get the data for a cell in the column. The function\r\n         *   takes three parameters:\r\n         *    * Parameters:\r\n         *      * {array|object} The data source for the row (based on `data`)\r\n         *      * {string} The type call data requested - this will be 'filter',\r\n         *        'display', 'type' or 'sort'.\r\n         *      * {array|object} The full data source for the row (not based on\r\n         *        `data`)\r\n         *    * Return:\r\n         *      * The return value from the function is what will be used for the\r\n         *        data requested.\r\n         *\r\n         *  @type string|int|function|object|null\r\n         *  @default null Use the data source value.\r\n         *\r\n         *  @name DataTable.defaults.column.render\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Create a comma separated list from an array of objects\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"ajaxSource\": \"sources/deep.txt\",\r\n         *        \"columns\": [\r\n         *          { \"data\": \"engine\" },\r\n         *          { \"data\": \"browser\" },\r\n         *          {\r\n         *            \"data\": \"platform\",\r\n         *            \"render\": \"[, ].name\"\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Execute a function to obtain data\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": null, // Use the full data source object for the renderer's source\r\n         *          \"render\": \"browserName()\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // As an object, extracting different data for the different types\r\n         *    // This would be used with a data source such as:\r\n         *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\r\n         *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\r\n         *    // (which has both forms) is used for filtering for if a user inputs either format, while\r\n         *    // the formatted phone number is the one that is shown in the table.\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": null, // Use the full data source object for the renderer's source\r\n         *          \"render\": {\r\n         *            \"_\": \"phone\",\r\n         *            \"filter\": \"phone_filter\",\r\n         *            \"display\": \"phone_display\"\r\n         *          }\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Use as a function to create a link from the data source\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"data\": \"download_link\",\r\n         *          \"render\": function ( data, type, full ) {\r\n         *            return '<a href=\"'+data+'\">Download</a>';\r\n         *          }\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        mRender: null,\r\n\r\n        /**\r\n         * Change the cell type created for the column - either TD cells or TH cells. This\r\n         * can be useful as TH cells have semantic meaning in the table body, allowing them\r\n         * to act as a header for a row (you may wish to add scope='row' to the TH elements).\r\n         *  @type string\r\n         *  @default td\r\n         *\r\n         *  @name DataTable.defaults.column.cellType\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Make the first column use TH cells\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [ {\r\n         *          \"targets\": [ 0 ],\r\n         *          \"cellType\": \"th\"\r\n         *        } ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sCellType: 'td',\r\n\r\n        /**\r\n         * Class to give to each cell in this column.\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         *\r\n         *  @name DataTable.defaults.column.class\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"class\": \"my_class\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sClass: '',\r\n\r\n        /**\r\n         * When DataTables calculates the column widths to assign to each column,\r\n         * it finds the longest string in each column and then constructs a\r\n         * temporary table and reads the widths from that. The problem with this\r\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\r\n         * string - thus the calculation can go wrong (doing it properly and putting\r\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\r\n         * a \"work around\" we provide this option. It will append its value to the\r\n         * text that is found to be the longest string for the column - i.e. padding.\r\n         * Generally you shouldn't need this!\r\n         *  @type string\r\n         *  @default <i>Empty string<i>\r\n         *\r\n         *  @name DataTable.defaults.column.contentPadding\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          {\r\n         *            \"contentPadding\": \"mmm\"\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sContentPadding: '',\r\n\r\n        /**\r\n         * Allows a default value to be given for a column's data, and will be used\r\n         * whenever a null data source is encountered (this can be because `data`\r\n         * is set to null, or because the data source itself is null).\r\n         *  @type string\r\n         *  @default null\r\n         *\r\n         *  @name DataTable.defaults.column.defaultContent\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          {\r\n         *            \"data\": null,\r\n         *            \"defaultContent\": \"Edit\",\r\n         *            \"targets\": [ -1 ]\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          {\r\n         *            \"data\": null,\r\n         *            \"defaultContent\": \"Edit\"\r\n         *          }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sDefaultContent: null,\r\n\r\n        /**\r\n         * This parameter is only used in DataTables' server-side processing. It can\r\n         * be exceptionally useful to know what columns are being displayed on the\r\n         * client side, and to map these to database fields. When defined, the names\r\n         * also allow DataTables to reorder information from the server if it comes\r\n         * back in an unexpected order (i.e. if you switch your columns around on the\r\n         * client-side, your server-side code does not also need updating).\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         *\r\n         *  @name DataTable.defaults.column.name\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"name\": \"engine\", \"targets\": [ 0 ] },\r\n         *          { \"name\": \"browser\", \"targets\": [ 1 ] },\r\n         *          { \"name\": \"platform\", \"targets\": [ 2 ] },\r\n         *          { \"name\": \"version\", \"targets\": [ 3 ] },\r\n         *          { \"name\": \"grade\", \"targets\": [ 4 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"name\": \"engine\" },\r\n         *          { \"name\": \"browser\" },\r\n         *          { \"name\": \"platform\" },\r\n         *          { \"name\": \"version\" },\r\n         *          { \"name\": \"grade\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sName: '',\r\n\r\n        /**\r\n         * Defines a data source type for the ordering which can be used to read\r\n         * real-time information from the table (updating the internally cached\r\n         * version) prior to ordering. This allows ordering to occur on user\r\n         * editable elements such as form inputs.\r\n         *  @type string\r\n         *  @default std\r\n         *\r\n         *  @name DataTable.defaults.column.orderDataType\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\r\n         *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\r\n         *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\r\n         *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          null,\r\n         *          null,\r\n         *          { \"orderDataType\": \"dom-text\" },\r\n         *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\r\n         *          { \"orderDataType\": \"dom-select\" },\r\n         *          { \"orderDataType\": \"dom-checkbox\" }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sSortDataType: 'std',\r\n\r\n        /**\r\n         * The title of this column.\r\n         *  @type string\r\n         *  @default null <i>Derived from the 'TH' value for this column in the\r\n         *    original HTML table.</i>\r\n         *\r\n         *  @name DataTable.defaults.column.title\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"title\": \"My column title\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sTitle: null,\r\n\r\n        /**\r\n         * The type allows you to specify how the data for this column will be\r\n         * ordered. Four types (string, numeric, date and html (which will strip\r\n         * HTML tags before ordering)) are currently available. Note that only date\r\n         * formats understood by Javascript's Date() object will be accepted as type\r\n         * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\r\n         * 'numeric', 'date' or 'html' (by default). Further types can be adding\r\n         * through plug-ins.\r\n         *  @type string\r\n         *  @default null <i>Auto-detected from raw data</i>\r\n         *\r\n         *  @name DataTable.defaults.column.type\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"type\": \"html\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"type\": \"html\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sType: null,\r\n\r\n        /**\r\n         * Defining the width of the column, this parameter may take any CSS value\r\n         * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\r\n         * been given a specific width through this interface ensuring that the table\r\n         * remains readable.\r\n         *  @type string\r\n         *  @default null <i>Automatic</i>\r\n         *\r\n         *  @name DataTable.defaults.column.width\r\n         *  @dtopt Columns\r\n         *\r\n         *  @example\r\n         *    // Using `columnDefs`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columnDefs\": [\r\n         *          { \"width\": \"20%\", \"targets\": [ 0 ] }\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         *\r\n         *  @example\r\n         *    // Using `columns`\r\n         *    $(document).ready( function() {\r\n         *      $('#example').dataTable( {\r\n         *        \"columns\": [\r\n         *          { \"width\": \"20%\" },\r\n         *          null,\r\n         *          null,\r\n         *          null,\r\n         *          null\r\n         *        ]\r\n         *      } );\r\n         *    } );\r\n         */\r\n        sWidth: null\r\n      }\r\n\r\n      _fnHungarianMap(DataTable.defaults.column)\r\n\r\n      /**\r\n       * DataTables settings object - this holds all the information needed for a\r\n       * given table, including configuration, data and current application of the\r\n       * table options. DataTables does not have a single instance for each DataTable\r\n       * with the settings attached to that instance, but rather instances of the\r\n       * DataTable \"class\" are created on-the-fly as needed (typically by a\r\n       * $().dataTable() call) and the settings object is then applied to that\r\n       * instance.\r\n       *\r\n       * Note that this object is related to {@link DataTable.defaults} but this\r\n       * one is the internal data store for DataTables's cache of columns. It should\r\n       * NOT be manipulated outside of DataTables. Any configuration should be done\r\n       * through the initialisation options.\r\n       *  @namespace\r\n       *  @todo Really should attach the settings object to individual instances so we\r\n       *    don't need to create new instances on each $().dataTable() call (if the\r\n       *    table already exists). It would also save passing oSettings around and\r\n       *    into every single function. However, this is a very significant\r\n       *    architecture change for DataTables and will almost certainly break\r\n       *    backwards compatibility with older installations. This is something that\r\n       *    will be done in 2.0.\r\n       */\r\n      DataTable.models.oSettings = {\r\n        /**\r\n         * Primary features of DataTables and their enablement state.\r\n         *  @namespace\r\n         */\r\n        oFeatures: {\r\n          /**\r\n           * Flag to say if DataTables should automatically try to calculate the\r\n           * optimum table and columns widths (true) or not (false).\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bAutoWidth: null,\r\n\r\n          /**\r\n           * Delay the creation of TR and TD elements until they are actually\r\n           * needed by a driven page draw. This can give a significant speed\r\n           * increase for Ajax source and Javascript source data, but makes no\r\n           * difference at all fro DOM and server-side processing tables.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bDeferRender: null,\r\n\r\n          /**\r\n           * Enable filtering on the table or not. Note that if this is disabled\r\n           * then there is no filtering at all on the table, including fnFilter.\r\n           * To just remove the filtering input use sDom and remove the 'f' option.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bFilter: null,\r\n\r\n          /**\r\n           * Table information element (the 'Showing x of y records' div) enable\r\n           * flag.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bInfo: null,\r\n\r\n          /**\r\n           * Present a user control allowing the end user to change the page size\r\n           * when pagination is enabled.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bLengthChange: null,\r\n\r\n          /**\r\n           * Pagination enabled or not. Note that if this is disabled then length\r\n           * changing must also be disabled.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bPaginate: null,\r\n\r\n          /**\r\n           * Processing indicator enable flag whenever DataTables is enacting a\r\n           * user request - typically an Ajax request for server-side processing.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bProcessing: null,\r\n\r\n          /**\r\n           * Server-side processing enabled flag - when enabled DataTables will\r\n           * get all data from the server for every draw - there is no filtering,\r\n           * sorting or paging done on the client-side.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bServerSide: null,\r\n\r\n          /**\r\n           * Sorting enablement flag.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bSort: null,\r\n\r\n          /**\r\n           * Multi-column sorting\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bSortMulti: null,\r\n\r\n          /**\r\n           * Apply a class to the columns which are being sorted to provide a\r\n           * visual highlight or not. This can slow things down when enabled since\r\n           * there is a lot of DOM interaction.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bSortClasses: null,\r\n\r\n          /**\r\n           * State saving enablement flag.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bStateSave: null\r\n        },\r\n\r\n        /**\r\n         * Scrolling settings for a table.\r\n         *  @namespace\r\n         */\r\n        oScroll: {\r\n          /**\r\n           * When the table is shorter in height than sScrollY, collapse the\r\n           * table container down to the height of the table (when true).\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type boolean\r\n           */\r\n          bCollapse: null,\r\n\r\n          /**\r\n           * Width of the scrollbar for the web-browser's platform. Calculated\r\n           * during table initialisation.\r\n           *  @type int\r\n           *  @default 0\r\n           */\r\n          iBarWidth: 0,\r\n\r\n          /**\r\n           * Viewport width for horizontal scrolling. Horizontal scrolling is\r\n           * disabled if an empty string.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type string\r\n           */\r\n          sX: null,\r\n\r\n          /**\r\n           * Width to expand the table to when using x-scrolling. Typically you\r\n           * should not need to use this.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type string\r\n           *  @deprecated\r\n           */\r\n          sXInner: null,\r\n\r\n          /**\r\n           * Viewport height for vertical scrolling. Vertical scrolling is disabled\r\n           * if an empty string.\r\n           * Note that this parameter will be set by the initialisation routine. To\r\n           * set a default use {@link DataTable.defaults}.\r\n           *  @type string\r\n           */\r\n          sY: null\r\n        },\r\n\r\n        /**\r\n         * Language information for the table.\r\n         *  @namespace\r\n         *  @extends DataTable.defaults.oLanguage\r\n         */\r\n        oLanguage: {\r\n          /**\r\n           * Information callback function. See\r\n           * {@link DataTable.defaults.fnInfoCallback}\r\n           *  @type function\r\n           *  @default null\r\n           */\r\n          fnInfoCallback: null\r\n        },\r\n\r\n        /**\r\n         * Browser support parameters\r\n         *  @namespace\r\n         */\r\n        oBrowser: {\r\n          /**\r\n           * Indicate if the browser incorrectly calculates width:100% inside a\r\n           * scrolling element (IE6/7)\r\n           *  @type boolean\r\n           *  @default false\r\n           */\r\n          bScrollOversize: false,\r\n\r\n          /**\r\n           * Determine if the vertical scrollbar is on the right or left of the\r\n           * scrolling container - needed for rtl language layout, although not\r\n           * all browsers move the scrollbar (Safari).\r\n           *  @type boolean\r\n           *  @default false\r\n           */\r\n          bScrollbarLeft: false\r\n        },\r\n\r\n        ajax: null,\r\n\r\n        /**\r\n         * Array referencing the nodes which are used for the features. The\r\n         * parameters of this object match what is allowed by sDom - i.e.\r\n         *   <ul>\r\n         *     <li>'l' - Length changing</li>\r\n         *     <li>'f' - Filtering input</li>\r\n         *     <li>'t' - The table!</li>\r\n         *     <li>'i' - Information</li>\r\n         *     <li>'p' - Pagination</li>\r\n         *     <li>'r' - pRocessing</li>\r\n         *   </ul>\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aanFeatures: [],\r\n\r\n        /**\r\n         * Store data information - see {@link DataTable.models.oRow} for detailed\r\n         * information.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoData: [],\r\n\r\n        /**\r\n         * Array of indexes which are in the current display (after filtering etc)\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aiDisplay: [],\r\n\r\n        /**\r\n         * Array of indexes for display - no filtering\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aiDisplayMaster: [],\r\n\r\n        /**\r\n         * Store information about each column that is in use\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoColumns: [],\r\n\r\n        /**\r\n         * Store information about the table's header\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoHeader: [],\r\n\r\n        /**\r\n         * Store information about the table's footer\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoFooter: [],\r\n\r\n        /**\r\n         * Store the applied global search information in case we want to force a\r\n         * research or compare the old search to a new one.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @namespace\r\n         *  @extends DataTable.models.oSearch\r\n         */\r\n        oPreviousSearch: {},\r\n\r\n        /**\r\n         * Store the applied search for each column - see\r\n         * {@link DataTable.models.oSearch} for the format that is used for the\r\n         * filtering information for each column.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoPreSearchCols: [],\r\n\r\n        /**\r\n         * Sorting that is applied to the table. Note that the inner arrays are\r\n         * used in the following manner:\r\n         * <ul>\r\n         *   <li>Index 0 - column number</li>\r\n         *   <li>Index 1 - current sorting direction</li>\r\n         * </ul>\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @todo These inner arrays should really be objects\r\n         */\r\n        aaSorting: null,\r\n\r\n        /**\r\n         * Sorting that is always applied to the table (i.e. prefixed in front of\r\n         * aaSorting).\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aaSortingFixed: [],\r\n\r\n        /**\r\n         * Classes to use for the striping of a table.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        asStripeClasses: null,\r\n\r\n        /**\r\n         * If restoring a table - we should restore its striping classes as well\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        asDestroyStripes: [],\r\n\r\n        /**\r\n         * If restoring a table - we should restore its width\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        sDestroyWidth: 0,\r\n\r\n        /**\r\n         * Callback functions array for every time a row is inserted (i.e. on a draw).\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoRowCallback: [],\r\n\r\n        /**\r\n         * Callback functions for the header on each draw.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoHeaderCallback: [],\r\n\r\n        /**\r\n         * Callback function for the footer on each draw.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoFooterCallback: [],\r\n\r\n        /**\r\n         * Array of callback functions for draw callback functions\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoDrawCallback: [],\r\n\r\n        /**\r\n         * Array of callback functions for row created function\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoRowCreatedCallback: [],\r\n\r\n        /**\r\n         * Callback functions for just before the table is redrawn. A return of\r\n         * false will be used to cancel the draw.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoPreDrawCallback: [],\r\n\r\n        /**\r\n         * Callback functions for when the table has been initialised.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoInitComplete: [],\r\n\r\n        /**\r\n         * Callbacks for modifying the settings to be stored for state saving, prior to\r\n         * saving state.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateSaveParams: [],\r\n\r\n        /**\r\n         * Callbacks for modifying the settings that have been stored for state saving\r\n         * prior to using the stored values to restore the state.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateLoadParams: [],\r\n\r\n        /**\r\n         * Callbacks for operating on the settings object once the saved state has been\r\n         * loaded\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateLoaded: [],\r\n\r\n        /**\r\n         * Cache the table ID for quick access\r\n         *  @type string\r\n         *  @default <i>Empty string</i>\r\n         */\r\n        sTableId: '',\r\n\r\n        /**\r\n         * The TABLE node for the main table\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTable: null,\r\n\r\n        /**\r\n         * Permanent ref to the thead element\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTHead: null,\r\n\r\n        /**\r\n         * Permanent ref to the tfoot element - if it exists\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTFoot: null,\r\n\r\n        /**\r\n         * Permanent ref to the tbody element\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTBody: null,\r\n\r\n        /**\r\n         * Cache the wrapper node (contains all DataTables controlled elements)\r\n         *  @type node\r\n         *  @default null\r\n         */\r\n        nTableWrapper: null,\r\n\r\n        /**\r\n         * Indicate if when using server-side processing the loading of data\r\n         * should be deferred until the second draw.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bDeferLoading: false,\r\n\r\n        /**\r\n         * Indicate if all required information has been read in\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bInitialised: false,\r\n\r\n        /**\r\n         * Information about open rows. Each object in the array has the parameters\r\n         * 'nTr' and 'nParent'\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoOpenRows: [],\r\n\r\n        /**\r\n         * Dictate the positioning of DataTables' control elements - see\r\n         * {@link DataTable.model.oInit.sDom}.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sDom: null,\r\n\r\n        /**\r\n         * Which type of pagination should be used.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         *  @default two_button\r\n         */\r\n        sPaginationType: 'two_button',\r\n\r\n        /**\r\n         * The state duration (for `stateSave`) in seconds.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        iStateDuration: 0,\r\n\r\n        /**\r\n         * Array of callback functions for state saving. Each array element is an\r\n         * object with the following parameters:\r\n         *   <ul>\r\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\r\n         *       and the JSON string to save that has been thus far created. Returns\r\n         *       a JSON string to be inserted into a json object\r\n         *       (i.e. '\"param\": [ 0, 1, 2]')</li>\r\n         *     <li>string:sName - name of callback</li>\r\n         *   </ul>\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateSave: [],\r\n\r\n        /**\r\n         * Array of callback functions for state loading. Each array element is an\r\n         * object with the following parameters:\r\n         *   <ul>\r\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\r\n         *       and the object stored. May return false to cancel state loading</li>\r\n         *     <li>string:sName - name of callback</li>\r\n         *   </ul>\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoStateLoad: [],\r\n\r\n        /**\r\n         * State that was saved. Useful for back reference\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oSavedState: null,\r\n\r\n        /**\r\n         * State that was loaded. Useful for back reference\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oLoadedState: null,\r\n\r\n        /**\r\n         * Source url for AJAX data for the table.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sAjaxSource: null,\r\n\r\n        /**\r\n         * Property from a given object from which to read the table data from. This\r\n         * can be an empty string (when not server-side processing), in which case\r\n         * it is  assumed an an array is given directly.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         */\r\n        sAjaxDataProp: null,\r\n\r\n        /**\r\n         * Note if draw should be blocked while getting data\r\n         *  @type boolean\r\n         *  @default true\r\n         */\r\n        bAjaxDataGet: true,\r\n\r\n        /**\r\n         * The last jQuery XHR object that was used for server-side data gathering.\r\n         * This can be used for working with the XHR information in one of the\r\n         * callbacks\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        jqXHR: null,\r\n\r\n        /**\r\n         * JSON returned from the server in the last Ajax request\r\n         *  @type object\r\n         *  @default undefined\r\n         */\r\n        json: undefined,\r\n\r\n        /**\r\n         * Data submitted as part of the last Ajax request\r\n         *  @type object\r\n         *  @default undefined\r\n         */\r\n        oAjaxData: undefined,\r\n\r\n        /**\r\n         * Function to get the server-side data.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type function\r\n         */\r\n        fnServerData: null,\r\n\r\n        /**\r\n         * Functions which are called prior to sending an Ajax request so extra\r\n         * parameters can easily be sent to the server\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoServerParams: [],\r\n\r\n        /**\r\n         * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\r\n         * required).\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type string\r\n         */\r\n        sServerMethod: null,\r\n\r\n        /**\r\n         * Format numbers for display.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type function\r\n         */\r\n        fnFormatNumber: null,\r\n\r\n        /**\r\n         * List of options that can be used for the user selectable length menu.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aLengthMenu: null,\r\n\r\n        /**\r\n         * Counter for the draws that the table does. Also used as a tracker for\r\n         * server-side processing\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        iDraw: 0,\r\n\r\n        /**\r\n         * Indicate if a redraw is being done - useful for Ajax\r\n         *  @type boolean\r\n         *  @default false\r\n         */\r\n        bDrawing: false,\r\n\r\n        /**\r\n         * Draw index (iDraw) of the last error when parsing the returned data\r\n         *  @type int\r\n         *  @default -1\r\n         */\r\n        iDrawError: -1,\r\n\r\n        /**\r\n         * Paging display length\r\n         *  @type int\r\n         *  @default 10\r\n         */\r\n        _iDisplayLength: 10,\r\n\r\n        /**\r\n         * Paging start point - aiDisplay index\r\n         *  @type int\r\n         *  @default 0\r\n         */\r\n        _iDisplayStart: 0,\r\n\r\n        /**\r\n         * Server-side processing - number of records in the result set\r\n         * (i.e. before filtering), Use fnRecordsTotal rather than\r\n         * this property to get the value of the number of records, regardless of\r\n         * the server-side processing setting.\r\n         *  @type int\r\n         *  @default 0\r\n         *  @private\r\n         */\r\n        _iRecordsTotal: 0,\r\n\r\n        /**\r\n         * Server-side processing - number of records in the current display set\r\n         * (i.e. after filtering). Use fnRecordsDisplay rather than\r\n         * this property to get the value of the number of records, regardless of\r\n         * the server-side processing setting.\r\n         *  @type boolean\r\n         *  @default 0\r\n         *  @private\r\n         */\r\n        _iRecordsDisplay: 0,\r\n\r\n        /**\r\n         * Flag to indicate if jQuery UI marking and classes should be used.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type boolean\r\n         */\r\n        bJUI: null,\r\n\r\n        /**\r\n         * The classes to use for the table\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        oClasses: {},\r\n\r\n        /**\r\n         * Flag attached to the settings object so you can check in the draw\r\n         * callback if filtering has been done in the draw. Deprecated in favour of\r\n         * events.\r\n         *  @type boolean\r\n         *  @default false\r\n         *  @deprecated\r\n         */\r\n        bFiltered: false,\r\n\r\n        /**\r\n         * Flag attached to the settings object so you can check in the draw\r\n         * callback if sorting has been done in the draw. Deprecated in favour of\r\n         * events.\r\n         *  @type boolean\r\n         *  @default false\r\n         *  @deprecated\r\n         */\r\n        bSorted: false,\r\n\r\n        /**\r\n         * Indicate that if multiple rows are in the header and there is more than\r\n         * one unique cell per column, if the top one (true) or bottom one (false)\r\n         * should be used for sorting / title by DataTables.\r\n         * Note that this parameter will be set by the initialisation routine. To\r\n         * set a default use {@link DataTable.defaults}.\r\n         *  @type boolean\r\n         */\r\n        bSortCellsTop: null,\r\n\r\n        /**\r\n         * Initialisation object that is used for the table\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oInit: null,\r\n\r\n        /**\r\n         * Destroy callback functions - for plug-ins to attach themselves to the\r\n         * destroy so they can clean up markup and events.\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aoDestroyCallback: [],\r\n\r\n        /**\r\n         * Get the number of records in the current record set, before filtering\r\n         *  @type function\r\n         */\r\n        fnRecordsTotal: function () {\r\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length\r\n        },\r\n\r\n        /**\r\n         * Get the number of records in the current record set, after filtering\r\n         *  @type function\r\n         */\r\n        fnRecordsDisplay: function () {\r\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length\r\n        },\r\n\r\n        /**\r\n         * Get the display end point - aiDisplay index\r\n         *  @type function\r\n         */\r\n        fnDisplayEnd: function () {\r\n          var len = this._iDisplayLength,\r\n            start = this._iDisplayStart,\r\n            calc = start + len,\r\n            records = this.aiDisplay.length,\r\n            features = this.oFeatures,\r\n            paginate = features.bPaginate\r\n\r\n          if (features.bServerSide) {\r\n            return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay)\r\n          } else {\r\n            return !paginate || calc > records || len === -1 ? records : calc\r\n          }\r\n        },\r\n\r\n        /**\r\n         * The DataTables object for this table\r\n         *  @type object\r\n         *  @default null\r\n         */\r\n        oInstance: null,\r\n\r\n        /**\r\n         * Unique identifier for each instance of the DataTables object. If there\r\n         * is an ID on the table node, then it takes that value, otherwise an\r\n         * incrementing internal counter is used.\r\n         *  @type string\r\n         *  @default null\r\n         */\r\n        sInstance: null,\r\n\r\n        /**\r\n         * tabindex attribute value that is added to DataTables control elements, allowing\r\n         * keyboard navigation of the table and its controls.\r\n         */\r\n        iTabIndex: 0,\r\n\r\n        /**\r\n         * DIV container for the footer scrolling table if scrolling\r\n         */\r\n        nScrollHead: null,\r\n\r\n        /**\r\n         * DIV container for the footer scrolling table if scrolling\r\n         */\r\n        nScrollFoot: null,\r\n\r\n        /**\r\n         * Last applied sort\r\n         *  @type array\r\n         *  @default []\r\n         */\r\n        aLastSort: [],\r\n\r\n        /**\r\n         * Stored plug-in instances\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        oPlugins: {}\r\n      }\r\n\r\n      /**\r\n       * Extension object for DataTables that is used to provide all extension\r\n       * options.\r\n       *\r\n       * Note that the `DataTable.ext` object is available through\r\n       * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\r\n       * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\r\n       *  @namespace\r\n       *  @extends DataTable.models.ext\r\n       */\r\n\r\n      /**\r\n       * DataTables extensions\r\n       *\r\n       * This namespace acts as a collection area for plug-ins that can be used to\r\n       * extend DataTables capabilities. Indeed many of the build in methods\r\n       * use this method to provide their own capabilities (sorting methods for\r\n       * example).\r\n       *\r\n       * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\r\n       * reasons\r\n       *\r\n       *  @namespace\r\n       */\r\n      DataTable.ext = _ext = {\r\n        /**\r\n         * Element class names\r\n         *\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        classes: {},\r\n\r\n        /**\r\n         * Error reporting.\r\n         *\r\n         * How should DataTables report an error. Can take the value 'alert' or\r\n         * 'throw'\r\n         *\r\n         *  @type string\r\n         *  @default alert\r\n         */\r\n        errMode: 'alert',\r\n\r\n        /**\r\n         * Feature plug-ins.\r\n         *\r\n         * This is an array of objects which describe the feature plug-ins that are\r\n         * available to DataTables. These feature plug-ins are then available for\r\n         * use through the `dom` initialisation option.\r\n         *\r\n         * Each feature plug-in is described by an object which must have the\r\n         * following properties:\r\n         *\r\n         * * `fnInit` - function that is used to initialise the plug-in,\r\n         * * `cFeature` - a character so the feature can be enabled by the `dom`\r\n         *   instillation option. This is case sensitive.\r\n         *\r\n         * The `fnInit` function has the following input parameters:\r\n         *\r\n         * 1. `{object}` DataTables settings object: see\r\n         *    {@link DataTable.models.oSettings}\r\n         *\r\n         * And the following return is expected:\r\n         *\r\n         * * {node|null} The element which contains your feature. Note that the\r\n         *   return may also be void if your plug-in does not require to inject any\r\n         *   DOM elements into DataTables control (`dom`) - for example this might\r\n         *   be useful when developing a plug-in which allows table control via\r\n         *   keyboard entry\r\n         *\r\n         *  @type array\r\n         *\r\n         *  @example\r\n         *    $.fn.dataTable.ext.features.push( {\r\n         *      \"fnInit\": function( oSettings ) {\r\n         *        return new TableTools( { \"oDTSettings\": oSettings } );\r\n         *      },\r\n         *      \"cFeature\": \"T\"\r\n         *    } );\r\n         */\r\n        feature: [],\r\n\r\n        /**\r\n         * Row searching.\r\n         *\r\n         * This method of searching is complimentary to the default type based\r\n         * searching, and a lot more comprehensive as it allows you complete control\r\n         * over the searching logic. Each element in this array is a function\r\n         * (parameters described below) that is called for every row in the table,\r\n         * and your logic decides if it should be included in the searching data set\r\n         * or not.\r\n         *\r\n         * Searching functions have the following input parameters:\r\n         *\r\n         * 1. `{object}` DataTables settings object: see\r\n         *    {@link DataTable.models.oSettings}\r\n         * 2. `{array|object}` Data for the row to be processed (same as the\r\n         *    original format that was passed in as the data source, or an array\r\n         *    from a DOM data source\r\n         * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\r\n         *    can be useful to retrieve the `TR` element if you need DOM interaction.\r\n         *\r\n         * And the following return is expected:\r\n         *\r\n         * * {boolean} Include the row in the searched result set (true) or not\r\n         *   (false)\r\n         *\r\n         * Note that as with the main search ability in DataTables, technically this\r\n         * is \"filtering\", since it is subtractive. However, for consistency in\r\n         * naming we call it searching here.\r\n         *\r\n         *  @type array\r\n         *  @default []\r\n         *\r\n         *  @example\r\n         *    // The following example shows custom search being applied to the\r\n         *    // fourth column (i.e. the data[3] index) based on two input values\r\n         *    // from the end-user, matching the data in a certain range.\r\n         *    $.fn.dataTable.ext.search.push(\r\n         *      function( settings, data, dataIndex ) {\r\n         *        var min = document.getElementById('min').value * 1;\r\n         *        var max = document.getElementById('max').value * 1;\r\n         *        var version = data[3] == \"-\" ? 0 : data[3]*1;\r\n         *\r\n         *        if ( min == \"\" && max == \"\" ) {\r\n         *          return true;\r\n         *        }\r\n         *        else if ( min == \"\" && version < max ) {\r\n         *          return true;\r\n         *        }\r\n         *        else if ( min < version && \"\" == max ) {\r\n         *          return true;\r\n         *        }\r\n         *        else if ( min < version && version < max ) {\r\n         *          return true;\r\n         *        }\r\n         *        return false;\r\n         *      }\r\n         *    );\r\n         */\r\n        search: [],\r\n\r\n        /**\r\n         * Internal functions, exposed for used in plug-ins.\r\n         *\r\n         * Please note that you should not need to use the internal methods for\r\n         * anything other than a plug-in (and even then, try to avoid if possible).\r\n         * The internal function may change between releases.\r\n         *\r\n         *  @type object\r\n         *  @default {}\r\n         */\r\n        internal: {},\r\n\r\n        /**\r\n         * Legacy configuration options. Enable and disable legacy options that\r\n         * are available in DataTables.\r\n         *\r\n         *  @type object\r\n         */\r\n        legacy: {\r\n          /**\r\n           * Enable / disable DataTables 1.9 compatible server-side processing\r\n           * requests\r\n           *\r\n           *  @type boolean\r\n           *  @default null\r\n           */\r\n          ajax: null\r\n        },\r\n\r\n        /**\r\n         * Pagination plug-in methods.\r\n         *\r\n         * Each entry in this object is a function and defines which buttons should\r\n         * be shown by the pagination rendering method that is used for the table:\r\n         * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\r\n         * buttons are displayed in the document, while the functions here tell it\r\n         * what buttons to display. This is done by returning an array of button\r\n         * descriptions (what each button will do).\r\n         *\r\n         * Pagination types (the four built in options and any additional plug-in\r\n         * options defined here) can be used through the `paginationType`\r\n         * initialisation parameter.\r\n         *\r\n         * The functions defined take two parameters:\r\n         *\r\n         * 1. `{int} page` The current page index\r\n         * 2. `{int} pages` The number of pages in the table\r\n         *\r\n         * Each function is expected to return an array where each element of the\r\n         * array can be one of:\r\n         *\r\n         * * `first` - Jump to first page when activated\r\n         * * `last` - Jump to last page when activated\r\n         * * `previous` - Show previous page when activated\r\n         * * `next` - Show next page when activated\r\n         * * `{int}` - Show page of the index given\r\n         * * `{array}` - A nested array containing the above elements to add a\r\n         *   containing 'DIV' element (might be useful for styling).\r\n         *\r\n         * Note that DataTables v1.9- used this object slightly differently whereby\r\n         * an object with two functions would be defined for each plug-in. That\r\n         * ability is still supported by DataTables 1.10+ to provide backwards\r\n         * compatibility, but this option of use is now decremented and no longer\r\n         * documented in DataTables 1.10+.\r\n         *\r\n         *  @type object\r\n         *  @default {}\r\n         *\r\n         *  @example\r\n         *    // Show previous, next and current page buttons only\r\n         *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\r\n         *      return [ 'previous', page, 'next' ];\r\n         *    };\r\n         */\r\n        pager: {},\r\n\r\n        renderer: {\r\n          pageButton: {},\r\n          header: {}\r\n        },\r\n\r\n        /**\r\n         * Ordering plug-ins - custom data source\r\n         *\r\n         * The extension options for ordering of data available here is complimentary\r\n         * to the default type based ordering that DataTables typically uses. It\r\n         * allows much greater control over the the data that is being used to\r\n         * order a column, but is necessarily therefore more complex.\r\n         *\r\n         * This type of ordering is useful if you want to do ordering based on data\r\n         * live from the DOM (for example the contents of an 'input' element) rather\r\n         * than just the static string that DataTables knows of.\r\n         *\r\n         * The way these plug-ins work is that you create an array of the values you\r\n         * wish to be ordering for the column in question and then return that\r\n         * array. The data in the array much be in the index order of the rows in\r\n         * the table (not the currently ordering order!). Which order data gathering\r\n         * function is run here depends on the `dt-init columns.orderDataType`\r\n         * parameter that is used for the column (if any).\r\n         *\r\n         * The functions defined take two parameters:\r\n         *\r\n         * 1. `{object}` DataTables settings object: see\r\n         *    {@link DataTable.models.oSettings}\r\n         * 2. `{int}` Target column index\r\n         *\r\n         * Each function is expected to return an array:\r\n         *\r\n         * * `{array}` Data for the column to be ordering upon\r\n         *\r\n         *  @type array\r\n         *\r\n         *  @example\r\n         *    // Ordering using `input` node values\r\n         *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\r\n         *    {\r\n         *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\r\n         *        return $('input', td).val();\r\n         *      } );\r\n         *    }\r\n         */\r\n        order: {},\r\n\r\n        /**\r\n         * Type based plug-ins.\r\n         *\r\n         * Each column in DataTables has a type assigned to it, either by automatic\r\n         * detection or by direct assignment using the `type` option for the column.\r\n         * The type of a column will effect how it is ordering and search (plug-ins\r\n         * can also make use of the column type if required).\r\n         *\r\n         * @namespace\r\n         */\r\n        type: {\r\n          /**\r\n           * Type detection functions.\r\n           *\r\n           * The functions defined in this object are used to automatically detect\r\n           * a column's type, making initialisation of DataTables super easy, even\r\n           * when complex data is in the table.\r\n           *\r\n           * The functions defined take two parameters:\r\n           *\r\n           *  1. `{*}` Data from the column cell to be analysed\r\n           *  2. `{settings}` DataTables settings object. This can be used to\r\n           *     perform context specific type detection - for example detection\r\n           *     based on language settings such as using a comma for a decimal\r\n           *     place. Generally speaking the options from the settings will not\r\n           *     be required\r\n           *\r\n           * Each function is expected to return:\r\n           *\r\n           * * `{string|null}` Data type detected, or null if unknown (and thus\r\n           *   pass it on to the other type detection functions.\r\n           *\r\n           *  @type array\r\n           *\r\n           *  @example\r\n           *    // Currency type detection plug-in:\r\n           *    $.fn.dataTable.ext.type.detect.push(\r\n           *      function ( data, settings ) {\r\n           *        // Check the numeric part\r\n           *        if ( ! $.isNumeric( data.substring(1) ) ) {\r\n           *          return null;\r\n           *        }\r\n           *\r\n           *        // Check prefixed by currency\r\n           *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\r\n           *          return 'currency';\r\n           *        }\r\n           *        return null;\r\n           *      }\r\n           *    );\r\n           */\r\n          detect: [],\r\n\r\n          /**\r\n           * Type based search formatting.\r\n           *\r\n           * The type based searching functions can be used to pre-format the\r\n           * data to be search on. For example, it can be used to strip HTML\r\n           * tags or to de-format telephone numbers for numeric only searching.\r\n           *\r\n           * Note that is a search is not defined for a column of a given type,\r\n           * no search formatting will be performed.\r\n           *\r\n           * Pre-processing of searching data plug-ins - When you assign the sType\r\n           * for a column (or have it automatically detected for you by DataTables\r\n           * or a type detection plug-in), you will typically be using this for\r\n           * custom sorting, but it can also be used to provide custom searching\r\n           * by allowing you to pre-processing the data and returning the data in\r\n           * the format that should be searched upon. This is done by adding\r\n           * functions this object with a parameter name which matches the sType\r\n           * for that target column. This is the corollary of <i>afnSortData</i>\r\n           * for searching data.\r\n           *\r\n           * The functions defined take a single parameter:\r\n           *\r\n           *  1. `{*}` Data from the column cell to be prepared for searching\r\n           *\r\n           * Each function is expected to return:\r\n           *\r\n           * * `{string|null}` Formatted string that will be used for the searching.\r\n           *\r\n           *  @type object\r\n           *  @default {}\r\n           *\r\n           *  @example\r\n           *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\r\n           *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\r\n           *    }\r\n           */\r\n          search: {},\r\n\r\n          /**\r\n           * Type based ordering.\r\n           *\r\n           * The column type tells DataTables what ordering to apply to the table\r\n           * when a column is sorted upon. The order for each type that is defined,\r\n           * is defined by the functions available in this object.\r\n           *\r\n           * Each ordering option can be described by three properties added to\r\n           * this object:\r\n           *\r\n           * * `{type}-pre` - Pre-formatting function\r\n           * * `{type}-asc` - Ascending order function\r\n           * * `{type}-desc` - Descending order function\r\n           *\r\n           * All three can be used together, only `{type}-pre` or only\r\n           * `{type}-asc` and `{type}-desc` together. It is generally recommended\r\n           * that only `{type}-pre` is used, as this provides the optimal\r\n           * implementation in terms of speed, although the others are provided\r\n           * for compatibility with existing Javascript sort functions.\r\n           *\r\n           * `{type}-pre`: Functions defined take a single parameter:\r\n           *\r\n           *  1. `{*}` Data from the column cell to be prepared for ordering\r\n           *\r\n           * And return:\r\n           *\r\n           * * `{*}` Data to be sorted upon\r\n           *\r\n           * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\r\n           * functions, taking two parameters:\r\n           *\r\n           *  1. `{*}` Data to compare to the second parameter\r\n           *  2. `{*}` Data to compare to the first parameter\r\n           *\r\n           * And returning:\r\n           *\r\n           * * `{*}` Ordering match: <0 if first parameter should be sorted lower\r\n           *   than the second parameter, ===0 if the two parameters are equal and\r\n           *   >0 if the first parameter should be sorted height than the second\r\n           *   parameter.\r\n           *\r\n           *  @type object\r\n           *  @default {}\r\n           *\r\n           *  @example\r\n           *    // Numeric ordering of formatted numbers with a pre-formatter\r\n           *    $.extend( $.fn.dataTable.ext.type.order, {\r\n           *      \"string-pre\": function(x) {\r\n           *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\r\n           *        return parseFloat( a );\r\n           *      }\r\n           *    } );\r\n           *\r\n           *  @example\r\n           *    // Case-sensitive string ordering, with no pre-formatting method\r\n           *    $.extend( $.fn.dataTable.ext.order, {\r\n           *      \"string-case-asc\": function(x,y) {\r\n           *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\r\n           *      },\r\n           *      \"string-case-desc\": function(x,y) {\r\n           *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\r\n           *      }\r\n           *    } );\r\n           */\r\n          order: {}\r\n        },\r\n\r\n        /**\r\n         * Unique DataTables instance counter\r\n         *\r\n         * @type int\r\n         * @private\r\n         */\r\n        _unique: 0,\r\n\r\n        //\r\n        // Depreciated\r\n        // The following properties are retained for backwards compatiblity only.\r\n        // The should not be used in new projects and will be removed in a future\r\n        // version\r\n        //\r\n\r\n        /**\r\n         * Version check function.\r\n         *  @type function\r\n         *  @depreciated Since 1.10\r\n         */\r\n        fnVersionCheck: DataTable.fnVersionCheck,\r\n\r\n        /**\r\n         * Index for what 'this' index API functions should use\r\n         *  @type int\r\n         *  @deprecated Since v1.10\r\n         */\r\n        iApiIndex: 0,\r\n\r\n        /**\r\n         * jQuery UI class container\r\n         *  @type object\r\n         *  @deprecated Since v1.10\r\n         */\r\n        oJUIClasses: {},\r\n\r\n        /**\r\n         * Software version\r\n         *  @type string\r\n         *  @deprecated Since v1.10\r\n         */\r\n        sVersion: DataTable.version\r\n      }\r\n\r\n      //\r\n      // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\r\n      //\r\n      $.extend(_ext, {\r\n        afnFiltering: _ext.search,\r\n        aTypes: _ext.type.detect,\r\n        ofnSearch: _ext.type.search,\r\n        oSort: _ext.type.order,\r\n        afnSortData: _ext.order,\r\n        aoFeatures: _ext.feature,\r\n        oApi: _ext.internal,\r\n        oStdClasses: _ext.classes,\r\n        oPagination: _ext.pager\r\n      })\r\n\r\n      $.extend(DataTable.ext.classes, {\r\n        sTable: 'dataTable',\r\n        sNoFooter: 'no-footer',\r\n\r\n        /* Paging buttons */\r\n        sPageButton: 'paginate_button',\r\n        sPageButtonActive: 'current',\r\n        sPageButtonDisabled: 'disabled',\r\n\r\n        /* Striping classes */\r\n        sStripeOdd: 'odd',\r\n        sStripeEven: 'even',\r\n\r\n        /* Empty row */\r\n        sRowEmpty: 'dataTables_empty',\r\n\r\n        /* Features */\r\n        sWrapper: 'dataTables_wrapper',\r\n        sFilter: 'dataTables_filter',\r\n        sInfo: 'dataTables_info',\r\n        sPaging: 'dataTables_paginate paging_' /* Note that the type is postfixed */,\r\n        sLength: 'dataTables_length',\r\n        sProcessing: 'dataTables_processing',\r\n\r\n        /* Sorting */\r\n        sSortAsc: 'sorting_asc',\r\n        sSortDesc: 'sorting_desc',\r\n        sSortable: 'sorting' /* Sortable in both directions */,\r\n        sSortableAsc: 'sorting_asc_disabled',\r\n        sSortableDesc: 'sorting_desc_disabled',\r\n        sSortableNone: 'sorting_disabled',\r\n        sSortColumn: 'sorting_' /* Note that an int is postfixed for the sorting order */,\r\n\r\n        /* Filtering */\r\n        sFilterInput: '',\r\n\r\n        /* Page length */\r\n        sLengthSelect: '',\r\n\r\n        /* Scrolling */\r\n        sScrollWrapper: 'dataTables_scroll',\r\n        sScrollHead: 'dataTables_scrollHead',\r\n        sScrollHeadInner: 'dataTables_scrollHeadInner',\r\n        sScrollBody: 'dataTables_scrollBody',\r\n        sScrollFoot: 'dataTables_scrollFoot',\r\n        sScrollFootInner: 'dataTables_scrollFootInner',\r\n\r\n        /* Misc */\r\n        sHeaderTH: '',\r\n        sFooterTH: '',\r\n\r\n        // Deprecated\r\n        sSortJUIAsc: '',\r\n        sSortJUIDesc: '',\r\n        sSortJUI: '',\r\n        sSortJUIAscAllowed: '',\r\n        sSortJUIDescAllowed: '',\r\n        sSortJUIWrapper: '',\r\n        sSortIcon: '',\r\n        sJUIHeader: '',\r\n        sJUIFooter: ''\r\n      })\r\n      ;(function () {\r\n        // Reused strings for better compression. Closure compiler appears to have a\r\n        // weird edge case where it is trying to expand strings rather than use the\r\n        // variable version. This results in about 200 bytes being added, for very\r\n        // little preference benefit since it this run on script load only.\r\n        var _empty = ''\r\n        _empty = ''\r\n\r\n        var _stateDefault = _empty + 'ui-state-default'\r\n        var _sortIcon = _empty + 'css_right ui-icon ui-icon-'\r\n        var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix'\r\n\r\n        $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {\r\n          /* Full numbers paging buttons */\r\n          sPageButton: 'fg-button ui-button ' + _stateDefault,\r\n          sPageButtonActive: 'ui-state-disabled',\r\n          sPageButtonDisabled: 'ui-state-disabled',\r\n\r\n          /* Features */\r\n          sPaging:\r\n            'dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ' +\r\n            'ui-buttonset-multi paging_' /* Note that the type is postfixed */,\r\n\r\n          /* Sorting */\r\n          sSortAsc: _stateDefault + ' sorting_asc',\r\n          sSortDesc: _stateDefault + ' sorting_desc',\r\n          sSortable: _stateDefault + ' sorting',\r\n          sSortableAsc: _stateDefault + ' sorting_asc_disabled',\r\n          sSortableDesc: _stateDefault + ' sorting_desc_disabled',\r\n          sSortableNone: _stateDefault + ' sorting_disabled',\r\n          sSortJUIAsc: _sortIcon + 'triangle-1-n',\r\n          sSortJUIDesc: _sortIcon + 'triangle-1-s',\r\n          sSortJUI: _sortIcon + 'carat-2-n-s',\r\n          sSortJUIAscAllowed: _sortIcon + 'carat-1-n',\r\n          sSortJUIDescAllowed: _sortIcon + 'carat-1-s',\r\n          sSortJUIWrapper: 'DataTables_sort_wrapper',\r\n          sSortIcon: 'DataTables_sort_icon',\r\n\r\n          /* Scrolling */\r\n          sScrollHead: 'dataTables_scrollHead ' + _stateDefault,\r\n          sScrollFoot: 'dataTables_scrollFoot ' + _stateDefault,\r\n\r\n          /* Misc */\r\n          sHeaderTH: _stateDefault,\r\n          sFooterTH: _stateDefault,\r\n          sJUIHeader: _headerFooter + ' ui-corner-tl ui-corner-tr',\r\n          sJUIFooter: _headerFooter + ' ui-corner-bl ui-corner-br'\r\n        })\r\n      })()\r\n\r\n      var extPagination = DataTable.ext.pager\r\n\r\n      function _numbers (page, pages) {\r\n        var numbers = [],\r\n          buttons = extPagination.numbers_length,\r\n          half = Math.floor(buttons / 2),\r\n          i = 1\r\n\r\n        if (pages <= buttons) {\r\n          numbers = _range(0, pages)\r\n        } else if (page <= half) {\r\n          numbers = _range(0, buttons - 2)\r\n          numbers.push('ellipsis')\r\n          numbers.push(pages - 1)\r\n        } else if (page >= pages - 1 - half) {\r\n          numbers = _range(pages - (buttons - 2), pages)\r\n          numbers.splice(0, 0, 'ellipsis') // no unshift in ie6\r\n          numbers.splice(0, 0, 0)\r\n        } else {\r\n          numbers = _range(page - 1, page + 2)\r\n          numbers.push('ellipsis')\r\n          numbers.push(pages - 1)\r\n          numbers.splice(0, 0, 'ellipsis')\r\n          numbers.splice(0, 0, 0)\r\n        }\r\n\r\n        numbers.DT_el = 'span'\r\n        return numbers\r\n      }\r\n\r\n      $.extend(extPagination, {\r\n        simple: function (page, pages) {\r\n          return ['previous', 'next']\r\n        },\r\n\r\n        full: function (page, pages) {\r\n          return ['first', 'previous', 'next', 'last']\r\n        },\r\n\r\n        simple_numbers: function (page, pages) {\r\n          return ['previous', _numbers(page, pages), 'next']\r\n        },\r\n\r\n        full_numbers: function (page, pages) {\r\n          return ['first', 'previous', _numbers(page, pages), 'next', 'last']\r\n        },\r\n\r\n        // For testing and plug-ins to use\r\n        _numbers: _numbers,\r\n        numbers_length: 7\r\n      })\r\n\r\n      $.extend(true, DataTable.ext.renderer, {\r\n        pageButton: {\r\n          _: function (settings, host, idx, buttons, page, pages) {\r\n            var classes = settings.oClasses\r\n            var lang = settings.oLanguage.oPaginate\r\n            var btnDisplay,\r\n              btnClass,\r\n              counter = 0\r\n\r\n            var attach = function (container, buttons) {\r\n              var i, ien, node, button\r\n              var clickHandler = function (e) {\r\n                _fnPageChange(settings, e.data.action, true)\r\n              }\r\n\r\n              for (i = 0, ien = buttons.length; i < ien; i++) {\r\n                button = buttons[i]\r\n\r\n                if ($.isArray(button)) {\r\n                  var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container)\r\n                  attach(inner, button)\r\n                } else {\r\n                  btnDisplay = ''\r\n                  btnClass = ''\r\n\r\n                  switch (button) {\r\n                    case 'ellipsis':\r\n                      container.append('<span>&hellip;</span>')\r\n                      break\r\n\r\n                    case 'first':\r\n                      btnDisplay = lang.sFirst\r\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    case 'previous':\r\n                      btnDisplay = lang.sPrevious\r\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    case 'next':\r\n                      btnDisplay = lang.sNext\r\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    case 'last':\r\n                      btnDisplay = lang.sLast\r\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\r\n                      break\r\n\r\n                    default:\r\n                      btnDisplay = button + 1\r\n                      btnClass = page === button ? classes.sPageButtonActive : ''\r\n                      break\r\n                  }\r\n\r\n                  if (btnDisplay) {\r\n                    node = $('<a>', {\r\n                      class: classes.sPageButton + ' ' + btnClass,\r\n                      'aria-controls': settings.sTableId,\r\n                      'data-dt-idx': counter,\r\n                      tabindex: settings.iTabIndex,\r\n                      id: idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null\r\n                    })\r\n                      .html(btnDisplay)\r\n                      .appendTo(container)\r\n\r\n                    _fnBindAction(node, { action: button }, clickHandler)\r\n\r\n                    counter++\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            // IE9 throws an 'unknown error' if document.activeElement is used\r\n            // inside an iframe or frame. Try / catch the error. Not good for\r\n            // accessibility, but neither are frames.\r\n            try {\r\n              // Because this approach is destroying and recreating the paging\r\n              // elements, focus is lost on the select button which is bad for\r\n              // accessibility. So we want to restore focus once the draw has\r\n              // completed\r\n              var activeEl = $(document.activeElement).data('dt-idx')\r\n\r\n              attach($(host).empty(), buttons)\r\n\r\n              if (activeEl !== null) {\r\n                $(host)\r\n                  .find('[data-dt-idx=' + activeEl + ']')\r\n                  .focus()\r\n              }\r\n            } catch (e) {}\r\n          }\r\n        }\r\n      })\r\n\r\n      var __numericReplace = function (d, decimalPlace, re1, re2) {\r\n        if (!d || d === '-') {\r\n          return -Infinity\r\n        }\r\n\r\n        // If a decimal place other than `.` is used, it needs to be given to the\r\n        // function so we can detect it and replace with a `.` which is the only\r\n        // decimal place Javascript recognises - it is not locale aware.\r\n        if (decimalPlace) {\r\n          d = _numToDecimal(d, decimalPlace)\r\n        }\r\n\r\n        if (d.replace) {\r\n          if (re1) {\r\n            d = d.replace(re1, '')\r\n          }\r\n\r\n          if (re2) {\r\n            d = d.replace(re2, '')\r\n          }\r\n        }\r\n\r\n        return d * 1\r\n      }\r\n\r\n      // Add the numeric 'deformatting' functions for sorting. This is done in a\r\n      // function to provide an easy ability for the language options to add\r\n      // additional methods if a non-period decimal place is used.\r\n      function _addNumericSort (decimalPlace) {\r\n        $.each(\r\n          {\r\n            // Plain numbers\r\n            num: function (d) {\r\n              return __numericReplace(d, decimalPlace)\r\n            },\r\n\r\n            // Formatted numbers\r\n            'num-fmt': function (d) {\r\n              return __numericReplace(d, decimalPlace, _re_formatted_numeric)\r\n            },\r\n\r\n            // HTML numeric\r\n            'html-num': function (d) {\r\n              return __numericReplace(d, decimalPlace, _re_html)\r\n            },\r\n\r\n            // HTML numeric, formatted\r\n            'html-num-fmt': function (d) {\r\n              return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric)\r\n            }\r\n          },\r\n          function (key, fn) {\r\n            _ext.type.order[key + decimalPlace + '-pre'] = fn\r\n          }\r\n        )\r\n      }\r\n\r\n      // Default sort methods\r\n      $.extend(_ext.type.order, {\r\n        // Dates\r\n        'date-pre': function (d) {\r\n          return Date.parse(d) || 0\r\n        },\r\n\r\n        // html\r\n        'html-pre': function (a) {\r\n          return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, '').toLowerCase() : a + ''\r\n        },\r\n\r\n        // string\r\n        'string-pre': function (a) {\r\n          // This is a little complex, but faster than always calling toString,\r\n          // http://jsperf.com/tostring-v-check\r\n          return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString()\r\n        },\r\n\r\n        // string-asc and -desc are retained only for compatibility with the old\r\n        // sort methods\r\n        'string-asc': function (x, y) {\r\n          return x < y ? -1 : x > y ? 1 : 0\r\n        },\r\n\r\n        'string-desc': function (x, y) {\r\n          return x < y ? 1 : x > y ? -1 : 0\r\n        }\r\n      })\r\n\r\n      // Numeric sorting types - order doesn't matter here\r\n      _addNumericSort('')\r\n\r\n      // Built in type detection. See model.ext.aTypes for information about\r\n      // what is required from this methods.\r\n      $.extend(DataTable.ext.type.detect, [\r\n        // Plain numbers - first since V8 detects some plain numbers as dates\r\n        // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _isNumber(d, decimal) ? 'num' + decimal : null\r\n        },\r\n\r\n        // Dates (only those recognised by the browser's Date.parse)\r\n        function (d, settings) {\r\n          // V8 will remove any unknown characters at the start and end of the\r\n          // expression, leading to false matches such as `$245.12` or `10%` being\r\n          // a valid date. See forum thread 18941 for detail.\r\n          if (d && (!_re_date_start.test(d) || !_re_date_end.test(d))) {\r\n            return null\r\n          }\r\n          var parsed = Date.parse(d)\r\n          return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null\r\n        },\r\n\r\n        // Formatted numbers\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null\r\n        },\r\n\r\n        // HTML numeric\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null\r\n        },\r\n\r\n        // HTML numeric, formatted\r\n        function (d, settings) {\r\n          var decimal = settings.oLanguage.sDecimal\r\n          return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null\r\n        },\r\n\r\n        // HTML (this is strict checking - there must be html)\r\n        function (d, settings) {\r\n          return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ? 'html' : null\r\n        }\r\n      ])\r\n\r\n      // Filter formatting functions. See model.ext.ofnSearch for information about\r\n      // what is required from these methods.\r\n\r\n      $.extend(DataTable.ext.type.search, {\r\n        html: function (data) {\r\n          return _empty(data)\r\n            ? data\r\n            : typeof data === 'string'\r\n            ? data.replace(_re_new_lines, ' ').replace(_re_html, '')\r\n            : ''\r\n        },\r\n\r\n        string: function (data) {\r\n          return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, ' ') : data\r\n        }\r\n      })\r\n\r\n      $.extend(true, DataTable.ext.renderer, {\r\n        header: {\r\n          _: function (settings, cell, column, classes) {\r\n            // No additional mark-up required\r\n            // Attach a sort listener to update on sort - note that using the\r\n            // `DT` namespace will allow the event to be removed automatically\r\n            // on destroy, while the `dt` namespaced event is the one we are\r\n            // listening for\r\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\r\n              if (settings !== ctx) {\r\n                // need to check this this is the host\r\n                return // table, not a nested one\r\n              }\r\n\r\n              var colIdx = column.idx\r\n\r\n              cell\r\n                .removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc)\r\n                .addClass(\r\n                  columns[colIdx] == 'asc'\r\n                    ? classes.sSortAsc\r\n                    : columns[colIdx] == 'desc'\r\n                    ? classes.sSortDesc\r\n                    : column.sSortingClass\r\n                )\r\n            })\r\n          },\r\n\r\n          jqueryui: function (settings, cell, column, classes) {\r\n            var colIdx = column.idx\r\n\r\n            $('<div/>')\r\n              .addClass(classes.sSortJUIWrapper)\r\n              .append(cell.contents())\r\n              .append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI))\r\n              .appendTo(cell)\r\n\r\n            // Attach a sort listener to update on sort\r\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\r\n              if (settings !== ctx) {\r\n                return\r\n              }\r\n\r\n              cell\r\n                .removeClass(classes.sSortAsc + ' ' + classes.sSortDesc)\r\n                .addClass(\r\n                  columns[colIdx] == 'asc'\r\n                    ? classes.sSortAsc\r\n                    : columns[colIdx] == 'desc'\r\n                    ? classes.sSortDesc\r\n                    : column.sSortingClass\r\n                )\r\n\r\n              cell\r\n                .find('span.' + classes.sSortIcon)\r\n                .removeClass(\r\n                  classes.sSortJUIAsc +\r\n                    ' ' +\r\n                    classes.sSortJUIDesc +\r\n                    ' ' +\r\n                    classes.sSortJUI +\r\n                    ' ' +\r\n                    classes.sSortJUIAscAllowed +\r\n                    ' ' +\r\n                    classes.sSortJUIDescAllowed\r\n                )\r\n                .addClass(\r\n                  columns[colIdx] == 'asc'\r\n                    ? classes.sSortJUIAsc\r\n                    : columns[colIdx] == 'desc'\r\n                    ? classes.sSortJUIDesc\r\n                    : column.sSortingClassJUI\r\n                )\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      /*\r\n       * Public helper functions. These aren't used internally by DataTables, or\r\n       * called by any of the options passed into DataTables, but they can be used\r\n       * externally by developers working with DataTables. They are helper functions\r\n       * to make working with DataTables a little bit easier.\r\n       */\r\n\r\n      /**\r\n       * Helpers for `columns.render`.\r\n       *\r\n       * The options defined here can be used with the `columns.render` initialisation\r\n       * option to provide a display renderer. The following functions are defined:\r\n       *\r\n       * * `number` - Will format numeric data (defined by `columns.data`) for\r\n       *   display, retaining the original unformatted data for sorting and filtering.\r\n       *   It takes 4 parameters:\r\n       *   * `string` - Thousands grouping separator\r\n       *   * `string` - Decimal point indicator\r\n       *   * `integer` - Number of decimal points to show\r\n       *   * `string` (optional) - Prefix.\r\n       *\r\n       * @example\r\n       *   // Column definition using the number renderer\r\n       *   {\r\n       *     data: \"salary\",\r\n       *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\r\n       *   }\r\n       *\r\n       * @namespace\r\n       */\r\n      DataTable.render = {\r\n        number: function (thousands, decimal, precision, prefix) {\r\n          return {\r\n            display: function (d) {\r\n              var negative = d < 0 ? '-' : ''\r\n              d = Math.abs(parseFloat(d))\r\n\r\n              var intPart = parseInt(d, 10)\r\n              var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : ''\r\n\r\n              return (\r\n                negative + (prefix || '') + intPart.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands) + floatPart\r\n              )\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      /*\r\n       * This is really a good bit rubbish this method of exposing the internal methods\r\n       * publicly... - To be fixed in 2.0 using methods on the prototype\r\n       */\r\n\r\n      /**\r\n       * Create a wrapper function for exporting an internal functions to an external API.\r\n       *  @param {string} fn API function name\r\n       *  @returns {function} wrapped function\r\n       *  @memberof DataTable#internal\r\n       */\r\n      function _fnExternApiFunc (fn) {\r\n        return function () {\r\n          var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments))\r\n          return DataTable.ext.internal[fn].apply(this, args)\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Reference to internal functions for use by plug-in developers. Note that\r\n       * these methods are references to internal functions and are considered to be\r\n       * private. If you use these methods, be aware that they are liable to change\r\n       * between versions.\r\n       *  @namespace\r\n       */\r\n      $.extend(DataTable.ext.internal, {\r\n        _fnExternApiFunc: _fnExternApiFunc,\r\n        _fnBuildAjax: _fnBuildAjax,\r\n        _fnAjaxUpdate: _fnAjaxUpdate,\r\n        _fnAjaxParameters: _fnAjaxParameters,\r\n        _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\r\n        _fnAjaxDataSrc: _fnAjaxDataSrc,\r\n        _fnAddColumn: _fnAddColumn,\r\n        _fnColumnOptions: _fnColumnOptions,\r\n        _fnAdjustColumnSizing: _fnAdjustColumnSizing,\r\n        _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\r\n        _fnColumnIndexToVisible: _fnColumnIndexToVisible,\r\n        _fnVisbleColumns: _fnVisbleColumns,\r\n        _fnGetColumns: _fnGetColumns,\r\n        _fnColumnTypes: _fnColumnTypes,\r\n        _fnApplyColumnDefs: _fnApplyColumnDefs,\r\n        _fnHungarianMap: _fnHungarianMap,\r\n        _fnCamelToHungarian: _fnCamelToHungarian,\r\n        _fnLanguageCompat: _fnLanguageCompat,\r\n        _fnBrowserDetect: _fnBrowserDetect,\r\n        _fnAddData: _fnAddData,\r\n        _fnAddTr: _fnAddTr,\r\n        _fnNodeToDataIndex: _fnNodeToDataIndex,\r\n        _fnNodeToColumnIndex: _fnNodeToColumnIndex,\r\n        _fnGetCellData: _fnGetCellData,\r\n        _fnSetCellData: _fnSetCellData,\r\n        _fnSplitObjNotation: _fnSplitObjNotation,\r\n        _fnGetObjectDataFn: _fnGetObjectDataFn,\r\n        _fnSetObjectDataFn: _fnSetObjectDataFn,\r\n        _fnGetDataMaster: _fnGetDataMaster,\r\n        _fnClearTable: _fnClearTable,\r\n        _fnDeleteIndex: _fnDeleteIndex,\r\n        _fnInvalidateRow: _fnInvalidateRow,\r\n        _fnGetRowElements: _fnGetRowElements,\r\n        _fnCreateTr: _fnCreateTr,\r\n        _fnBuildHead: _fnBuildHead,\r\n        _fnDrawHead: _fnDrawHead,\r\n        _fnDraw: _fnDraw,\r\n        _fnReDraw: _fnReDraw,\r\n        _fnAddOptionsHtml: _fnAddOptionsHtml,\r\n        _fnDetectHeader: _fnDetectHeader,\r\n        _fnGetUniqueThs: _fnGetUniqueThs,\r\n        _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\r\n        _fnFilterComplete: _fnFilterComplete,\r\n        _fnFilterCustom: _fnFilterCustom,\r\n        _fnFilterColumn: _fnFilterColumn,\r\n        _fnFilter: _fnFilter,\r\n        _fnFilterCreateSearch: _fnFilterCreateSearch,\r\n        _fnEscapeRegex: _fnEscapeRegex,\r\n        _fnFilterData: _fnFilterData,\r\n        _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\r\n        _fnUpdateInfo: _fnUpdateInfo,\r\n        _fnInfoMacros: _fnInfoMacros,\r\n        _fnInitialise: _fnInitialise,\r\n        _fnInitComplete: _fnInitComplete,\r\n        _fnLengthChange: _fnLengthChange,\r\n        _fnFeatureHtmlLength: _fnFeatureHtmlLength,\r\n        _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\r\n        _fnPageChange: _fnPageChange,\r\n        _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\r\n        _fnProcessingDisplay: _fnProcessingDisplay,\r\n        _fnFeatureHtmlTable: _fnFeatureHtmlTable,\r\n        _fnScrollDraw: _fnScrollDraw,\r\n        _fnApplyToChildren: _fnApplyToChildren,\r\n        _fnCalculateColumnWidths: _fnCalculateColumnWidths,\r\n        _fnThrottle: _fnThrottle,\r\n        _fnConvertToWidth: _fnConvertToWidth,\r\n        _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,\r\n        _fnGetWidestNode: _fnGetWidestNode,\r\n        _fnGetMaxLenString: _fnGetMaxLenString,\r\n        _fnStringToCss: _fnStringToCss,\r\n        _fnScrollBarWidth: _fnScrollBarWidth,\r\n        _fnSortFlatten: _fnSortFlatten,\r\n        _fnSort: _fnSort,\r\n        _fnSortAria: _fnSortAria,\r\n        _fnSortListener: _fnSortListener,\r\n        _fnSortAttachListener: _fnSortAttachListener,\r\n        _fnSortingClasses: _fnSortingClasses,\r\n        _fnSortData: _fnSortData,\r\n        _fnSaveState: _fnSaveState,\r\n        _fnLoadState: _fnLoadState,\r\n        _fnSettingsFromNode: _fnSettingsFromNode,\r\n        _fnLog: _fnLog,\r\n        _fnMap: _fnMap,\r\n        _fnBindAction: _fnBindAction,\r\n        _fnCallbackReg: _fnCallbackReg,\r\n        _fnCallbackFire: _fnCallbackFire,\r\n        _fnLengthOverflow: _fnLengthOverflow,\r\n        _fnRenderer: _fnRenderer,\r\n        _fnDataSource: _fnDataSource,\r\n        _fnRowAttributes: _fnRowAttributes,\r\n        _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant\r\n        // in 1.10, so this dead-end function is\r\n        // added to prevent errors\r\n      })\r\n\r\n      // jQuery access\r\n      $.fn.dataTable = DataTable\r\n\r\n      // Legacy aliases\r\n      $.fn.dataTableSettings = DataTable.settings\r\n      $.fn.dataTableExt = DataTable.ext\r\n\r\n      // With a capital `D` we return a DataTables API instance rather than a\r\n      // jQuery object\r\n      $.fn.DataTable = function (opts) {\r\n        return $(this)\r\n          .dataTable(opts)\r\n          .api()\r\n      }\r\n\r\n      // All properties that are available to $.fn.dataTable should also be\r\n      // available on $.fn.DataTable\r\n      $.each(DataTable, function (prop, val) {\r\n        $.fn.DataTable[prop] = val\r\n      })\r\n\r\n      // Information about events fired by DataTables - for documentation.\r\n      /**\r\n       * Draw event, fired whenever the table is redrawn on the page, at the same\r\n       * point as fnDrawCallback. This may be useful for binding events or\r\n       * performing calculations when the table is altered at all.\r\n       *  @name DataTable#draw.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Search event, fired when the searching applied to the table (using the\r\n       * built-in global search, or column filters) is altered.\r\n       *  @name DataTable#search.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Page change event, fired when the paging of the table is altered.\r\n       *  @name DataTable#page.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Order event, fired when the ordering applied to the table is altered.\r\n       *  @name DataTable#order.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * DataTables initialisation complete event, fired when the table is fully\r\n       * drawn, including Ajax data loaded, if Ajax data is required.\r\n       *  @name DataTable#init.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The JSON object request from the server - only\r\n       *    present if client-side Ajax sourced data is used</li></ol>\r\n       */\r\n\r\n      /**\r\n       * State save event, fired when the table has changed state a new state save\r\n       * is required. This event allows modification of the state saving object\r\n       * prior to actually doing the save, including addition or other state\r\n       * properties (for plug-ins) or modification of a DataTables core property.\r\n       *  @name DataTable#stateSaveParams.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The state information to be saved\r\n       */\r\n\r\n      /**\r\n       * State load event, fired when the table is loading state from the stored\r\n       * data, but prior to the settings object being modified by the saved state\r\n       * - allowing modification of the saved state is required or loading of\r\n       * state for a plug-in.\r\n       *  @name DataTable#stateLoadParams.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The saved state information\r\n       */\r\n\r\n      /**\r\n       * State loaded event, fired when state has been loaded from stored data and\r\n       * the settings object has been modified by the loaded data.\r\n       *  @name DataTable#stateLoaded.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {object} json The saved state information\r\n       */\r\n\r\n      /**\r\n       * Processing event, fired when DataTables is doing some kind of processing\r\n       * (be it, order, searcg or anything else). It can be used to indicate to\r\n       * the end user that there is something happening, or that something has\r\n       * finished.\r\n       *  @name DataTable#processing.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} oSettings DataTables settings object\r\n       *  @param {boolean} bShow Flag for if DataTables is doing processing or not\r\n       */\r\n\r\n      /**\r\n       * Ajax (XHR) event, fired whenever an Ajax request is completed from a\r\n       * request to made to the server for new data. This event is called before\r\n       * DataTables processed the returned data, so it can also be used to pre-\r\n       * process the data returned from the server, if needed.\r\n       *\r\n       * Note that this trigger is called in `fnServerData`, if you override\r\n       * `fnServerData` and which to use this event, you need to trigger it in you\r\n       * success function.\r\n       *  @name DataTable#xhr.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       *  @param {object} json JSON returned from the server\r\n       *\r\n       *  @example\r\n       *     // Use a custom property returned from the server in another DOM element\r\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\r\n       *       $('#status').html( json.status );\r\n       *     } );\r\n       *\r\n       *  @example\r\n       *     // Pre-process the data returned from the server\r\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\r\n       *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {\r\n       *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;\r\n       *       }\r\n       *       // Note no return - manipulate the data directly in the JSON object.\r\n       *     } );\r\n       */\r\n\r\n      /**\r\n       * Destroy event, fired when the DataTable is destroyed by calling fnDestroy\r\n       * or passing the bDestroy:true parameter in the initialisation object. This\r\n       * can be used to remove bound events, added DOM nodes, etc.\r\n       *  @name DataTable#destroy.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Page length change event, fired when number of records to show on each\r\n       * page (the length) is changed.\r\n       *  @name DataTable#length.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       *  @param {integer} len New length\r\n       */\r\n\r\n      /**\r\n       * Column sizing has changed.\r\n       *  @name DataTable#column-sizing.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       */\r\n\r\n      /**\r\n       * Column visibility has changed.\r\n       *  @name DataTable#column-visibility.dt\r\n       *  @event\r\n       *  @param {event} e jQuery event object\r\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\r\n       *  @param {int} column Column index\r\n       *  @param {bool} vis `false` if column now hidden, or `true` if visible\r\n       */\r\n\r\n      return $.fn.dataTable\r\n    }\r\n  )\r\n})(window, document)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/datatables/jquery.dataTables.js?");

/***/ }),

/***/ 0:
/*!***********************************************!*\
  !*** ./src/public/js/vendor/jquery/jquery.js ***!
  \***********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * jQuery JavaScript Library v2.2.4\r\n * http://jquery.com/\r\n *\r\n * Includes Sizzle.js\r\n * http://sizzlejs.com/\r\n *\r\n * Copyright jQuery Foundation and other contributors\r\n * Released under the MIT license\r\n * http://jquery.org/license\r\n *\r\n * Date: 2016-05-20T17:23Z\r\n */\r\n\r\n;(function (global, factory) {\r\n  if ( true && typeof module.exports === 'object') {\r\n    // For CommonJS and CommonJS-like environments where a proper `window`\r\n    // is present, execute the factory and get jQuery.\r\n    // For environments that do not have a `window` with a `document`\r\n    // (such as Node.js), expose a factory as module.exports.\r\n    // This accentuates the need for the creation of a real `window`.\r\n    // e.g. var jQuery = require(\"jquery\")(window);\r\n    // See ticket #14549 for more info.\r\n    module.exports = global.document\r\n      ? factory(global, true)\r\n      : function (w) {\r\n          if (!w.document) {\r\n            throw new Error('jQuery requires a window with a document')\r\n          }\r\n          return factory(w)\r\n        }\r\n  } else {\r\n    factory(global)\r\n  }\r\n\r\n  // Pass this if window is not defined yet\r\n})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {\r\n  // Support: Firefox 18+\r\n  // Can't be in strict mode, several libs including ASP.NET trace\r\n  // the stack via arguments.caller.callee and Firefox dies if\r\n  // you try to trace through \"use strict\" call chains. (#13335)\r\n  //\"use strict\";\r\n  var arr = []\r\n\r\n  var document = window.document\r\n\r\n  var slice = arr.slice\r\n\r\n  var concat = arr.concat\r\n\r\n  var push = arr.push\r\n\r\n  var indexOf = arr.indexOf\r\n\r\n  var class2type = {}\r\n\r\n  var toString = class2type.toString\r\n\r\n  var hasOwn = class2type.hasOwnProperty\r\n\r\n  var support = {}\r\n\r\n  var version = '2.2.4',\r\n    // Define a local copy of jQuery\r\n    jQuery = function (selector, context) {\r\n      // The jQuery object is actually just the init constructor 'enhanced'\r\n      // Need init if jQuery is called (just allow error to be thrown if not included)\r\n      return new jQuery.fn.init(selector, context)\r\n    },\r\n    // Support: Android<4.1\r\n    // Make sure we trim BOM and NBSP\r\n    rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\r\n    // Matches dashed string for camelizing\r\n    rmsPrefix = /^-ms-/,\r\n    rdashAlpha = /-([\\da-z])/gi,\r\n    // Used by jQuery.camelCase as callback to replace()\r\n    fcamelCase = function (all, letter) {\r\n      return letter.toUpperCase()\r\n    }\r\n\r\n  jQuery.fn = jQuery.prototype = {\r\n    // The current version of jQuery being used\r\n    jquery: version,\r\n\r\n    constructor: jQuery,\r\n\r\n    // Start with an empty selector\r\n    selector: '',\r\n\r\n    // The default length of a jQuery object is 0\r\n    length: 0,\r\n\r\n    toArray: function () {\r\n      return slice.call(this)\r\n    },\r\n\r\n    // Get the Nth element in the matched element set OR\r\n    // Get the whole matched element set as a clean array\r\n    get: function (num) {\r\n      return num != null\r\n        ? // Return just the one element from the set\r\n          num < 0\r\n          ? this[num + this.length]\r\n          : this[num]\r\n        : // Return all the elements in a clean array\r\n          slice.call(this)\r\n    },\r\n\r\n    // Take an array of elements and push it onto the stack\r\n    // (returning the new matched element set)\r\n    pushStack: function (elems) {\r\n      // Build a new jQuery matched element set\r\n      var ret = jQuery.merge(this.constructor(), elems)\r\n\r\n      // Add the old object onto the stack (as a reference)\r\n      ret.prevObject = this\r\n      ret.context = this.context\r\n\r\n      // Return the newly-formed element set\r\n      return ret\r\n    },\r\n\r\n    // Execute a callback for every element in the matched set.\r\n    each: function (callback) {\r\n      return jQuery.each(this, callback)\r\n    },\r\n\r\n    map: function (callback) {\r\n      return this.pushStack(\r\n        jQuery.map(this, function (elem, i) {\r\n          return callback.call(elem, i, elem)\r\n        })\r\n      )\r\n    },\r\n\r\n    slice: function () {\r\n      return this.pushStack(slice.apply(this, arguments))\r\n    },\r\n\r\n    first: function () {\r\n      return this.eq(0)\r\n    },\r\n\r\n    last: function () {\r\n      return this.eq(-1)\r\n    },\r\n\r\n    eq: function (i) {\r\n      var len = this.length,\r\n        j = +i + (i < 0 ? len : 0)\r\n      return this.pushStack(j >= 0 && j < len ? [this[j]] : [])\r\n    },\r\n\r\n    end: function () {\r\n      return this.prevObject || this.constructor()\r\n    },\r\n\r\n    // For internal use only.\r\n    // Behaves like an Array's method, not like a jQuery method.\r\n    push: push,\r\n    sort: arr.sort,\r\n    splice: arr.splice\r\n  }\r\n\r\n  jQuery.extend = jQuery.fn.extend = function () {\r\n    var options,\r\n      name,\r\n      src,\r\n      copy,\r\n      copyIsArray,\r\n      clone,\r\n      target = arguments[0] || {},\r\n      i = 1,\r\n      length = arguments.length,\r\n      deep = false\r\n\r\n    // Handle a deep copy situation\r\n    if (typeof target === 'boolean') {\r\n      deep = target\r\n\r\n      // Skip the boolean and the target\r\n      target = arguments[i] || {}\r\n      i++\r\n    }\r\n\r\n    // Handle case when target is a string or something (possible in deep copy)\r\n    if (typeof target !== 'object' && !jQuery.isFunction(target)) {\r\n      target = {}\r\n    }\r\n\r\n    // Extend jQuery itself if only one argument is passed\r\n    if (i === length) {\r\n      target = this\r\n      i--\r\n    }\r\n\r\n    for (; i < length; i++) {\r\n      // Only deal with non-null/undefined values\r\n      if ((options = arguments[i]) != null) {\r\n        // Extend the base object\r\n        for (name in options) {\r\n          src = target[name]\r\n          copy = options[name]\r\n\r\n          // Prevent never-ending loop\r\n          if (target === copy) {\r\n            continue\r\n          }\r\n\r\n          // Recurse if we're merging plain objects or arrays\r\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\r\n            if (copyIsArray) {\r\n              copyIsArray = false\r\n              clone = src && jQuery.isArray(src) ? src : []\r\n            } else {\r\n              clone = src && jQuery.isPlainObject(src) ? src : {}\r\n            }\r\n\r\n            // Never move original objects, clone them\r\n            target[name] = jQuery.extend(deep, clone, copy)\r\n\r\n            // Don't bring in undefined values\r\n          } else if (copy !== undefined) {\r\n            target[name] = copy\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Return the modified object\r\n    return target\r\n  }\r\n\r\n  jQuery.extend({\r\n    // Unique for each copy of jQuery on the page\r\n    expando: 'jQuery' + (version + Math.random()).replace(/\\D/g, ''),\r\n\r\n    // Assume jQuery is ready without the ready module\r\n    isReady: true,\r\n\r\n    error: function (msg) {\r\n      throw new Error(msg)\r\n    },\r\n\r\n    noop: function () {},\r\n\r\n    isFunction: function (obj) {\r\n      return jQuery.type(obj) === 'function'\r\n    },\r\n\r\n    isArray: Array.isArray,\r\n\r\n    isWindow: function (obj) {\r\n      return obj != null && obj === obj.window\r\n    },\r\n\r\n    isNumeric: function (obj) {\r\n      // parseFloat NaNs numeric-cast false positives (null|true|false|\"\")\r\n      // ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\r\n      // subtraction forces infinities to NaN\r\n      // adding 1 corrects loss of precision from parseFloat (#15100)\r\n      var realStringObj = obj && obj.toString()\r\n      return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0\r\n    },\r\n\r\n    isPlainObject: function (obj) {\r\n      var key\r\n\r\n      // Not plain objects:\r\n      // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\r\n      // - DOM nodes\r\n      // - window\r\n      if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {\r\n        return false\r\n      }\r\n\r\n      // Not own constructor property must be Object\r\n      if (\r\n        obj.constructor &&\r\n        !hasOwn.call(obj, 'constructor') &&\r\n        !hasOwn.call(obj.constructor.prototype || {}, 'isPrototypeOf')\r\n      ) {\r\n        return false\r\n      }\r\n\r\n      // Own properties are enumerated firstly, so to speed up,\r\n      // if last one is own, then all properties are own\r\n      for (key in obj) {\r\n      }\r\n\r\n      return key === undefined || hasOwn.call(obj, key)\r\n    },\r\n\r\n    isEmptyObject: function (obj) {\r\n      var name\r\n      for (name in obj) {\r\n        return false\r\n      }\r\n      return true\r\n    },\r\n\r\n    type: function (obj) {\r\n      if (obj == null) {\r\n        return obj + ''\r\n      }\r\n\r\n      // Support: Android<4.0, iOS<6 (functionish RegExp)\r\n      return typeof obj === 'object' || typeof obj === 'function'\r\n        ? class2type[toString.call(obj)] || 'object'\r\n        : typeof obj\r\n    },\r\n\r\n    // Evaluates a script in a global context\r\n    globalEval: function (code) {\r\n      var script,\r\n        indirect = eval\r\n\r\n      code = jQuery.trim(code)\r\n\r\n      if (code) {\r\n        // If the code includes a valid, prologue position\r\n        // strict mode pragma, execute code by injecting a\r\n        // script tag into the document.\r\n        if (code.indexOf('use strict') === 1) {\r\n          script = document.createElement('script')\r\n          script.text = code\r\n          document.head.appendChild(script).parentNode.removeChild(script)\r\n        } else {\r\n          // Otherwise, avoid the DOM node creation, insertion\r\n          // and removal by using an indirect global eval\r\n\r\n          indirect(code)\r\n        }\r\n      }\r\n    },\r\n\r\n    // Convert dashed to camelCase; used by the css and data modules\r\n    // Support: IE9-11+\r\n    // Microsoft forgot to hump their vendor prefix (#9572)\r\n    camelCase: function (string) {\r\n      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase)\r\n    },\r\n\r\n    nodeName: function (elem, name) {\r\n      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()\r\n    },\r\n\r\n    each: function (obj, callback) {\r\n      var length,\r\n        i = 0\r\n\r\n      if (isArrayLike(obj)) {\r\n        length = obj.length\r\n        for (; i < length; i++) {\r\n          if (callback.call(obj[i], i, obj[i]) === false) {\r\n            break\r\n          }\r\n        }\r\n      } else {\r\n        for (i in obj) {\r\n          if (callback.call(obj[i], i, obj[i]) === false) {\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      return obj\r\n    },\r\n\r\n    // Support: Android<4.1\r\n    trim: function (text) {\r\n      return text == null ? '' : (text + '').replace(rtrim, '')\r\n    },\r\n\r\n    // results is for internal usage only\r\n    makeArray: function (arr, results) {\r\n      var ret = results || []\r\n\r\n      if (arr != null) {\r\n        if (isArrayLike(Object(arr))) {\r\n          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr)\r\n        } else {\r\n          push.call(ret, arr)\r\n        }\r\n      }\r\n\r\n      return ret\r\n    },\r\n\r\n    inArray: function (elem, arr, i) {\r\n      return arr == null ? -1 : indexOf.call(arr, elem, i)\r\n    },\r\n\r\n    merge: function (first, second) {\r\n      var len = +second.length,\r\n        j = 0,\r\n        i = first.length\r\n\r\n      for (; j < len; j++) {\r\n        first[i++] = second[j]\r\n      }\r\n\r\n      first.length = i\r\n\r\n      return first\r\n    },\r\n\r\n    grep: function (elems, callback, invert) {\r\n      var callbackInverse,\r\n        matches = [],\r\n        i = 0,\r\n        length = elems.length,\r\n        callbackExpect = !invert\r\n\r\n      // Go through the array, only saving the items\r\n      // that pass the validator function\r\n      for (; i < length; i++) {\r\n        callbackInverse = !callback(elems[i], i)\r\n        if (callbackInverse !== callbackExpect) {\r\n          matches.push(elems[i])\r\n        }\r\n      }\r\n\r\n      return matches\r\n    },\r\n\r\n    // arg is for internal usage only\r\n    map: function (elems, callback, arg) {\r\n      var length,\r\n        value,\r\n        i = 0,\r\n        ret = []\r\n\r\n      // Go through the array, translating each of the items to their new values\r\n      if (isArrayLike(elems)) {\r\n        length = elems.length\r\n        for (; i < length; i++) {\r\n          value = callback(elems[i], i, arg)\r\n\r\n          if (value != null) {\r\n            ret.push(value)\r\n          }\r\n        }\r\n\r\n        // Go through every key on the object,\r\n      } else {\r\n        for (i in elems) {\r\n          value = callback(elems[i], i, arg)\r\n\r\n          if (value != null) {\r\n            ret.push(value)\r\n          }\r\n        }\r\n      }\r\n\r\n      // Flatten any nested arrays\r\n      return concat.apply([], ret)\r\n    },\r\n\r\n    // A global GUID counter for objects\r\n    guid: 1,\r\n\r\n    // Bind a function to a context, optionally partially applying any\r\n    // arguments.\r\n    proxy: function (fn, context) {\r\n      var tmp, args, proxy\r\n\r\n      if (typeof context === 'string') {\r\n        tmp = fn[context]\r\n        context = fn\r\n        fn = tmp\r\n      }\r\n\r\n      // Quick check to determine if target is callable, in the spec\r\n      // this throws a TypeError, but we will just return undefined.\r\n      if (!jQuery.isFunction(fn)) {\r\n        return undefined\r\n      }\r\n\r\n      // Simulated bind\r\n      args = slice.call(arguments, 2)\r\n      proxy = function () {\r\n        return fn.apply(context || this, args.concat(slice.call(arguments)))\r\n      }\r\n\r\n      // Set the guid of unique handler to the same of original handler, so it can be removed\r\n      proxy.guid = fn.guid = fn.guid || jQuery.guid++\r\n\r\n      return proxy\r\n    },\r\n\r\n    now: Date.now,\r\n\r\n    // jQuery.support is not used in Core but other projects attach their\r\n    // properties to it so it needs to exist.\r\n    support: support\r\n  })\r\n\r\n  // JSHint would error on this code due to the Symbol not being defined in ES5.\r\n  // Defining this global in .jshintrc would create a danger of using the global\r\n  // unguarded in another place, it seems safer to just disable JSHint for these\r\n  // three lines.\r\n  /* jshint ignore: start */\r\n  if (typeof Symbol === 'function') {\r\n    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]\r\n  }\r\n  /* jshint ignore: end */\r\n\r\n  // Populate the class2type map\r\n  jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {\r\n    class2type['[object ' + name + ']'] = name.toLowerCase()\r\n  })\r\n\r\n  function isArrayLike (obj) {\r\n    // Support: iOS 8.2 (not reproducible in simulator)\r\n    // `in` check used to prevent JIT error (gh-2145)\r\n    // hasOwn isn't used here due to false negatives\r\n    // regarding Nodelist length in IE\r\n    var length = !!obj && 'length' in obj && obj.length,\r\n      type = jQuery.type(obj)\r\n\r\n    if (type === 'function' || jQuery.isWindow(obj)) {\r\n      return false\r\n    }\r\n\r\n    return type === 'array' || length === 0 || (typeof length === 'number' && length > 0 && length - 1 in obj)\r\n  }\r\n  var Sizzle =\r\n    /*!\r\n     * Sizzle CSS Selector Engine v2.2.1\r\n     * http://sizzlejs.com/\r\n     *\r\n     * Copyright jQuery Foundation and other contributors\r\n     * Released under the MIT license\r\n     * http://jquery.org/license\r\n     *\r\n     * Date: 2015-10-17\r\n     */\r\n    (function (window) {\r\n      var i,\r\n        support,\r\n        Expr,\r\n        getText,\r\n        isXML,\r\n        tokenize,\r\n        compile,\r\n        select,\r\n        outermostContext,\r\n        sortInput,\r\n        hasDuplicate,\r\n        // Local document vars\r\n        setDocument,\r\n        document,\r\n        docElem,\r\n        documentIsHTML,\r\n        rbuggyQSA,\r\n        rbuggyMatches,\r\n        matches,\r\n        contains,\r\n        // Instance-specific data\r\n        expando = 'sizzle' + 1 * new Date(),\r\n        preferredDoc = window.document,\r\n        dirruns = 0,\r\n        done = 0,\r\n        classCache = createCache(),\r\n        tokenCache = createCache(),\r\n        compilerCache = createCache(),\r\n        sortOrder = function (a, b) {\r\n          if (a === b) {\r\n            hasDuplicate = true\r\n          }\r\n          return 0\r\n        },\r\n        // General-purpose constants\r\n        MAX_NEGATIVE = 1 << 31,\r\n        // Instance methods\r\n        hasOwn = {}.hasOwnProperty,\r\n        arr = [],\r\n        pop = arr.pop,\r\n        push_native = arr.push,\r\n        push = arr.push,\r\n        slice = arr.slice,\r\n        // Use a stripped-down indexOf as it's faster than native\r\n        // http://jsperf.com/thor-indexof-vs-for/5\r\n        indexOf = function (list, elem) {\r\n          var i = 0,\r\n            len = list.length\r\n          for (; i < len; i++) {\r\n            if (list[i] === elem) {\r\n              return i\r\n            }\r\n          }\r\n          return -1\r\n        },\r\n        booleans =\r\n          'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',\r\n        // Regular expressions\r\n\r\n        // http://www.w3.org/TR/css3-selectors/#whitespace\r\n        whitespace = '[\\\\x20\\\\t\\\\r\\\\n\\\\f]',\r\n        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\r\n        identifier = '(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+',\r\n        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\r\n        attributes =\r\n          '\\\\[' +\r\n          whitespace +\r\n          '*(' +\r\n          identifier +\r\n          ')(?:' +\r\n          whitespace +\r\n          // Operator (capture 2)\r\n          '*([*^$|!~]?=)' +\r\n          whitespace +\r\n          // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\r\n          '*(?:\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\"|(' +\r\n          identifier +\r\n          '))|)' +\r\n          whitespace +\r\n          '*\\\\]',\r\n        pseudos =\r\n          ':(' +\r\n          identifier +\r\n          ')(?:\\\\((' +\r\n          // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\r\n          // 1. quoted (capture 3; capture 4 or capture 5)\r\n          '(\\'((?:\\\\\\\\.|[^\\\\\\\\\\'])*)\\'|\"((?:\\\\\\\\.|[^\\\\\\\\\"])*)\")|' +\r\n          // 2. simple (capture 6)\r\n          '((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|' +\r\n          attributes +\r\n          ')*)|' +\r\n          // 3. anything else (capture 2)\r\n          '.*' +\r\n          ')\\\\)|)',\r\n        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\r\n        rwhitespace = new RegExp(whitespace + '+', 'g'),\r\n        rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)' + whitespace + '+$', 'g'),\r\n        rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'),\r\n        rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'),\r\n        rattributeQuotes = new RegExp('=' + whitespace + '*([^\\\\]\\'\"]*?)' + whitespace + '*\\\\]', 'g'),\r\n        rpseudo = new RegExp(pseudos),\r\n        ridentifier = new RegExp('^' + identifier + '$'),\r\n        matchExpr = {\r\n          ID: new RegExp('^#(' + identifier + ')'),\r\n          CLASS: new RegExp('^\\\\.(' + identifier + ')'),\r\n          TAG: new RegExp('^(' + identifier + '|[*])'),\r\n          ATTR: new RegExp('^' + attributes),\r\n          PSEUDO: new RegExp('^' + pseudos),\r\n          CHILD: new RegExp(\r\n            '^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(' +\r\n              whitespace +\r\n              '*(even|odd|(([+-]|)(\\\\d*)n|)' +\r\n              whitespace +\r\n              '*(?:([+-]|)' +\r\n              whitespace +\r\n              '*(\\\\d+)|))' +\r\n              whitespace +\r\n              '*\\\\)|)',\r\n            'i'\r\n          ),\r\n          bool: new RegExp('^(?:' + booleans + ')$', 'i'),\r\n          // For use in libraries implementing .is()\r\n          // We use this for POS matching in `select`\r\n          needsContext: new RegExp(\r\n            '^' +\r\n              whitespace +\r\n              '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(' +\r\n              whitespace +\r\n              '*((?:-\\\\d)?\\\\d*)' +\r\n              whitespace +\r\n              '*\\\\)|)(?=[^-]|$)',\r\n            'i'\r\n          )\r\n        },\r\n        rinputs = /^(?:input|select|textarea|button)$/i,\r\n        rheader = /^h\\d$/i,\r\n        rnative = /^[^{]+\\{\\s*\\[native \\w/,\r\n        // Easily-parseable/retrievable ID or TAG or CLASS selectors\r\n        rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\r\n        rsibling = /[+~]/,\r\n        rescape = /'|\\\\/g,\r\n        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\r\n        runescape = new RegExp('\\\\\\\\([\\\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'),\r\n        funescape = function (_, escaped, escapedWhitespace) {\r\n          var high = '0x' + escaped - 0x10000\r\n          // NaN means non-codepoint\r\n          // Support: Firefox<24\r\n          // Workaround erroneous numeric interpretation of +\"0x\"\r\n          return high !== high || escapedWhitespace\r\n            ? escaped\r\n            : high < 0\r\n            ? // BMP codepoint\r\n              String.fromCharCode(high + 0x10000)\r\n            : // Supplemental Plane codepoint (surrogate pair)\r\n              String.fromCharCode((high >> 10) | 0xd800, (high & 0x3ff) | 0xdc00)\r\n        },\r\n        // Used for iframes\r\n        // See setDocument()\r\n        // Removing the function wrapper causes a \"Permission Denied\"\r\n        // error in IE\r\n        unloadHandler = function () {\r\n          setDocument()\r\n        }\r\n\r\n      // Optimize for push.apply( _, NodeList )\r\n      try {\r\n        push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes)\r\n        // Support: Android<4.0\r\n        // Detect silently failing push.apply\r\n        arr[preferredDoc.childNodes.length].nodeType\r\n      } catch (e) {\r\n        push = {\r\n          apply: arr.length\r\n            ? // Leverage slice if possible\r\n              function (target, els) {\r\n                push_native.apply(target, slice.call(els))\r\n              }\r\n            : // Support: IE<9\r\n              // Otherwise append directly\r\n              function (target, els) {\r\n                var j = target.length,\r\n                  i = 0\r\n                // Can't trust NodeList.length\r\n                while ((target[j++] = els[i++])) {}\r\n                target.length = j - 1\r\n              }\r\n        }\r\n      }\r\n\r\n      function Sizzle (selector, context, results, seed) {\r\n        var m,\r\n          i,\r\n          elem,\r\n          nid,\r\n          nidselect,\r\n          match,\r\n          groups,\r\n          newSelector,\r\n          newContext = context && context.ownerDocument,\r\n          // nodeType defaults to 9, since context defaults to document\r\n          nodeType = context ? context.nodeType : 9\r\n\r\n        results = results || []\r\n\r\n        // Return early from calls with invalid selector or context\r\n        if (typeof selector !== 'string' || !selector || (nodeType !== 1 && nodeType !== 9 && nodeType !== 11)) {\r\n          return results\r\n        }\r\n\r\n        // Try to shortcut find operations (as opposed to filters) in HTML documents\r\n        if (!seed) {\r\n          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {\r\n            setDocument(context)\r\n          }\r\n          context = context || document\r\n\r\n          if (documentIsHTML) {\r\n            // If the selector is sufficiently simple, try using a \"get*By*\" DOM method\r\n            // (excepting DocumentFragment context, where the methods don't exist)\r\n            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\r\n              // ID selector\r\n              if ((m = match[1])) {\r\n                // Document context\r\n                if (nodeType === 9) {\r\n                  if ((elem = context.getElementById(m))) {\r\n                    // Support: IE, Opera, Webkit\r\n                    // TODO: identify versions\r\n                    // getElementById can match elements by name instead of ID\r\n                    if (elem.id === m) {\r\n                      results.push(elem)\r\n                      return results\r\n                    }\r\n                  } else {\r\n                    return results\r\n                  }\r\n\r\n                  // Element context\r\n                } else {\r\n                  // Support: IE, Opera, Webkit\r\n                  // TODO: identify versions\r\n                  // getElementById can match elements by name instead of ID\r\n                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\r\n                    results.push(elem)\r\n                    return results\r\n                  }\r\n                }\r\n\r\n                // Type selector\r\n              } else if (match[2]) {\r\n                push.apply(results, context.getElementsByTagName(selector))\r\n                return results\r\n\r\n                // Class selector\r\n              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\r\n                push.apply(results, context.getElementsByClassName(m))\r\n                return results\r\n              }\r\n            }\r\n\r\n            // Take advantage of querySelectorAll\r\n            if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\r\n              if (nodeType !== 1) {\r\n                newContext = context\r\n                newSelector = selector\r\n\r\n                // qSA looks outside Element context, which is not what we want\r\n                // Thanks to Andrew Dupont for this workaround technique\r\n                // Support: IE <=8\r\n                // Exclude object elements\r\n              } else if (context.nodeName.toLowerCase() !== 'object') {\r\n                // Capture the context ID, setting it first if necessary\r\n                if ((nid = context.getAttribute('id'))) {\r\n                  nid = nid.replace(rescape, '\\\\$&')\r\n                } else {\r\n                  context.setAttribute('id', (nid = expando))\r\n                }\r\n\r\n                // Prefix every selector in the list\r\n                groups = tokenize(selector)\r\n                i = groups.length\r\n                nidselect = ridentifier.test(nid) ? '#' + nid : \"[id='\" + nid + \"']\"\r\n                while (i--) {\r\n                  groups[i] = nidselect + ' ' + toSelector(groups[i])\r\n                }\r\n                newSelector = groups.join(',')\r\n\r\n                // Expand context for sibling selectors\r\n                newContext = (rsibling.test(selector) && testContext(context.parentNode)) || context\r\n              }\r\n\r\n              if (newSelector) {\r\n                try {\r\n                  push.apply(results, newContext.querySelectorAll(newSelector))\r\n                  return results\r\n                } catch (qsaError) {\r\n                } finally {\r\n                  if (nid === expando) {\r\n                    context.removeAttribute('id')\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // All others\r\n        return select(selector.replace(rtrim, '$1'), context, results, seed)\r\n      }\r\n\r\n      /**\r\n       * Create key-value caches of limited size\r\n       * @returns {function(string, object)} Returns the Object data after storing it on itself with\r\n       *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\r\n       *\tdeleting the oldest entry\r\n       */\r\n      function createCache () {\r\n        var keys = []\r\n\r\n        function cache (key, value) {\r\n          // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\r\n          if (keys.push(key + ' ') > Expr.cacheLength) {\r\n            // Only keep the most recent entries\r\n            delete cache[keys.shift()]\r\n          }\r\n          return (cache[key + ' '] = value)\r\n        }\r\n        return cache\r\n      }\r\n\r\n      /**\r\n       * Mark a function for special use by Sizzle\r\n       * @param {Function} fn The function to mark\r\n       */\r\n      function markFunction (fn) {\r\n        fn[expando] = true\r\n        return fn\r\n      }\r\n\r\n      /**\r\n       * Support testing using an element\r\n       * @param {Function} fn Passed the created div and expects a boolean result\r\n       */\r\n      function assert (fn) {\r\n        var div = document.createElement('div')\r\n\r\n        try {\r\n          return !!fn(div)\r\n        } catch (e) {\r\n          return false\r\n        } finally {\r\n          // Remove from its parent by default\r\n          if (div.parentNode) {\r\n            div.parentNode.removeChild(div)\r\n          }\r\n          // release memory in IE\r\n          div = null\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Adds the same handler for all of the specified attrs\r\n       * @param {String} attrs Pipe-separated list of attributes\r\n       * @param {Function} handler The method that will be applied\r\n       */\r\n      function addHandle (attrs, handler) {\r\n        var arr = attrs.split('|'),\r\n          i = arr.length\r\n\r\n        while (i--) {\r\n          Expr.attrHandle[arr[i]] = handler\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Checks document order of two siblings\r\n       * @param {Element} a\r\n       * @param {Element} b\r\n       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\r\n       */\r\n      function siblingCheck (a, b) {\r\n        var cur = b && a,\r\n          diff =\r\n            cur &&\r\n            a.nodeType === 1 &&\r\n            b.nodeType === 1 &&\r\n            (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE)\r\n\r\n        // Use IE sourceIndex if available on both nodes\r\n        if (diff) {\r\n          return diff\r\n        }\r\n\r\n        // Check if b follows a\r\n        if (cur) {\r\n          while ((cur = cur.nextSibling)) {\r\n            if (cur === b) {\r\n              return -1\r\n            }\r\n          }\r\n        }\r\n\r\n        return a ? 1 : -1\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for input types\r\n       * @param {String} type\r\n       */\r\n      function createInputPseudo (type) {\r\n        return function (elem) {\r\n          var name = elem.nodeName.toLowerCase()\r\n          return name === 'input' && elem.type === type\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for buttons\r\n       * @param {String} type\r\n       */\r\n      function createButtonPseudo (type) {\r\n        return function (elem) {\r\n          var name = elem.nodeName.toLowerCase()\r\n          return (name === 'input' || name === 'button') && elem.type === type\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Returns a function to use in pseudos for positionals\r\n       * @param {Function} fn\r\n       */\r\n      function createPositionalPseudo (fn) {\r\n        return markFunction(function (argument) {\r\n          argument = +argument\r\n          return markFunction(function (seed, matches) {\r\n            var j,\r\n              matchIndexes = fn([], seed.length, argument),\r\n              i = matchIndexes.length\r\n\r\n            // Match elements found at the specified indexes\r\n            while (i--) {\r\n              if (seed[(j = matchIndexes[i])]) {\r\n                seed[j] = !(matches[j] = seed[j])\r\n              }\r\n            }\r\n          })\r\n        })\r\n      }\r\n\r\n      /**\r\n       * Checks a node for validity as a Sizzle context\r\n       * @param {Element|Object=} context\r\n       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\r\n       */\r\n      function testContext (context) {\r\n        return context && typeof context.getElementsByTagName !== 'undefined' && context\r\n      }\r\n\r\n      // Expose support vars for convenience\r\n      support = Sizzle.support = {}\r\n\r\n      /**\r\n       * Detects XML nodes\r\n       * @param {Element|Object} elem An element or a document\r\n       * @returns {Boolean} True iff elem is a non-HTML XML node\r\n       */\r\n      isXML = Sizzle.isXML = function (elem) {\r\n        // documentElement is verified for cases where it doesn't yet exist\r\n        // (such as loading iframes in IE - #4833)\r\n        var documentElement = elem && (elem.ownerDocument || elem).documentElement\r\n        return documentElement ? documentElement.nodeName !== 'HTML' : false\r\n      }\r\n\r\n      /**\r\n       * Sets document-related variables once based on the current document\r\n       * @param {Element|Object} [doc] An element or document object to use to set the document\r\n       * @returns {Object} Returns the current document\r\n       */\r\n      setDocument = Sizzle.setDocument = function (node) {\r\n        var hasCompare,\r\n          parent,\r\n          doc = node ? node.ownerDocument || node : preferredDoc\r\n\r\n        // Return early if doc is invalid or already selected\r\n        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\r\n          return document\r\n        }\r\n\r\n        // Update global variables\r\n        document = doc\r\n        docElem = document.documentElement\r\n        documentIsHTML = !isXML(document)\r\n\r\n        // Support: IE 9-11, Edge\r\n        // Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\r\n        if ((parent = document.defaultView) && parent.top !== parent) {\r\n          // Support: IE 11\r\n          if (parent.addEventListener) {\r\n            parent.addEventListener('unload', unloadHandler, false)\r\n\r\n            // Support: IE 9 - 10 only\r\n          } else if (parent.attachEvent) {\r\n            parent.attachEvent('onunload', unloadHandler)\r\n          }\r\n        }\r\n\r\n        /* Attributes\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // Support: IE<8\r\n        // Verify that getAttribute really returns attributes and not properties\r\n        // (excepting IE8 booleans)\r\n        support.attributes = assert(function (div) {\r\n          div.className = 'i'\r\n          return !div.getAttribute('className')\r\n        })\r\n\r\n        /* getElement(s)By*\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // Check if getElementsByTagName(\"*\") returns only elements\r\n        support.getElementsByTagName = assert(function (div) {\r\n          div.appendChild(document.createComment(''))\r\n          return !div.getElementsByTagName('*').length\r\n        })\r\n\r\n        // Support: IE<9\r\n        support.getElementsByClassName = rnative.test(document.getElementsByClassName)\r\n\r\n        // Support: IE<10\r\n        // Check if getElementById returns elements by name\r\n        // The broken getElementById methods don't pick up programatically-set names,\r\n        // so use a roundabout getElementsByName test\r\n        support.getById = assert(function (div) {\r\n          docElem.appendChild(div).id = expando\r\n          return !document.getElementsByName || !document.getElementsByName(expando).length\r\n        })\r\n\r\n        // ID find and filter\r\n        if (support.getById) {\r\n          Expr.find['ID'] = function (id, context) {\r\n            if (typeof context.getElementById !== 'undefined' && documentIsHTML) {\r\n              var m = context.getElementById(id)\r\n              return m ? [m] : []\r\n            }\r\n          }\r\n          Expr.filter['ID'] = function (id) {\r\n            var attrId = id.replace(runescape, funescape)\r\n            return function (elem) {\r\n              return elem.getAttribute('id') === attrId\r\n            }\r\n          }\r\n        } else {\r\n          // Support: IE6/7\r\n          // getElementById is not reliable as a find shortcut\r\n          delete Expr.find['ID']\r\n\r\n          Expr.filter['ID'] = function (id) {\r\n            var attrId = id.replace(runescape, funescape)\r\n            return function (elem) {\r\n              var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id')\r\n              return node && node.value === attrId\r\n            }\r\n          }\r\n        }\r\n\r\n        // Tag\r\n        Expr.find['TAG'] = support.getElementsByTagName\r\n          ? function (tag, context) {\r\n              if (typeof context.getElementsByTagName !== 'undefined') {\r\n                return context.getElementsByTagName(tag)\r\n\r\n                // DocumentFragment nodes don't have gEBTN\r\n              } else if (support.qsa) {\r\n                return context.querySelectorAll(tag)\r\n              }\r\n            }\r\n          : function (tag, context) {\r\n              var elem,\r\n                tmp = [],\r\n                i = 0,\r\n                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\r\n                results = context.getElementsByTagName(tag)\r\n\r\n              // Filter out possible comments\r\n              if (tag === '*') {\r\n                while ((elem = results[i++])) {\r\n                  if (elem.nodeType === 1) {\r\n                    tmp.push(elem)\r\n                  }\r\n                }\r\n\r\n                return tmp\r\n              }\r\n              return results\r\n            }\r\n\r\n        // Class\r\n        Expr.find['CLASS'] =\r\n          support.getElementsByClassName &&\r\n          function (className, context) {\r\n            if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {\r\n              return context.getElementsByClassName(className)\r\n            }\r\n          }\r\n\r\n        /* QSA/matchesSelector\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // QSA and matchesSelector support\r\n\r\n        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\r\n        rbuggyMatches = []\r\n\r\n        // qSa(:focus) reports false when true (Chrome 21)\r\n        // We allow this because of a bug in IE8/9 that throws an error\r\n        // whenever `document.activeElement` is accessed on an iframe\r\n        // So, we allow :focus to pass through QSA all the time to avoid the IE error\r\n        // See http://bugs.jquery.com/ticket/13378\r\n        rbuggyQSA = []\r\n\r\n        if ((support.qsa = rnative.test(document.querySelectorAll))) {\r\n          // Build QSA regex\r\n          // Regex strategy adopted from Diego Perini\r\n          assert(function (div) {\r\n            // Select is set to empty string on purpose\r\n            // This is to test IE's treatment of not explicitly\r\n            // setting a boolean content attribute,\r\n            // since its presence should be enough\r\n            // http://bugs.jquery.com/ticket/12359\r\n            docElem.appendChild(div).innerHTML =\r\n              \"<a id='\" +\r\n              expando +\r\n              \"'></a>\" +\r\n              \"<select id='\" +\r\n              expando +\r\n              \"-\\r\\\\' msallowcapture=''>\" +\r\n              \"<option selected=''></option></select>\"\r\n\r\n            // Support: IE8, Opera 11-12.16\r\n            // Nothing should be selected when empty strings follow ^= or $= or *=\r\n            // The test attribute must be unknown in Opera but \"safe\" for WinRT\r\n            // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\r\n            if (div.querySelectorAll(\"[msallowcapture^='']\").length) {\r\n              rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\\'\\'|\"\")')\r\n            }\r\n\r\n            // Support: IE8\r\n            // Boolean attributes and \"value\" are not treated correctly\r\n            if (!div.querySelectorAll('[selected]').length) {\r\n              rbuggyQSA.push('\\\\[' + whitespace + '*(?:value|' + booleans + ')')\r\n            }\r\n\r\n            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\r\n            if (!div.querySelectorAll('[id~=' + expando + '-]').length) {\r\n              rbuggyQSA.push('~=')\r\n            }\r\n\r\n            // Webkit/Opera - :checked should return selected option elements\r\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n            // IE8 throws error here and will not see later tests\r\n            if (!div.querySelectorAll(':checked').length) {\r\n              rbuggyQSA.push(':checked')\r\n            }\r\n\r\n            // Support: Safari 8+, iOS 8+\r\n            // https://bugs.webkit.org/show_bug.cgi?id=136851\r\n            // In-page `selector#id sibing-combinator selector` fails\r\n            if (!div.querySelectorAll('a#' + expando + '+*').length) {\r\n              rbuggyQSA.push('.#.+[+~]')\r\n            }\r\n          })\r\n\r\n          assert(function (div) {\r\n            // Support: Windows 8 Native Apps\r\n            // The type and name attributes are restricted during .innerHTML assignment\r\n            var input = document.createElement('input')\r\n            input.setAttribute('type', 'hidden')\r\n            div.appendChild(input).setAttribute('name', 'D')\r\n\r\n            // Support: IE8\r\n            // Enforce case-sensitivity of name attribute\r\n            if (div.querySelectorAll('[name=d]').length) {\r\n              rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=')\r\n            }\r\n\r\n            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\r\n            // IE8 throws error here and will not see later tests\r\n            if (!div.querySelectorAll(':enabled').length) {\r\n              rbuggyQSA.push(':enabled', ':disabled')\r\n            }\r\n\r\n            // Opera 10-11 does not throw on post-comma invalid pseudos\r\n            div.querySelectorAll('*,:x')\r\n            rbuggyQSA.push(',.*:')\r\n          })\r\n        }\r\n\r\n        if (\r\n          (support.matchesSelector = rnative.test(\r\n            (matches =\r\n              docElem.matches ||\r\n              docElem.webkitMatchesSelector ||\r\n              docElem.mozMatchesSelector ||\r\n              docElem.oMatchesSelector ||\r\n              docElem.msMatchesSelector)\r\n          ))\r\n        ) {\r\n          assert(function (div) {\r\n            // Check to see if it's possible to do matchesSelector\r\n            // on a disconnected node (IE 9)\r\n            support.disconnectedMatch = matches.call(div, 'div')\r\n\r\n            // This should fail with an exception\r\n            // Gecko does not error, returns false instead\r\n            matches.call(div, \"[s!='']:x\")\r\n            rbuggyMatches.push('!=', pseudos)\r\n          })\r\n        }\r\n\r\n        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'))\r\n        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'))\r\n\r\n        /* Contains\r\n\t---------------------------------------------------------------------- */\r\n        hasCompare = rnative.test(docElem.compareDocumentPosition)\r\n\r\n        // Element contains another\r\n        // Purposefully self-exclusive\r\n        // As in, an element does not contain itself\r\n        contains =\r\n          hasCompare || rnative.test(docElem.contains)\r\n            ? function (a, b) {\r\n                var adown = a.nodeType === 9 ? a.documentElement : a,\r\n                  bup = b && b.parentNode\r\n                return (\r\n                  a === bup ||\r\n                  !!(\r\n                    bup &&\r\n                    bup.nodeType === 1 &&\r\n                    (adown.contains\r\n                      ? adown.contains(bup)\r\n                      : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16)\r\n                  )\r\n                )\r\n              }\r\n            : function (a, b) {\r\n                if (b) {\r\n                  while ((b = b.parentNode)) {\r\n                    if (b === a) {\r\n                      return true\r\n                    }\r\n                  }\r\n                }\r\n                return false\r\n              }\r\n\r\n        /* Sorting\r\n\t---------------------------------------------------------------------- */\r\n\r\n        // Document order sorting\r\n        sortOrder = hasCompare\r\n          ? function (a, b) {\r\n              // Flag for duplicate removal\r\n              if (a === b) {\r\n                hasDuplicate = true\r\n                return 0\r\n              }\r\n\r\n              // Sort on method existence if only one input has compareDocumentPosition\r\n              var compare = !a.compareDocumentPosition - !b.compareDocumentPosition\r\n              if (compare) {\r\n                return compare\r\n              }\r\n\r\n              // Calculate position if both inputs belong to the same document\r\n              compare =\r\n                (a.ownerDocument || a) === (b.ownerDocument || b)\r\n                  ? a.compareDocumentPosition(b)\r\n                  : // Otherwise we know they are disconnected\r\n                    1\r\n\r\n              // Disconnected nodes\r\n              if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {\r\n                // Choose the first element that is related to our preferred document\r\n                if (a === document || (a.ownerDocument === preferredDoc && contains(preferredDoc, a))) {\r\n                  return -1\r\n                }\r\n                if (b === document || (b.ownerDocument === preferredDoc && contains(preferredDoc, b))) {\r\n                  return 1\r\n                }\r\n\r\n                // Maintain original order\r\n                return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0\r\n              }\r\n\r\n              return compare & 4 ? -1 : 1\r\n            }\r\n          : function (a, b) {\r\n              // Exit early if the nodes are identical\r\n              if (a === b) {\r\n                hasDuplicate = true\r\n                return 0\r\n              }\r\n\r\n              var cur,\r\n                i = 0,\r\n                aup = a.parentNode,\r\n                bup = b.parentNode,\r\n                ap = [a],\r\n                bp = [b]\r\n\r\n              // Parentless nodes are either documents or disconnected\r\n              if (!aup || !bup) {\r\n                return a === document\r\n                  ? -1\r\n                  : b === document\r\n                  ? 1\r\n                  : aup\r\n                  ? -1\r\n                  : bup\r\n                  ? 1\r\n                  : sortInput\r\n                  ? indexOf(sortInput, a) - indexOf(sortInput, b)\r\n                  : 0\r\n\r\n                // If the nodes are siblings, we can do a quick check\r\n              } else if (aup === bup) {\r\n                return siblingCheck(a, b)\r\n              }\r\n\r\n              // Otherwise we need full lists of their ancestors for comparison\r\n              cur = a\r\n              while ((cur = cur.parentNode)) {\r\n                ap.unshift(cur)\r\n              }\r\n              cur = b\r\n              while ((cur = cur.parentNode)) {\r\n                bp.unshift(cur)\r\n              }\r\n\r\n              // Walk down the tree looking for a discrepancy\r\n              while (ap[i] === bp[i]) {\r\n                i++\r\n              }\r\n\r\n              return i\r\n                ? // Do a sibling check if the nodes have a common ancestor\r\n                  siblingCheck(ap[i], bp[i])\r\n                : // Otherwise nodes in our document sort first\r\n                ap[i] === preferredDoc\r\n                ? -1\r\n                : bp[i] === preferredDoc\r\n                ? 1\r\n                : 0\r\n            }\r\n\r\n        return document\r\n      }\r\n\r\n      Sizzle.matches = function (expr, elements) {\r\n        return Sizzle(expr, null, null, elements)\r\n      }\r\n\r\n      Sizzle.matchesSelector = function (elem, expr) {\r\n        // Set document vars if needed\r\n        if ((elem.ownerDocument || elem) !== document) {\r\n          setDocument(elem)\r\n        }\r\n\r\n        // Make sure that attribute selectors are quoted\r\n        expr = expr.replace(rattributeQuotes, \"='$1']\")\r\n\r\n        if (\r\n          support.matchesSelector &&\r\n          documentIsHTML &&\r\n          !compilerCache[expr + ' '] &&\r\n          (!rbuggyMatches || !rbuggyMatches.test(expr)) &&\r\n          (!rbuggyQSA || !rbuggyQSA.test(expr))\r\n        ) {\r\n          try {\r\n            var ret = matches.call(elem, expr)\r\n\r\n            // IE 9's matchesSelector returns false on disconnected nodes\r\n            if (\r\n              ret ||\r\n              support.disconnectedMatch ||\r\n              // As well, disconnected nodes are said to be in a document\r\n              // fragment in IE 9\r\n              (elem.document && elem.document.nodeType !== 11)\r\n            ) {\r\n              return ret\r\n            }\r\n          } catch (e) {}\r\n        }\r\n\r\n        return Sizzle(expr, document, null, [elem]).length > 0\r\n      }\r\n\r\n      Sizzle.contains = function (context, elem) {\r\n        // Set document vars if needed\r\n        if ((context.ownerDocument || context) !== document) {\r\n          setDocument(context)\r\n        }\r\n        return contains(context, elem)\r\n      }\r\n\r\n      Sizzle.attr = function (elem, name) {\r\n        // Set document vars if needed\r\n        if ((elem.ownerDocument || elem) !== document) {\r\n          setDocument(elem)\r\n        }\r\n\r\n        var fn = Expr.attrHandle[name.toLowerCase()],\r\n          // Don't get fooled by Object.prototype properties (jQuery #13807)\r\n          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined\r\n\r\n        return val !== undefined\r\n          ? val\r\n          : support.attributes || !documentIsHTML\r\n          ? elem.getAttribute(name)\r\n          : (val = elem.getAttributeNode(name)) && val.specified\r\n          ? val.value\r\n          : null\r\n      }\r\n\r\n      Sizzle.error = function (msg) {\r\n        throw new Error('Syntax error, unrecognized expression: ' + msg)\r\n      }\r\n\r\n      /**\r\n       * Document sorting and removing duplicates\r\n       * @param {ArrayLike} results\r\n       */\r\n      Sizzle.uniqueSort = function (results) {\r\n        var elem,\r\n          duplicates = [],\r\n          j = 0,\r\n          i = 0\r\n\r\n        // Unless we *know* we can detect duplicates, assume their presence\r\n        hasDuplicate = !support.detectDuplicates\r\n        sortInput = !support.sortStable && results.slice(0)\r\n        results.sort(sortOrder)\r\n\r\n        if (hasDuplicate) {\r\n          while ((elem = results[i++])) {\r\n            if (elem === results[i]) {\r\n              j = duplicates.push(i)\r\n            }\r\n          }\r\n          while (j--) {\r\n            results.splice(duplicates[j], 1)\r\n          }\r\n        }\r\n\r\n        // Clear input after sorting to release objects\r\n        // See https://github.com/jquery/sizzle/pull/225\r\n        sortInput = null\r\n\r\n        return results\r\n      }\r\n\r\n      /**\r\n       * Utility function for retrieving the text value of an array of DOM nodes\r\n       * @param {Array|Element} elem\r\n       */\r\n      getText = Sizzle.getText = function (elem) {\r\n        var node,\r\n          ret = '',\r\n          i = 0,\r\n          nodeType = elem.nodeType\r\n\r\n        if (!nodeType) {\r\n          // If no nodeType, this is expected to be an array\r\n          while ((node = elem[i++])) {\r\n            // Do not traverse comment nodes\r\n            ret += getText(node)\r\n          }\r\n        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\r\n          // Use textContent for elements\r\n          // innerText usage removed for consistency of new lines (jQuery #11153)\r\n          if (typeof elem.textContent === 'string') {\r\n            return elem.textContent\r\n          } else {\r\n            // Traverse its children\r\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n              ret += getText(elem)\r\n            }\r\n          }\r\n        } else if (nodeType === 3 || nodeType === 4) {\r\n          return elem.nodeValue\r\n        }\r\n        // Do not include comment or processing instruction nodes\r\n\r\n        return ret\r\n      }\r\n\r\n      Expr = Sizzle.selectors = {\r\n        // Can be adjusted by the user\r\n        cacheLength: 50,\r\n\r\n        createPseudo: markFunction,\r\n\r\n        match: matchExpr,\r\n\r\n        attrHandle: {},\r\n\r\n        find: {},\r\n\r\n        relative: {\r\n          '>': { dir: 'parentNode', first: true },\r\n          ' ': { dir: 'parentNode' },\r\n          '+': { dir: 'previousSibling', first: true },\r\n          '~': { dir: 'previousSibling' }\r\n        },\r\n\r\n        preFilter: {\r\n          ATTR: function (match) {\r\n            match[1] = match[1].replace(runescape, funescape)\r\n\r\n            // Move the given value to match[3] whether quoted or unquoted\r\n            match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape)\r\n\r\n            if (match[2] === '~=') {\r\n              match[3] = ' ' + match[3] + ' '\r\n            }\r\n\r\n            return match.slice(0, 4)\r\n          },\r\n\r\n          CHILD: function (match) {\r\n            /* matches from matchExpr[\"CHILD\"]\r\n\t\t\t\t1 type (only|nth|...)\r\n\t\t\t\t2 what (child|of-type)\r\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\r\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\r\n\t\t\t\t5 sign of xn-component\r\n\t\t\t\t6 x of xn-component\r\n\t\t\t\t7 sign of y-component\r\n\t\t\t\t8 y of y-component\r\n\t\t\t*/\r\n            match[1] = match[1].toLowerCase()\r\n\r\n            if (match[1].slice(0, 3) === 'nth') {\r\n              // nth-* requires argument\r\n              if (!match[3]) {\r\n                Sizzle.error(match[0])\r\n              }\r\n\r\n              // numeric x and y parameters for Expr.filter.CHILD\r\n              // remember that false/true cast respectively to 0/1\r\n              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'))\r\n              match[5] = +(match[7] + match[8] || match[3] === 'odd')\r\n\r\n              // other types prohibit arguments\r\n            } else if (match[3]) {\r\n              Sizzle.error(match[0])\r\n            }\r\n\r\n            return match\r\n          },\r\n\r\n          PSEUDO: function (match) {\r\n            var excess,\r\n              unquoted = !match[6] && match[2]\r\n\r\n            if (matchExpr['CHILD'].test(match[0])) {\r\n              return null\r\n            }\r\n\r\n            // Accept quoted arguments as-is\r\n            if (match[3]) {\r\n              match[2] = match[4] || match[5] || ''\r\n\r\n              // Strip excess characters from unquoted arguments\r\n            } else if (\r\n              unquoted &&\r\n              rpseudo.test(unquoted) &&\r\n              // Get excess from tokenize (recursively)\r\n              (excess = tokenize(unquoted, true)) &&\r\n              // advance to the next closing parenthesis\r\n              (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)\r\n            ) {\r\n              // excess is a negative index\r\n              match[0] = match[0].slice(0, excess)\r\n              match[2] = unquoted.slice(0, excess)\r\n            }\r\n\r\n            // Return only captures needed by the pseudo filter method (type and argument)\r\n            return match.slice(0, 3)\r\n          }\r\n        },\r\n\r\n        filter: {\r\n          TAG: function (nodeNameSelector) {\r\n            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase()\r\n            return nodeNameSelector === '*'\r\n              ? function () {\r\n                  return true\r\n                }\r\n              : function (elem) {\r\n                  return elem.nodeName && elem.nodeName.toLowerCase() === nodeName\r\n                }\r\n          },\r\n\r\n          CLASS: function (className) {\r\n            var pattern = classCache[className + ' ']\r\n\r\n            return (\r\n              pattern ||\r\n              ((pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) &&\r\n                classCache(className, function (elem) {\r\n                  return pattern.test(\r\n                    (typeof elem.className === 'string' && elem.className) ||\r\n                      (typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class')) ||\r\n                      ''\r\n                  )\r\n                }))\r\n            )\r\n          },\r\n\r\n          ATTR: function (name, operator, check) {\r\n            return function (elem) {\r\n              var result = Sizzle.attr(elem, name)\r\n\r\n              if (result == null) {\r\n                return operator === '!='\r\n              }\r\n              if (!operator) {\r\n                return true\r\n              }\r\n\r\n              result += ''\r\n\r\n              return operator === '='\r\n                ? result === check\r\n                : operator === '!='\r\n                ? result !== check\r\n                : operator === '^='\r\n                ? check && result.indexOf(check) === 0\r\n                : operator === '*='\r\n                ? check && result.indexOf(check) > -1\r\n                : operator === '$='\r\n                ? check && result.slice(-check.length) === check\r\n                : operator === '~='\r\n                ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1\r\n                : operator === '|='\r\n                ? result === check || result.slice(0, check.length + 1) === check + '-'\r\n                : false\r\n            }\r\n          },\r\n\r\n          CHILD: function (type, what, argument, first, last) {\r\n            var simple = type.slice(0, 3) !== 'nth',\r\n              forward = type.slice(-4) !== 'last',\r\n              ofType = what === 'of-type'\r\n\r\n            return first === 1 && last === 0\r\n              ? // Shortcut for :nth-*(n)\r\n                function (elem) {\r\n                  return !!elem.parentNode\r\n                }\r\n              : function (elem, context, xml) {\r\n                  var cache,\r\n                    uniqueCache,\r\n                    outerCache,\r\n                    node,\r\n                    nodeIndex,\r\n                    start,\r\n                    dir = simple !== forward ? 'nextSibling' : 'previousSibling',\r\n                    parent = elem.parentNode,\r\n                    name = ofType && elem.nodeName.toLowerCase(),\r\n                    useCache = !xml && !ofType,\r\n                    diff = false\r\n\r\n                  if (parent) {\r\n                    // :(first|last|only)-(child|of-type)\r\n                    if (simple) {\r\n                      while (dir) {\r\n                        node = elem\r\n                        while ((node = node[dir])) {\r\n                          if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\r\n                            return false\r\n                          }\r\n                        }\r\n                        // Reverse direction for :only-* (if we haven't yet done so)\r\n                        start = dir = type === 'only' && !start && 'nextSibling'\r\n                      }\r\n                      return true\r\n                    }\r\n\r\n                    start = [forward ? parent.firstChild : parent.lastChild]\r\n\r\n                    // non-xml :nth-child(...) stores cache data on `parent`\r\n                    if (forward && useCache) {\r\n                      // Seek `elem` from a previously-cached index\r\n\r\n                      // ...in a gzip-friendly way\r\n                      node = parent\r\n                      outerCache = node[expando] || (node[expando] = {})\r\n\r\n                      // Support: IE <9 only\r\n                      // Defend against cloned attroperties (jQuery gh-1709)\r\n                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {})\r\n\r\n                      cache = uniqueCache[type] || []\r\n                      nodeIndex = cache[0] === dirruns && cache[1]\r\n                      diff = nodeIndex && cache[2]\r\n                      node = nodeIndex && parent.childNodes[nodeIndex]\r\n\r\n                      while (\r\n                        (node =\r\n                          (++nodeIndex && node && node[dir]) ||\r\n                          // Fallback to seeking `elem` from the start\r\n                          (diff = nodeIndex = 0) ||\r\n                          start.pop())\r\n                      ) {\r\n                        // When found, cache indexes on `parent` and break\r\n                        if (node.nodeType === 1 && ++diff && node === elem) {\r\n                          uniqueCache[type] = [dirruns, nodeIndex, diff]\r\n                          break\r\n                        }\r\n                      }\r\n                    } else {\r\n                      // Use previously-cached element index if available\r\n                      if (useCache) {\r\n                        // ...in a gzip-friendly way\r\n                        node = elem\r\n                        outerCache = node[expando] || (node[expando] = {})\r\n\r\n                        // Support: IE <9 only\r\n                        // Defend against cloned attroperties (jQuery gh-1709)\r\n                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {})\r\n\r\n                        cache = uniqueCache[type] || []\r\n                        nodeIndex = cache[0] === dirruns && cache[1]\r\n                        diff = nodeIndex\r\n                      }\r\n\r\n                      // xml :nth-child(...)\r\n                      // or :nth-last-child(...) or :nth(-last)?-of-type(...)\r\n                      if (diff === false) {\r\n                        // Use the same loop as above to seek `elem` from the start\r\n                        while ((node = (++nodeIndex && node && node[dir]) || (diff = nodeIndex = 0) || start.pop())) {\r\n                          if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\r\n                            // Cache the index of each encountered element\r\n                            if (useCache) {\r\n                              outerCache = node[expando] || (node[expando] = {})\r\n\r\n                              // Support: IE <9 only\r\n                              // Defend against cloned attroperties (jQuery gh-1709)\r\n                              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {})\r\n\r\n                              uniqueCache[type] = [dirruns, diff]\r\n                            }\r\n\r\n                            if (node === elem) {\r\n                              break\r\n                            }\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    // Incorporate the offset, then check against cycle size\r\n                    diff -= last\r\n                    return diff === first || (diff % first === 0 && diff / first >= 0)\r\n                  }\r\n                }\r\n          },\r\n\r\n          PSEUDO: function (pseudo, argument) {\r\n            // pseudo-class names are case-insensitive\r\n            // http://www.w3.org/TR/selectors/#pseudo-classes\r\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\r\n            // Remember that setFilters inherits from pseudos\r\n            var args,\r\n              fn =\r\n                Expr.pseudos[pseudo] ||\r\n                Expr.setFilters[pseudo.toLowerCase()] ||\r\n                Sizzle.error('unsupported pseudo: ' + pseudo)\r\n\r\n            // The user may use createPseudo to indicate that\r\n            // arguments are needed to create the filter function\r\n            // just as Sizzle does\r\n            if (fn[expando]) {\r\n              return fn(argument)\r\n            }\r\n\r\n            // But maintain support for old signatures\r\n            if (fn.length > 1) {\r\n              args = [pseudo, pseudo, '', argument]\r\n              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase())\r\n                ? markFunction(function (seed, matches) {\r\n                    var idx,\r\n                      matched = fn(seed, argument),\r\n                      i = matched.length\r\n                    while (i--) {\r\n                      idx = indexOf(seed, matched[i])\r\n                      seed[idx] = !(matches[idx] = matched[i])\r\n                    }\r\n                  })\r\n                : function (elem) {\r\n                    return fn(elem, 0, args)\r\n                  }\r\n            }\r\n\r\n            return fn\r\n          }\r\n        },\r\n\r\n        pseudos: {\r\n          // Potentially complex pseudos\r\n          not: markFunction(function (selector) {\r\n            // Trim the selector passed to compile\r\n            // to avoid treating leading and trailing\r\n            // spaces as combinators\r\n            var input = [],\r\n              results = [],\r\n              matcher = compile(selector.replace(rtrim, '$1'))\r\n\r\n            return matcher[expando]\r\n              ? markFunction(function (seed, matches, context, xml) {\r\n                  var elem,\r\n                    unmatched = matcher(seed, null, xml, []),\r\n                    i = seed.length\r\n\r\n                  // Match elements unmatched by `matcher`\r\n                  while (i--) {\r\n                    if ((elem = unmatched[i])) {\r\n                      seed[i] = !(matches[i] = elem)\r\n                    }\r\n                  }\r\n                })\r\n              : function (elem, context, xml) {\r\n                  input[0] = elem\r\n                  matcher(input, null, xml, results)\r\n                  // Don't keep the element (issue #299)\r\n                  input[0] = null\r\n                  return !results.pop()\r\n                }\r\n          }),\r\n\r\n          has: markFunction(function (selector) {\r\n            return function (elem) {\r\n              return Sizzle(selector, elem).length > 0\r\n            }\r\n          }),\r\n\r\n          contains: markFunction(function (text) {\r\n            text = text.replace(runescape, funescape)\r\n            return function (elem) {\r\n              return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1\r\n            }\r\n          }),\r\n\r\n          // \"Whether an element is represented by a :lang() selector\r\n          // is based solely on the element's language value\r\n          // being equal to the identifier C,\r\n          // or beginning with the identifier C immediately followed by \"-\".\r\n          // The matching of C against the element's language value is performed case-insensitively.\r\n          // The identifier C does not have to be a valid language name.\"\r\n          // http://www.w3.org/TR/selectors/#lang-pseudo\r\n          lang: markFunction(function (lang) {\r\n            // lang value must be a valid identifier\r\n            if (!ridentifier.test(lang || '')) {\r\n              Sizzle.error('unsupported lang: ' + lang)\r\n            }\r\n            lang = lang.replace(runescape, funescape).toLowerCase()\r\n            return function (elem) {\r\n              var elemLang\r\n              do {\r\n                if (\r\n                  (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang'))\r\n                ) {\r\n                  elemLang = elemLang.toLowerCase()\r\n                  return elemLang === lang || elemLang.indexOf(lang + '-') === 0\r\n                }\r\n              } while ((elem = elem.parentNode) && elem.nodeType === 1)\r\n              return false\r\n            }\r\n          }),\r\n\r\n          // Miscellaneous\r\n          target: function (elem) {\r\n            var hash = window.location && window.location.hash\r\n            return hash && hash.slice(1) === elem.id\r\n          },\r\n\r\n          root: function (elem) {\r\n            return elem === docElem\r\n          },\r\n\r\n          focus: function (elem) {\r\n            return (\r\n              elem === document.activeElement &&\r\n              (!document.hasFocus || document.hasFocus()) &&\r\n              !!(elem.type || elem.href || ~elem.tabIndex)\r\n            )\r\n          },\r\n\r\n          // Boolean properties\r\n          enabled: function (elem) {\r\n            return elem.disabled === false\r\n          },\r\n\r\n          disabled: function (elem) {\r\n            return elem.disabled === true\r\n          },\r\n\r\n          checked: function (elem) {\r\n            // In CSS3, :checked should return both checked and selected elements\r\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\r\n            var nodeName = elem.nodeName.toLowerCase()\r\n            return (nodeName === 'input' && !!elem.checked) || (nodeName === 'option' && !!elem.selected)\r\n          },\r\n\r\n          selected: function (elem) {\r\n            // Accessing this property makes selected-by-default\r\n            // options in Safari work properly\r\n            if (elem.parentNode) {\r\n              elem.parentNode.selectedIndex\r\n            }\r\n\r\n            return elem.selected === true\r\n          },\r\n\r\n          // Contents\r\n          empty: function (elem) {\r\n            // http://www.w3.org/TR/selectors/#empty-pseudo\r\n            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\r\n            //   but not by others (comment: 8; processing instruction: 7; etc.)\r\n            // nodeType < 6 works because attributes (2) do not appear as children\r\n            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\r\n              if (elem.nodeType < 6) {\r\n                return false\r\n              }\r\n            }\r\n            return true\r\n          },\r\n\r\n          parent: function (elem) {\r\n            return !Expr.pseudos['empty'](elem)\r\n          },\r\n\r\n          // Element/input types\r\n          header: function (elem) {\r\n            return rheader.test(elem.nodeName)\r\n          },\r\n\r\n          input: function (elem) {\r\n            return rinputs.test(elem.nodeName)\r\n          },\r\n\r\n          button: function (elem) {\r\n            var name = elem.nodeName.toLowerCase()\r\n            return (name === 'input' && elem.type === 'button') || name === 'button'\r\n          },\r\n\r\n          text: function (elem) {\r\n            var attr\r\n            return (\r\n              elem.nodeName.toLowerCase() === 'input' &&\r\n              elem.type === 'text' &&\r\n              // Support: IE<8\r\n              // New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\r\n              ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text')\r\n            )\r\n          },\r\n\r\n          // Position-in-collection\r\n          first: createPositionalPseudo(function () {\r\n            return [0]\r\n          }),\r\n\r\n          last: createPositionalPseudo(function (matchIndexes, length) {\r\n            return [length - 1]\r\n          }),\r\n\r\n          eq: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n            return [argument < 0 ? argument + length : argument]\r\n          }),\r\n\r\n          even: createPositionalPseudo(function (matchIndexes, length) {\r\n            var i = 0\r\n            for (; i < length; i += 2) {\r\n              matchIndexes.push(i)\r\n            }\r\n            return matchIndexes\r\n          }),\r\n\r\n          odd: createPositionalPseudo(function (matchIndexes, length) {\r\n            var i = 1\r\n            for (; i < length; i += 2) {\r\n              matchIndexes.push(i)\r\n            }\r\n            return matchIndexes\r\n          }),\r\n\r\n          lt: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n            var i = argument < 0 ? argument + length : argument\r\n            for (; --i >= 0; ) {\r\n              matchIndexes.push(i)\r\n            }\r\n            return matchIndexes\r\n          }),\r\n\r\n          gt: createPositionalPseudo(function (matchIndexes, length, argument) {\r\n            var i = argument < 0 ? argument + length : argument\r\n            for (; ++i < length; ) {\r\n              matchIndexes.push(i)\r\n            }\r\n            return matchIndexes\r\n          })\r\n        }\r\n      }\r\n\r\n      Expr.pseudos['nth'] = Expr.pseudos['eq']\r\n\r\n      // Add button/input type pseudos\r\n      for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {\r\n        Expr.pseudos[i] = createInputPseudo(i)\r\n      }\r\n      for (i in { submit: true, reset: true }) {\r\n        Expr.pseudos[i] = createButtonPseudo(i)\r\n      }\r\n\r\n      // Easy API for creating new setFilters\r\n      function setFilters () {}\r\n      setFilters.prototype = Expr.filters = Expr.pseudos\r\n      Expr.setFilters = new setFilters()\r\n\r\n      tokenize = Sizzle.tokenize = function (selector, parseOnly) {\r\n        var matched,\r\n          match,\r\n          tokens,\r\n          type,\r\n          soFar,\r\n          groups,\r\n          preFilters,\r\n          cached = tokenCache[selector + ' ']\r\n\r\n        if (cached) {\r\n          return parseOnly ? 0 : cached.slice(0)\r\n        }\r\n\r\n        soFar = selector\r\n        groups = []\r\n        preFilters = Expr.preFilter\r\n\r\n        while (soFar) {\r\n          // Comma and first run\r\n          if (!matched || (match = rcomma.exec(soFar))) {\r\n            if (match) {\r\n              // Don't consume trailing commas as valid\r\n              soFar = soFar.slice(match[0].length) || soFar\r\n            }\r\n            groups.push((tokens = []))\r\n          }\r\n\r\n          matched = false\r\n\r\n          // Combinators\r\n          if ((match = rcombinators.exec(soFar))) {\r\n            matched = match.shift()\r\n            tokens.push({\r\n              value: matched,\r\n              // Cast descendant combinators to space\r\n              type: match[0].replace(rtrim, ' ')\r\n            })\r\n            soFar = soFar.slice(matched.length)\r\n          }\r\n\r\n          // Filters\r\n          for (type in Expr.filter) {\r\n            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\r\n              matched = match.shift()\r\n              tokens.push({\r\n                value: matched,\r\n                type: type,\r\n                matches: match\r\n              })\r\n              soFar = soFar.slice(matched.length)\r\n            }\r\n          }\r\n\r\n          if (!matched) {\r\n            break\r\n          }\r\n        }\r\n\r\n        // Return the length of the invalid excess\r\n        // if we're just parsing\r\n        // Otherwise, throw an error or return tokens\r\n        return parseOnly\r\n          ? soFar.length\r\n          : soFar\r\n          ? Sizzle.error(selector)\r\n          : // Cache the tokens\r\n            tokenCache(selector, groups).slice(0)\r\n      }\r\n\r\n      function toSelector (tokens) {\r\n        var i = 0,\r\n          len = tokens.length,\r\n          selector = ''\r\n        for (; i < len; i++) {\r\n          selector += tokens[i].value\r\n        }\r\n        return selector\r\n      }\r\n\r\n      function addCombinator (matcher, combinator, base) {\r\n        var dir = combinator.dir,\r\n          checkNonElements = base && dir === 'parentNode',\r\n          doneName = done++\r\n\r\n        return combinator.first\r\n          ? // Check against closest ancestor/preceding element\r\n            function (elem, context, xml) {\r\n              while ((elem = elem[dir])) {\r\n                if (elem.nodeType === 1 || checkNonElements) {\r\n                  return matcher(elem, context, xml)\r\n                }\r\n              }\r\n            }\r\n          : // Check against all ancestor/preceding elements\r\n            function (elem, context, xml) {\r\n              var oldCache,\r\n                uniqueCache,\r\n                outerCache,\r\n                newCache = [dirruns, doneName]\r\n\r\n              // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\r\n              if (xml) {\r\n                while ((elem = elem[dir])) {\r\n                  if (elem.nodeType === 1 || checkNonElements) {\r\n                    if (matcher(elem, context, xml)) {\r\n                      return true\r\n                    }\r\n                  }\r\n                }\r\n              } else {\r\n                while ((elem = elem[dir])) {\r\n                  if (elem.nodeType === 1 || checkNonElements) {\r\n                    outerCache = elem[expando] || (elem[expando] = {})\r\n\r\n                    // Support: IE <9 only\r\n                    // Defend against cloned attroperties (jQuery gh-1709)\r\n                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {})\r\n\r\n                    if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\r\n                      // Assign to newCache so results back-propagate to previous elements\r\n                      return (newCache[2] = oldCache[2])\r\n                    } else {\r\n                      // Reuse newcache so results back-propagate to previous elements\r\n                      uniqueCache[dir] = newCache\r\n\r\n                      // A match means we're done; a fail means we have to keep checking\r\n                      if ((newCache[2] = matcher(elem, context, xml))) {\r\n                        return true\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n      }\r\n\r\n      function elementMatcher (matchers) {\r\n        return matchers.length > 1\r\n          ? function (elem, context, xml) {\r\n              var i = matchers.length\r\n              while (i--) {\r\n                if (!matchers[i](elem, context, xml)) {\r\n                  return false\r\n                }\r\n              }\r\n              return true\r\n            }\r\n          : matchers[0]\r\n      }\r\n\r\n      function multipleContexts (selector, contexts, results) {\r\n        var i = 0,\r\n          len = contexts.length\r\n        for (; i < len; i++) {\r\n          Sizzle(selector, contexts[i], results)\r\n        }\r\n        return results\r\n      }\r\n\r\n      function condense (unmatched, map, filter, context, xml) {\r\n        var elem,\r\n          newUnmatched = [],\r\n          i = 0,\r\n          len = unmatched.length,\r\n          mapped = map != null\r\n\r\n        for (; i < len; i++) {\r\n          if ((elem = unmatched[i])) {\r\n            if (!filter || filter(elem, context, xml)) {\r\n              newUnmatched.push(elem)\r\n              if (mapped) {\r\n                map.push(i)\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        return newUnmatched\r\n      }\r\n\r\n      function setMatcher (preFilter, selector, matcher, postFilter, postFinder, postSelector) {\r\n        if (postFilter && !postFilter[expando]) {\r\n          postFilter = setMatcher(postFilter)\r\n        }\r\n        if (postFinder && !postFinder[expando]) {\r\n          postFinder = setMatcher(postFinder, postSelector)\r\n        }\r\n        return markFunction(function (seed, results, context, xml) {\r\n          var temp,\r\n            i,\r\n            elem,\r\n            preMap = [],\r\n            postMap = [],\r\n            preexisting = results.length,\r\n            // Get initial elements from seed or context\r\n            elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),\r\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\r\n            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\r\n            matcherOut = matcher\r\n              ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\r\n                postFinder || (seed ? preFilter : preexisting || postFilter)\r\n                ? // ...intermediate processing is necessary\r\n                  []\r\n                : // ...otherwise use results directly\r\n                  results\r\n              : matcherIn\r\n\r\n          // Find primary matches\r\n          if (matcher) {\r\n            matcher(matcherIn, matcherOut, context, xml)\r\n          }\r\n\r\n          // Apply postFilter\r\n          if (postFilter) {\r\n            temp = condense(matcherOut, postMap)\r\n            postFilter(temp, [], context, xml)\r\n\r\n            // Un-match failing elements by moving them back to matcherIn\r\n            i = temp.length\r\n            while (i--) {\r\n              if ((elem = temp[i])) {\r\n                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem)\r\n              }\r\n            }\r\n          }\r\n\r\n          if (seed) {\r\n            if (postFinder || preFilter) {\r\n              if (postFinder) {\r\n                // Get the final matcherOut by condensing this intermediate into postFinder contexts\r\n                temp = []\r\n                i = matcherOut.length\r\n                while (i--) {\r\n                  if ((elem = matcherOut[i])) {\r\n                    // Restore matcherIn since elem is not yet a final match\r\n                    temp.push((matcherIn[i] = elem))\r\n                  }\r\n                }\r\n                postFinder(null, (matcherOut = []), temp, xml)\r\n              }\r\n\r\n              // Move matched elements from seed to results to keep them synchronized\r\n              i = matcherOut.length\r\n              while (i--) {\r\n                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\r\n                  seed[temp] = !(results[temp] = elem)\r\n                }\r\n              }\r\n            }\r\n\r\n            // Add elements to results, through postFinder if defined\r\n          } else {\r\n            matcherOut = condense(\r\n              matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut\r\n            )\r\n            if (postFinder) {\r\n              postFinder(null, results, matcherOut, xml)\r\n            } else {\r\n              push.apply(results, matcherOut)\r\n            }\r\n          }\r\n        })\r\n      }\r\n\r\n      function matcherFromTokens (tokens) {\r\n        var checkContext,\r\n          matcher,\r\n          j,\r\n          len = tokens.length,\r\n          leadingRelative = Expr.relative[tokens[0].type],\r\n          implicitRelative = leadingRelative || Expr.relative[' '],\r\n          i = leadingRelative ? 1 : 0,\r\n          // The foundational matcher ensures that elements are reachable from top-level context(s)\r\n          matchContext = addCombinator(\r\n            function (elem) {\r\n              return elem === checkContext\r\n            },\r\n            implicitRelative,\r\n            true\r\n          ),\r\n          matchAnyContext = addCombinator(\r\n            function (elem) {\r\n              return indexOf(checkContext, elem) > -1\r\n            },\r\n            implicitRelative,\r\n            true\r\n          ),\r\n          matchers = [\r\n            function (elem, context, xml) {\r\n              var ret =\r\n                (!leadingRelative && (xml || context !== outermostContext)) ||\r\n                ((checkContext = context).nodeType\r\n                  ? matchContext(elem, context, xml)\r\n                  : matchAnyContext(elem, context, xml))\r\n              // Avoid hanging onto element (issue #299)\r\n              checkContext = null\r\n              return ret\r\n            }\r\n          ]\r\n\r\n        for (; i < len; i++) {\r\n          if ((matcher = Expr.relative[tokens[i].type])) {\r\n            matchers = [addCombinator(elementMatcher(matchers), matcher)]\r\n          } else {\r\n            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches)\r\n\r\n            // Return special upon seeing a positional matcher\r\n            if (matcher[expando]) {\r\n              // Find the next relative operator (if any) for proper handling\r\n              j = ++i\r\n              for (; j < len; j++) {\r\n                if (Expr.relative[tokens[j].type]) {\r\n                  break\r\n                }\r\n              }\r\n              return setMatcher(\r\n                i > 1 && elementMatcher(matchers),\r\n                i > 1 &&\r\n                  toSelector(\r\n                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`\r\n                    tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })\r\n                  ).replace(rtrim, '$1'),\r\n                matcher,\r\n                i < j && matcherFromTokens(tokens.slice(i, j)),\r\n                j < len && matcherFromTokens((tokens = tokens.slice(j))),\r\n                j < len && toSelector(tokens)\r\n              )\r\n            }\r\n            matchers.push(matcher)\r\n          }\r\n        }\r\n\r\n        return elementMatcher(matchers)\r\n      }\r\n\r\n      function matcherFromGroupMatchers (elementMatchers, setMatchers) {\r\n        var bySet = setMatchers.length > 0,\r\n          byElement = elementMatchers.length > 0,\r\n          superMatcher = function (seed, context, xml, results, outermost) {\r\n            var elem,\r\n              j,\r\n              matcher,\r\n              matchedCount = 0,\r\n              i = '0',\r\n              unmatched = seed && [],\r\n              setMatched = [],\r\n              contextBackup = outermostContext,\r\n              // We must always have either seed elements or outermost context\r\n              elems = seed || (byElement && Expr.find['TAG']('*', outermost)),\r\n              // Use integer dirruns iff this is the outermost matcher\r\n              dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\r\n              len = elems.length\r\n\r\n            if (outermost) {\r\n              outermostContext = context === document || context || outermost\r\n            }\r\n\r\n            // Add elements passing elementMatchers directly to results\r\n            // Support: IE<9, Safari\r\n            // Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\r\n            for (; i !== len && (elem = elems[i]) != null; i++) {\r\n              if (byElement && elem) {\r\n                j = 0\r\n                if (!context && elem.ownerDocument !== document) {\r\n                  setDocument(elem)\r\n                  xml = !documentIsHTML\r\n                }\r\n                while ((matcher = elementMatchers[j++])) {\r\n                  if (matcher(elem, context || document, xml)) {\r\n                    results.push(elem)\r\n                    break\r\n                  }\r\n                }\r\n                if (outermost) {\r\n                  dirruns = dirrunsUnique\r\n                }\r\n              }\r\n\r\n              // Track unmatched elements for set filters\r\n              if (bySet) {\r\n                // They will have gone through all possible matchers\r\n                if ((elem = !matcher && elem)) {\r\n                  matchedCount--\r\n                }\r\n\r\n                // Lengthen the array for every element, matched or not\r\n                if (seed) {\r\n                  unmatched.push(elem)\r\n                }\r\n              }\r\n            }\r\n\r\n            // `i` is now the count of elements visited above, and adding it to `matchedCount`\r\n            // makes the latter nonnegative.\r\n            matchedCount += i\r\n\r\n            // Apply set filters to unmatched elements\r\n            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\r\n            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have\r\n            // no element matchers and no seed.\r\n            // Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\r\n            // case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\r\n            // numerically zero.\r\n            if (bySet && i !== matchedCount) {\r\n              j = 0\r\n              while ((matcher = setMatchers[j++])) {\r\n                matcher(unmatched, setMatched, context, xml)\r\n              }\r\n\r\n              if (seed) {\r\n                // Reintegrate element matches to eliminate the need for sorting\r\n                if (matchedCount > 0) {\r\n                  while (i--) {\r\n                    if (!(unmatched[i] || setMatched[i])) {\r\n                      setMatched[i] = pop.call(results)\r\n                    }\r\n                  }\r\n                }\r\n\r\n                // Discard index placeholder values to get only actual matches\r\n                setMatched = condense(setMatched)\r\n              }\r\n\r\n              // Add matches to results\r\n              push.apply(results, setMatched)\r\n\r\n              // Seedless set matches succeeding multiple successful matchers stipulate sorting\r\n              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\r\n                Sizzle.uniqueSort(results)\r\n              }\r\n            }\r\n\r\n            // Override manipulation of globals by nested matchers\r\n            if (outermost) {\r\n              dirruns = dirrunsUnique\r\n              outermostContext = contextBackup\r\n            }\r\n\r\n            return unmatched\r\n          }\r\n\r\n        return bySet ? markFunction(superMatcher) : superMatcher\r\n      }\r\n\r\n      compile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\r\n        var i,\r\n          setMatchers = [],\r\n          elementMatchers = [],\r\n          cached = compilerCache[selector + ' ']\r\n\r\n        if (!cached) {\r\n          // Generate a function of recursive functions that can be used to check each element\r\n          if (!match) {\r\n            match = tokenize(selector)\r\n          }\r\n          i = match.length\r\n          while (i--) {\r\n            cached = matcherFromTokens(match[i])\r\n            if (cached[expando]) {\r\n              setMatchers.push(cached)\r\n            } else {\r\n              elementMatchers.push(cached)\r\n            }\r\n          }\r\n\r\n          // Cache the compiled function\r\n          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers))\r\n\r\n          // Save selector and tokenization\r\n          cached.selector = selector\r\n        }\r\n        return cached\r\n      }\r\n\r\n      /**\r\n       * A low-level selection function that works with Sizzle's compiled\r\n       *  selector functions\r\n       * @param {String|Function} selector A selector or a pre-compiled\r\n       *  selector function built with Sizzle.compile\r\n       * @param {Element} context\r\n       * @param {Array} [results]\r\n       * @param {Array} [seed] A set of elements to match against\r\n       */\r\n      select = Sizzle.select = function (selector, context, results, seed) {\r\n        var i,\r\n          tokens,\r\n          token,\r\n          type,\r\n          find,\r\n          compiled = typeof selector === 'function' && selector,\r\n          match = !seed && tokenize((selector = compiled.selector || selector))\r\n\r\n        results = results || []\r\n\r\n        // Try to minimize operations if there is only one selector in the list and no seed\r\n        // (the latter of which guarantees us context)\r\n        if (match.length === 1) {\r\n          // Reduce context if the leading compound selector is an ID\r\n          tokens = match[0] = match[0].slice(0)\r\n          if (\r\n            tokens.length > 2 &&\r\n            (token = tokens[0]).type === 'ID' &&\r\n            support.getById &&\r\n            context.nodeType === 9 &&\r\n            documentIsHTML &&\r\n            Expr.relative[tokens[1].type]\r\n          ) {\r\n            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0]\r\n            if (!context) {\r\n              return results\r\n\r\n              // Precompiled matchers will still verify ancestry, so step up a level\r\n            } else if (compiled) {\r\n              context = context.parentNode\r\n            }\r\n\r\n            selector = selector.slice(tokens.shift().value.length)\r\n          }\r\n\r\n          // Fetch a seed set for right-to-left matching\r\n          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length\r\n          while (i--) {\r\n            token = tokens[i]\r\n\r\n            // Abort if we hit a combinator\r\n            if (Expr.relative[(type = token.type)]) {\r\n              break\r\n            }\r\n            if ((find = Expr.find[type])) {\r\n              // Search, expanding context for leading sibling combinators\r\n              if (\r\n                (seed = find(\r\n                  token.matches[0].replace(runescape, funescape),\r\n                  (rsibling.test(tokens[0].type) && testContext(context.parentNode)) || context\r\n                ))\r\n              ) {\r\n                // If seed is empty or no tokens remain, we can return early\r\n                tokens.splice(i, 1)\r\n                selector = seed.length && toSelector(tokens)\r\n                if (!selector) {\r\n                  push.apply(results, seed)\r\n                  return results\r\n                }\r\n\r\n                break\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Compile and execute a filtering function if one is not provided\r\n        // Provide `match` to avoid retokenization if we modified the selector above\r\n        ;(compiled || compile(selector, match))(\r\n          seed,\r\n          context,\r\n          !documentIsHTML,\r\n          results,\r\n          !context || (rsibling.test(selector) && testContext(context.parentNode)) || context\r\n        )\r\n        return results\r\n      }\r\n\r\n      // One-time assignments\r\n\r\n      // Sort stability\r\n      support.sortStable =\r\n        expando\r\n          .split('')\r\n          .sort(sortOrder)\r\n          .join('') === expando\r\n\r\n      // Support: Chrome 14-35+\r\n      // Always assume duplicates if they aren't passed to the comparison function\r\n      support.detectDuplicates = !!hasDuplicate\r\n\r\n      // Initialize against the default document\r\n      setDocument()\r\n\r\n      // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\r\n      // Detached nodes confoundingly follow *each other*\r\n      support.sortDetached = assert(function (div1) {\r\n        // Should return 1, but returns 4 (following)\r\n        return div1.compareDocumentPosition(document.createElement('div')) & 1\r\n      })\r\n\r\n      // Support: IE<8\r\n      // Prevent attribute/property \"interpolation\"\r\n      // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\r\n      if (\r\n        !assert(function (div) {\r\n          div.innerHTML = \"<a href='#'></a>\"\r\n          return div.firstChild.getAttribute('href') === '#'\r\n        })\r\n      ) {\r\n        addHandle('type|href|height|width', function (elem, name, isXML) {\r\n          if (!isXML) {\r\n            return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2)\r\n          }\r\n        })\r\n      }\r\n\r\n      // Support: IE<9\r\n      // Use defaultValue in place of getAttribute(\"value\")\r\n      if (\r\n        !support.attributes ||\r\n        !assert(function (div) {\r\n          div.innerHTML = '<input/>'\r\n          div.firstChild.setAttribute('value', '')\r\n          return div.firstChild.getAttribute('value') === ''\r\n        })\r\n      ) {\r\n        addHandle('value', function (elem, name, isXML) {\r\n          if (!isXML && elem.nodeName.toLowerCase() === 'input') {\r\n            return elem.defaultValue\r\n          }\r\n        })\r\n      }\r\n\r\n      // Support: IE<9\r\n      // Use getAttributeNode to fetch booleans when getAttribute lies\r\n      if (\r\n        !assert(function (div) {\r\n          return div.getAttribute('disabled') == null\r\n        })\r\n      ) {\r\n        addHandle(booleans, function (elem, name, isXML) {\r\n          var val\r\n          if (!isXML) {\r\n            return elem[name] === true\r\n              ? name.toLowerCase()\r\n              : (val = elem.getAttributeNode(name)) && val.specified\r\n              ? val.value\r\n              : null\r\n          }\r\n        })\r\n      }\r\n\r\n      return Sizzle\r\n    })(window)\r\n\r\n  jQuery.find = Sizzle\r\n  jQuery.expr = Sizzle.selectors\r\n  jQuery.expr[':'] = jQuery.expr.pseudos\r\n  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort\r\n  jQuery.text = Sizzle.getText\r\n  jQuery.isXMLDoc = Sizzle.isXML\r\n  jQuery.contains = Sizzle.contains\r\n\r\n  var dir = function (elem, dir, until) {\r\n    var matched = [],\r\n      truncate = until !== undefined\r\n\r\n    while ((elem = elem[dir]) && elem.nodeType !== 9) {\r\n      if (elem.nodeType === 1) {\r\n        if (truncate && jQuery(elem).is(until)) {\r\n          break\r\n        }\r\n        matched.push(elem)\r\n      }\r\n    }\r\n    return matched\r\n  }\r\n\r\n  var siblings = function (n, elem) {\r\n    var matched = []\r\n\r\n    for (; n; n = n.nextSibling) {\r\n      if (n.nodeType === 1 && n !== elem) {\r\n        matched.push(n)\r\n      }\r\n    }\r\n\r\n    return matched\r\n  }\r\n\r\n  var rneedsContext = jQuery.expr.match.needsContext\r\n\r\n  var rsingleTag = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/\r\n\r\n  var risSimple = /^.[^:#\\[\\.,]*$/\r\n\r\n  // Implement the identical functionality for filter and not\r\n  function winnow (elements, qualifier, not) {\r\n    if (jQuery.isFunction(qualifier)) {\r\n      return jQuery.grep(elements, function (elem, i) {\r\n        /* jshint -W018 */\r\n        return !!qualifier.call(elem, i, elem) !== not\r\n      })\r\n    }\r\n\r\n    if (qualifier.nodeType) {\r\n      return jQuery.grep(elements, function (elem) {\r\n        return (elem === qualifier) !== not\r\n      })\r\n    }\r\n\r\n    if (typeof qualifier === 'string') {\r\n      if (risSimple.test(qualifier)) {\r\n        return jQuery.filter(qualifier, elements, not)\r\n      }\r\n\r\n      qualifier = jQuery.filter(qualifier, elements)\r\n    }\r\n\r\n    return jQuery.grep(elements, function (elem) {\r\n      return indexOf.call(qualifier, elem) > -1 !== not\r\n    })\r\n  }\r\n\r\n  jQuery.filter = function (expr, elems, not) {\r\n    var elem = elems[0]\r\n\r\n    if (not) {\r\n      expr = ':not(' + expr + ')'\r\n    }\r\n\r\n    return elems.length === 1 && elem.nodeType === 1\r\n      ? jQuery.find.matchesSelector(elem, expr)\r\n        ? [elem]\r\n        : []\r\n      : jQuery.find.matches(\r\n          expr,\r\n          jQuery.grep(elems, function (elem) {\r\n            return elem.nodeType === 1\r\n          })\r\n        )\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    find: function (selector) {\r\n      var i,\r\n        len = this.length,\r\n        ret = [],\r\n        self = this\r\n\r\n      if (typeof selector !== 'string') {\r\n        return this.pushStack(\r\n          jQuery(selector).filter(function () {\r\n            for (i = 0; i < len; i++) {\r\n              if (jQuery.contains(self[i], this)) {\r\n                return true\r\n              }\r\n            }\r\n          })\r\n        )\r\n      }\r\n\r\n      for (i = 0; i < len; i++) {\r\n        jQuery.find(selector, self[i], ret)\r\n      }\r\n\r\n      // Needed because $( selector, context ) becomes $( context ).find( selector )\r\n      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret)\r\n      ret.selector = this.selector ? this.selector + ' ' + selector : selector\r\n      return ret\r\n    },\r\n    filter: function (selector) {\r\n      return this.pushStack(winnow(this, selector || [], false))\r\n    },\r\n    not: function (selector) {\r\n      return this.pushStack(winnow(this, selector || [], true))\r\n    },\r\n    is: function (selector) {\r\n      return !!winnow(\r\n        this,\r\n\r\n        // If this is a positional/relative selector, check membership in the returned set\r\n        // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\r\n        typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [],\r\n        false\r\n      ).length\r\n    }\r\n  })\r\n\r\n  // Initialize a jQuery object\r\n\r\n  // A central reference to the root jQuery(document)\r\n  var rootjQuery,\r\n    // A simple way to check for HTML strings\r\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\r\n    // Strict HTML recognition (#11290: must start with <)\r\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\r\n    init = (jQuery.fn.init = function (selector, context, root) {\r\n      var match, elem\r\n\r\n      // HANDLE: $(\"\"), $(null), $(undefined), $(false)\r\n      if (!selector) {\r\n        return this\r\n      }\r\n\r\n      // Method init() accepts an alternate rootjQuery\r\n      // so migrate can support jQuery.sub (gh-2101)\r\n      root = root || rootjQuery\r\n\r\n      // Handle HTML strings\r\n      if (typeof selector === 'string') {\r\n        if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {\r\n          // Assume that strings that start and end with <> are HTML and skip the regex check\r\n          match = [null, selector, null]\r\n        } else {\r\n          match = rquickExpr.exec(selector)\r\n        }\r\n\r\n        // Match html or make sure no context is specified for #id\r\n        if (match && (match[1] || !context)) {\r\n          // HANDLE: $(html) -> $(array)\r\n          if (match[1]) {\r\n            context = context instanceof jQuery ? context[0] : context\r\n\r\n            // Option to run scripts is true for back-compat\r\n            // Intentionally let the error be thrown if parseHTML is not present\r\n            jQuery.merge(\r\n              this,\r\n              jQuery.parseHTML(\r\n                match[1],\r\n                context && context.nodeType ? context.ownerDocument || context : document,\r\n                true\r\n              )\r\n            )\r\n\r\n            // HANDLE: $(html, props)\r\n            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {\r\n              for (match in context) {\r\n                // Properties of context are called as methods if possible\r\n                if (jQuery.isFunction(this[match])) {\r\n                  this[match](context[match])\r\n\r\n                  // ...and otherwise set as attributes\r\n                } else {\r\n                  this.attr(match, context[match])\r\n                }\r\n              }\r\n            }\r\n\r\n            return this\r\n\r\n            // HANDLE: $(#id)\r\n          } else {\r\n            elem = document.getElementById(match[2])\r\n\r\n            // Support: Blackberry 4.6\r\n            // gEBID returns nodes no longer in the document (#6963)\r\n            if (elem && elem.parentNode) {\r\n              // Inject the element directly into the jQuery object\r\n              this.length = 1\r\n              this[0] = elem\r\n            }\r\n\r\n            this.context = document\r\n            this.selector = selector\r\n            return this\r\n          }\r\n\r\n          // HANDLE: $(expr, $(...))\r\n        } else if (!context || context.jquery) {\r\n          return (context || root).find(selector)\r\n\r\n          // HANDLE: $(expr, context)\r\n          // (which is just equivalent to: $(context).find(expr)\r\n        } else {\r\n          return this.constructor(context).find(selector)\r\n        }\r\n\r\n        // HANDLE: $(DOMElement)\r\n      } else if (selector.nodeType) {\r\n        this.context = this[0] = selector\r\n        this.length = 1\r\n        return this\r\n\r\n        // HANDLE: $(function)\r\n        // Shortcut for document ready\r\n      } else if (jQuery.isFunction(selector)) {\r\n        return root.ready !== undefined\r\n          ? root.ready(selector)\r\n          : // Execute immediately if ready is not present\r\n            selector(jQuery)\r\n      }\r\n\r\n      if (selector.selector !== undefined) {\r\n        this.selector = selector.selector\r\n        this.context = selector.context\r\n      }\r\n\r\n      return jQuery.makeArray(selector, this)\r\n    })\r\n\r\n  // Give the init function the jQuery prototype for later instantiation\r\n  init.prototype = jQuery.fn\r\n\r\n  // Initialize central reference\r\n  rootjQuery = jQuery(document)\r\n\r\n  var rparentsprev = /^(?:parents|prev(?:Until|All))/,\r\n    // Methods guaranteed to produce a unique set when starting from a unique set\r\n    guaranteedUnique = {\r\n      children: true,\r\n      contents: true,\r\n      next: true,\r\n      prev: true\r\n    }\r\n\r\n  jQuery.fn.extend({\r\n    has: function (target) {\r\n      var targets = jQuery(target, this),\r\n        l = targets.length\r\n\r\n      return this.filter(function () {\r\n        var i = 0\r\n        for (; i < l; i++) {\r\n          if (jQuery.contains(this, targets[i])) {\r\n            return true\r\n          }\r\n        }\r\n      })\r\n    },\r\n\r\n    closest: function (selectors, context) {\r\n      var cur,\r\n        i = 0,\r\n        l = this.length,\r\n        matched = [],\r\n        pos =\r\n          rneedsContext.test(selectors) || typeof selectors !== 'string'\r\n            ? jQuery(selectors, context || this.context)\r\n            : 0\r\n\r\n      for (; i < l; i++) {\r\n        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {\r\n          // Always skip document fragments\r\n          if (\r\n            cur.nodeType < 11 &&\r\n            (pos\r\n              ? pos.index(cur) > -1\r\n              : // Don't pass non-elements to Sizzle\r\n                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))\r\n          ) {\r\n            matched.push(cur)\r\n            break\r\n          }\r\n        }\r\n      }\r\n\r\n      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)\r\n    },\r\n\r\n    // Determine the position of an element within the set\r\n    index: function (elem) {\r\n      // No argument, return index in parent\r\n      if (!elem) {\r\n        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1\r\n      }\r\n\r\n      // Index in selector\r\n      if (typeof elem === 'string') {\r\n        return indexOf.call(jQuery(elem), this[0])\r\n      }\r\n\r\n      // Locate the position of the desired element\r\n      return indexOf.call(\r\n        this,\r\n\r\n        // If it receives a jQuery object, the first element is used\r\n        elem.jquery ? elem[0] : elem\r\n      )\r\n    },\r\n\r\n    add: function (selector, context) {\r\n      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))\r\n    },\r\n\r\n    addBack: function (selector) {\r\n      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector))\r\n    }\r\n  })\r\n\r\n  function sibling (cur, dir) {\r\n    while ((cur = cur[dir]) && cur.nodeType !== 1) {}\r\n    return cur\r\n  }\r\n\r\n  jQuery.each(\r\n    {\r\n      parent: function (elem) {\r\n        var parent = elem.parentNode\r\n        return parent && parent.nodeType !== 11 ? parent : null\r\n      },\r\n      parents: function (elem) {\r\n        return dir(elem, 'parentNode')\r\n      },\r\n      parentsUntil: function (elem, i, until) {\r\n        return dir(elem, 'parentNode', until)\r\n      },\r\n      next: function (elem) {\r\n        return sibling(elem, 'nextSibling')\r\n      },\r\n      prev: function (elem) {\r\n        return sibling(elem, 'previousSibling')\r\n      },\r\n      nextAll: function (elem) {\r\n        return dir(elem, 'nextSibling')\r\n      },\r\n      prevAll: function (elem) {\r\n        return dir(elem, 'previousSibling')\r\n      },\r\n      nextUntil: function (elem, i, until) {\r\n        return dir(elem, 'nextSibling', until)\r\n      },\r\n      prevUntil: function (elem, i, until) {\r\n        return dir(elem, 'previousSibling', until)\r\n      },\r\n      siblings: function (elem) {\r\n        return siblings((elem.parentNode || {}).firstChild, elem)\r\n      },\r\n      children: function (elem) {\r\n        return siblings(elem.firstChild)\r\n      },\r\n      contents: function (elem) {\r\n        return elem.contentDocument || jQuery.merge([], elem.childNodes)\r\n      }\r\n    },\r\n    function (name, fn) {\r\n      jQuery.fn[name] = function (until, selector) {\r\n        var matched = jQuery.map(this, fn, until)\r\n\r\n        if (name.slice(-5) !== 'Until') {\r\n          selector = until\r\n        }\r\n\r\n        if (selector && typeof selector === 'string') {\r\n          matched = jQuery.filter(selector, matched)\r\n        }\r\n\r\n        if (this.length > 1) {\r\n          // Remove duplicates\r\n          if (!guaranteedUnique[name]) {\r\n            jQuery.uniqueSort(matched)\r\n          }\r\n\r\n          // Reverse order for parents* and prev-derivatives\r\n          if (rparentsprev.test(name)) {\r\n            matched.reverse()\r\n          }\r\n        }\r\n\r\n        return this.pushStack(matched)\r\n      }\r\n    }\r\n  )\r\n  var rnotwhite = /\\S+/g\r\n\r\n  // Convert String-formatted options into Object-formatted ones\r\n  function createOptions (options) {\r\n    var object = {}\r\n    jQuery.each(options.match(rnotwhite) || [], function (_, flag) {\r\n      object[flag] = true\r\n    })\r\n    return object\r\n  }\r\n\r\n  /*\r\n   * Create a callback list using the following parameters:\r\n   *\r\n   *\toptions: an optional list of space-separated options that will change how\r\n   *\t\t\tthe callback list behaves or a more traditional option object\r\n   *\r\n   * By default a callback list will act like an event callback list and can be\r\n   * \"fired\" multiple times.\r\n   *\r\n   * Possible options:\r\n   *\r\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\r\n   *\r\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\r\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\r\n   *\t\t\t\t\tvalues (like a Deferred)\r\n   *\r\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\r\n   *\r\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\r\n   *\r\n   */\r\n  jQuery.Callbacks = function (options) {\r\n    // Convert options from String-formatted to Object-formatted if needed\r\n    // (we check in cache first)\r\n    options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options)\r\n\r\n    var // Flag to know if list is currently firing\r\n      firing,\r\n      // Last fire value for non-forgettable lists\r\n      memory,\r\n      // Flag to know if list was already fired\r\n      fired,\r\n      // Flag to prevent firing\r\n      locked,\r\n      // Actual callback list\r\n      list = [],\r\n      // Queue of execution data for repeatable lists\r\n      queue = [],\r\n      // Index of currently firing callback (modified by add/remove as needed)\r\n      firingIndex = -1,\r\n      // Fire callbacks\r\n      fire = function () {\r\n        // Enforce single-firing\r\n        locked = options.once\r\n\r\n        // Execute callbacks for all pending executions,\r\n        // respecting firingIndex overrides and runtime changes\r\n        fired = firing = true\r\n        for (; queue.length; firingIndex = -1) {\r\n          memory = queue.shift()\r\n          while (++firingIndex < list.length) {\r\n            // Run callback and check for early termination\r\n            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\r\n              // Jump to end and forget the data so .add doesn't re-fire\r\n              firingIndex = list.length\r\n              memory = false\r\n            }\r\n          }\r\n        }\r\n\r\n        // Forget the data if we're done with it\r\n        if (!options.memory) {\r\n          memory = false\r\n        }\r\n\r\n        firing = false\r\n\r\n        // Clean up if we're done firing for good\r\n        if (locked) {\r\n          // Keep an empty list if we have data for future add calls\r\n          if (memory) {\r\n            list = []\r\n\r\n            // Otherwise, this object is spent\r\n          } else {\r\n            list = ''\r\n          }\r\n        }\r\n      },\r\n      // Actual Callbacks object\r\n      self = {\r\n        // Add a callback or a collection of callbacks to the list\r\n        add: function () {\r\n          if (list) {\r\n            // If we have memory from a past run, we should fire after adding\r\n            if (memory && !firing) {\r\n              firingIndex = list.length - 1\r\n              queue.push(memory)\r\n            }\r\n\r\n            ;(function add (args) {\r\n              jQuery.each(args, function (_, arg) {\r\n                if (jQuery.isFunction(arg)) {\r\n                  if (!options.unique || !self.has(arg)) {\r\n                    list.push(arg)\r\n                  }\r\n                } else if (arg && arg.length && jQuery.type(arg) !== 'string') {\r\n                  // Inspect recursively\r\n                  add(arg)\r\n                }\r\n              })\r\n            })(arguments)\r\n\r\n            if (memory && !firing) {\r\n              fire()\r\n            }\r\n          }\r\n          return this\r\n        },\r\n\r\n        // Remove a callback from the list\r\n        remove: function () {\r\n          jQuery.each(arguments, function (_, arg) {\r\n            var index\r\n            while ((index = jQuery.inArray(arg, list, index)) > -1) {\r\n              list.splice(index, 1)\r\n\r\n              // Handle firing indexes\r\n              if (index <= firingIndex) {\r\n                firingIndex--\r\n              }\r\n            }\r\n          })\r\n          return this\r\n        },\r\n\r\n        // Check if a given callback is in the list.\r\n        // If no argument is given, return whether or not list has callbacks attached.\r\n        has: function (fn) {\r\n          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0\r\n        },\r\n\r\n        // Remove all callbacks from the list\r\n        empty: function () {\r\n          if (list) {\r\n            list = []\r\n          }\r\n          return this\r\n        },\r\n\r\n        // Disable .fire and .add\r\n        // Abort any current/pending executions\r\n        // Clear all callbacks and values\r\n        disable: function () {\r\n          locked = queue = []\r\n          list = memory = ''\r\n          return this\r\n        },\r\n        disabled: function () {\r\n          return !list\r\n        },\r\n\r\n        // Disable .fire\r\n        // Also disable .add unless we have memory (since it would have no effect)\r\n        // Abort any pending executions\r\n        lock: function () {\r\n          locked = queue = []\r\n          if (!memory) {\r\n            list = memory = ''\r\n          }\r\n          return this\r\n        },\r\n        locked: function () {\r\n          return !!locked\r\n        },\r\n\r\n        // Call all callbacks with the given context and arguments\r\n        fireWith: function (context, args) {\r\n          if (!locked) {\r\n            args = args || []\r\n            args = [context, args.slice ? args.slice() : args]\r\n            queue.push(args)\r\n            if (!firing) {\r\n              fire()\r\n            }\r\n          }\r\n          return this\r\n        },\r\n\r\n        // Call all the callbacks with the given arguments\r\n        fire: function () {\r\n          self.fireWith(this, arguments)\r\n          return this\r\n        },\r\n\r\n        // To know if the callbacks have already been called at least once\r\n        fired: function () {\r\n          return !!fired\r\n        }\r\n      }\r\n\r\n    return self\r\n  }\r\n\r\n  jQuery.extend({\r\n    Deferred: function (func) {\r\n      var tuples = [\r\n          // action, add listener, listener list, final state\r\n          ['resolve', 'done', jQuery.Callbacks('once memory'), 'resolved'],\r\n          ['reject', 'fail', jQuery.Callbacks('once memory'), 'rejected'],\r\n          ['notify', 'progress', jQuery.Callbacks('memory')]\r\n        ],\r\n        state = 'pending',\r\n        promise = {\r\n          state: function () {\r\n            return state\r\n          },\r\n          always: function () {\r\n            deferred.done(arguments).fail(arguments)\r\n            return this\r\n          },\r\n          then: function (/* fnDone, fnFail, fnProgress */) {\r\n            var fns = arguments\r\n            return jQuery\r\n              .Deferred(function (newDefer) {\r\n                jQuery.each(tuples, function (i, tuple) {\r\n                  var fn = jQuery.isFunction(fns[i]) && fns[i]\r\n\r\n                  // deferred[ done | fail | progress ] for forwarding actions to newDefer\r\n                  deferred[tuple[1]](function () {\r\n                    var returned = fn && fn.apply(this, arguments)\r\n                    if (returned && jQuery.isFunction(returned.promise)) {\r\n                      returned\r\n                        .promise()\r\n                        .progress(newDefer.notify)\r\n                        .done(newDefer.resolve)\r\n                        .fail(newDefer.reject)\r\n                    } else {\r\n                      newDefer[tuple[0] + 'With'](\r\n                        this === promise ? newDefer.promise() : this,\r\n                        fn ? [returned] : arguments\r\n                      )\r\n                    }\r\n                  })\r\n                })\r\n                fns = null\r\n              })\r\n              .promise()\r\n          },\r\n\r\n          // Get a promise for this deferred\r\n          // If obj is provided, the promise aspect is added to the object\r\n          promise: function (obj) {\r\n            return obj != null ? jQuery.extend(obj, promise) : promise\r\n          }\r\n        },\r\n        deferred = {}\r\n\r\n      // Keep pipe for back-compat\r\n      promise.pipe = promise.then\r\n\r\n      // Add list-specific methods\r\n      jQuery.each(tuples, function (i, tuple) {\r\n        var list = tuple[2],\r\n          stateString = tuple[3]\r\n\r\n        // promise[ done | fail | progress ] = list.add\r\n        promise[tuple[1]] = list.add\r\n\r\n        // Handle state\r\n        if (stateString) {\r\n          list.add(\r\n            function () {\r\n              // state = [ resolved | rejected ]\r\n              state = stateString\r\n\r\n              // [ reject_list | resolve_list ].disable; progress_list.lock\r\n            },\r\n            tuples[i ^ 1][2].disable,\r\n            tuples[2][2].lock\r\n          )\r\n        }\r\n\r\n        // deferred[ resolve | reject | notify ]\r\n        deferred[tuple[0]] = function () {\r\n          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments)\r\n          return this\r\n        }\r\n        deferred[tuple[0] + 'With'] = list.fireWith\r\n      })\r\n\r\n      // Make the deferred a promise\r\n      promise.promise(deferred)\r\n\r\n      // Call given func if any\r\n      if (func) {\r\n        func.call(deferred, deferred)\r\n      }\r\n\r\n      // All done!\r\n      return deferred\r\n    },\r\n\r\n    // Deferred helper\r\n    when: function (subordinate /* , ..., subordinateN */) {\r\n      var i = 0,\r\n        resolveValues = slice.call(arguments),\r\n        length = resolveValues.length,\r\n        // the count of uncompleted subordinates\r\n        remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,\r\n        // the master Deferred.\r\n        // If resolveValues consist of only a single Deferred, just use that.\r\n        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\r\n        // Update function for both resolve and progress values\r\n        updateFunc = function (i, contexts, values) {\r\n          return function (value) {\r\n            contexts[i] = this\r\n            values[i] = arguments.length > 1 ? slice.call(arguments) : value\r\n            if (values === progressValues) {\r\n              deferred.notifyWith(contexts, values)\r\n            } else if (!--remaining) {\r\n              deferred.resolveWith(contexts, values)\r\n            }\r\n          }\r\n        },\r\n        progressValues,\r\n        progressContexts,\r\n        resolveContexts\r\n\r\n      // Add listeners to Deferred subordinates; treat others as resolved\r\n      if (length > 1) {\r\n        progressValues = new Array(length)\r\n        progressContexts = new Array(length)\r\n        resolveContexts = new Array(length)\r\n        for (; i < length; i++) {\r\n          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\r\n            resolveValues[i]\r\n              .promise()\r\n              .progress(updateFunc(i, progressContexts, progressValues))\r\n              .done(updateFunc(i, resolveContexts, resolveValues))\r\n              .fail(deferred.reject)\r\n          } else {\r\n            --remaining\r\n          }\r\n        }\r\n      }\r\n\r\n      // If we're not waiting on anything, resolve the master\r\n      if (!remaining) {\r\n        deferred.resolveWith(resolveContexts, resolveValues)\r\n      }\r\n\r\n      return deferred.promise()\r\n    }\r\n  })\r\n\r\n  // The deferred used on DOM ready\r\n  var readyList\r\n\r\n  jQuery.fn.ready = function (fn) {\r\n    // Add the callback\r\n    jQuery.ready.promise().done(fn)\r\n\r\n    return this\r\n  }\r\n\r\n  jQuery.extend({\r\n    // Is the DOM ready to be used? Set to true once it occurs.\r\n    isReady: false,\r\n\r\n    // A counter to track how many items to wait for before\r\n    // the ready event fires. See #6781\r\n    readyWait: 1,\r\n\r\n    // Hold (or release) the ready event\r\n    holdReady: function (hold) {\r\n      if (hold) {\r\n        jQuery.readyWait++\r\n      } else {\r\n        jQuery.ready(true)\r\n      }\r\n    },\r\n\r\n    // Handle when the DOM is ready\r\n    ready: function (wait) {\r\n      // Abort if there are pending holds or we're already ready\r\n      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {\r\n        return\r\n      }\r\n\r\n      // Remember that the DOM is ready\r\n      jQuery.isReady = true\r\n\r\n      // If a normal DOM Ready event fired, decrement, and wait if need be\r\n      if (wait !== true && --jQuery.readyWait > 0) {\r\n        return\r\n      }\r\n\r\n      // If there are functions bound, to execute\r\n      readyList.resolveWith(document, [jQuery])\r\n\r\n      // Trigger any bound ready events\r\n      if (jQuery.fn.triggerHandler) {\r\n        jQuery(document).triggerHandler('ready')\r\n        jQuery(document).off('ready')\r\n      }\r\n    }\r\n  })\r\n\r\n  /**\r\n   * The ready event handler and self cleanup method\r\n   */\r\n  function completed () {\r\n    document.removeEventListener('DOMContentLoaded', completed)\r\n    window.removeEventListener('load', completed)\r\n    jQuery.ready()\r\n  }\r\n\r\n  jQuery.ready.promise = function (obj) {\r\n    if (!readyList) {\r\n      readyList = jQuery.Deferred()\r\n\r\n      // Catch cases where $(document).ready() is called\r\n      // after the browser event has already occurred.\r\n      // Support: IE9-10 only\r\n      // Older IE sometimes signals \"interactive\" too soon\r\n      if (\r\n        document.readyState === 'complete' ||\r\n        (document.readyState !== 'loading' && !document.documentElement.doScroll)\r\n      ) {\r\n        // Handle it asynchronously to allow scripts the opportunity to delay ready\r\n        window.setTimeout(jQuery.ready)\r\n      } else {\r\n        // Use the handy event callback\r\n        document.addEventListener('DOMContentLoaded', completed)\r\n\r\n        // A fallback to window.onload, that will always work\r\n        window.addEventListener('load', completed)\r\n      }\r\n    }\r\n    return readyList.promise(obj)\r\n  }\r\n\r\n  // Kick off the DOM ready check even if the user does not\r\n  jQuery.ready.promise()\r\n\r\n  // Multifunctional method to get and set values of a collection\r\n  // The value/s can optionally be executed if it's a function\r\n  var access = function (elems, fn, key, value, chainable, emptyGet, raw) {\r\n    var i = 0,\r\n      len = elems.length,\r\n      bulk = key == null\r\n\r\n    // Sets many values\r\n    if (jQuery.type(key) === 'object') {\r\n      chainable = true\r\n      for (i in key) {\r\n        access(elems, fn, i, key[i], true, emptyGet, raw)\r\n      }\r\n\r\n      // Sets one value\r\n    } else if (value !== undefined) {\r\n      chainable = true\r\n\r\n      if (!jQuery.isFunction(value)) {\r\n        raw = true\r\n      }\r\n\r\n      if (bulk) {\r\n        // Bulk operations run against the entire set\r\n        if (raw) {\r\n          fn.call(elems, value)\r\n          fn = null\r\n\r\n          // ...except when executing function values\r\n        } else {\r\n          bulk = fn\r\n          fn = function (elem, key, value) {\r\n            return bulk.call(jQuery(elem), value)\r\n          }\r\n        }\r\n      }\r\n\r\n      if (fn) {\r\n        for (; i < len; i++) {\r\n          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)))\r\n        }\r\n      }\r\n    }\r\n\r\n    return chainable\r\n      ? elems\r\n      : // Gets\r\n      bulk\r\n      ? fn.call(elems)\r\n      : len\r\n      ? fn(elems[0], key)\r\n      : emptyGet\r\n  }\r\n  var acceptData = function (owner) {\r\n    // Accepts only:\r\n    //  - Node\r\n    //    - Node.ELEMENT_NODE\r\n    //    - Node.DOCUMENT_NODE\r\n    //  - Object\r\n    //    - Any\r\n    /* jshint -W018 */\r\n    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType\r\n  }\r\n\r\n  function Data () {\r\n    this.expando = jQuery.expando + Data.uid++\r\n  }\r\n\r\n  Data.uid = 1\r\n\r\n  Data.prototype = {\r\n    register: function (owner, initial) {\r\n      var value = initial || {}\r\n\r\n      // If it is a node unlikely to be stringify-ed or looped over\r\n      // use plain assignment\r\n      if (owner.nodeType) {\r\n        owner[this.expando] = value\r\n\r\n        // Otherwise secure it in a non-enumerable, non-writable property\r\n        // configurability must be true to allow the property to be\r\n        // deleted with the delete operator\r\n      } else {\r\n        Object.defineProperty(owner, this.expando, {\r\n          value: value,\r\n          writable: true,\r\n          configurable: true\r\n        })\r\n      }\r\n      return owner[this.expando]\r\n    },\r\n    cache: function (owner) {\r\n      // We can accept data for non-element nodes in modern browsers,\r\n      // but we should not, see #8335.\r\n      // Always return an empty object.\r\n      if (!acceptData(owner)) {\r\n        return {}\r\n      }\r\n\r\n      // Check if the owner object already has a cache\r\n      var value = owner[this.expando]\r\n\r\n      // If not, create one\r\n      if (!value) {\r\n        value = {}\r\n\r\n        // We can accept data for non-element nodes in modern browsers,\r\n        // but we should not, see #8335.\r\n        // Always return an empty object.\r\n        if (acceptData(owner)) {\r\n          // If it is a node unlikely to be stringify-ed or looped over\r\n          // use plain assignment\r\n          if (owner.nodeType) {\r\n            owner[this.expando] = value\r\n\r\n            // Otherwise secure it in a non-enumerable property\r\n            // configurable must be true to allow the property to be\r\n            // deleted when data is removed\r\n          } else {\r\n            Object.defineProperty(owner, this.expando, {\r\n              value: value,\r\n              configurable: true\r\n            })\r\n          }\r\n        }\r\n      }\r\n\r\n      return value\r\n    },\r\n    set: function (owner, data, value) {\r\n      var prop,\r\n        cache = this.cache(owner)\r\n\r\n      // Handle: [ owner, key, value ] args\r\n      if (typeof data === 'string') {\r\n        cache[data] = value\r\n\r\n        // Handle: [ owner, { properties } ] args\r\n      } else {\r\n        // Copy the properties one-by-one to the cache object\r\n        for (prop in data) {\r\n          cache[prop] = data[prop]\r\n        }\r\n      }\r\n      return cache\r\n    },\r\n    get: function (owner, key) {\r\n      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key]\r\n    },\r\n    access: function (owner, key, value) {\r\n      var stored\r\n\r\n      // In cases where either:\r\n      //\r\n      //   1. No key was specified\r\n      //   2. A string key was specified, but no value provided\r\n      //\r\n      // Take the \"read\" path and allow the get method to determine\r\n      // which value to return, respectively either:\r\n      //\r\n      //   1. The entire cache object\r\n      //   2. The data stored at the key\r\n      //\r\n      if (key === undefined || (key && typeof key === 'string' && value === undefined)) {\r\n        stored = this.get(owner, key)\r\n\r\n        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key))\r\n      }\r\n\r\n      // When the key is not a string, or both a key and value\r\n      // are specified, set or extend (existing objects) with either:\r\n      //\r\n      //   1. An object of properties\r\n      //   2. A key and value\r\n      //\r\n      this.set(owner, key, value)\r\n\r\n      // Since the \"set\" path can have two possible entry points\r\n      // return the expected data based on which path was taken[*]\r\n      return value !== undefined ? value : key\r\n    },\r\n    remove: function (owner, key) {\r\n      var i,\r\n        name,\r\n        camel,\r\n        cache = owner[this.expando]\r\n\r\n      if (cache === undefined) {\r\n        return\r\n      }\r\n\r\n      if (key === undefined) {\r\n        this.register(owner)\r\n      } else {\r\n        // Support array or space separated string of keys\r\n        if (jQuery.isArray(key)) {\r\n          // If \"name\" is an array of keys...\r\n          // When data is initially created, via (\"key\", \"val\") signature,\r\n          // keys will be converted to camelCase.\r\n          // Since there is no way to tell _how_ a key was added, remove\r\n          // both plain key and camelCase key. #12786\r\n          // This will only penalize the array argument path.\r\n          name = key.concat(key.map(jQuery.camelCase))\r\n        } else {\r\n          camel = jQuery.camelCase(key)\r\n\r\n          // Try the string as a key before any manipulation\r\n          if (key in cache) {\r\n            name = [key, camel]\r\n          } else {\r\n            // If a key with the spaces exists, use it.\r\n            // Otherwise, create an array by matching non-whitespace\r\n            name = camel\r\n            name = name in cache ? [name] : name.match(rnotwhite) || []\r\n          }\r\n        }\r\n\r\n        i = name.length\r\n\r\n        while (i--) {\r\n          delete cache[name[i]]\r\n        }\r\n      }\r\n\r\n      // Remove the expando if there's no more data\r\n      if (key === undefined || jQuery.isEmptyObject(cache)) {\r\n        // Support: Chrome <= 35-45+\r\n        // Webkit & Blink performance suffers when deleting properties\r\n        // from DOM nodes, so set to undefined instead\r\n        // https://code.google.com/p/chromium/issues/detail?id=378607\r\n        if (owner.nodeType) {\r\n          owner[this.expando] = undefined\r\n        } else {\r\n          delete owner[this.expando]\r\n        }\r\n      }\r\n    },\r\n    hasData: function (owner) {\r\n      var cache = owner[this.expando]\r\n      return cache !== undefined && !jQuery.isEmptyObject(cache)\r\n    }\r\n  }\r\n  var dataPriv = new Data()\r\n\r\n  var dataUser = new Data()\r\n\r\n  //\tImplementation Summary\r\n  //\r\n  //\t1. Enforce API surface and semantic compatibility with 1.9.x branch\r\n  //\t2. Improve the module's maintainability by reducing the storage\r\n  //\t\tpaths to a single mechanism.\r\n  //\t3. Use the same single mechanism to support \"private\" and \"user\" data.\r\n  //\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\r\n  //\t5. Avoid exposing implementation details on user objects (eg. expando properties)\r\n  //\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\r\n\r\n  var rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\r\n    rmultiDash = /[A-Z]/g\r\n\r\n  function dataAttr (elem, key, data) {\r\n    var name\r\n\r\n    // If nothing was found internally, try to fetch any\r\n    // data from the HTML5 data-* attribute\r\n    if (data === undefined && elem.nodeType === 1) {\r\n      name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase()\r\n      data = elem.getAttribute(name)\r\n\r\n      if (typeof data === 'string') {\r\n        try {\r\n          data =\r\n            data === 'true'\r\n              ? true\r\n              : data === 'false'\r\n              ? false\r\n              : data === 'null'\r\n              ? null\r\n              : // Only convert to a number if it doesn't change the string\r\n              +data + '' === data\r\n              ? +data\r\n              : rbrace.test(data)\r\n              ? jQuery.parseJSON(data)\r\n              : data\r\n        } catch (e) {}\r\n\r\n        // Make sure we set the data so it isn't changed later\r\n        dataUser.set(elem, key, data)\r\n      } else {\r\n        data = undefined\r\n      }\r\n    }\r\n    return data\r\n  }\r\n\r\n  jQuery.extend({\r\n    hasData: function (elem) {\r\n      return dataUser.hasData(elem) || dataPriv.hasData(elem)\r\n    },\r\n\r\n    data: function (elem, name, data) {\r\n      return dataUser.access(elem, name, data)\r\n    },\r\n\r\n    removeData: function (elem, name) {\r\n      dataUser.remove(elem, name)\r\n    },\r\n\r\n    // TODO: Now that all calls to _data and _removeData have been replaced\r\n    // with direct calls to dataPriv methods, these can be deprecated.\r\n    _data: function (elem, name, data) {\r\n      return dataPriv.access(elem, name, data)\r\n    },\r\n\r\n    _removeData: function (elem, name) {\r\n      dataPriv.remove(elem, name)\r\n    }\r\n  })\r\n\r\n  jQuery.fn.extend({\r\n    data: function (key, value) {\r\n      var i,\r\n        name,\r\n        data,\r\n        elem = this[0],\r\n        attrs = elem && elem.attributes\r\n\r\n      // Gets all values\r\n      if (key === undefined) {\r\n        if (this.length) {\r\n          data = dataUser.get(elem)\r\n\r\n          if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {\r\n            i = attrs.length\r\n            while (i--) {\r\n              // Support: IE11+\r\n              // The attrs elements can be null (#14894)\r\n              if (attrs[i]) {\r\n                name = attrs[i].name\r\n                if (name.indexOf('data-') === 0) {\r\n                  name = jQuery.camelCase(name.slice(5))\r\n                  dataAttr(elem, name, data[name])\r\n                }\r\n              }\r\n            }\r\n            dataPriv.set(elem, 'hasDataAttrs', true)\r\n          }\r\n        }\r\n\r\n        return data\r\n      }\r\n\r\n      // Sets multiple values\r\n      if (typeof key === 'object') {\r\n        return this.each(function () {\r\n          dataUser.set(this, key)\r\n        })\r\n      }\r\n\r\n      return access(\r\n        this,\r\n        function (value) {\r\n          var data, camelKey\r\n\r\n          // The calling jQuery object (element matches) is not empty\r\n          // (and therefore has an element appears at this[ 0 ]) and the\r\n          // `value` parameter was not undefined. An empty jQuery object\r\n          // will result in `undefined` for elem = this[ 0 ] which will\r\n          // throw an exception if an attempt to read a data cache is made.\r\n          if (elem && value === undefined) {\r\n            // Attempt to get data from the cache\r\n            // with the key as-is\r\n            data =\r\n              dataUser.get(elem, key) ||\r\n              // Try to find dashed key if it exists (gh-2779)\r\n              // This is for 2.2.x only\r\n              dataUser.get(elem, key.replace(rmultiDash, '-$&').toLowerCase())\r\n\r\n            if (data !== undefined) {\r\n              return data\r\n            }\r\n\r\n            camelKey = jQuery.camelCase(key)\r\n\r\n            // Attempt to get data from the cache\r\n            // with the key camelized\r\n            data = dataUser.get(elem, camelKey)\r\n            if (data !== undefined) {\r\n              return data\r\n            }\r\n\r\n            // Attempt to \"discover\" the data in\r\n            // HTML5 custom data-* attrs\r\n            data = dataAttr(elem, camelKey, undefined)\r\n            if (data !== undefined) {\r\n              return data\r\n            }\r\n\r\n            // We tried really hard, but the data doesn't exist.\r\n            return\r\n          }\r\n\r\n          // Set the data...\r\n          camelKey = jQuery.camelCase(key)\r\n          this.each(function () {\r\n            // First, attempt to store a copy or reference of any\r\n            // data that might've been store with a camelCased key.\r\n            var data = dataUser.get(this, camelKey)\r\n\r\n            // For HTML5 data-* attribute interop, we have to\r\n            // store property names with dashes in a camelCase form.\r\n            // This might not apply to all properties...*\r\n            dataUser.set(this, camelKey, value)\r\n\r\n            // *... In the case of properties that might _actually_\r\n            // have dashes, we need to also store a copy of that\r\n            // unchanged property.\r\n            if (key.indexOf('-') > -1 && data !== undefined) {\r\n              dataUser.set(this, key, value)\r\n            }\r\n          })\r\n        },\r\n        null,\r\n        value,\r\n        arguments.length > 1,\r\n        null,\r\n        true\r\n      )\r\n    },\r\n\r\n    removeData: function (key) {\r\n      return this.each(function () {\r\n        dataUser.remove(this, key)\r\n      })\r\n    }\r\n  })\r\n\r\n  jQuery.extend({\r\n    queue: function (elem, type, data) {\r\n      var queue\r\n\r\n      if (elem) {\r\n        type = (type || 'fx') + 'queue'\r\n        queue = dataPriv.get(elem, type)\r\n\r\n        // Speed up dequeue by getting out quickly if this is just a lookup\r\n        if (data) {\r\n          if (!queue || jQuery.isArray(data)) {\r\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data))\r\n          } else {\r\n            queue.push(data)\r\n          }\r\n        }\r\n        return queue || []\r\n      }\r\n    },\r\n\r\n    dequeue: function (elem, type) {\r\n      type = type || 'fx'\r\n\r\n      var queue = jQuery.queue(elem, type),\r\n        startLength = queue.length,\r\n        fn = queue.shift(),\r\n        hooks = jQuery._queueHooks(elem, type),\r\n        next = function () {\r\n          jQuery.dequeue(elem, type)\r\n        }\r\n\r\n      // If the fx queue is dequeued, always remove the progress sentinel\r\n      if (fn === 'inprogress') {\r\n        fn = queue.shift()\r\n        startLength--\r\n      }\r\n\r\n      if (fn) {\r\n        // Add a progress sentinel to prevent the fx queue from being\r\n        // automatically dequeued\r\n        if (type === 'fx') {\r\n          queue.unshift('inprogress')\r\n        }\r\n\r\n        // Clear up the last queue stop function\r\n        delete hooks.stop\r\n        fn.call(elem, next, hooks)\r\n      }\r\n\r\n      if (!startLength && hooks) {\r\n        hooks.empty.fire()\r\n      }\r\n    },\r\n\r\n    // Not public - generate a queueHooks object, or return the current one\r\n    _queueHooks: function (elem, type) {\r\n      var key = type + 'queueHooks'\r\n      return (\r\n        dataPriv.get(elem, key) ||\r\n        dataPriv.access(elem, key, {\r\n          empty: jQuery.Callbacks('once memory').add(function () {\r\n            dataPriv.remove(elem, [type + 'queue', key])\r\n          })\r\n        })\r\n      )\r\n    }\r\n  })\r\n\r\n  jQuery.fn.extend({\r\n    queue: function (type, data) {\r\n      var setter = 2\r\n\r\n      if (typeof type !== 'string') {\r\n        data = type\r\n        type = 'fx'\r\n        setter--\r\n      }\r\n\r\n      if (arguments.length < setter) {\r\n        return jQuery.queue(this[0], type)\r\n      }\r\n\r\n      return data === undefined\r\n        ? this\r\n        : this.each(function () {\r\n            var queue = jQuery.queue(this, type, data)\r\n\r\n            // Ensure a hooks for this queue\r\n            jQuery._queueHooks(this, type)\r\n\r\n            if (type === 'fx' && queue[0] !== 'inprogress') {\r\n              jQuery.dequeue(this, type)\r\n            }\r\n          })\r\n    },\r\n    dequeue: function (type) {\r\n      return this.each(function () {\r\n        jQuery.dequeue(this, type)\r\n      })\r\n    },\r\n    clearQueue: function (type) {\r\n      return this.queue(type || 'fx', [])\r\n    },\r\n\r\n    // Get a promise resolved when queues of a certain type\r\n    // are emptied (fx is the type by default)\r\n    promise: function (type, obj) {\r\n      var tmp,\r\n        count = 1,\r\n        defer = jQuery.Deferred(),\r\n        elements = this,\r\n        i = this.length,\r\n        resolve = function () {\r\n          if (!--count) {\r\n            defer.resolveWith(elements, [elements])\r\n          }\r\n        }\r\n\r\n      if (typeof type !== 'string') {\r\n        obj = type\r\n        type = undefined\r\n      }\r\n      type = type || 'fx'\r\n\r\n      while (i--) {\r\n        tmp = dataPriv.get(elements[i], type + 'queueHooks')\r\n        if (tmp && tmp.empty) {\r\n          count++\r\n          tmp.empty.add(resolve)\r\n        }\r\n      }\r\n      resolve()\r\n      return defer.promise(obj)\r\n    }\r\n  })\r\n  var pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source\r\n\r\n  var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i')\r\n\r\n  var cssExpand = ['Top', 'Right', 'Bottom', 'Left']\r\n\r\n  var isHidden = function (elem, el) {\r\n    // isHidden might be called from jQuery#filter function;\r\n    // in that case, element will be second argument\r\n    elem = el || elem\r\n    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem)\r\n  }\r\n\r\n  function adjustCSS (elem, prop, valueParts, tween) {\r\n    var adjusted,\r\n      scale = 1,\r\n      maxIterations = 20,\r\n      currentValue = tween\r\n        ? function () {\r\n            return tween.cur()\r\n          }\r\n        : function () {\r\n            return jQuery.css(elem, prop, '')\r\n          },\r\n      initial = currentValue(),\r\n      unit = (valueParts && valueParts[3]) || (jQuery.cssNumber[prop] ? '' : 'px'),\r\n      // Starting value computation is required for potential unit mismatches\r\n      initialInUnit = (jQuery.cssNumber[prop] || (unit !== 'px' && +initial)) && rcssNum.exec(jQuery.css(elem, prop))\r\n\r\n    if (initialInUnit && initialInUnit[3] !== unit) {\r\n      // Trust units reported by jQuery.css\r\n      unit = unit || initialInUnit[3]\r\n\r\n      // Make sure we update the tween properties later on\r\n      valueParts = valueParts || []\r\n\r\n      // Iteratively approximate from a nonzero starting point\r\n      initialInUnit = +initial || 1\r\n\r\n      do {\r\n        // If previous iteration zeroed out, double until we get *something*.\r\n        // Use string for doubling so we don't accidentally see scale as unchanged below\r\n        scale = scale || '.5'\r\n\r\n        // Adjust and apply\r\n        initialInUnit = initialInUnit / scale\r\n        jQuery.style(elem, prop, initialInUnit + unit)\r\n\r\n        // Update scale, tolerating zero or NaN from tween.cur()\r\n        // Break the loop if scale is unchanged or perfect, or if we've just had enough.\r\n      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations)\r\n    }\r\n\r\n    if (valueParts) {\r\n      initialInUnit = +initialInUnit || +initial || 0\r\n\r\n      // Apply relative offset (+=/-=) if specified\r\n      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2]\r\n      if (tween) {\r\n        tween.unit = unit\r\n        tween.start = initialInUnit\r\n        tween.end = adjusted\r\n      }\r\n    }\r\n    return adjusted\r\n  }\r\n  var rcheckableType = /^(?:checkbox|radio)$/i\r\n\r\n  var rtagName = /<([\\w:-]+)/\r\n\r\n  var rscriptType = /^$|\\/(?:java|ecma)script/i\r\n\r\n  // We have to close these tags to support XHTML (#13200)\r\n  var wrapMap = {\r\n    // Support: IE9\r\n    option: [1, \"<select multiple='multiple'>\", '</select>'],\r\n\r\n    // XHTML parsers do not magically insert elements in the\r\n    // same way that tag soup parsers do. So we cannot shorten\r\n    // this by omitting <tbody> or other required elements.\r\n    thead: [1, '<table>', '</table>'],\r\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\r\n    tr: [2, '<table><tbody>', '</tbody></table>'],\r\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\r\n\r\n    _default: [0, '', '']\r\n  }\r\n\r\n  // Support: IE9\r\n  wrapMap.optgroup = wrapMap.option\r\n\r\n  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead\r\n  wrapMap.th = wrapMap.td\r\n\r\n  function getAll (context, tag) {\r\n    // Support: IE9-11+\r\n    // Use typeof to avoid zero-argument method invocation on host objects (#15151)\r\n    var ret =\r\n      typeof context.getElementsByTagName !== 'undefined'\r\n        ? context.getElementsByTagName(tag || '*')\r\n        : typeof context.querySelectorAll !== 'undefined'\r\n        ? context.querySelectorAll(tag || '*')\r\n        : []\r\n\r\n    return tag === undefined || (tag && jQuery.nodeName(context, tag)) ? jQuery.merge([context], ret) : ret\r\n  }\r\n\r\n  // Mark scripts as having already been evaluated\r\n  function setGlobalEval (elems, refElements) {\r\n    var i = 0,\r\n      l = elems.length\r\n\r\n    for (; i < l; i++) {\r\n      dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'))\r\n    }\r\n  }\r\n\r\n  var rhtml = /<|&#?\\w+;/\r\n\r\n  function buildFragment (elems, context, scripts, selection, ignored) {\r\n    var elem,\r\n      tmp,\r\n      tag,\r\n      wrap,\r\n      contains,\r\n      j,\r\n      fragment = context.createDocumentFragment(),\r\n      nodes = [],\r\n      i = 0,\r\n      l = elems.length\r\n\r\n    for (; i < l; i++) {\r\n      elem = elems[i]\r\n\r\n      if (elem || elem === 0) {\r\n        // Add nodes directly\r\n        if (jQuery.type(elem) === 'object') {\r\n          // Support: Android<4.1, PhantomJS<2\r\n          // push.apply(_, arraylike) throws on ancient WebKit\r\n          jQuery.merge(nodes, elem.nodeType ? [elem] : elem)\r\n\r\n          // Convert non-html into a text node\r\n        } else if (!rhtml.test(elem)) {\r\n          nodes.push(context.createTextNode(elem))\r\n\r\n          // Convert html into DOM nodes\r\n        } else {\r\n          tmp = tmp || fragment.appendChild(context.createElement('div'))\r\n\r\n          // Deserialize a standard representation\r\n          tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase()\r\n          wrap = wrapMap[tag] || wrapMap._default\r\n          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]\r\n\r\n          // Descend through wrappers to the right content\r\n          j = wrap[0]\r\n          while (j--) {\r\n            tmp = tmp.lastChild\r\n          }\r\n\r\n          // Support: Android<4.1, PhantomJS<2\r\n          // push.apply(_, arraylike) throws on ancient WebKit\r\n          jQuery.merge(nodes, tmp.childNodes)\r\n\r\n          // Remember the top-level container\r\n          tmp = fragment.firstChild\r\n\r\n          // Ensure the created nodes are orphaned (#12392)\r\n          tmp.textContent = ''\r\n        }\r\n      }\r\n    }\r\n\r\n    // Remove wrapper from fragment\r\n    fragment.textContent = ''\r\n\r\n    i = 0\r\n    while ((elem = nodes[i++])) {\r\n      // Skip elements already in the context collection (trac-4087)\r\n      if (selection && jQuery.inArray(elem, selection) > -1) {\r\n        if (ignored) {\r\n          ignored.push(elem)\r\n        }\r\n        continue\r\n      }\r\n\r\n      contains = jQuery.contains(elem.ownerDocument, elem)\r\n\r\n      // Append to fragment\r\n      tmp = getAll(fragment.appendChild(elem), 'script')\r\n\r\n      // Preserve script evaluation history\r\n      if (contains) {\r\n        setGlobalEval(tmp)\r\n      }\r\n\r\n      // Capture executables\r\n      if (scripts) {\r\n        j = 0\r\n        while ((elem = tmp[j++])) {\r\n          if (rscriptType.test(elem.type || '')) {\r\n            scripts.push(elem)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return fragment\r\n  }\r\n\r\n  ;(function () {\r\n    var fragment = document.createDocumentFragment(),\r\n      div = fragment.appendChild(document.createElement('div')),\r\n      input = document.createElement('input')\r\n\r\n    // Support: Android 4.0-4.3, Safari<=5.1\r\n    // Check state lost if the name is set (#11217)\r\n    // Support: Windows Web Apps (WWA)\r\n    // `name` and `type` must use .setAttribute for WWA (#14901)\r\n    input.setAttribute('type', 'radio')\r\n    input.setAttribute('checked', 'checked')\r\n    input.setAttribute('name', 't')\r\n\r\n    div.appendChild(input)\r\n\r\n    // Support: Safari<=5.1, Android<4.2\r\n    // Older WebKit doesn't clone checked state correctly in fragments\r\n    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked\r\n\r\n    // Support: IE<=11+\r\n    // Make sure textarea (and checkbox) defaultValue is properly cloned\r\n    div.innerHTML = '<textarea>x</textarea>'\r\n    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue\r\n  })()\r\n\r\n  var rkeyEvent = /^key/,\r\n    rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\r\n    rtypenamespace = /^([^.]*)(?:\\.(.+)|)/\r\n\r\n  function returnTrue () {\r\n    return true\r\n  }\r\n\r\n  function returnFalse () {\r\n    return false\r\n  }\r\n\r\n  // Support: IE9\r\n  // See #13393 for more info\r\n  function safeActiveElement () {\r\n    try {\r\n      return document.activeElement\r\n    } catch (err) {}\r\n  }\r\n\r\n  function on (elem, types, selector, data, fn, one) {\r\n    var origFn, type\r\n\r\n    // Types can be a map of types/handlers\r\n    if (typeof types === 'object') {\r\n      // ( types-Object, selector, data )\r\n      if (typeof selector !== 'string') {\r\n        // ( types-Object, data )\r\n        data = data || selector\r\n        selector = undefined\r\n      }\r\n      for (type in types) {\r\n        on(elem, type, selector, data, types[type], one)\r\n      }\r\n      return elem\r\n    }\r\n\r\n    if (data == null && fn == null) {\r\n      // ( types, fn )\r\n      fn = selector\r\n      data = selector = undefined\r\n    } else if (fn == null) {\r\n      if (typeof selector === 'string') {\r\n        // ( types, selector, fn )\r\n        fn = data\r\n        data = undefined\r\n      } else {\r\n        // ( types, data, fn )\r\n        fn = data\r\n        data = selector\r\n        selector = undefined\r\n      }\r\n    }\r\n    if (fn === false) {\r\n      fn = returnFalse\r\n    } else if (!fn) {\r\n      return elem\r\n    }\r\n\r\n    if (one === 1) {\r\n      origFn = fn\r\n      fn = function (event) {\r\n        // Can use an empty set, since event contains the info\r\n        jQuery().off(event)\r\n        return origFn.apply(this, arguments)\r\n      }\r\n\r\n      // Use same guid so caller can remove using origFn\r\n      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)\r\n    }\r\n    return elem.each(function () {\r\n      jQuery.event.add(this, types, fn, data, selector)\r\n    })\r\n  }\r\n\r\n  /*\r\n   * Helper functions for managing events -- not part of the public interface.\r\n   * Props to Dean Edwards' addEvent library for many of the ideas.\r\n   */\r\n  jQuery.event = {\r\n    global: {},\r\n\r\n    add: function (elem, types, handler, data, selector) {\r\n      var handleObjIn,\r\n        eventHandle,\r\n        tmp,\r\n        events,\r\n        t,\r\n        handleObj,\r\n        special,\r\n        handlers,\r\n        type,\r\n        namespaces,\r\n        origType,\r\n        elemData = dataPriv.get(elem)\r\n\r\n      // Don't attach events to noData or text/comment nodes (but allow plain objects)\r\n      if (!elemData) {\r\n        return\r\n      }\r\n\r\n      // Caller can pass in an object of custom data in lieu of the handler\r\n      if (handler.handler) {\r\n        handleObjIn = handler\r\n        handler = handleObjIn.handler\r\n        selector = handleObjIn.selector\r\n      }\r\n\r\n      // Make sure that the handler has a unique ID, used to find/remove it later\r\n      if (!handler.guid) {\r\n        handler.guid = jQuery.guid++\r\n      }\r\n\r\n      // Init the element's event structure and main handler, if this is the first\r\n      if (!(events = elemData.events)) {\r\n        events = elemData.events = {}\r\n      }\r\n      if (!(eventHandle = elemData.handle)) {\r\n        eventHandle = elemData.handle = function (e) {\r\n          // Discard the second event of a jQuery.event.trigger() and\r\n          // when an event is called after a page has unloaded\r\n          return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type\r\n            ? jQuery.event.dispatch.apply(elem, arguments)\r\n            : undefined\r\n        }\r\n      }\r\n\r\n      // Handle multiple events separated by a space\r\n      types = (types || '').match(rnotwhite) || ['']\r\n      t = types.length\r\n      while (t--) {\r\n        tmp = rtypenamespace.exec(types[t]) || []\r\n        type = origType = tmp[1]\r\n        namespaces = (tmp[2] || '').split('.').sort()\r\n\r\n        // There *must* be a type, no attaching namespace-only handlers\r\n        if (!type) {\r\n          continue\r\n        }\r\n\r\n        // If event changes its type, use the special event handlers for the changed type\r\n        special = jQuery.event.special[type] || {}\r\n\r\n        // If selector defined, determine special event api type, otherwise given type\r\n        type = (selector ? special.delegateType : special.bindType) || type\r\n\r\n        // Update special based on newly reset type\r\n        special = jQuery.event.special[type] || {}\r\n\r\n        // handleObj is passed to all event handlers\r\n        handleObj = jQuery.extend(\r\n          {\r\n            type: type,\r\n            origType: origType,\r\n            data: data,\r\n            handler: handler,\r\n            guid: handler.guid,\r\n            selector: selector,\r\n            needsContext: selector && jQuery.expr.match.needsContext.test(selector),\r\n            namespace: namespaces.join('.')\r\n          },\r\n          handleObjIn\r\n        )\r\n\r\n        // Init the event handler queue if we're the first\r\n        if (!(handlers = events[type])) {\r\n          handlers = events[type] = []\r\n          handlers.delegateCount = 0\r\n\r\n          // Only use addEventListener if the special events handler returns false\r\n          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {\r\n            if (elem.addEventListener) {\r\n              elem.addEventListener(type, eventHandle)\r\n            }\r\n          }\r\n        }\r\n\r\n        if (special.add) {\r\n          special.add.call(elem, handleObj)\r\n\r\n          if (!handleObj.handler.guid) {\r\n            handleObj.handler.guid = handler.guid\r\n          }\r\n        }\r\n\r\n        // Add to the element's handler list, delegates in front\r\n        if (selector) {\r\n          handlers.splice(handlers.delegateCount++, 0, handleObj)\r\n        } else {\r\n          handlers.push(handleObj)\r\n        }\r\n\r\n        // Keep track of which events have ever been used, for event optimization\r\n        jQuery.event.global[type] = true\r\n      }\r\n    },\r\n\r\n    // Detach an event or set of events from an element\r\n    remove: function (elem, types, handler, selector, mappedTypes) {\r\n      var j,\r\n        origCount,\r\n        tmp,\r\n        events,\r\n        t,\r\n        handleObj,\r\n        special,\r\n        handlers,\r\n        type,\r\n        namespaces,\r\n        origType,\r\n        elemData = dataPriv.hasData(elem) && dataPriv.get(elem)\r\n\r\n      if (!elemData || !(events = elemData.events)) {\r\n        return\r\n      }\r\n\r\n      // Once for each type.namespace in types; type may be omitted\r\n      types = (types || '').match(rnotwhite) || ['']\r\n      t = types.length\r\n      while (t--) {\r\n        tmp = rtypenamespace.exec(types[t]) || []\r\n        type = origType = tmp[1]\r\n        namespaces = (tmp[2] || '').split('.').sort()\r\n\r\n        // Unbind all events (on this namespace, if provided) for the element\r\n        if (!type) {\r\n          for (type in events) {\r\n            jQuery.event.remove(elem, type + types[t], handler, selector, true)\r\n          }\r\n          continue\r\n        }\r\n\r\n        special = jQuery.event.special[type] || {}\r\n        type = (selector ? special.delegateType : special.bindType) || type\r\n        handlers = events[type] || []\r\n        tmp = tmp[2] && new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)')\r\n\r\n        // Remove matching events\r\n        origCount = j = handlers.length\r\n        while (j--) {\r\n          handleObj = handlers[j]\r\n\r\n          if (\r\n            (mappedTypes || origType === handleObj.origType) &&\r\n            (!handler || handler.guid === handleObj.guid) &&\r\n            (!tmp || tmp.test(handleObj.namespace)) &&\r\n            (!selector || selector === handleObj.selector || (selector === '**' && handleObj.selector))\r\n          ) {\r\n            handlers.splice(j, 1)\r\n\r\n            if (handleObj.selector) {\r\n              handlers.delegateCount--\r\n            }\r\n            if (special.remove) {\r\n              special.remove.call(elem, handleObj)\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove generic event handler if we removed something and no more handlers exist\r\n        // (avoids potential for endless recursion during removal of special event handlers)\r\n        if (origCount && !handlers.length) {\r\n          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {\r\n            jQuery.removeEvent(elem, type, elemData.handle)\r\n          }\r\n\r\n          delete events[type]\r\n        }\r\n      }\r\n\r\n      // Remove data and the expando if it's no longer used\r\n      if (jQuery.isEmptyObject(events)) {\r\n        dataPriv.remove(elem, 'handle events')\r\n      }\r\n    },\r\n\r\n    dispatch: function (event) {\r\n      // Make a writable jQuery.Event from the native event object\r\n      event = jQuery.event.fix(event)\r\n\r\n      var i,\r\n        j,\r\n        ret,\r\n        matched,\r\n        handleObj,\r\n        handlerQueue = [],\r\n        args = slice.call(arguments),\r\n        handlers = (dataPriv.get(this, 'events') || {})[event.type] || [],\r\n        special = jQuery.event.special[event.type] || {}\r\n\r\n      // Use the fix-ed jQuery.Event rather than the (read-only) native event\r\n      args[0] = event\r\n      event.delegateTarget = this\r\n\r\n      // Call the preDispatch hook for the mapped type, and let it bail if desired\r\n      if (special.preDispatch && special.preDispatch.call(this, event) === false) {\r\n        return\r\n      }\r\n\r\n      // Determine handlers\r\n      handlerQueue = jQuery.event.handlers.call(this, event, handlers)\r\n\r\n      // Run delegates first; they may want to stop propagation beneath us\r\n      i = 0\r\n      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {\r\n        event.currentTarget = matched.elem\r\n\r\n        j = 0\r\n        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {\r\n          // Triggered event must either 1) have no namespace, or 2) have namespace(s)\r\n          // a subset or equal to those in the bound event (both can have no namespace).\r\n          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {\r\n            event.handleObj = handleObj\r\n            event.data = handleObj.data\r\n\r\n            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(\r\n              matched.elem,\r\n              args\r\n            )\r\n\r\n            if (ret !== undefined) {\r\n              if ((event.result = ret) === false) {\r\n                event.preventDefault()\r\n                event.stopPropagation()\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Call the postDispatch hook for the mapped type\r\n      if (special.postDispatch) {\r\n        special.postDispatch.call(this, event)\r\n      }\r\n\r\n      return event.result\r\n    },\r\n\r\n    handlers: function (event, handlers) {\r\n      var i,\r\n        matches,\r\n        sel,\r\n        handleObj,\r\n        handlerQueue = [],\r\n        delegateCount = handlers.delegateCount,\r\n        cur = event.target\r\n\r\n      // Support (at least): Chrome, IE9\r\n      // Find delegate handlers\r\n      // Black-hole SVG <use> instance trees (#13180)\r\n      //\r\n      // Support: Firefox<=42+\r\n      // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)\r\n      if (delegateCount && cur.nodeType && (event.type !== 'click' || isNaN(event.button) || event.button < 1)) {\r\n        for (; cur !== this; cur = cur.parentNode || this) {\r\n          // Don't check non-elements (#13208)\r\n          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\r\n          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {\r\n            matches = []\r\n            for (i = 0; i < delegateCount; i++) {\r\n              handleObj = handlers[i]\r\n\r\n              // Don't conflict with Object.prototype properties (#13203)\r\n              sel = handleObj.selector + ' '\r\n\r\n              if (matches[sel] === undefined) {\r\n                matches[sel] = handleObj.needsContext\r\n                  ? jQuery(sel, this).index(cur) > -1\r\n                  : jQuery.find(sel, this, null, [cur]).length\r\n              }\r\n              if (matches[sel]) {\r\n                matches.push(handleObj)\r\n              }\r\n            }\r\n            if (matches.length) {\r\n              handlerQueue.push({ elem: cur, handlers: matches })\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Add the remaining (directly-bound) handlers\r\n      if (delegateCount < handlers.length) {\r\n        handlerQueue.push({ elem: this, handlers: handlers.slice(delegateCount) })\r\n      }\r\n\r\n      return handlerQueue\r\n    },\r\n\r\n    // Includes some event props shared by KeyEvent and MouseEvent\r\n    props: (\r\n      'altKey bubbles cancelable ctrlKey currentTarget detail eventPhase ' +\r\n      'metaKey relatedTarget shiftKey target timeStamp view which'\r\n    ).split(' '),\r\n\r\n    fixHooks: {},\r\n\r\n    keyHooks: {\r\n      props: 'char charCode key keyCode'.split(' '),\r\n      filter: function (event, original) {\r\n        // Add which for key events\r\n        if (event.which == null) {\r\n          event.which = original.charCode != null ? original.charCode : original.keyCode\r\n        }\r\n\r\n        return event\r\n      }\r\n    },\r\n\r\n    mouseHooks: {\r\n      props: ('button buttons clientX clientY offsetX offsetY pageX pageY ' + 'screenX screenY toElement').split(' '),\r\n      filter: function (event, original) {\r\n        var eventDoc,\r\n          doc,\r\n          body,\r\n          button = original.button\r\n\r\n        // Calculate pageX/Y if missing and clientX/Y available\r\n        if (event.pageX == null && original.clientX != null) {\r\n          eventDoc = event.target.ownerDocument || document\r\n          doc = eventDoc.documentElement\r\n          body = eventDoc.body\r\n\r\n          event.pageX =\r\n            original.clientX +\r\n            ((doc && doc.scrollLeft) || (body && body.scrollLeft) || 0) -\r\n            ((doc && doc.clientLeft) || (body && body.clientLeft) || 0)\r\n          event.pageY =\r\n            original.clientY +\r\n            ((doc && doc.scrollTop) || (body && body.scrollTop) || 0) -\r\n            ((doc && doc.clientTop) || (body && body.clientTop) || 0)\r\n        }\r\n\r\n        // Add which for click: 1 === left; 2 === middle; 3 === right\r\n        // Note: button is not normalized, so don't use it\r\n        if (!event.which && button !== undefined) {\r\n          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0\r\n        }\r\n\r\n        return event\r\n      }\r\n    },\r\n\r\n    fix: function (event) {\r\n      if (event[jQuery.expando]) {\r\n        return event\r\n      }\r\n\r\n      // Create a writable copy of the event object and normalize some properties\r\n      var i,\r\n        prop,\r\n        copy,\r\n        type = event.type,\r\n        originalEvent = event,\r\n        fixHook = this.fixHooks[type]\r\n\r\n      if (!fixHook) {\r\n        this.fixHooks[type] = fixHook = rmouseEvent.test(type)\r\n          ? this.mouseHooks\r\n          : rkeyEvent.test(type)\r\n          ? this.keyHooks\r\n          : {}\r\n      }\r\n      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props\r\n\r\n      event = new jQuery.Event(originalEvent)\r\n\r\n      i = copy.length\r\n      while (i--) {\r\n        prop = copy[i]\r\n        event[prop] = originalEvent[prop]\r\n      }\r\n\r\n      // Support: Cordova 2.5 (WebKit) (#13255)\r\n      // All events should have a target; Cordova deviceready doesn't\r\n      if (!event.target) {\r\n        event.target = document\r\n      }\r\n\r\n      // Support: Safari 6.0+, Chrome<28\r\n      // Target should not be a text node (#504, #13143)\r\n      if (event.target.nodeType === 3) {\r\n        event.target = event.target.parentNode\r\n      }\r\n\r\n      return fixHook.filter ? fixHook.filter(event, originalEvent) : event\r\n    },\r\n\r\n    special: {\r\n      load: {\r\n        // Prevent triggered image.load events from bubbling to window.load\r\n        noBubble: true\r\n      },\r\n      focus: {\r\n        // Fire native event if possible so blur/focus sequence is correct\r\n        trigger: function () {\r\n          if (this !== safeActiveElement() && this.focus) {\r\n            this.focus()\r\n            return false\r\n          }\r\n        },\r\n        delegateType: 'focusin'\r\n      },\r\n      blur: {\r\n        trigger: function () {\r\n          if (this === safeActiveElement() && this.blur) {\r\n            this.blur()\r\n            return false\r\n          }\r\n        },\r\n        delegateType: 'focusout'\r\n      },\r\n      click: {\r\n        // For checkbox, fire native event so checked state will be right\r\n        trigger: function () {\r\n          if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {\r\n            this.click()\r\n            return false\r\n          }\r\n        },\r\n\r\n        // For cross-browser consistency, don't fire native .click() on links\r\n        _default: function (event) {\r\n          return jQuery.nodeName(event.target, 'a')\r\n        }\r\n      },\r\n\r\n      beforeunload: {\r\n        postDispatch: function (event) {\r\n          // Support: Firefox 20+\r\n          // Firefox doesn't alert if the returnValue field is not set.\r\n          if (event.result !== undefined && event.originalEvent) {\r\n            event.originalEvent.returnValue = event.result\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  jQuery.removeEvent = function (elem, type, handle) {\r\n    // This \"if\" is needed for plain objects\r\n    if (elem.removeEventListener) {\r\n      elem.removeEventListener(type, handle)\r\n    }\r\n  }\r\n\r\n  jQuery.Event = function (src, props) {\r\n    // Allow instantiation without the 'new' keyword\r\n    if (!(this instanceof jQuery.Event)) {\r\n      return new jQuery.Event(src, props)\r\n    }\r\n\r\n    // Event object\r\n    if (src && src.type) {\r\n      this.originalEvent = src\r\n      this.type = src.type\r\n\r\n      // Events bubbling up the document may have been marked as prevented\r\n      // by a handler lower down the tree; reflect the correct value.\r\n      this.isDefaultPrevented =\r\n        src.defaultPrevented ||\r\n        (src.defaultPrevented === undefined &&\r\n          // Support: Android<4.0\r\n          src.returnValue === false)\r\n          ? returnTrue\r\n          : returnFalse\r\n\r\n      // Event type\r\n    } else {\r\n      this.type = src\r\n    }\r\n\r\n    // Put explicitly provided properties onto the event object\r\n    if (props) {\r\n      jQuery.extend(this, props)\r\n    }\r\n\r\n    // Create a timestamp if incoming event doesn't have one\r\n    this.timeStamp = (src && src.timeStamp) || jQuery.now()\r\n\r\n    // Mark it as fixed\r\n    this[jQuery.expando] = true\r\n  }\r\n\r\n  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\r\n  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\r\n  jQuery.Event.prototype = {\r\n    constructor: jQuery.Event,\r\n    isDefaultPrevented: returnFalse,\r\n    isPropagationStopped: returnFalse,\r\n    isImmediatePropagationStopped: returnFalse,\r\n    isSimulated: false,\r\n\r\n    preventDefault: function () {\r\n      var e = this.originalEvent\r\n\r\n      this.isDefaultPrevented = returnTrue\r\n\r\n      if (e && !this.isSimulated) {\r\n        e.preventDefault()\r\n      }\r\n    },\r\n    stopPropagation: function () {\r\n      var e = this.originalEvent\r\n\r\n      this.isPropagationStopped = returnTrue\r\n\r\n      if (e && !this.isSimulated) {\r\n        e.stopPropagation()\r\n      }\r\n    },\r\n    stopImmediatePropagation: function () {\r\n      var e = this.originalEvent\r\n\r\n      this.isImmediatePropagationStopped = returnTrue\r\n\r\n      if (e && !this.isSimulated) {\r\n        e.stopImmediatePropagation()\r\n      }\r\n\r\n      this.stopPropagation()\r\n    }\r\n  }\r\n\r\n  // Create mouseenter/leave events using mouseover/out and event-time checks\r\n  // so that event delegation works in jQuery.\r\n  // Do the same for pointerenter/pointerleave and pointerover/pointerout\r\n  //\r\n  // Support: Safari 7 only\r\n  // Safari sends mouseenter too often; see:\r\n  // https://code.google.com/p/chromium/issues/detail?id=470258\r\n  // for the description of the bug (it existed in older Chrome versions as well).\r\n  jQuery.each(\r\n    {\r\n      mouseenter: 'mouseover',\r\n      mouseleave: 'mouseout',\r\n      pointerenter: 'pointerover',\r\n      pointerleave: 'pointerout'\r\n    },\r\n    function (orig, fix) {\r\n      jQuery.event.special[orig] = {\r\n        delegateType: fix,\r\n        bindType: fix,\r\n\r\n        handle: function (event) {\r\n          var ret,\r\n            target = this,\r\n            related = event.relatedTarget,\r\n            handleObj = event.handleObj\r\n\r\n          // For mouseenter/leave call the handler if related is outside the target.\r\n          // NB: No relatedTarget if the mouse left/entered the browser window\r\n          if (!related || (related !== target && !jQuery.contains(target, related))) {\r\n            event.type = handleObj.origType\r\n            ret = handleObj.handler.apply(this, arguments)\r\n            event.type = fix\r\n          }\r\n          return ret\r\n        }\r\n      }\r\n    }\r\n  )\r\n\r\n  jQuery.fn.extend({\r\n    on: function (types, selector, data, fn) {\r\n      return on(this, types, selector, data, fn)\r\n    },\r\n    one: function (types, selector, data, fn) {\r\n      return on(this, types, selector, data, fn, 1)\r\n    },\r\n    off: function (types, selector, fn) {\r\n      var handleObj, type\r\n      if (types && types.preventDefault && types.handleObj) {\r\n        // ( event )  dispatched jQuery.Event\r\n        handleObj = types.handleObj\r\n        jQuery(types.delegateTarget).off(\r\n          handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType,\r\n          handleObj.selector,\r\n          handleObj.handler\r\n        )\r\n        return this\r\n      }\r\n      if (typeof types === 'object') {\r\n        // ( types-object [, selector] )\r\n        for (type in types) {\r\n          this.off(type, selector, types[type])\r\n        }\r\n        return this\r\n      }\r\n      if (selector === false || typeof selector === 'function') {\r\n        // ( types [, fn] )\r\n        fn = selector\r\n        selector = undefined\r\n      }\r\n      if (fn === false) {\r\n        fn = returnFalse\r\n      }\r\n      return this.each(function () {\r\n        jQuery.event.remove(this, types, fn, selector)\r\n      })\r\n    }\r\n  })\r\n\r\n  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\r\n    // Support: IE 10-11, Edge 10240+\r\n    // In IE/Edge using regex groups here causes severe slowdowns.\r\n    // See https://connect.microsoft.com/IE/feedback/details/1736512/\r\n    rnoInnerhtml = /<script|<style|<link/i,\r\n    // checked=\"checked\" or checked\r\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\r\n    rscriptTypeMasked = /^true\\/(.*)/,\r\n    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g\r\n\r\n  // Manipulating tables requires a tbody\r\n  function manipulationTarget (elem, content) {\r\n    return jQuery.nodeName(elem, 'table') &&\r\n      jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr')\r\n      ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody'))\r\n      : elem\r\n  }\r\n\r\n  // Replace/restore the type attribute of script elements for safe DOM manipulation\r\n  function disableScript (elem) {\r\n    elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type\r\n    return elem\r\n  }\r\n  function restoreScript (elem) {\r\n    var match = rscriptTypeMasked.exec(elem.type)\r\n\r\n    if (match) {\r\n      elem.type = match[1]\r\n    } else {\r\n      elem.removeAttribute('type')\r\n    }\r\n\r\n    return elem\r\n  }\r\n\r\n  function cloneCopyEvent (src, dest) {\r\n    var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events\r\n\r\n    if (dest.nodeType !== 1) {\r\n      return\r\n    }\r\n\r\n    // 1. Copy private data: events, handlers, etc.\r\n    if (dataPriv.hasData(src)) {\r\n      pdataOld = dataPriv.access(src)\r\n      pdataCur = dataPriv.set(dest, pdataOld)\r\n      events = pdataOld.events\r\n\r\n      if (events) {\r\n        delete pdataCur.handle\r\n        pdataCur.events = {}\r\n\r\n        for (type in events) {\r\n          for (i = 0, l = events[type].length; i < l; i++) {\r\n            jQuery.event.add(dest, type, events[type][i])\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // 2. Copy user data\r\n    if (dataUser.hasData(src)) {\r\n      udataOld = dataUser.access(src)\r\n      udataCur = jQuery.extend({}, udataOld)\r\n\r\n      dataUser.set(dest, udataCur)\r\n    }\r\n  }\r\n\r\n  // Fix IE bugs, see support tests\r\n  function fixInput (src, dest) {\r\n    var nodeName = dest.nodeName.toLowerCase()\r\n\r\n    // Fails to persist the checked state of a cloned checkbox or radio button.\r\n    if (nodeName === 'input' && rcheckableType.test(src.type)) {\r\n      dest.checked = src.checked\r\n\r\n      // Fails to return the selected option to the default selected state when cloning options\r\n    } else if (nodeName === 'input' || nodeName === 'textarea') {\r\n      dest.defaultValue = src.defaultValue\r\n    }\r\n  }\r\n\r\n  function domManip (collection, args, callback, ignored) {\r\n    // Flatten any nested arrays\r\n    args = concat.apply([], args)\r\n\r\n    var fragment,\r\n      first,\r\n      scripts,\r\n      hasScripts,\r\n      node,\r\n      doc,\r\n      i = 0,\r\n      l = collection.length,\r\n      iNoClone = l - 1,\r\n      value = args[0],\r\n      isFunction = jQuery.isFunction(value)\r\n\r\n    // We can't cloneNode fragments that contain checked, in WebKit\r\n    if (isFunction || (l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value))) {\r\n      return collection.each(function (index) {\r\n        var self = collection.eq(index)\r\n        if (isFunction) {\r\n          args[0] = value.call(this, index, self.html())\r\n        }\r\n        domManip(self, args, callback, ignored)\r\n      })\r\n    }\r\n\r\n    if (l) {\r\n      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored)\r\n      first = fragment.firstChild\r\n\r\n      if (fragment.childNodes.length === 1) {\r\n        fragment = first\r\n      }\r\n\r\n      // Require either new content or an interest in ignored elements to invoke the callback\r\n      if (first || ignored) {\r\n        scripts = jQuery.map(getAll(fragment, 'script'), disableScript)\r\n        hasScripts = scripts.length\r\n\r\n        // Use the original fragment for the last item\r\n        // instead of the first because it can end up\r\n        // being emptied incorrectly in certain situations (#8070).\r\n        for (; i < l; i++) {\r\n          node = fragment\r\n\r\n          if (i !== iNoClone) {\r\n            node = jQuery.clone(node, true, true)\r\n\r\n            // Keep references to cloned scripts for later restoration\r\n            if (hasScripts) {\r\n              // Support: Android<4.1, PhantomJS<2\r\n              // push.apply(_, arraylike) throws on ancient WebKit\r\n              jQuery.merge(scripts, getAll(node, 'script'))\r\n            }\r\n          }\r\n\r\n          callback.call(collection[i], node, i)\r\n        }\r\n\r\n        if (hasScripts) {\r\n          doc = scripts[scripts.length - 1].ownerDocument\r\n\r\n          // Reenable scripts\r\n          jQuery.map(scripts, restoreScript)\r\n\r\n          // Evaluate executable scripts on first document insertion\r\n          for (i = 0; i < hasScripts; i++) {\r\n            node = scripts[i]\r\n            if (\r\n              rscriptType.test(node.type || '') &&\r\n              !dataPriv.access(node, 'globalEval') &&\r\n              jQuery.contains(doc, node)\r\n            ) {\r\n              if (node.src) {\r\n                // Optional AJAX dependency, but won't run scripts if not present\r\n                if (jQuery._evalUrl) {\r\n                  jQuery._evalUrl(node.src)\r\n                }\r\n              } else {\r\n                jQuery.globalEval(node.textContent.replace(rcleanScript, ''))\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return collection\r\n  }\r\n\r\n  function remove (elem, selector, keepData) {\r\n    var node,\r\n      nodes = selector ? jQuery.filter(selector, elem) : elem,\r\n      i = 0\r\n\r\n    for (; (node = nodes[i]) != null; i++) {\r\n      if (!keepData && node.nodeType === 1) {\r\n        jQuery.cleanData(getAll(node))\r\n      }\r\n\r\n      if (node.parentNode) {\r\n        if (keepData && jQuery.contains(node.ownerDocument, node)) {\r\n          setGlobalEval(getAll(node, 'script'))\r\n        }\r\n        node.parentNode.removeChild(node)\r\n      }\r\n    }\r\n\r\n    return elem\r\n  }\r\n\r\n  jQuery.extend({\r\n    htmlPrefilter: function (html) {\r\n      return html.replace(rxhtmlTag, '<$1></$2>')\r\n    },\r\n\r\n    clone: function (elem, dataAndEvents, deepDataAndEvents) {\r\n      var i,\r\n        l,\r\n        srcElements,\r\n        destElements,\r\n        clone = elem.cloneNode(true),\r\n        inPage = jQuery.contains(elem.ownerDocument, elem)\r\n\r\n      // Fix IE cloning issues\r\n      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {\r\n        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\r\n        destElements = getAll(clone)\r\n        srcElements = getAll(elem)\r\n\r\n        for (i = 0, l = srcElements.length; i < l; i++) {\r\n          fixInput(srcElements[i], destElements[i])\r\n        }\r\n      }\r\n\r\n      // Copy the events from the original to the clone\r\n      if (dataAndEvents) {\r\n        if (deepDataAndEvents) {\r\n          srcElements = srcElements || getAll(elem)\r\n          destElements = destElements || getAll(clone)\r\n\r\n          for (i = 0, l = srcElements.length; i < l; i++) {\r\n            cloneCopyEvent(srcElements[i], destElements[i])\r\n          }\r\n        } else {\r\n          cloneCopyEvent(elem, clone)\r\n        }\r\n      }\r\n\r\n      // Preserve script evaluation history\r\n      destElements = getAll(clone, 'script')\r\n      if (destElements.length > 0) {\r\n        setGlobalEval(destElements, !inPage && getAll(elem, 'script'))\r\n      }\r\n\r\n      // Return the cloned set\r\n      return clone\r\n    },\r\n\r\n    cleanData: function (elems) {\r\n      var data,\r\n        elem,\r\n        type,\r\n        special = jQuery.event.special,\r\n        i = 0\r\n\r\n      for (; (elem = elems[i]) !== undefined; i++) {\r\n        if (acceptData(elem)) {\r\n          if ((data = elem[dataPriv.expando])) {\r\n            if (data.events) {\r\n              for (type in data.events) {\r\n                if (special[type]) {\r\n                  jQuery.event.remove(elem, type)\r\n\r\n                  // This is a shortcut to avoid jQuery.event.remove's overhead\r\n                } else {\r\n                  jQuery.removeEvent(elem, type, data.handle)\r\n                }\r\n              }\r\n            }\r\n\r\n            // Support: Chrome <= 35-45+\r\n            // Assign undefined instead of using delete, see Data#remove\r\n            elem[dataPriv.expando] = undefined\r\n          }\r\n          if (elem[dataUser.expando]) {\r\n            // Support: Chrome <= 35-45+\r\n            // Assign undefined instead of using delete, see Data#remove\r\n            elem[dataUser.expando] = undefined\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  jQuery.fn.extend({\r\n    // Keep domManip exposed until 3.0 (gh-2225)\r\n    domManip: domManip,\r\n\r\n    detach: function (selector) {\r\n      return remove(this, selector, true)\r\n    },\r\n\r\n    remove: function (selector) {\r\n      return remove(this, selector)\r\n    },\r\n\r\n    text: function (value) {\r\n      return access(\r\n        this,\r\n        function (value) {\r\n          return value === undefined\r\n            ? jQuery.text(this)\r\n            : this.empty().each(function () {\r\n                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n                  this.textContent = value\r\n                }\r\n              })\r\n        },\r\n        null,\r\n        value,\r\n        arguments.length\r\n      )\r\n    },\r\n\r\n    append: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n          var target = manipulationTarget(this, elem)\r\n          target.appendChild(elem)\r\n        }\r\n      })\r\n    },\r\n\r\n    prepend: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {\r\n          var target = manipulationTarget(this, elem)\r\n          target.insertBefore(elem, target.firstChild)\r\n        }\r\n      })\r\n    },\r\n\r\n    before: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.parentNode) {\r\n          this.parentNode.insertBefore(elem, this)\r\n        }\r\n      })\r\n    },\r\n\r\n    after: function () {\r\n      return domManip(this, arguments, function (elem) {\r\n        if (this.parentNode) {\r\n          this.parentNode.insertBefore(elem, this.nextSibling)\r\n        }\r\n      })\r\n    },\r\n\r\n    empty: function () {\r\n      var elem,\r\n        i = 0\r\n\r\n      for (; (elem = this[i]) != null; i++) {\r\n        if (elem.nodeType === 1) {\r\n          // Prevent memory leaks\r\n          jQuery.cleanData(getAll(elem, false))\r\n\r\n          // Remove any remaining nodes\r\n          elem.textContent = ''\r\n        }\r\n      }\r\n\r\n      return this\r\n    },\r\n\r\n    clone: function (dataAndEvents, deepDataAndEvents) {\r\n      dataAndEvents = dataAndEvents == null ? false : dataAndEvents\r\n      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents\r\n\r\n      return this.map(function () {\r\n        return jQuery.clone(this, dataAndEvents, deepDataAndEvents)\r\n      })\r\n    },\r\n\r\n    html: function (value) {\r\n      return access(\r\n        this,\r\n        function (value) {\r\n          var elem = this[0] || {},\r\n            i = 0,\r\n            l = this.length\r\n\r\n          if (value === undefined && elem.nodeType === 1) {\r\n            return elem.innerHTML\r\n          }\r\n\r\n          // See if we can take a shortcut and just use innerHTML\r\n          if (\r\n            typeof value === 'string' &&\r\n            !rnoInnerhtml.test(value) &&\r\n            !wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]\r\n          ) {\r\n            value = jQuery.htmlPrefilter(value)\r\n\r\n            try {\r\n              for (; i < l; i++) {\r\n                elem = this[i] || {}\r\n\r\n                // Remove element nodes and prevent memory leaks\r\n                if (elem.nodeType === 1) {\r\n                  jQuery.cleanData(getAll(elem, false))\r\n                  elem.innerHTML = value\r\n                }\r\n              }\r\n\r\n              elem = 0\r\n\r\n              // If using innerHTML throws an exception, use the fallback method\r\n            } catch (e) {}\r\n          }\r\n\r\n          if (elem) {\r\n            this.empty().append(value)\r\n          }\r\n        },\r\n        null,\r\n        value,\r\n        arguments.length\r\n      )\r\n    },\r\n\r\n    replaceWith: function () {\r\n      var ignored = []\r\n\r\n      // Make the changes, replacing each non-ignored context element with the new content\r\n      return domManip(\r\n        this,\r\n        arguments,\r\n        function (elem) {\r\n          var parent = this.parentNode\r\n\r\n          if (jQuery.inArray(this, ignored) < 0) {\r\n            jQuery.cleanData(getAll(this))\r\n            if (parent) {\r\n              parent.replaceChild(elem, this)\r\n            }\r\n          }\r\n\r\n          // Force callback invocation\r\n        },\r\n        ignored\r\n      )\r\n    }\r\n  })\r\n\r\n  jQuery.each(\r\n    {\r\n      appendTo: 'append',\r\n      prependTo: 'prepend',\r\n      insertBefore: 'before',\r\n      insertAfter: 'after',\r\n      replaceAll: 'replaceWith'\r\n    },\r\n    function (name, original) {\r\n      jQuery.fn[name] = function (selector) {\r\n        var elems,\r\n          ret = [],\r\n          insert = jQuery(selector),\r\n          last = insert.length - 1,\r\n          i = 0\r\n\r\n        for (; i <= last; i++) {\r\n          elems = i === last ? this : this.clone(true)\r\n          jQuery(insert[i])[original](elems)\r\n\r\n          // Support: QtWebKit\r\n          // .get() because push.apply(_, arraylike) throws\r\n          push.apply(ret, elems.get())\r\n        }\r\n\r\n        return this.pushStack(ret)\r\n      }\r\n    }\r\n  )\r\n\r\n  var iframe,\r\n    elemdisplay = {\r\n      // Support: Firefox\r\n      // We have to pre-define these values for FF (#10227)\r\n      HTML: 'block',\r\n      BODY: 'block'\r\n    }\r\n\r\n  /**\r\n   * Retrieve the actual display of a element\r\n   * @param {String} name nodeName of the element\r\n   * @param {Object} doc Document object\r\n   */\r\n\r\n  // Called only from within defaultDisplay\r\n  function actualDisplay (name, doc) {\r\n    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),\r\n      display = jQuery.css(elem[0], 'display')\r\n\r\n    // We don't have any data stored on the element,\r\n    // so use \"detach\" method as fast way to get rid of the element\r\n    elem.detach()\r\n\r\n    return display\r\n  }\r\n\r\n  /**\r\n   * Try to determine the default display value of an element\r\n   * @param {String} nodeName\r\n   */\r\n  function defaultDisplay (nodeName) {\r\n    var doc = document,\r\n      display = elemdisplay[nodeName]\r\n\r\n    if (!display) {\r\n      display = actualDisplay(nodeName, doc)\r\n\r\n      // If the simple way fails, read from inside an iframe\r\n      if (display === 'none' || !display) {\r\n        // Use the already-created iframe if possible\r\n        iframe = (iframe || jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(doc.documentElement)\r\n\r\n        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\r\n        doc = iframe[0].contentDocument\r\n\r\n        // Support: IE\r\n        doc.write()\r\n        doc.close()\r\n\r\n        display = actualDisplay(nodeName, doc)\r\n        iframe.detach()\r\n      }\r\n\r\n      // Store the correct default display\r\n      elemdisplay[nodeName] = display\r\n    }\r\n\r\n    return display\r\n  }\r\n  var rmargin = /^margin/\r\n\r\n  var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i')\r\n\r\n  var getStyles = function (elem) {\r\n    // Support: IE<=11+, Firefox<=30+ (#15098, #14150)\r\n    // IE throws on elements created in popups\r\n    // FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\r\n    var view = elem.ownerDocument.defaultView\r\n\r\n    if (!view || !view.opener) {\r\n      view = window\r\n    }\r\n\r\n    return view.getComputedStyle(elem)\r\n  }\r\n\r\n  var swap = function (elem, options, callback, args) {\r\n    var ret,\r\n      name,\r\n      old = {}\r\n\r\n    // Remember the old values, and insert the new ones\r\n    for (name in options) {\r\n      old[name] = elem.style[name]\r\n      elem.style[name] = options[name]\r\n    }\r\n\r\n    ret = callback.apply(elem, args || [])\r\n\r\n    // Revert the old values\r\n    for (name in options) {\r\n      elem.style[name] = old[name]\r\n    }\r\n\r\n    return ret\r\n  }\r\n\r\n  var documentElement = document.documentElement\r\n\r\n  ;(function () {\r\n    var pixelPositionVal,\r\n      boxSizingReliableVal,\r\n      pixelMarginRightVal,\r\n      reliableMarginLeftVal,\r\n      container = document.createElement('div'),\r\n      div = document.createElement('div')\r\n\r\n    // Finish early in limited (non-browser) environments\r\n    if (!div.style) {\r\n      return\r\n    }\r\n\r\n    // Support: IE9-11+\r\n    // Style of cloned element affects source element cloned (#8908)\r\n    div.style.backgroundClip = 'content-box'\r\n    div.cloneNode(true).style.backgroundClip = ''\r\n    support.clearCloneStyle = div.style.backgroundClip === 'content-box'\r\n\r\n    container.style.cssText =\r\n      'border:0;width:8px;height:0;top:0;left:-9999px;' + 'padding:0;margin-top:1px;position:absolute'\r\n    container.appendChild(div)\r\n\r\n    // Executing both pixelPosition & boxSizingReliable tests require only one layout\r\n    // so they're executed at the same time to save the second computation.\r\n    function computeStyleTests () {\r\n      div.style.cssText =\r\n        // Support: Firefox<29, Android 2.3\r\n        // Vendor-prefix box-sizing\r\n        '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' +\r\n        'position:relative;display:block;' +\r\n        'margin:auto;border:1px;padding:1px;' +\r\n        'top:1%;width:50%'\r\n      div.innerHTML = ''\r\n      documentElement.appendChild(container)\r\n\r\n      var divStyle = window.getComputedStyle(div)\r\n      pixelPositionVal = divStyle.top !== '1%'\r\n      reliableMarginLeftVal = divStyle.marginLeft === '2px'\r\n      boxSizingReliableVal = divStyle.width === '4px'\r\n\r\n      // Support: Android 4.0 - 4.3 only\r\n      // Some styles come back with percentage values, even though they shouldn't\r\n      div.style.marginRight = '50%'\r\n      pixelMarginRightVal = divStyle.marginRight === '4px'\r\n\r\n      documentElement.removeChild(container)\r\n    }\r\n\r\n    jQuery.extend(support, {\r\n      pixelPosition: function () {\r\n        // This test is executed only once but we still do memoizing\r\n        // since we can use the boxSizingReliable pre-computing.\r\n        // No need to check if the test was already performed, though.\r\n        computeStyleTests()\r\n        return pixelPositionVal\r\n      },\r\n      boxSizingReliable: function () {\r\n        if (boxSizingReliableVal == null) {\r\n          computeStyleTests()\r\n        }\r\n        return boxSizingReliableVal\r\n      },\r\n      pixelMarginRight: function () {\r\n        // Support: Android 4.0-4.3\r\n        // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal\r\n        // since that compresses better and they're computed together anyway.\r\n        if (boxSizingReliableVal == null) {\r\n          computeStyleTests()\r\n        }\r\n        return pixelMarginRightVal\r\n      },\r\n      reliableMarginLeft: function () {\r\n        // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37\r\n        if (boxSizingReliableVal == null) {\r\n          computeStyleTests()\r\n        }\r\n        return reliableMarginLeftVal\r\n      },\r\n      reliableMarginRight: function () {\r\n        // Support: Android 2.3\r\n        // Check if div with explicit width and no margin-right incorrectly\r\n        // gets computed margin-right based on width of container. (#3333)\r\n        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\r\n        // This support function is only executed once so no memoizing is needed.\r\n        var ret,\r\n          marginDiv = div.appendChild(document.createElement('div'))\r\n\r\n        // Reset CSS: box-sizing; display; margin; border; padding\r\n        marginDiv.style.cssText = div.style.cssText =\r\n          // Support: Android 2.3\r\n          // Vendor-prefix box-sizing\r\n          '-webkit-box-sizing:content-box;box-sizing:content-box;' + 'display:block;margin:0;border:0;padding:0'\r\n        marginDiv.style.marginRight = marginDiv.style.width = '0'\r\n        div.style.width = '1px'\r\n        documentElement.appendChild(container)\r\n\r\n        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight)\r\n\r\n        documentElement.removeChild(container)\r\n        div.removeChild(marginDiv)\r\n\r\n        return ret\r\n      }\r\n    })\r\n  })()\r\n\r\n  function curCSS (elem, name, computed) {\r\n    var width,\r\n      minWidth,\r\n      maxWidth,\r\n      ret,\r\n      style = elem.style\r\n\r\n    computed = computed || getStyles(elem)\r\n    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined\r\n\r\n    // Support: Opera 12.1x only\r\n    // Fall back to style even without computed\r\n    // computed is undefined for elems on document fragments\r\n    if ((ret === '' || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {\r\n      ret = jQuery.style(elem, name)\r\n    }\r\n\r\n    // Support: IE9\r\n    // getPropertyValue is only needed for .css('filter') (#12537)\r\n    if (computed) {\r\n      // A tribute to the \"awesome hack by Dean Edwards\"\r\n      // Android Browser returns percentage for some values,\r\n      // but width seems to be reliably pixels.\r\n      // This is against the CSSOM draft spec:\r\n      // http://dev.w3.org/csswg/cssom/#resolved-values\r\n      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {\r\n        // Remember the original values\r\n        width = style.width\r\n        minWidth = style.minWidth\r\n        maxWidth = style.maxWidth\r\n\r\n        // Put in the new values to get a computed value out\r\n        style.minWidth = style.maxWidth = style.width = ret\r\n        ret = computed.width\r\n\r\n        // Revert the changed values\r\n        style.width = width\r\n        style.minWidth = minWidth\r\n        style.maxWidth = maxWidth\r\n      }\r\n    }\r\n\r\n    return ret !== undefined\r\n      ? // Support: IE9-11+\r\n        // IE returns zIndex value as an integer.\r\n        ret + ''\r\n      : ret\r\n  }\r\n\r\n  function addGetHookIf (conditionFn, hookFn) {\r\n    // Define the hook, we'll check on the first run if it's really needed.\r\n    return {\r\n      get: function () {\r\n        if (conditionFn()) {\r\n          // Hook not needed (or it's not possible to use it due\r\n          // to missing dependency), remove it.\r\n          delete this.get\r\n          return\r\n        }\r\n\r\n        // Hook needed; redefine it so that the support test is not executed again.\r\n        return (this.get = hookFn).apply(this, arguments)\r\n      }\r\n    }\r\n  }\r\n\r\n  var // Swappable if display is none or starts with table\r\n    // except \"table\", \"table-cell\", or \"table-caption\"\r\n    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\r\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\r\n    cssShow = { position: 'absolute', visibility: 'hidden', display: 'block' },\r\n    cssNormalTransform = {\r\n      letterSpacing: '0',\r\n      fontWeight: '400'\r\n    },\r\n    cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'],\r\n    emptyStyle = document.createElement('div').style\r\n\r\n  // Return a css property mapped to a potentially vendor prefixed property\r\n  function vendorPropName (name) {\r\n    // Shortcut for names that are not vendor prefixed\r\n    if (name in emptyStyle) {\r\n      return name\r\n    }\r\n\r\n    // Check for vendor prefixed names\r\n    var capName = name[0].toUpperCase() + name.slice(1),\r\n      i = cssPrefixes.length\r\n\r\n    while (i--) {\r\n      name = cssPrefixes[i] + capName\r\n      if (name in emptyStyle) {\r\n        return name\r\n      }\r\n    }\r\n  }\r\n\r\n  function setPositiveNumber (elem, value, subtract) {\r\n    // Any relative (+/-) values have already been\r\n    // normalized at this point\r\n    var matches = rcssNum.exec(value)\r\n    return matches\r\n      ? // Guard against undefined \"subtract\", e.g., when used as in cssHooks\r\n        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px')\r\n      : value\r\n  }\r\n\r\n  function augmentWidthOrHeight (elem, name, extra, isBorderBox, styles) {\r\n    var i =\r\n        extra === (isBorderBox ? 'border' : 'content')\r\n          ? // If we already have the right measurement, avoid augmentation\r\n            4\r\n          : // Otherwise initialize for horizontal or vertical properties\r\n          name === 'width'\r\n          ? 1\r\n          : 0,\r\n      val = 0\r\n\r\n    for (; i < 4; i += 2) {\r\n      // Both box models exclude margin, so add it if we want it\r\n      if (extra === 'margin') {\r\n        val += jQuery.css(elem, extra + cssExpand[i], true, styles)\r\n      }\r\n\r\n      if (isBorderBox) {\r\n        // border-box includes padding, so remove it if we want content\r\n        if (extra === 'content') {\r\n          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles)\r\n        }\r\n\r\n        // At this point, extra isn't border nor margin, so remove border\r\n        if (extra !== 'margin') {\r\n          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles)\r\n        }\r\n      } else {\r\n        // At this point, extra isn't content, so add padding\r\n        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles)\r\n\r\n        // At this point, extra isn't content nor padding, so add border\r\n        if (extra !== 'padding') {\r\n          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles)\r\n        }\r\n      }\r\n    }\r\n\r\n    return val\r\n  }\r\n\r\n  function getWidthOrHeight (elem, name, extra) {\r\n    // Start with offset property, which is equivalent to the border-box value\r\n    var valueIsBorderBox = true,\r\n      val = name === 'width' ? elem.offsetWidth : elem.offsetHeight,\r\n      styles = getStyles(elem),\r\n      isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box'\r\n\r\n    // Some non-html elements return undefined for offsetWidth, so check for null/undefined\r\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\r\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\r\n    if (val <= 0 || val == null) {\r\n      // Fall back to computed then uncomputed css if necessary\r\n      val = curCSS(elem, name, styles)\r\n      if (val < 0 || val == null) {\r\n        val = elem.style[name]\r\n      }\r\n\r\n      // Computed unit is not pixels. Stop here and return.\r\n      if (rnumnonpx.test(val)) {\r\n        return val\r\n      }\r\n\r\n      // Check for style in case a browser which returns unreliable values\r\n      // for getComputedStyle silently falls back to the reliable elem.style\r\n      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name])\r\n\r\n      // Normalize \"\", auto, and prepare for extra\r\n      val = parseFloat(val) || 0\r\n    }\r\n\r\n    // Use the active box-sizing model to add/subtract irrelevant styles\r\n    return (\r\n      val +\r\n      augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) +\r\n      'px'\r\n    )\r\n  }\r\n\r\n  function showHide (elements, show) {\r\n    var display,\r\n      elem,\r\n      hidden,\r\n      values = [],\r\n      index = 0,\r\n      length = elements.length\r\n\r\n    for (; index < length; index++) {\r\n      elem = elements[index]\r\n      if (!elem.style) {\r\n        continue\r\n      }\r\n\r\n      values[index] = dataPriv.get(elem, 'olddisplay')\r\n      display = elem.style.display\r\n      if (show) {\r\n        // Reset the inline display of this element to learn if it is\r\n        // being hidden by cascaded rules or not\r\n        if (!values[index] && display === 'none') {\r\n          elem.style.display = ''\r\n        }\r\n\r\n        // Set elements which have been overridden with display: none\r\n        // in a stylesheet to whatever the default browser style is\r\n        // for such an element\r\n        if (elem.style.display === '' && isHidden(elem)) {\r\n          values[index] = dataPriv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName))\r\n        }\r\n      } else {\r\n        hidden = isHidden(elem)\r\n\r\n        if (display !== 'none' || !hidden) {\r\n          dataPriv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'))\r\n        }\r\n      }\r\n    }\r\n\r\n    // Set the display of most of the elements in a second loop\r\n    // to avoid the constant reflow\r\n    for (index = 0; index < length; index++) {\r\n      elem = elements[index]\r\n      if (!elem.style) {\r\n        continue\r\n      }\r\n      if (!show || elem.style.display === 'none' || elem.style.display === '') {\r\n        elem.style.display = show ? values[index] || '' : 'none'\r\n      }\r\n    }\r\n\r\n    return elements\r\n  }\r\n\r\n  jQuery.extend({\r\n    // Add in style property hooks for overriding the default\r\n    // behavior of getting and setting a style property\r\n    cssHooks: {\r\n      opacity: {\r\n        get: function (elem, computed) {\r\n          if (computed) {\r\n            // We should always get a number back from opacity\r\n            var ret = curCSS(elem, 'opacity')\r\n            return ret === '' ? '1' : ret\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    // Don't automatically add \"px\" to these possibly-unitless properties\r\n    cssNumber: {\r\n      animationIterationCount: true,\r\n      columnCount: true,\r\n      fillOpacity: true,\r\n      flexGrow: true,\r\n      flexShrink: true,\r\n      fontWeight: true,\r\n      lineHeight: true,\r\n      opacity: true,\r\n      order: true,\r\n      orphans: true,\r\n      widows: true,\r\n      zIndex: true,\r\n      zoom: true\r\n    },\r\n\r\n    // Add in properties whose names you wish to fix before\r\n    // setting or getting the value\r\n    cssProps: {\r\n      float: 'cssFloat'\r\n    },\r\n\r\n    // Get and set the style property on a DOM Node\r\n    style: function (elem, name, value, extra) {\r\n      // Don't set styles on text and comment nodes\r\n      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {\r\n        return\r\n      }\r\n\r\n      // Make sure that we're working with the right name\r\n      var ret,\r\n        type,\r\n        hooks,\r\n        origName = jQuery.camelCase(name),\r\n        style = elem.style\r\n\r\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName)\r\n\r\n      // Gets hook for the prefixed version, then unprefixed version\r\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]\r\n\r\n      // Check if we're setting a value\r\n      if (value !== undefined) {\r\n        type = typeof value\r\n\r\n        // Convert \"+=\" or \"-=\" to relative numbers (#7345)\r\n        if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {\r\n          value = adjustCSS(elem, name, ret)\r\n\r\n          // Fixes bug #9237\r\n          type = 'number'\r\n        }\r\n\r\n        // Make sure that null and NaN values aren't set (#7116)\r\n        if (value == null || value !== value) {\r\n          return\r\n        }\r\n\r\n        // If a number was passed in, add the unit (except for certain CSS properties)\r\n        if (type === 'number') {\r\n          value += (ret && ret[3]) || (jQuery.cssNumber[origName] ? '' : 'px')\r\n        }\r\n\r\n        // Support: IE9-11+\r\n        // background-* props affect original clone's values\r\n        if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {\r\n          style[name] = 'inherit'\r\n        }\r\n\r\n        // If a hook was provided, use that value, otherwise just set the specified value\r\n        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {\r\n          style[name] = value\r\n        }\r\n      } else {\r\n        // If a hook was provided get the non-computed value from there\r\n        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {\r\n          return ret\r\n        }\r\n\r\n        // Otherwise just get the value from the style object\r\n        return style[name]\r\n      }\r\n    },\r\n\r\n    css: function (elem, name, extra, styles) {\r\n      var val,\r\n        num,\r\n        hooks,\r\n        origName = jQuery.camelCase(name)\r\n\r\n      // Make sure that we're working with the right name\r\n      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName)\r\n\r\n      // Try prefixed name followed by the unprefixed name\r\n      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]\r\n\r\n      // If a hook was provided get the computed value from there\r\n      if (hooks && 'get' in hooks) {\r\n        val = hooks.get(elem, true, extra)\r\n      }\r\n\r\n      // Otherwise, if a way to get the computed value exists, use that\r\n      if (val === undefined) {\r\n        val = curCSS(elem, name, styles)\r\n      }\r\n\r\n      // Convert \"normal\" to computed value\r\n      if (val === 'normal' && name in cssNormalTransform) {\r\n        val = cssNormalTransform[name]\r\n      }\r\n\r\n      // Make numeric if forced or a qualifier was provided and val looks numeric\r\n      if (extra === '' || extra) {\r\n        num = parseFloat(val)\r\n        return extra === true || isFinite(num) ? num || 0 : val\r\n      }\r\n      return val\r\n    }\r\n  })\r\n\r\n  jQuery.each(['height', 'width'], function (i, name) {\r\n    jQuery.cssHooks[name] = {\r\n      get: function (elem, computed, extra) {\r\n        if (computed) {\r\n          // Certain elements can have dimension info if we invisibly show them\r\n          // but it must have a current display style that would benefit\r\n          return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0\r\n            ? swap(elem, cssShow, function () {\r\n                return getWidthOrHeight(elem, name, extra)\r\n              })\r\n            : getWidthOrHeight(elem, name, extra)\r\n        }\r\n      },\r\n\r\n      set: function (elem, value, extra) {\r\n        var matches,\r\n          styles = extra && getStyles(elem),\r\n          subtract =\r\n            extra &&\r\n            augmentWidthOrHeight(\r\n              elem,\r\n              name,\r\n              extra,\r\n              jQuery.css(elem, 'boxSizing', false, styles) === 'border-box',\r\n              styles\r\n            )\r\n\r\n        // Convert to pixels if value adjustment is needed\r\n        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {\r\n          elem.style[name] = value\r\n          value = jQuery.css(elem, name)\r\n        }\r\n\r\n        return setPositiveNumber(elem, value, subtract)\r\n      }\r\n    }\r\n  })\r\n\r\n  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {\r\n    if (computed) {\r\n      return (\r\n        (parseFloat(curCSS(elem, 'marginLeft')) ||\r\n          elem.getBoundingClientRect().left -\r\n            swap(elem, { marginLeft: 0 }, function () {\r\n              return elem.getBoundingClientRect().left\r\n            })) + 'px'\r\n      )\r\n    }\r\n  })\r\n\r\n  // Support: Android 2.3\r\n  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {\r\n    if (computed) {\r\n      return swap(elem, { display: 'inline-block' }, curCSS, [elem, 'marginRight'])\r\n    }\r\n  })\r\n\r\n  // These hooks are used by animate to expand properties\r\n  jQuery.each(\r\n    {\r\n      margin: '',\r\n      padding: '',\r\n      border: 'Width'\r\n    },\r\n    function (prefix, suffix) {\r\n      jQuery.cssHooks[prefix + suffix] = {\r\n        expand: function (value) {\r\n          var i = 0,\r\n            expanded = {},\r\n            // Assumes a single number if not a string\r\n            parts = typeof value === 'string' ? value.split(' ') : [value]\r\n\r\n          for (; i < 4; i++) {\r\n            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0]\r\n          }\r\n\r\n          return expanded\r\n        }\r\n      }\r\n\r\n      if (!rmargin.test(prefix)) {\r\n        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber\r\n      }\r\n    }\r\n  )\r\n\r\n  jQuery.fn.extend({\r\n    css: function (name, value) {\r\n      return access(\r\n        this,\r\n        function (elem, name, value) {\r\n          var styles,\r\n            len,\r\n            map = {},\r\n            i = 0\r\n\r\n          if (jQuery.isArray(name)) {\r\n            styles = getStyles(elem)\r\n            len = name.length\r\n\r\n            for (; i < len; i++) {\r\n              map[name[i]] = jQuery.css(elem, name[i], false, styles)\r\n            }\r\n\r\n            return map\r\n          }\r\n\r\n          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name)\r\n        },\r\n        name,\r\n        value,\r\n        arguments.length > 1\r\n      )\r\n    },\r\n    show: function () {\r\n      return showHide(this, true)\r\n    },\r\n    hide: function () {\r\n      return showHide(this)\r\n    },\r\n    toggle: function (state) {\r\n      if (typeof state === 'boolean') {\r\n        return state ? this.show() : this.hide()\r\n      }\r\n\r\n      return this.each(function () {\r\n        if (isHidden(this)) {\r\n          jQuery(this).show()\r\n        } else {\r\n          jQuery(this).hide()\r\n        }\r\n      })\r\n    }\r\n  })\r\n\r\n  function Tween (elem, options, prop, end, easing) {\r\n    return new Tween.prototype.init(elem, options, prop, end, easing)\r\n  }\r\n  jQuery.Tween = Tween\r\n\r\n  Tween.prototype = {\r\n    constructor: Tween,\r\n    init: function (elem, options, prop, end, easing, unit) {\r\n      this.elem = elem\r\n      this.prop = prop\r\n      this.easing = easing || jQuery.easing._default\r\n      this.options = options\r\n      this.start = this.now = this.cur()\r\n      this.end = end\r\n      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px')\r\n    },\r\n    cur: function () {\r\n      var hooks = Tween.propHooks[this.prop]\r\n\r\n      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)\r\n    },\r\n    run: function (percent) {\r\n      var eased,\r\n        hooks = Tween.propHooks[this.prop]\r\n\r\n      if (this.options.duration) {\r\n        this.pos = eased = jQuery.easing[this.easing](\r\n          percent,\r\n          this.options.duration * percent,\r\n          0,\r\n          1,\r\n          this.options.duration\r\n        )\r\n      } else {\r\n        this.pos = eased = percent\r\n      }\r\n      this.now = (this.end - this.start) * eased + this.start\r\n\r\n      if (this.options.step) {\r\n        this.options.step.call(this.elem, this.now, this)\r\n      }\r\n\r\n      if (hooks && hooks.set) {\r\n        hooks.set(this)\r\n      } else {\r\n        Tween.propHooks._default.set(this)\r\n      }\r\n      return this\r\n    }\r\n  }\r\n\r\n  Tween.prototype.init.prototype = Tween.prototype\r\n\r\n  Tween.propHooks = {\r\n    _default: {\r\n      get: function (tween) {\r\n        var result\r\n\r\n        // Use a property on the element directly when it is not a DOM element,\r\n        // or when there is no matching style property that exists.\r\n        if (tween.elem.nodeType !== 1 || (tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null)) {\r\n          return tween.elem[tween.prop]\r\n        }\r\n\r\n        // Passing an empty string as a 3rd parameter to .css will automatically\r\n        // attempt a parseFloat and fallback to a string if the parse fails.\r\n        // Simple values such as \"10px\" are parsed to Float;\r\n        // complex values such as \"rotate(1rad)\" are returned as-is.\r\n        result = jQuery.css(tween.elem, tween.prop, '')\r\n\r\n        // Empty strings, null, undefined and \"auto\" are converted to 0.\r\n        return !result || result === 'auto' ? 0 : result\r\n      },\r\n      set: function (tween) {\r\n        // Use step hook for back compat.\r\n        // Use cssHook if its there.\r\n        // Use .style if available and use plain properties where available.\r\n        if (jQuery.fx.step[tween.prop]) {\r\n          jQuery.fx.step[tween.prop](tween)\r\n        } else if (\r\n          tween.elem.nodeType === 1 &&\r\n          (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])\r\n        ) {\r\n          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)\r\n        } else {\r\n          tween.elem[tween.prop] = tween.now\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Support: IE9\r\n  // Panic based approach to setting things on disconnected nodes\r\n  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\r\n    set: function (tween) {\r\n      if (tween.elem.nodeType && tween.elem.parentNode) {\r\n        tween.elem[tween.prop] = tween.now\r\n      }\r\n    }\r\n  }\r\n\r\n  jQuery.easing = {\r\n    linear: function (p) {\r\n      return p\r\n    },\r\n    swing: function (p) {\r\n      return 0.5 - Math.cos(p * Math.PI) / 2\r\n    },\r\n    _default: 'swing'\r\n  }\r\n\r\n  jQuery.fx = Tween.prototype.init\r\n\r\n  // Back Compat <1.8 extension point\r\n  jQuery.fx.step = {}\r\n\r\n  var fxNow,\r\n    timerId,\r\n    rfxtypes = /^(?:toggle|show|hide)$/,\r\n    rrun = /queueHooks$/\r\n\r\n  // Animations created synchronously will run synchronously\r\n  function createFxNow () {\r\n    window.setTimeout(function () {\r\n      fxNow = undefined\r\n    })\r\n    return (fxNow = jQuery.now())\r\n  }\r\n\r\n  // Generate parameters to create a standard animation\r\n  function genFx (type, includeWidth) {\r\n    var which,\r\n      i = 0,\r\n      attrs = { height: type }\r\n\r\n    // If we include width, step value is 1 to do all cssExpand values,\r\n    // otherwise step value is 2 to skip over Left and Right\r\n    includeWidth = includeWidth ? 1 : 0\r\n    for (; i < 4; i += 2 - includeWidth) {\r\n      which = cssExpand[i]\r\n      attrs['margin' + which] = attrs['padding' + which] = type\r\n    }\r\n\r\n    if (includeWidth) {\r\n      attrs.opacity = attrs.width = type\r\n    }\r\n\r\n    return attrs\r\n  }\r\n\r\n  function createTween (value, prop, animation) {\r\n    var tween,\r\n      collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']),\r\n      index = 0,\r\n      length = collection.length\r\n    for (; index < length; index++) {\r\n      if ((tween = collection[index].call(animation, prop, value))) {\r\n        // We're done with this property\r\n        return tween\r\n      }\r\n    }\r\n  }\r\n\r\n  function defaultPrefilter (elem, props, opts) {\r\n    /* jshint validthis: true */\r\n    var prop,\r\n      value,\r\n      toggle,\r\n      tween,\r\n      hooks,\r\n      oldfire,\r\n      display,\r\n      checkDisplay,\r\n      anim = this,\r\n      orig = {},\r\n      style = elem.style,\r\n      hidden = elem.nodeType && isHidden(elem),\r\n      dataShow = dataPriv.get(elem, 'fxshow')\r\n\r\n    // Handle queue: false promises\r\n    if (!opts.queue) {\r\n      hooks = jQuery._queueHooks(elem, 'fx')\r\n      if (hooks.unqueued == null) {\r\n        hooks.unqueued = 0\r\n        oldfire = hooks.empty.fire\r\n        hooks.empty.fire = function () {\r\n          if (!hooks.unqueued) {\r\n            oldfire()\r\n          }\r\n        }\r\n      }\r\n      hooks.unqueued++\r\n\r\n      anim.always(function () {\r\n        // Ensure the complete handler is called before this completes\r\n        anim.always(function () {\r\n          hooks.unqueued--\r\n          if (!jQuery.queue(elem, 'fx').length) {\r\n            hooks.empty.fire()\r\n          }\r\n        })\r\n      })\r\n    }\r\n\r\n    // Height/width overflow pass\r\n    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {\r\n      // Make sure that nothing sneaks out\r\n      // Record all 3 overflow attributes because IE9-10 do not\r\n      // change the overflow attribute when overflowX and\r\n      // overflowY are set to the same value\r\n      opts.overflow = [style.overflow, style.overflowX, style.overflowY]\r\n\r\n      // Set display property to inline-block for height/width\r\n      // animations on inline elements that are having width/height animated\r\n      display = jQuery.css(elem, 'display')\r\n\r\n      // Test default display if display is currently \"none\"\r\n      checkDisplay = display === 'none' ? dataPriv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display\r\n\r\n      if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {\r\n        style.display = 'inline-block'\r\n      }\r\n    }\r\n\r\n    if (opts.overflow) {\r\n      style.overflow = 'hidden'\r\n      anim.always(function () {\r\n        style.overflow = opts.overflow[0]\r\n        style.overflowX = opts.overflow[1]\r\n        style.overflowY = opts.overflow[2]\r\n      })\r\n    }\r\n\r\n    // show/hide pass\r\n    for (prop in props) {\r\n      value = props[prop]\r\n      if (rfxtypes.exec(value)) {\r\n        delete props[prop]\r\n        toggle = toggle || value === 'toggle'\r\n        if (value === (hidden ? 'hide' : 'show')) {\r\n          // If there is dataShow left over from a stopped hide or show\r\n          // and we are going to proceed with show, we should pretend to be hidden\r\n          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {\r\n            hidden = true\r\n          } else {\r\n            continue\r\n          }\r\n        }\r\n        orig[prop] = (dataShow && dataShow[prop]) || jQuery.style(elem, prop)\r\n\r\n        // Any non-fx value stops us from restoring the original display value\r\n      } else {\r\n        display = undefined\r\n      }\r\n    }\r\n\r\n    if (!jQuery.isEmptyObject(orig)) {\r\n      if (dataShow) {\r\n        if ('hidden' in dataShow) {\r\n          hidden = dataShow.hidden\r\n        }\r\n      } else {\r\n        dataShow = dataPriv.access(elem, 'fxshow', {})\r\n      }\r\n\r\n      // Store state if its toggle - enables .stop().toggle() to \"reverse\"\r\n      if (toggle) {\r\n        dataShow.hidden = !hidden\r\n      }\r\n      if (hidden) {\r\n        jQuery(elem).show()\r\n      } else {\r\n        anim.done(function () {\r\n          jQuery(elem).hide()\r\n        })\r\n      }\r\n      anim.done(function () {\r\n        var prop\r\n\r\n        dataPriv.remove(elem, 'fxshow')\r\n        for (prop in orig) {\r\n          jQuery.style(elem, prop, orig[prop])\r\n        }\r\n      })\r\n      for (prop in orig) {\r\n        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim)\r\n\r\n        if (!(prop in dataShow)) {\r\n          dataShow[prop] = tween.start\r\n          if (hidden) {\r\n            tween.end = tween.start\r\n            tween.start = prop === 'width' || prop === 'height' ? 1 : 0\r\n          }\r\n        }\r\n      }\r\n\r\n      // If this is a noop like .hide().hide(), restore an overwritten display value\r\n    } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {\r\n      style.display = display\r\n    }\r\n  }\r\n\r\n  function propFilter (props, specialEasing) {\r\n    var index, name, easing, value, hooks\r\n\r\n    // camelCase, specialEasing and expand cssHook pass\r\n    for (index in props) {\r\n      name = jQuery.camelCase(index)\r\n      easing = specialEasing[name]\r\n      value = props[index]\r\n      if (jQuery.isArray(value)) {\r\n        easing = value[1]\r\n        value = props[index] = value[0]\r\n      }\r\n\r\n      if (index !== name) {\r\n        props[name] = value\r\n        delete props[index]\r\n      }\r\n\r\n      hooks = jQuery.cssHooks[name]\r\n      if (hooks && 'expand' in hooks) {\r\n        value = hooks.expand(value)\r\n        delete props[name]\r\n\r\n        // Not quite $.extend, this won't overwrite existing keys.\r\n        // Reusing 'index' because we have the correct \"name\"\r\n        for (index in value) {\r\n          if (!(index in props)) {\r\n            props[index] = value[index]\r\n            specialEasing[index] = easing\r\n          }\r\n        }\r\n      } else {\r\n        specialEasing[name] = easing\r\n      }\r\n    }\r\n  }\r\n\r\n  function Animation (elem, properties, options) {\r\n    var result,\r\n      stopped,\r\n      index = 0,\r\n      length = Animation.prefilters.length,\r\n      deferred = jQuery.Deferred().always(function () {\r\n        // Don't match elem in the :animated selector\r\n        delete tick.elem\r\n      }),\r\n      tick = function () {\r\n        if (stopped) {\r\n          return false\r\n        }\r\n        var currentTime = fxNow || createFxNow(),\r\n          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),\r\n          // Support: Android 2.3\r\n          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\r\n          temp = remaining / animation.duration || 0,\r\n          percent = 1 - temp,\r\n          index = 0,\r\n          length = animation.tweens.length\r\n\r\n        for (; index < length; index++) {\r\n          animation.tweens[index].run(percent)\r\n        }\r\n\r\n        deferred.notifyWith(elem, [animation, percent, remaining])\r\n\r\n        if (percent < 1 && length) {\r\n          return remaining\r\n        } else {\r\n          deferred.resolveWith(elem, [animation])\r\n          return false\r\n        }\r\n      },\r\n      animation = deferred.promise({\r\n        elem: elem,\r\n        props: jQuery.extend({}, properties),\r\n        opts: jQuery.extend(\r\n          true,\r\n          {\r\n            specialEasing: {},\r\n            easing: jQuery.easing._default\r\n          },\r\n          options\r\n        ),\r\n        originalProperties: properties,\r\n        originalOptions: options,\r\n        startTime: fxNow || createFxNow(),\r\n        duration: options.duration,\r\n        tweens: [],\r\n        createTween: function (prop, end) {\r\n          var tween = jQuery.Tween(\r\n            elem,\r\n            animation.opts,\r\n            prop,\r\n            end,\r\n            animation.opts.specialEasing[prop] || animation.opts.easing\r\n          )\r\n          animation.tweens.push(tween)\r\n          return tween\r\n        },\r\n        stop: function (gotoEnd) {\r\n          var index = 0,\r\n            // If we are going to the end, we want to run all the tweens\r\n            // otherwise we skip this part\r\n            length = gotoEnd ? animation.tweens.length : 0\r\n          if (stopped) {\r\n            return this\r\n          }\r\n          stopped = true\r\n          for (; index < length; index++) {\r\n            animation.tweens[index].run(1)\r\n          }\r\n\r\n          // Resolve when we played the last frame; otherwise, reject\r\n          if (gotoEnd) {\r\n            deferred.notifyWith(elem, [animation, 1, 0])\r\n            deferred.resolveWith(elem, [animation, gotoEnd])\r\n          } else {\r\n            deferred.rejectWith(elem, [animation, gotoEnd])\r\n          }\r\n          return this\r\n        }\r\n      }),\r\n      props = animation.props\r\n\r\n    propFilter(props, animation.opts.specialEasing)\r\n\r\n    for (; index < length; index++) {\r\n      result = Animation.prefilters[index].call(animation, elem, props, animation.opts)\r\n      if (result) {\r\n        if (jQuery.isFunction(result.stop)) {\r\n          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)\r\n        }\r\n        return result\r\n      }\r\n    }\r\n\r\n    jQuery.map(props, createTween, animation)\r\n\r\n    if (jQuery.isFunction(animation.opts.start)) {\r\n      animation.opts.start.call(elem, animation)\r\n    }\r\n\r\n    jQuery.fx.timer(\r\n      jQuery.extend(tick, {\r\n        elem: elem,\r\n        anim: animation,\r\n        queue: animation.opts.queue\r\n      })\r\n    )\r\n\r\n    // attach callbacks from options\r\n    return animation\r\n      .progress(animation.opts.progress)\r\n      .done(animation.opts.done, animation.opts.complete)\r\n      .fail(animation.opts.fail)\r\n      .always(animation.opts.always)\r\n  }\r\n\r\n  jQuery.Animation = jQuery.extend(Animation, {\r\n    tweeners: {\r\n      '*': [\r\n        function (prop, value) {\r\n          var tween = this.createTween(prop, value)\r\n          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween)\r\n          return tween\r\n        }\r\n      ]\r\n    },\r\n\r\n    tweener: function (props, callback) {\r\n      if (jQuery.isFunction(props)) {\r\n        callback = props\r\n        props = ['*']\r\n      } else {\r\n        props = props.match(rnotwhite)\r\n      }\r\n\r\n      var prop,\r\n        index = 0,\r\n        length = props.length\r\n\r\n      for (; index < length; index++) {\r\n        prop = props[index]\r\n        Animation.tweeners[prop] = Animation.tweeners[prop] || []\r\n        Animation.tweeners[prop].unshift(callback)\r\n      }\r\n    },\r\n\r\n    prefilters: [defaultPrefilter],\r\n\r\n    prefilter: function (callback, prepend) {\r\n      if (prepend) {\r\n        Animation.prefilters.unshift(callback)\r\n      } else {\r\n        Animation.prefilters.push(callback)\r\n      }\r\n    }\r\n  })\r\n\r\n  jQuery.speed = function (speed, easing, fn) {\r\n    var opt =\r\n      speed && typeof speed === 'object'\r\n        ? jQuery.extend({}, speed)\r\n        : {\r\n            complete: fn || (!fn && easing) || (jQuery.isFunction(speed) && speed),\r\n            duration: speed,\r\n            easing: (fn && easing) || (easing && !jQuery.isFunction(easing) && easing)\r\n          }\r\n\r\n    opt.duration = jQuery.fx.off\r\n      ? 0\r\n      : typeof opt.duration === 'number'\r\n      ? opt.duration\r\n      : opt.duration in jQuery.fx.speeds\r\n      ? jQuery.fx.speeds[opt.duration]\r\n      : jQuery.fx.speeds._default\r\n\r\n    // Normalize opt.queue - true/undefined/null -> \"fx\"\r\n    if (opt.queue == null || opt.queue === true) {\r\n      opt.queue = 'fx'\r\n    }\r\n\r\n    // Queueing\r\n    opt.old = opt.complete\r\n\r\n    opt.complete = function () {\r\n      if (jQuery.isFunction(opt.old)) {\r\n        opt.old.call(this)\r\n      }\r\n\r\n      if (opt.queue) {\r\n        jQuery.dequeue(this, opt.queue)\r\n      }\r\n    }\r\n\r\n    return opt\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    fadeTo: function (speed, to, easing, callback) {\r\n      // Show any hidden elements after setting opacity to 0\r\n      return (\r\n        this.filter(isHidden)\r\n          .css('opacity', 0)\r\n          .show()\r\n\r\n          // Animate to the value specified\r\n          .end()\r\n          .animate({ opacity: to }, speed, easing, callback)\r\n      )\r\n    },\r\n    animate: function (prop, speed, easing, callback) {\r\n      var empty = jQuery.isEmptyObject(prop),\r\n        optall = jQuery.speed(speed, easing, callback),\r\n        doAnimation = function () {\r\n          // Operate on a copy of prop so per-property easing won't be lost\r\n          var anim = Animation(this, jQuery.extend({}, prop), optall)\r\n\r\n          // Empty animations, or finishing resolves immediately\r\n          if (empty || dataPriv.get(this, 'finish')) {\r\n            anim.stop(true)\r\n          }\r\n        }\r\n      doAnimation.finish = doAnimation\r\n\r\n      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)\r\n    },\r\n    stop: function (type, clearQueue, gotoEnd) {\r\n      var stopQueue = function (hooks) {\r\n        var stop = hooks.stop\r\n        delete hooks.stop\r\n        stop(gotoEnd)\r\n      }\r\n\r\n      if (typeof type !== 'string') {\r\n        gotoEnd = clearQueue\r\n        clearQueue = type\r\n        type = undefined\r\n      }\r\n      if (clearQueue && type !== false) {\r\n        this.queue(type || 'fx', [])\r\n      }\r\n\r\n      return this.each(function () {\r\n        var dequeue = true,\r\n          index = type != null && type + 'queueHooks',\r\n          timers = jQuery.timers,\r\n          data = dataPriv.get(this)\r\n\r\n        if (index) {\r\n          if (data[index] && data[index].stop) {\r\n            stopQueue(data[index])\r\n          }\r\n        } else {\r\n          for (index in data) {\r\n            if (data[index] && data[index].stop && rrun.test(index)) {\r\n              stopQueue(data[index])\r\n            }\r\n          }\r\n        }\r\n\r\n        for (index = timers.length; index--; ) {\r\n          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {\r\n            timers[index].anim.stop(gotoEnd)\r\n            dequeue = false\r\n            timers.splice(index, 1)\r\n          }\r\n        }\r\n\r\n        // Start the next in the queue if the last step wasn't forced.\r\n        // Timers currently will call their complete callbacks, which\r\n        // will dequeue but only if they were gotoEnd.\r\n        if (dequeue || !gotoEnd) {\r\n          jQuery.dequeue(this, type)\r\n        }\r\n      })\r\n    },\r\n    finish: function (type) {\r\n      if (type !== false) {\r\n        type = type || 'fx'\r\n      }\r\n      return this.each(function () {\r\n        var index,\r\n          data = dataPriv.get(this),\r\n          queue = data[type + 'queue'],\r\n          hooks = data[type + 'queueHooks'],\r\n          timers = jQuery.timers,\r\n          length = queue ? queue.length : 0\r\n\r\n        // Enable finishing flag on private data\r\n        data.finish = true\r\n\r\n        // Empty the queue first\r\n        jQuery.queue(this, type, [])\r\n\r\n        if (hooks && hooks.stop) {\r\n          hooks.stop.call(this, true)\r\n        }\r\n\r\n        // Look for any active animations, and finish them\r\n        for (index = timers.length; index--; ) {\r\n          if (timers[index].elem === this && timers[index].queue === type) {\r\n            timers[index].anim.stop(true)\r\n            timers.splice(index, 1)\r\n          }\r\n        }\r\n\r\n        // Look for any animations in the old queue and finish them\r\n        for (index = 0; index < length; index++) {\r\n          if (queue[index] && queue[index].finish) {\r\n            queue[index].finish.call(this)\r\n          }\r\n        }\r\n\r\n        // Turn off finishing flag\r\n        delete data.finish\r\n      })\r\n    }\r\n  })\r\n\r\n  jQuery.each(['toggle', 'show', 'hide'], function (i, name) {\r\n    var cssFn = jQuery.fn[name]\r\n    jQuery.fn[name] = function (speed, easing, callback) {\r\n      return speed == null || typeof speed === 'boolean'\r\n        ? cssFn.apply(this, arguments)\r\n        : this.animate(genFx(name, true), speed, easing, callback)\r\n    }\r\n  })\r\n\r\n  // Generate shortcuts for custom animations\r\n  jQuery.each(\r\n    {\r\n      slideDown: genFx('show'),\r\n      slideUp: genFx('hide'),\r\n      slideToggle: genFx('toggle'),\r\n      fadeIn: { opacity: 'show' },\r\n      fadeOut: { opacity: 'hide' },\r\n      fadeToggle: { opacity: 'toggle' }\r\n    },\r\n    function (name, props) {\r\n      jQuery.fn[name] = function (speed, easing, callback) {\r\n        return this.animate(props, speed, easing, callback)\r\n      }\r\n    }\r\n  )\r\n\r\n  jQuery.timers = []\r\n  jQuery.fx.tick = function () {\r\n    var timer,\r\n      i = 0,\r\n      timers = jQuery.timers\r\n\r\n    fxNow = jQuery.now()\r\n\r\n    for (; i < timers.length; i++) {\r\n      timer = timers[i]\r\n\r\n      // Checks the timer has not already been removed\r\n      if (!timer() && timers[i] === timer) {\r\n        timers.splice(i--, 1)\r\n      }\r\n    }\r\n\r\n    if (!timers.length) {\r\n      jQuery.fx.stop()\r\n    }\r\n    fxNow = undefined\r\n  }\r\n\r\n  jQuery.fx.timer = function (timer) {\r\n    jQuery.timers.push(timer)\r\n    if (timer()) {\r\n      jQuery.fx.start()\r\n    } else {\r\n      jQuery.timers.pop()\r\n    }\r\n  }\r\n\r\n  jQuery.fx.interval = 13\r\n  jQuery.fx.start = function () {\r\n    if (!timerId) {\r\n      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval)\r\n    }\r\n  }\r\n\r\n  jQuery.fx.stop = function () {\r\n    window.clearInterval(timerId)\r\n\r\n    timerId = null\r\n  }\r\n\r\n  jQuery.fx.speeds = {\r\n    slow: 600,\r\n    fast: 200,\r\n\r\n    // Default speed\r\n    _default: 400\r\n  }\r\n\r\n  // Based off of the plugin by Clint Helfers, with permission.\r\n  // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\r\n  jQuery.fn.delay = function (time, type) {\r\n    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time\r\n    type = type || 'fx'\r\n\r\n    return this.queue(type, function (next, hooks) {\r\n      var timeout = window.setTimeout(next, time)\r\n      hooks.stop = function () {\r\n        window.clearTimeout(timeout)\r\n      }\r\n    })\r\n  }\r\n  ;(function () {\r\n    var input = document.createElement('input'),\r\n      select = document.createElement('select'),\r\n      opt = select.appendChild(document.createElement('option'))\r\n\r\n    input.type = 'checkbox'\r\n\r\n    // Support: iOS<=5.1, Android<=4.2+\r\n    // Default value for a checkbox should be \"on\"\r\n    support.checkOn = input.value !== ''\r\n\r\n    // Support: IE<=11+\r\n    // Must access selectedIndex to make default options select\r\n    support.optSelected = opt.selected\r\n\r\n    // Support: Android<=2.3\r\n    // Options inside disabled selects are incorrectly marked as disabled\r\n    select.disabled = true\r\n    support.optDisabled = !opt.disabled\r\n\r\n    // Support: IE<=11+\r\n    // An input loses its value after becoming a radio\r\n    input = document.createElement('input')\r\n    input.value = 't'\r\n    input.type = 'radio'\r\n    support.radioValue = input.value === 't'\r\n  })()\r\n\r\n  var boolHook,\r\n    attrHandle = jQuery.expr.attrHandle\r\n\r\n  jQuery.fn.extend({\r\n    attr: function (name, value) {\r\n      return access(this, jQuery.attr, name, value, arguments.length > 1)\r\n    },\r\n\r\n    removeAttr: function (name) {\r\n      return this.each(function () {\r\n        jQuery.removeAttr(this, name)\r\n      })\r\n    }\r\n  })\r\n\r\n  jQuery.extend({\r\n    attr: function (elem, name, value) {\r\n      var ret,\r\n        hooks,\r\n        nType = elem.nodeType\r\n\r\n      // Don't get/set attributes on text, comment and attribute nodes\r\n      if (nType === 3 || nType === 8 || nType === 2) {\r\n        return\r\n      }\r\n\r\n      // Fallback to prop when attributes are not supported\r\n      if (typeof elem.getAttribute === 'undefined') {\r\n        return jQuery.prop(elem, name, value)\r\n      }\r\n\r\n      // All attributes are lowercase\r\n      // Grab necessary hook if one is defined\r\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\r\n        name = name.toLowerCase()\r\n        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined)\r\n      }\r\n\r\n      if (value !== undefined) {\r\n        if (value === null) {\r\n          jQuery.removeAttr(elem, name)\r\n          return\r\n        }\r\n\r\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\r\n          return ret\r\n        }\r\n\r\n        elem.setAttribute(name, value + '')\r\n        return value\r\n      }\r\n\r\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\r\n        return ret\r\n      }\r\n\r\n      ret = jQuery.find.attr(elem, name)\r\n\r\n      // Non-existent attributes return null, we normalize to undefined\r\n      return ret == null ? undefined : ret\r\n    },\r\n\r\n    attrHooks: {\r\n      type: {\r\n        set: function (elem, value) {\r\n          if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {\r\n            var val = elem.value\r\n            elem.setAttribute('type', value)\r\n            if (val) {\r\n              elem.value = val\r\n            }\r\n            return value\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    removeAttr: function (elem, value) {\r\n      var name,\r\n        propName,\r\n        i = 0,\r\n        attrNames = value && value.match(rnotwhite)\r\n\r\n      if (attrNames && elem.nodeType === 1) {\r\n        while ((name = attrNames[i++])) {\r\n          propName = jQuery.propFix[name] || name\r\n\r\n          // Boolean attributes get special treatment (#10870)\r\n          if (jQuery.expr.match.bool.test(name)) {\r\n            // Set corresponding property to false\r\n            elem[propName] = false\r\n          }\r\n\r\n          elem.removeAttribute(name)\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  // Hooks for boolean attributes\r\n  boolHook = {\r\n    set: function (elem, value, name) {\r\n      if (value === false) {\r\n        // Remove boolean attributes when set to false\r\n        jQuery.removeAttr(elem, name)\r\n      } else {\r\n        elem.setAttribute(name, name)\r\n      }\r\n      return name\r\n    }\r\n  }\r\n  jQuery.each(jQuery.expr.match.bool.source.match(/\\w+/g), function (i, name) {\r\n    var getter = attrHandle[name] || jQuery.find.attr\r\n\r\n    attrHandle[name] = function (elem, name, isXML) {\r\n      var ret, handle\r\n      if (!isXML) {\r\n        // Avoid an infinite loop by temporarily removing this function from the getter\r\n        handle = attrHandle[name]\r\n        attrHandle[name] = ret\r\n        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null\r\n        attrHandle[name] = handle\r\n      }\r\n      return ret\r\n    }\r\n  })\r\n\r\n  var rfocusable = /^(?:input|select|textarea|button)$/i,\r\n    rclickable = /^(?:a|area)$/i\r\n\r\n  jQuery.fn.extend({\r\n    prop: function (name, value) {\r\n      return access(this, jQuery.prop, name, value, arguments.length > 1)\r\n    },\r\n\r\n    removeProp: function (name) {\r\n      return this.each(function () {\r\n        delete this[jQuery.propFix[name] || name]\r\n      })\r\n    }\r\n  })\r\n\r\n  jQuery.extend({\r\n    prop: function (elem, name, value) {\r\n      var ret,\r\n        hooks,\r\n        nType = elem.nodeType\r\n\r\n      // Don't get/set properties on text, comment and attribute nodes\r\n      if (nType === 3 || nType === 8 || nType === 2) {\r\n        return\r\n      }\r\n\r\n      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {\r\n        // Fix name and attach hooks\r\n        name = jQuery.propFix[name] || name\r\n        hooks = jQuery.propHooks[name]\r\n      }\r\n\r\n      if (value !== undefined) {\r\n        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {\r\n          return ret\r\n        }\r\n\r\n        return (elem[name] = value)\r\n      }\r\n\r\n      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {\r\n        return ret\r\n      }\r\n\r\n      return elem[name]\r\n    },\r\n\r\n    propHooks: {\r\n      tabIndex: {\r\n        get: function (elem) {\r\n          // elem.tabIndex doesn't always return the\r\n          // correct value when it hasn't been explicitly set\r\n          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\r\n          // Use proper attribute retrieval(#12072)\r\n          var tabindex = jQuery.find.attr(elem, 'tabindex')\r\n\r\n          return tabindex\r\n            ? parseInt(tabindex, 10)\r\n            : rfocusable.test(elem.nodeName) || (rclickable.test(elem.nodeName) && elem.href)\r\n            ? 0\r\n            : -1\r\n        }\r\n      }\r\n    },\r\n\r\n    propFix: {\r\n      for: 'htmlFor',\r\n      class: 'className'\r\n    }\r\n  })\r\n\r\n  // Support: IE <=11 only\r\n  // Accessing the selectedIndex property\r\n  // forces the browser to respect setting selected\r\n  // on the option\r\n  // The getter ensures a default option is selected\r\n  // when in an optgroup\r\n  if (!support.optSelected) {\r\n    jQuery.propHooks.selected = {\r\n      get: function (elem) {\r\n        var parent = elem.parentNode\r\n        if (parent && parent.parentNode) {\r\n          parent.parentNode.selectedIndex\r\n        }\r\n        return null\r\n      },\r\n      set: function (elem) {\r\n        var parent = elem.parentNode\r\n        if (parent) {\r\n          parent.selectedIndex\r\n\r\n          if (parent.parentNode) {\r\n            parent.parentNode.selectedIndex\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  jQuery.each(\r\n    [\r\n      'tabIndex',\r\n      'readOnly',\r\n      'maxLength',\r\n      'cellSpacing',\r\n      'cellPadding',\r\n      'rowSpan',\r\n      'colSpan',\r\n      'useMap',\r\n      'frameBorder',\r\n      'contentEditable'\r\n    ],\r\n    function () {\r\n      jQuery.propFix[this.toLowerCase()] = this\r\n    }\r\n  )\r\n\r\n  var rclass = /[\\t\\r\\n\\f]/g\r\n\r\n  function getClass (elem) {\r\n    return (elem.getAttribute && elem.getAttribute('class')) || ''\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    addClass: function (value) {\r\n      var classes,\r\n        elem,\r\n        cur,\r\n        curValue,\r\n        clazz,\r\n        j,\r\n        finalValue,\r\n        i = 0\r\n\r\n      if (jQuery.isFunction(value)) {\r\n        return this.each(function (j) {\r\n          jQuery(this).addClass(value.call(this, j, getClass(this)))\r\n        })\r\n      }\r\n\r\n      if (typeof value === 'string' && value) {\r\n        classes = value.match(rnotwhite) || []\r\n\r\n        while ((elem = this[i++])) {\r\n          curValue = getClass(elem)\r\n          cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ')\r\n\r\n          if (cur) {\r\n            j = 0\r\n            while ((clazz = classes[j++])) {\r\n              if (cur.indexOf(' ' + clazz + ' ') < 0) {\r\n                cur += clazz + ' '\r\n              }\r\n            }\r\n\r\n            // Only assign if different to avoid unneeded rendering.\r\n            finalValue = jQuery.trim(cur)\r\n            if (curValue !== finalValue) {\r\n              elem.setAttribute('class', finalValue)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return this\r\n    },\r\n\r\n    removeClass: function (value) {\r\n      var classes,\r\n        elem,\r\n        cur,\r\n        curValue,\r\n        clazz,\r\n        j,\r\n        finalValue,\r\n        i = 0\r\n\r\n      if (jQuery.isFunction(value)) {\r\n        return this.each(function (j) {\r\n          jQuery(this).removeClass(value.call(this, j, getClass(this)))\r\n        })\r\n      }\r\n\r\n      if (!arguments.length) {\r\n        return this.attr('class', '')\r\n      }\r\n\r\n      if (typeof value === 'string' && value) {\r\n        classes = value.match(rnotwhite) || []\r\n\r\n        while ((elem = this[i++])) {\r\n          curValue = getClass(elem)\r\n\r\n          // This expression is here for better compressibility (see addClass)\r\n          cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ')\r\n\r\n          if (cur) {\r\n            j = 0\r\n            while ((clazz = classes[j++])) {\r\n              // Remove *all* instances\r\n              while (cur.indexOf(' ' + clazz + ' ') > -1) {\r\n                cur = cur.replace(' ' + clazz + ' ', ' ')\r\n              }\r\n            }\r\n\r\n            // Only assign if different to avoid unneeded rendering.\r\n            finalValue = jQuery.trim(cur)\r\n            if (curValue !== finalValue) {\r\n              elem.setAttribute('class', finalValue)\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return this\r\n    },\r\n\r\n    toggleClass: function (value, stateVal) {\r\n      var type = typeof value\r\n\r\n      if (typeof stateVal === 'boolean' && type === 'string') {\r\n        return stateVal ? this.addClass(value) : this.removeClass(value)\r\n      }\r\n\r\n      if (jQuery.isFunction(value)) {\r\n        return this.each(function (i) {\r\n          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)\r\n        })\r\n      }\r\n\r\n      return this.each(function () {\r\n        var className, i, self, classNames\r\n\r\n        if (type === 'string') {\r\n          // Toggle individual class names\r\n          i = 0\r\n          self = jQuery(this)\r\n          classNames = value.match(rnotwhite) || []\r\n\r\n          while ((className = classNames[i++])) {\r\n            // Check each className given, space separated list\r\n            if (self.hasClass(className)) {\r\n              self.removeClass(className)\r\n            } else {\r\n              self.addClass(className)\r\n            }\r\n          }\r\n\r\n          // Toggle whole class name\r\n        } else if (value === undefined || type === 'boolean') {\r\n          className = getClass(this)\r\n          if (className) {\r\n            // Store className if set\r\n            dataPriv.set(this, '__className__', className)\r\n          }\r\n\r\n          // If the element has a class name or if we're passed `false`,\r\n          // then remove the whole classname (if there was one, the above saved it).\r\n          // Otherwise bring back whatever was previously saved (if anything),\r\n          // falling back to the empty string if nothing was stored.\r\n          if (this.setAttribute) {\r\n            this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '')\r\n          }\r\n        }\r\n      })\r\n    },\r\n\r\n    hasClass: function (selector) {\r\n      var className,\r\n        elem,\r\n        i = 0\r\n\r\n      className = ' ' + selector + ' '\r\n      while ((elem = this[i++])) {\r\n        if (elem.nodeType === 1 && (' ' + getClass(elem) + ' ').replace(rclass, ' ').indexOf(className) > -1) {\r\n          return true\r\n        }\r\n      }\r\n\r\n      return false\r\n    }\r\n  })\r\n\r\n  var rreturn = /\\r/g,\r\n    rspaces = /[\\x20\\t\\r\\n\\f]+/g\r\n\r\n  jQuery.fn.extend({\r\n    val: function (value) {\r\n      var hooks,\r\n        ret,\r\n        isFunction,\r\n        elem = this[0]\r\n\r\n      if (!arguments.length) {\r\n        if (elem) {\r\n          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]\r\n\r\n          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {\r\n            return ret\r\n          }\r\n\r\n          ret = elem.value\r\n\r\n          return typeof ret === 'string'\r\n            ? // Handle most common string cases\r\n              ret.replace(rreturn, '')\r\n            : // Handle cases where value is null/undef or number\r\n            ret == null\r\n            ? ''\r\n            : ret\r\n        }\r\n\r\n        return\r\n      }\r\n\r\n      isFunction = jQuery.isFunction(value)\r\n\r\n      return this.each(function (i) {\r\n        var val\r\n\r\n        if (this.nodeType !== 1) {\r\n          return\r\n        }\r\n\r\n        if (isFunction) {\r\n          val = value.call(this, i, jQuery(this).val())\r\n        } else {\r\n          val = value\r\n        }\r\n\r\n        // Treat null/undefined as \"\"; convert numbers to string\r\n        if (val == null) {\r\n          val = ''\r\n        } else if (typeof val === 'number') {\r\n          val += ''\r\n        } else if (jQuery.isArray(val)) {\r\n          val = jQuery.map(val, function (value) {\r\n            return value == null ? '' : value + ''\r\n          })\r\n        }\r\n\r\n        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]\r\n\r\n        // If set returns undefined, fall back to normal setting\r\n        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {\r\n          this.value = val\r\n        }\r\n      })\r\n    }\r\n  })\r\n\r\n  jQuery.extend({\r\n    valHooks: {\r\n      option: {\r\n        get: function (elem) {\r\n          var val = jQuery.find.attr(elem, 'value')\r\n          return val != null\r\n            ? val\r\n            : // Support: IE10-11+\r\n              // option.text throws exceptions (#14686, #14858)\r\n              // Strip and collapse whitespace\r\n              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace\r\n              jQuery.trim(jQuery.text(elem)).replace(rspaces, ' ')\r\n        }\r\n      },\r\n      select: {\r\n        get: function (elem) {\r\n          var value,\r\n            option,\r\n            options = elem.options,\r\n            index = elem.selectedIndex,\r\n            one = elem.type === 'select-one' || index < 0,\r\n            values = one ? null : [],\r\n            max = one ? index + 1 : options.length,\r\n            i = index < 0 ? max : one ? index : 0\r\n\r\n          // Loop through all the selected options\r\n          for (; i < max; i++) {\r\n            option = options[i]\r\n\r\n            // IE8-9 doesn't update selected after form reset (#2551)\r\n            if (\r\n              (option.selected || i === index) &&\r\n              // Don't return options that are disabled or in a disabled optgroup\r\n              (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) &&\r\n              (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))\r\n            ) {\r\n              // Get the specific value for the option\r\n              value = jQuery(option).val()\r\n\r\n              // We don't need an array for one selects\r\n              if (one) {\r\n                return value\r\n              }\r\n\r\n              // Multi-Selects return an array\r\n              values.push(value)\r\n            }\r\n          }\r\n\r\n          return values\r\n        },\r\n\r\n        set: function (elem, value) {\r\n          var optionSet,\r\n            option,\r\n            options = elem.options,\r\n            values = jQuery.makeArray(value),\r\n            i = options.length\r\n\r\n          while (i--) {\r\n            option = options[i]\r\n            if ((option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1)) {\r\n              optionSet = true\r\n            }\r\n          }\r\n\r\n          // Force browsers to behave consistently when non-matching value is set\r\n          if (!optionSet) {\r\n            elem.selectedIndex = -1\r\n          }\r\n          return values\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  // Radios and checkboxes getter/setter\r\n  jQuery.each(['radio', 'checkbox'], function () {\r\n    jQuery.valHooks[this] = {\r\n      set: function (elem, value) {\r\n        if (jQuery.isArray(value)) {\r\n          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1)\r\n        }\r\n      }\r\n    }\r\n    if (!support.checkOn) {\r\n      jQuery.valHooks[this].get = function (elem) {\r\n        return elem.getAttribute('value') === null ? 'on' : elem.value\r\n      }\r\n    }\r\n  })\r\n\r\n  // Return jQuery for attributes-only inclusion\r\n\r\n  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/\r\n\r\n  jQuery.extend(jQuery.event, {\r\n    trigger: function (event, data, elem, onlyHandlers) {\r\n      var i,\r\n        cur,\r\n        tmp,\r\n        bubbleType,\r\n        ontype,\r\n        handle,\r\n        special,\r\n        eventPath = [elem || document],\r\n        type = hasOwn.call(event, 'type') ? event.type : event,\r\n        namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : []\r\n\r\n      cur = tmp = elem = elem || document\r\n\r\n      // Don't do events on text and comment nodes\r\n      if (elem.nodeType === 3 || elem.nodeType === 8) {\r\n        return\r\n      }\r\n\r\n      // focus/blur morphs to focusin/out; ensure we're not firing them right now\r\n      if (rfocusMorph.test(type + jQuery.event.triggered)) {\r\n        return\r\n      }\r\n\r\n      if (type.indexOf('.') > -1) {\r\n        // Namespaced trigger; create a regexp to match event type in handle()\r\n        namespaces = type.split('.')\r\n        type = namespaces.shift()\r\n        namespaces.sort()\r\n      }\r\n      ontype = type.indexOf(':') < 0 && 'on' + type\r\n\r\n      // Caller can pass in a jQuery.Event object, Object, or just an event type string\r\n      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event)\r\n\r\n      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\r\n      event.isTrigger = onlyHandlers ? 2 : 3\r\n      event.namespace = namespaces.join('.')\r\n      event.rnamespace = event.namespace ? new RegExp('(^|\\\\.)' + namespaces.join('\\\\.(?:.*\\\\.|)') + '(\\\\.|$)') : null\r\n\r\n      // Clean up the event in case it is being reused\r\n      event.result = undefined\r\n      if (!event.target) {\r\n        event.target = elem\r\n      }\r\n\r\n      // Clone any incoming data and prepend the event, creating the handler arg list\r\n      data = data == null ? [event] : jQuery.makeArray(data, [event])\r\n\r\n      // Allow special events to draw outside the lines\r\n      special = jQuery.event.special[type] || {}\r\n      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {\r\n        return\r\n      }\r\n\r\n      // Determine event propagation path in advance, per W3C events spec (#9951)\r\n      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\r\n      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {\r\n        bubbleType = special.delegateType || type\r\n        if (!rfocusMorph.test(bubbleType + type)) {\r\n          cur = cur.parentNode\r\n        }\r\n        for (; cur; cur = cur.parentNode) {\r\n          eventPath.push(cur)\r\n          tmp = cur\r\n        }\r\n\r\n        // Only add window if we got to document (e.g., not plain obj or detached DOM)\r\n        if (tmp === (elem.ownerDocument || document)) {\r\n          eventPath.push(tmp.defaultView || tmp.parentWindow || window)\r\n        }\r\n      }\r\n\r\n      // Fire handlers on the event path\r\n      i = 0\r\n      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {\r\n        event.type = i > 1 ? bubbleType : special.bindType || type\r\n\r\n        // jQuery handler\r\n        handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle')\r\n        if (handle) {\r\n          handle.apply(cur, data)\r\n        }\r\n\r\n        // Native handler\r\n        handle = ontype && cur[ontype]\r\n        if (handle && handle.apply && acceptData(cur)) {\r\n          event.result = handle.apply(cur, data)\r\n          if (event.result === false) {\r\n            event.preventDefault()\r\n          }\r\n        }\r\n      }\r\n      event.type = type\r\n\r\n      // If nobody prevented the default action, do it now\r\n      if (!onlyHandlers && !event.isDefaultPrevented()) {\r\n        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {\r\n          // Call a native DOM method on the target with the same name name as the event.\r\n          // Don't do default actions on window, that's where global variables be (#6170)\r\n          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {\r\n            // Don't re-trigger an onFOO event when we call its FOO() method\r\n            tmp = elem[ontype]\r\n\r\n            if (tmp) {\r\n              elem[ontype] = null\r\n            }\r\n\r\n            // Prevent re-triggering of the same event, since we already bubbled it above\r\n            jQuery.event.triggered = type\r\n            elem[type]()\r\n            jQuery.event.triggered = undefined\r\n\r\n            if (tmp) {\r\n              elem[ontype] = tmp\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return event.result\r\n    },\r\n\r\n    // Piggyback on a donor event to simulate a different one\r\n    // Used only for `focus(in | out)` events\r\n    simulate: function (type, elem, event) {\r\n      var e = jQuery.extend(new jQuery.Event(), event, {\r\n        type: type,\r\n        isSimulated: true\r\n      })\r\n\r\n      jQuery.event.trigger(e, null, elem)\r\n    }\r\n  })\r\n\r\n  jQuery.fn.extend({\r\n    trigger: function (type, data) {\r\n      return this.each(function () {\r\n        jQuery.event.trigger(type, data, this)\r\n      })\r\n    },\r\n    triggerHandler: function (type, data) {\r\n      var elem = this[0]\r\n      if (elem) {\r\n        return jQuery.event.trigger(type, data, elem, true)\r\n      }\r\n    }\r\n  })\r\n\r\n  jQuery.each(\r\n    (\r\n      'blur focus focusin focusout load resize scroll unload click dblclick ' +\r\n      'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' +\r\n      'change select submit keydown keypress keyup error contextmenu'\r\n    ).split(' '),\r\n    function (i, name) {\r\n      // Handle event binding\r\n      jQuery.fn[name] = function (data, fn) {\r\n        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)\r\n      }\r\n    }\r\n  )\r\n\r\n  jQuery.fn.extend({\r\n    hover: function (fnOver, fnOut) {\r\n      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)\r\n    }\r\n  })\r\n\r\n  support.focusin = 'onfocusin' in window\r\n\r\n  // Support: Firefox\r\n  // Firefox doesn't have focus(in | out) events\r\n  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\r\n  //\r\n  // Support: Chrome, Safari\r\n  // focus(in | out) events fire after focus & blur events,\r\n  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\r\n  // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857\r\n  if (!support.focusin) {\r\n    jQuery.each({ focus: 'focusin', blur: 'focusout' }, function (orig, fix) {\r\n      // Attach a single capturing handler on the document while someone wants focusin/focusout\r\n      var handler = function (event) {\r\n        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))\r\n      }\r\n\r\n      jQuery.event.special[fix] = {\r\n        setup: function () {\r\n          var doc = this.ownerDocument || this,\r\n            attaches = dataPriv.access(doc, fix)\r\n\r\n          if (!attaches) {\r\n            doc.addEventListener(orig, handler, true)\r\n          }\r\n          dataPriv.access(doc, fix, (attaches || 0) + 1)\r\n        },\r\n        teardown: function () {\r\n          var doc = this.ownerDocument || this,\r\n            attaches = dataPriv.access(doc, fix) - 1\r\n\r\n          if (!attaches) {\r\n            doc.removeEventListener(orig, handler, true)\r\n            dataPriv.remove(doc, fix)\r\n          } else {\r\n            dataPriv.access(doc, fix, attaches)\r\n          }\r\n        }\r\n      }\r\n    })\r\n  }\r\n  var location = window.location\r\n\r\n  var nonce = jQuery.now()\r\n\r\n  var rquery = /\\?/\r\n\r\n  // Support: Android 2.3\r\n  // Workaround failure to string-cast null input\r\n  jQuery.parseJSON = function (data) {\r\n    return JSON.parse(data + '')\r\n  }\r\n\r\n  // Cross-browser xml parsing\r\n  jQuery.parseXML = function (data) {\r\n    var xml\r\n    if (!data || typeof data !== 'string') {\r\n      return null\r\n    }\r\n\r\n    // Support: IE9\r\n    try {\r\n      xml = new window.DOMParser().parseFromString(data, 'text/xml')\r\n    } catch (e) {\r\n      xml = undefined\r\n    }\r\n\r\n    if (!xml || xml.getElementsByTagName('parsererror').length) {\r\n      jQuery.error('Invalid XML: ' + data)\r\n    }\r\n    return xml\r\n  }\r\n\r\n  var rhash = /#.*$/,\r\n    rts = /([?&])_=[^&]*/,\r\n    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\r\n    // #7653, #8125, #8152: local protocol detection\r\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\r\n    rnoContent = /^(?:GET|HEAD)$/,\r\n    rprotocol = /^\\/\\//,\r\n    /* Prefilters\r\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\r\n     * 2) These are called:\r\n     *    - BEFORE asking for a transport\r\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\r\n     * 3) key is the dataType\r\n     * 4) the catchall symbol \"*\" can be used\r\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\r\n     */\r\n    prefilters = {},\r\n    /* Transports bindings\r\n     * 1) key is the dataType\r\n     * 2) the catchall symbol \"*\" can be used\r\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\r\n     */\r\n    transports = {},\r\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\r\n    allTypes = '*/'.concat('*'),\r\n    // Anchor tag for parsing the document origin\r\n    originAnchor = document.createElement('a')\r\n  originAnchor.href = location.href\r\n\r\n  // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\r\n  function addToPrefiltersOrTransports (structure) {\r\n    // dataTypeExpression is optional and defaults to \"*\"\r\n    return function (dataTypeExpression, func) {\r\n      if (typeof dataTypeExpression !== 'string') {\r\n        func = dataTypeExpression\r\n        dataTypeExpression = '*'\r\n      }\r\n\r\n      var dataType,\r\n        i = 0,\r\n        dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || []\r\n\r\n      if (jQuery.isFunction(func)) {\r\n        // For each dataType in the dataTypeExpression\r\n        while ((dataType = dataTypes[i++])) {\r\n          // Prepend if requested\r\n          if (dataType[0] === '+') {\r\n            dataType = dataType.slice(1) || '*'\r\n            ;(structure[dataType] = structure[dataType] || []).unshift(func)\r\n\r\n            // Otherwise append\r\n          } else {\r\n            ;(structure[dataType] = structure[dataType] || []).push(func)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Base inspection function for prefilters and transports\r\n  function inspectPrefiltersOrTransports (structure, options, originalOptions, jqXHR) {\r\n    var inspected = {},\r\n      seekingTransport = structure === transports\r\n\r\n    function inspect (dataType) {\r\n      var selected\r\n      inspected[dataType] = true\r\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\r\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR)\r\n        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {\r\n          options.dataTypes.unshift(dataTypeOrTransport)\r\n          inspect(dataTypeOrTransport)\r\n          return false\r\n        } else if (seekingTransport) {\r\n          return !(selected = dataTypeOrTransport)\r\n        }\r\n      })\r\n      return selected\r\n    }\r\n\r\n    return inspect(options.dataTypes[0]) || (!inspected['*'] && inspect('*'))\r\n  }\r\n\r\n  // A special extend for ajax options\r\n  // that takes \"flat\" options (not to be deep extended)\r\n  // Fixes #9887\r\n  function ajaxExtend (target, src) {\r\n    var key,\r\n      deep,\r\n      flatOptions = jQuery.ajaxSettings.flatOptions || {}\r\n\r\n    for (key in src) {\r\n      if (src[key] !== undefined) {\r\n        ;(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]\r\n      }\r\n    }\r\n    if (deep) {\r\n      jQuery.extend(true, target, deep)\r\n    }\r\n\r\n    return target\r\n  }\r\n\r\n  /* Handles responses to an ajax request:\r\n   * - finds the right dataType (mediates between content-type and expected dataType)\r\n   * - returns the corresponding response\r\n   */\r\n  function ajaxHandleResponses (s, jqXHR, responses) {\r\n    var ct,\r\n      type,\r\n      finalDataType,\r\n      firstDataType,\r\n      contents = s.contents,\r\n      dataTypes = s.dataTypes\r\n\r\n    // Remove auto dataType and get content-type in the process\r\n    while (dataTypes[0] === '*') {\r\n      dataTypes.shift()\r\n      if (ct === undefined) {\r\n        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type')\r\n      }\r\n    }\r\n\r\n    // Check if we're dealing with a known content-type\r\n    if (ct) {\r\n      for (type in contents) {\r\n        if (contents[type] && contents[type].test(ct)) {\r\n          dataTypes.unshift(type)\r\n          break\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check to see if we have a response for the expected dataType\r\n    if (dataTypes[0] in responses) {\r\n      finalDataType = dataTypes[0]\r\n    } else {\r\n      // Try convertible dataTypes\r\n      for (type in responses) {\r\n        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {\r\n          finalDataType = type\r\n          break\r\n        }\r\n        if (!firstDataType) {\r\n          firstDataType = type\r\n        }\r\n      }\r\n\r\n      // Or just use first one\r\n      finalDataType = finalDataType || firstDataType\r\n    }\r\n\r\n    // If we found a dataType\r\n    // We add the dataType to the list if needed\r\n    // and return the corresponding response\r\n    if (finalDataType) {\r\n      if (finalDataType !== dataTypes[0]) {\r\n        dataTypes.unshift(finalDataType)\r\n      }\r\n      return responses[finalDataType]\r\n    }\r\n  }\r\n\r\n  /* Chain conversions given the request and the original response\r\n   * Also sets the responseXXX fields on the jqXHR instance\r\n   */\r\n  function ajaxConvert (s, response, jqXHR, isSuccess) {\r\n    var conv2,\r\n      current,\r\n      conv,\r\n      tmp,\r\n      prev,\r\n      converters = {},\r\n      // Work with a copy of dataTypes in case we need to modify it for conversion\r\n      dataTypes = s.dataTypes.slice()\r\n\r\n    // Create converters map with lowercased keys\r\n    if (dataTypes[1]) {\r\n      for (conv in s.converters) {\r\n        converters[conv.toLowerCase()] = s.converters[conv]\r\n      }\r\n    }\r\n\r\n    current = dataTypes.shift()\r\n\r\n    // Convert to each sequential dataType\r\n    while (current) {\r\n      if (s.responseFields[current]) {\r\n        jqXHR[s.responseFields[current]] = response\r\n      }\r\n\r\n      // Apply the dataFilter if provided\r\n      if (!prev && isSuccess && s.dataFilter) {\r\n        response = s.dataFilter(response, s.dataType)\r\n      }\r\n\r\n      prev = current\r\n      current = dataTypes.shift()\r\n\r\n      if (current) {\r\n        // There's only work to do if current dataType is non-auto\r\n        if (current === '*') {\r\n          current = prev\r\n\r\n          // Convert response if prev dataType is non-auto and differs from current\r\n        } else if (prev !== '*' && prev !== current) {\r\n          // Seek a direct converter\r\n          conv = converters[prev + ' ' + current] || converters['* ' + current]\r\n\r\n          // If none found, seek a pair\r\n          if (!conv) {\r\n            for (conv2 in converters) {\r\n              // If conv2 outputs current\r\n              tmp = conv2.split(' ')\r\n              if (tmp[1] === current) {\r\n                // If prev can be converted to accepted input\r\n                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]]\r\n                if (conv) {\r\n                  // Condense equivalence converters\r\n                  if (conv === true) {\r\n                    conv = converters[conv2]\r\n\r\n                    // Otherwise, insert the intermediate dataType\r\n                  } else if (converters[conv2] !== true) {\r\n                    current = tmp[0]\r\n                    dataTypes.unshift(tmp[1])\r\n                  }\r\n                  break\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Apply converter (if not an equivalence)\r\n          if (conv !== true) {\r\n            // Unless errors are allowed to bubble, catch and return them\r\n            if (conv && s.throws) {\r\n              response = conv(response)\r\n            } else {\r\n              try {\r\n                response = conv(response)\r\n              } catch (e) {\r\n                return {\r\n                  state: 'parsererror',\r\n                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return { state: 'success', data: response }\r\n  }\r\n\r\n  jQuery.extend({\r\n    // Counter for holding the number of active queries\r\n    active: 0,\r\n\r\n    // Last-Modified header cache for next request\r\n    lastModified: {},\r\n    etag: {},\r\n\r\n    ajaxSettings: {\r\n      url: location.href,\r\n      type: 'GET',\r\n      isLocal: rlocalProtocol.test(location.protocol),\r\n      global: true,\r\n      processData: true,\r\n      async: true,\r\n      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',\r\n      /*\r\n\t\ttimeout: 0,\r\n\t\tdata: null,\r\n\t\tdataType: null,\r\n\t\tusername: null,\r\n\t\tpassword: null,\r\n\t\tcache: null,\r\n\t\tthrows: false,\r\n\t\ttraditional: false,\r\n\t\theaders: {},\r\n\t\t*/\r\n\r\n      accepts: {\r\n        '*': allTypes,\r\n        text: 'text/plain',\r\n        html: 'text/html',\r\n        xml: 'application/xml, text/xml',\r\n        json: 'application/json, text/javascript'\r\n      },\r\n\r\n      contents: {\r\n        xml: /\\bxml\\b/,\r\n        html: /\\bhtml/,\r\n        json: /\\bjson\\b/\r\n      },\r\n\r\n      responseFields: {\r\n        xml: 'responseXML',\r\n        text: 'responseText',\r\n        json: 'responseJSON'\r\n      },\r\n\r\n      // Data converters\r\n      // Keys separate source (or catchall \"*\") and destination types with a single space\r\n      converters: {\r\n        // Convert anything to text\r\n        '* text': String,\r\n\r\n        // Text to html (true = no transformation)\r\n        'text html': true,\r\n\r\n        // Evaluate text as a json expression\r\n        'text json': jQuery.parseJSON,\r\n\r\n        // Parse text as xml\r\n        'text xml': jQuery.parseXML\r\n      },\r\n\r\n      // For options that shouldn't be deep extended:\r\n      // you can add your own custom options here if\r\n      // and when you create one that shouldn't be\r\n      // deep extended (see ajaxExtend)\r\n      flatOptions: {\r\n        url: true,\r\n        context: true\r\n      }\r\n    },\r\n\r\n    // Creates a full fledged settings object into target\r\n    // with both ajaxSettings and settings fields.\r\n    // If target is omitted, writes into ajaxSettings.\r\n    ajaxSetup: function (target, settings) {\r\n      return settings\r\n        ? // Building a settings object\r\n          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)\r\n        : // Extending ajaxSettings\r\n          ajaxExtend(jQuery.ajaxSettings, target)\r\n    },\r\n\r\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\r\n    ajaxTransport: addToPrefiltersOrTransports(transports),\r\n\r\n    // Main method\r\n    ajax: function (url, options) {\r\n      // If url is an object, simulate pre-1.5 signature\r\n      if (typeof url === 'object') {\r\n        options = url\r\n        url = undefined\r\n      }\r\n\r\n      // Force options to be an object\r\n      options = options || {}\r\n\r\n      var transport,\r\n        // URL without anti-cache param\r\n        cacheURL,\r\n        // Response headers\r\n        responseHeadersString,\r\n        responseHeaders,\r\n        // timeout handle\r\n        timeoutTimer,\r\n        // Url cleanup var\r\n        urlAnchor,\r\n        // To know if global events are to be dispatched\r\n        fireGlobals,\r\n        // Loop variable\r\n        i,\r\n        // Create the final options object\r\n        s = jQuery.ajaxSetup({}, options),\r\n        // Callbacks context\r\n        callbackContext = s.context || s,\r\n        // Context for global events is callbackContext if it is a DOM node or jQuery collection\r\n        globalEventContext =\r\n          s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\r\n        // Deferreds\r\n        deferred = jQuery.Deferred(),\r\n        completeDeferred = jQuery.Callbacks('once memory'),\r\n        // Status-dependent callbacks\r\n        statusCode = s.statusCode || {},\r\n        // Headers (they are sent all at once)\r\n        requestHeaders = {},\r\n        requestHeadersNames = {},\r\n        // The jqXHR state\r\n        state = 0,\r\n        // Default abort message\r\n        strAbort = 'canceled',\r\n        // Fake xhr\r\n        jqXHR = {\r\n          readyState: 0,\r\n\r\n          // Builds headers hashtable if needed\r\n          getResponseHeader: function (key) {\r\n            var match\r\n            if (state === 2) {\r\n              if (!responseHeaders) {\r\n                responseHeaders = {}\r\n                while ((match = rheaders.exec(responseHeadersString))) {\r\n                  responseHeaders[match[1].toLowerCase()] = match[2]\r\n                }\r\n              }\r\n              match = responseHeaders[key.toLowerCase()]\r\n            }\r\n            return match == null ? null : match\r\n          },\r\n\r\n          // Raw string\r\n          getAllResponseHeaders: function () {\r\n            return state === 2 ? responseHeadersString : null\r\n          },\r\n\r\n          // Caches the header\r\n          setRequestHeader: function (name, value) {\r\n            var lname = name.toLowerCase()\r\n            if (!state) {\r\n              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name\r\n              requestHeaders[name] = value\r\n            }\r\n            return this\r\n          },\r\n\r\n          // Overrides response content-type header\r\n          overrideMimeType: function (type) {\r\n            if (!state) {\r\n              s.mimeType = type\r\n            }\r\n            return this\r\n          },\r\n\r\n          // Status-dependent callbacks\r\n          statusCode: function (map) {\r\n            var code\r\n            if (map) {\r\n              if (state < 2) {\r\n                for (code in map) {\r\n                  // Lazy-add the new callback in a way that preserves old ones\r\n                  statusCode[code] = [statusCode[code], map[code]]\r\n                }\r\n              } else {\r\n                // Execute the appropriate callbacks\r\n                jqXHR.always(map[jqXHR.status])\r\n              }\r\n            }\r\n            return this\r\n          },\r\n\r\n          // Cancel the request\r\n          abort: function (statusText) {\r\n            var finalText = statusText || strAbort\r\n            if (transport) {\r\n              transport.abort(finalText)\r\n            }\r\n            done(0, finalText)\r\n            return this\r\n          }\r\n        }\r\n\r\n      // Attach deferreds\r\n      deferred.promise(jqXHR).complete = completeDeferred.add\r\n      jqXHR.success = jqXHR.done\r\n      jqXHR.error = jqXHR.fail\r\n\r\n      // Remove hash character (#7531: and string promotion)\r\n      // Add protocol if not provided (prefilters might expect it)\r\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\r\n      // We also use the url parameter if available\r\n      s.url = ((url || s.url || location.href) + '').replace(rhash, '').replace(rprotocol, location.protocol + '//')\r\n\r\n      // Alias method option to type as per ticket #12004\r\n      s.type = options.method || options.type || s.method || s.type\r\n\r\n      // Extract dataTypes list\r\n      s.dataTypes = jQuery\r\n        .trim(s.dataType || '*')\r\n        .toLowerCase()\r\n        .match(rnotwhite) || ['']\r\n\r\n      // A cross-domain request is in order when the origin doesn't match the current origin.\r\n      if (s.crossDomain == null) {\r\n        urlAnchor = document.createElement('a')\r\n\r\n        // Support: IE8-11+\r\n        // IE throws exception if url is malformed, e.g. http://example.com:80x/\r\n        try {\r\n          urlAnchor.href = s.url\r\n\r\n          // Support: IE8-11+\r\n          // Anchor's host property isn't correctly set when s.url is relative\r\n          urlAnchor.href = urlAnchor.href\r\n          s.crossDomain =\r\n            originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host\r\n        } catch (e) {\r\n          // If there is an error parsing the URL, assume it is crossDomain,\r\n          // it can be rejected by the transport if it is invalid\r\n          s.crossDomain = true\r\n        }\r\n      }\r\n\r\n      // Convert data if not already a string\r\n      if (s.data && s.processData && typeof s.data !== 'string') {\r\n        s.data = jQuery.param(s.data, s.traditional)\r\n      }\r\n\r\n      // Apply prefilters\r\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR)\r\n\r\n      // If request was aborted inside a prefilter, stop there\r\n      if (state === 2) {\r\n        return jqXHR\r\n      }\r\n\r\n      // We can fire global events as of now if asked to\r\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\r\n      fireGlobals = jQuery.event && s.global\r\n\r\n      // Watch for a new set of requests\r\n      if (fireGlobals && jQuery.active++ === 0) {\r\n        jQuery.event.trigger('ajaxStart')\r\n      }\r\n\r\n      // Uppercase the type\r\n      s.type = s.type.toUpperCase()\r\n\r\n      // Determine if request has content\r\n      s.hasContent = !rnoContent.test(s.type)\r\n\r\n      // Save the URL in case we're toying with the If-Modified-Since\r\n      // and/or If-None-Match header later on\r\n      cacheURL = s.url\r\n\r\n      // More options handling for requests with no content\r\n      if (!s.hasContent) {\r\n        // If data is available, append data to url\r\n        if (s.data) {\r\n          cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data\r\n\r\n          // #9682: remove data so that it's not used in an eventual retry\r\n          delete s.data\r\n        }\r\n\r\n        // Add anti-cache in url if needed\r\n        if (s.cache === false) {\r\n          s.url = rts.test(cacheURL)\r\n            ? // If there is already a '_' parameter, set its value\r\n              cacheURL.replace(rts, '$1_=' + nonce++)\r\n            : // Otherwise add one to the end\r\n              cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++\r\n        }\r\n      }\r\n\r\n      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n      if (s.ifModified) {\r\n        if (jQuery.lastModified[cacheURL]) {\r\n          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL])\r\n        }\r\n        if (jQuery.etag[cacheURL]) {\r\n          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL])\r\n        }\r\n      }\r\n\r\n      // Set the correct header, if data is being sent\r\n      if ((s.data && s.hasContent && s.contentType !== false) || options.contentType) {\r\n        jqXHR.setRequestHeader('Content-Type', s.contentType)\r\n      }\r\n\r\n      // Set the Accepts header for the server, depending on the dataType\r\n      jqXHR.setRequestHeader(\r\n        'Accept',\r\n        s.dataTypes[0] && s.accepts[s.dataTypes[0]]\r\n          ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '')\r\n          : s.accepts['*']\r\n      )\r\n\r\n      // Check for headers option\r\n      for (i in s.headers) {\r\n        jqXHR.setRequestHeader(i, s.headers[i])\r\n      }\r\n\r\n      // Allow custom headers/mimetypes and early abort\r\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\r\n        // Abort if not done already and return\r\n        return jqXHR.abort()\r\n      }\r\n\r\n      // Aborting is no longer a cancellation\r\n      strAbort = 'abort'\r\n\r\n      // Install callbacks on deferreds\r\n      for (i in { success: 1, error: 1, complete: 1 }) {\r\n        jqXHR[i](s[i])\r\n      }\r\n\r\n      // Get transport\r\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)\r\n\r\n      // If no transport, we auto-abort\r\n      if (!transport) {\r\n        done(-1, 'No Transport')\r\n      } else {\r\n        jqXHR.readyState = 1\r\n\r\n        // Send global event\r\n        if (fireGlobals) {\r\n          globalEventContext.trigger('ajaxSend', [jqXHR, s])\r\n        }\r\n\r\n        // If request was aborted inside ajaxSend, stop there\r\n        if (state === 2) {\r\n          return jqXHR\r\n        }\r\n\r\n        // Timeout\r\n        if (s.async && s.timeout > 0) {\r\n          timeoutTimer = window.setTimeout(function () {\r\n            jqXHR.abort('timeout')\r\n          }, s.timeout)\r\n        }\r\n\r\n        try {\r\n          state = 1\r\n          transport.send(requestHeaders, done)\r\n        } catch (e) {\r\n          // Propagate exception as error if not done\r\n          if (state < 2) {\r\n            done(-1, e)\r\n\r\n            // Simply rethrow otherwise\r\n          } else {\r\n            throw e\r\n          }\r\n        }\r\n      }\r\n\r\n      // Callback for when everything is done\r\n      function done (status, nativeStatusText, responses, headers) {\r\n        var isSuccess,\r\n          success,\r\n          error,\r\n          response,\r\n          modified,\r\n          statusText = nativeStatusText\r\n\r\n        // Called once\r\n        if (state === 2) {\r\n          return\r\n        }\r\n\r\n        // State is \"done\" now\r\n        state = 2\r\n\r\n        // Clear timeout if it exists\r\n        if (timeoutTimer) {\r\n          window.clearTimeout(timeoutTimer)\r\n        }\r\n\r\n        // Dereference transport for early garbage collection\r\n        // (no matter how long the jqXHR object will be used)\r\n        transport = undefined\r\n\r\n        // Cache response headers\r\n        responseHeadersString = headers || ''\r\n\r\n        // Set readyState\r\n        jqXHR.readyState = status > 0 ? 4 : 0\r\n\r\n        // Determine if successful\r\n        isSuccess = (status >= 200 && status < 300) || status === 304\r\n\r\n        // Get response data\r\n        if (responses) {\r\n          response = ajaxHandleResponses(s, jqXHR, responses)\r\n        }\r\n\r\n        // Convert no matter what (that way responseXXX fields are always set)\r\n        response = ajaxConvert(s, response, jqXHR, isSuccess)\r\n\r\n        // If successful, handle type chaining\r\n        if (isSuccess) {\r\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\r\n          if (s.ifModified) {\r\n            modified = jqXHR.getResponseHeader('Last-Modified')\r\n            if (modified) {\r\n              jQuery.lastModified[cacheURL] = modified\r\n            }\r\n            modified = jqXHR.getResponseHeader('etag')\r\n            if (modified) {\r\n              jQuery.etag[cacheURL] = modified\r\n            }\r\n          }\r\n\r\n          // if no content\r\n          if (status === 204 || s.type === 'HEAD') {\r\n            statusText = 'nocontent'\r\n\r\n            // if not modified\r\n          } else if (status === 304) {\r\n            statusText = 'notmodified'\r\n\r\n            // If we have data, let's convert it\r\n          } else {\r\n            statusText = response.state\r\n            success = response.data\r\n            error = response.error\r\n            isSuccess = !error\r\n          }\r\n        } else {\r\n          // Extract error from statusText and normalize for non-aborts\r\n          error = statusText\r\n          if (status || !statusText) {\r\n            statusText = 'error'\r\n            if (status < 0) {\r\n              status = 0\r\n            }\r\n          }\r\n        }\r\n\r\n        // Set data for the fake xhr object\r\n        jqXHR.status = status\r\n        jqXHR.statusText = (nativeStatusText || statusText) + ''\r\n\r\n        // Success/Error\r\n        if (isSuccess) {\r\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR])\r\n        } else {\r\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error])\r\n        }\r\n\r\n        // Status-dependent callbacks\r\n        jqXHR.statusCode(statusCode)\r\n        statusCode = undefined\r\n\r\n        if (fireGlobals) {\r\n          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [jqXHR, s, isSuccess ? success : error])\r\n        }\r\n\r\n        // Complete\r\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText])\r\n\r\n        if (fireGlobals) {\r\n          globalEventContext.trigger('ajaxComplete', [jqXHR, s])\r\n\r\n          // Handle the global AJAX counter\r\n          if (!--jQuery.active) {\r\n            jQuery.event.trigger('ajaxStop')\r\n          }\r\n        }\r\n      }\r\n\r\n      return jqXHR\r\n    },\r\n\r\n    getJSON: function (url, data, callback) {\r\n      return jQuery.get(url, data, callback, 'json')\r\n    },\r\n\r\n    getScript: function (url, callback) {\r\n      return jQuery.get(url, undefined, callback, 'script')\r\n    }\r\n  })\r\n\r\n  jQuery.each(['get', 'post'], function (i, method) {\r\n    jQuery[method] = function (url, data, callback, type) {\r\n      // Shift arguments if data argument was omitted\r\n      if (jQuery.isFunction(data)) {\r\n        type = type || callback\r\n        callback = data\r\n        data = undefined\r\n      }\r\n\r\n      // The url can be an options object (which then must have .url)\r\n      return jQuery.ajax(\r\n        jQuery.extend(\r\n          {\r\n            url: url,\r\n            type: method,\r\n            dataType: type,\r\n            data: data,\r\n            success: callback\r\n          },\r\n          jQuery.isPlainObject(url) && url\r\n        )\r\n      )\r\n    }\r\n  })\r\n\r\n  jQuery._evalUrl = function (url) {\r\n    return jQuery.ajax({\r\n      url: url,\r\n\r\n      // Make this explicit, since user can override this through ajaxSetup (#11264)\r\n      type: 'GET',\r\n      dataType: 'script',\r\n      async: false,\r\n      global: false,\r\n      throws: true\r\n    })\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    wrapAll: function (html) {\r\n      var wrap\r\n\r\n      if (jQuery.isFunction(html)) {\r\n        return this.each(function (i) {\r\n          jQuery(this).wrapAll(html.call(this, i))\r\n        })\r\n      }\r\n\r\n      if (this[0]) {\r\n        // The elements to wrap the target around\r\n        wrap = jQuery(html, this[0].ownerDocument)\r\n          .eq(0)\r\n          .clone(true)\r\n\r\n        if (this[0].parentNode) {\r\n          wrap.insertBefore(this[0])\r\n        }\r\n\r\n        wrap\r\n          .map(function () {\r\n            var elem = this\r\n\r\n            while (elem.firstElementChild) {\r\n              elem = elem.firstElementChild\r\n            }\r\n\r\n            return elem\r\n          })\r\n          .append(this)\r\n      }\r\n\r\n      return this\r\n    },\r\n\r\n    wrapInner: function (html) {\r\n      if (jQuery.isFunction(html)) {\r\n        return this.each(function (i) {\r\n          jQuery(this).wrapInner(html.call(this, i))\r\n        })\r\n      }\r\n\r\n      return this.each(function () {\r\n        var self = jQuery(this),\r\n          contents = self.contents()\r\n\r\n        if (contents.length) {\r\n          contents.wrapAll(html)\r\n        } else {\r\n          self.append(html)\r\n        }\r\n      })\r\n    },\r\n\r\n    wrap: function (html) {\r\n      var isFunction = jQuery.isFunction(html)\r\n\r\n      return this.each(function (i) {\r\n        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)\r\n      })\r\n    },\r\n\r\n    unwrap: function () {\r\n      return this.parent()\r\n        .each(function () {\r\n          if (!jQuery.nodeName(this, 'body')) {\r\n            jQuery(this).replaceWith(this.childNodes)\r\n          }\r\n        })\r\n        .end()\r\n    }\r\n  })\r\n\r\n  jQuery.expr.filters.hidden = function (elem) {\r\n    return !jQuery.expr.filters.visible(elem)\r\n  }\r\n  jQuery.expr.filters.visible = function (elem) {\r\n    // Support: Opera <= 12.12\r\n    // Opera reports offsetWidths and offsetHeights less than zero on some elements\r\n    // Use OR instead of AND as the element is not visible if either is true\r\n    // See tickets #10406 and #13132\r\n    return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0\r\n  }\r\n\r\n  var r20 = /%20/g,\r\n    rbracket = /\\[\\]$/,\r\n    rCRLF = /\\r?\\n/g,\r\n    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\r\n    rsubmittable = /^(?:input|select|textarea|keygen)/i\r\n\r\n  function buildParams (prefix, obj, traditional, add) {\r\n    var name\r\n\r\n    if (jQuery.isArray(obj)) {\r\n      // Serialize array item.\r\n      jQuery.each(obj, function (i, v) {\r\n        if (traditional || rbracket.test(prefix)) {\r\n          // Treat each array item as a scalar.\r\n          add(prefix, v)\r\n        } else {\r\n          // Item is non-scalar (array or object), encode its numeric index.\r\n          buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add)\r\n        }\r\n      })\r\n    } else if (!traditional && jQuery.type(obj) === 'object') {\r\n      // Serialize object item.\r\n      for (name in obj) {\r\n        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)\r\n      }\r\n    } else {\r\n      // Serialize scalar item.\r\n      add(prefix, obj)\r\n    }\r\n  }\r\n\r\n  // Serialize an array of form elements or a set of\r\n  // key/values into a query string\r\n  jQuery.param = function (a, traditional) {\r\n    var prefix,\r\n      s = [],\r\n      add = function (key, value) {\r\n        // If value is a function, invoke it and return its value\r\n        value = jQuery.isFunction(value) ? value() : value == null ? '' : value\r\n        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value)\r\n      }\r\n\r\n    // Set traditional to true for jQuery <= 1.3.2 behavior.\r\n    if (traditional === undefined) {\r\n      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional\r\n    }\r\n\r\n    // If an array was passed in, assume that it is an array of form elements.\r\n    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {\r\n      // Serialize the form elements\r\n      jQuery.each(a, function () {\r\n        add(this.name, this.value)\r\n      })\r\n    } else {\r\n      // If traditional, encode the \"old\" way (the way 1.3.2 or older\r\n      // did it), otherwise encode params recursively.\r\n      for (prefix in a) {\r\n        buildParams(prefix, a[prefix], traditional, add)\r\n      }\r\n    }\r\n\r\n    // Return the resulting serialization\r\n    return s.join('&').replace(r20, '+')\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    serialize: function () {\r\n      return jQuery.param(this.serializeArray())\r\n    },\r\n    serializeArray: function () {\r\n      return this.map(function () {\r\n        // Can add propHook for \"elements\" to filter or add form elements\r\n        var elements = jQuery.prop(this, 'elements')\r\n        return elements ? jQuery.makeArray(elements) : this\r\n      })\r\n        .filter(function () {\r\n          var type = this.type\r\n\r\n          // Use .is( \":disabled\" ) so that fieldset[disabled] works\r\n          return (\r\n            this.name &&\r\n            !jQuery(this).is(':disabled') &&\r\n            rsubmittable.test(this.nodeName) &&\r\n            !rsubmitterTypes.test(type) &&\r\n            (this.checked || !rcheckableType.test(type))\r\n          )\r\n        })\r\n        .map(function (i, elem) {\r\n          var val = jQuery(this).val()\r\n\r\n          return val == null\r\n            ? null\r\n            : jQuery.isArray(val)\r\n            ? jQuery.map(val, function (val) {\r\n                return { name: elem.name, value: val.replace(rCRLF, '\\r\\n') }\r\n              })\r\n            : { name: elem.name, value: val.replace(rCRLF, '\\r\\n') }\r\n        })\r\n        .get()\r\n    }\r\n  })\r\n\r\n  jQuery.ajaxSettings.xhr = function () {\r\n    try {\r\n      return new window.XMLHttpRequest()\r\n    } catch (e) {}\r\n  }\r\n\r\n  var xhrSuccessStatus = {\r\n      // File protocol always yields status code 0, assume 200\r\n      0: 200,\r\n\r\n      // Support: IE9\r\n      // #1450: sometimes IE returns 1223 when it should be 204\r\n      1223: 204\r\n    },\r\n    xhrSupported = jQuery.ajaxSettings.xhr()\r\n\r\n  support.cors = !!xhrSupported && 'withCredentials' in xhrSupported\r\n  support.ajax = xhrSupported = !!xhrSupported\r\n\r\n  jQuery.ajaxTransport(function (options) {\r\n    var callback, errorCallback\r\n\r\n    // Cross domain only allowed if supported through XMLHttpRequest\r\n    if (support.cors || (xhrSupported && !options.crossDomain)) {\r\n      return {\r\n        send: function (headers, complete) {\r\n          var i,\r\n            xhr = options.xhr()\r\n\r\n          xhr.open(options.type, options.url, options.async, options.username, options.password)\r\n\r\n          // Apply custom fields if provided\r\n          if (options.xhrFields) {\r\n            for (i in options.xhrFields) {\r\n              xhr[i] = options.xhrFields[i]\r\n            }\r\n          }\r\n\r\n          // Override mime type if needed\r\n          if (options.mimeType && xhr.overrideMimeType) {\r\n            xhr.overrideMimeType(options.mimeType)\r\n          }\r\n\r\n          // X-Requested-With header\r\n          // For cross-domain requests, seeing as conditions for a preflight are\r\n          // akin to a jigsaw puzzle, we simply never set it to be sure.\r\n          // (it can always be set on a per-request basis or even using ajaxSetup)\r\n          // For same-domain requests, won't change header if already provided.\r\n          if (!options.crossDomain && !headers['X-Requested-With']) {\r\n            headers['X-Requested-With'] = 'XMLHttpRequest'\r\n          }\r\n\r\n          // Set headers\r\n          for (i in headers) {\r\n            xhr.setRequestHeader(i, headers[i])\r\n          }\r\n\r\n          // Callback\r\n          callback = function (type) {\r\n            return function () {\r\n              if (callback) {\r\n                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null\r\n\r\n                if (type === 'abort') {\r\n                  xhr.abort()\r\n                } else if (type === 'error') {\r\n                  // Support: IE9\r\n                  // On a manual native abort, IE9 throws\r\n                  // errors on any property access that is not readyState\r\n                  if (typeof xhr.status !== 'number') {\r\n                    complete(0, 'error')\r\n                  } else {\r\n                    complete(\r\n                      // File: protocol always yields status 0; see #8605, #14207\r\n                      xhr.status,\r\n                      xhr.statusText\r\n                    )\r\n                  }\r\n                } else {\r\n                  complete(\r\n                    xhrSuccessStatus[xhr.status] || xhr.status,\r\n                    xhr.statusText,\r\n\r\n                    // Support: IE9 only\r\n                    // IE9 has no XHR2 but throws on binary (trac-11426)\r\n                    // For XHR2 non-text, let the caller handle it (gh-2498)\r\n                    (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string'\r\n                      ? { binary: xhr.response }\r\n                      : { text: xhr.responseText },\r\n                    xhr.getAllResponseHeaders()\r\n                  )\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // Listen to events\r\n          xhr.onload = callback()\r\n          errorCallback = xhr.onerror = callback('error')\r\n\r\n          // Support: IE9\r\n          // Use onreadystatechange to replace onabort\r\n          // to handle uncaught aborts\r\n          if (xhr.onabort !== undefined) {\r\n            xhr.onabort = errorCallback\r\n          } else {\r\n            xhr.onreadystatechange = function () {\r\n              // Check readyState before timeout as it changes\r\n              if (xhr.readyState === 4) {\r\n                // Allow onerror to be called first,\r\n                // but that will not handle a native abort\r\n                // Also, save errorCallback to a variable\r\n                // as xhr.onerror cannot be accessed\r\n                window.setTimeout(function () {\r\n                  if (callback) {\r\n                    errorCallback()\r\n                  }\r\n                })\r\n              }\r\n            }\r\n          }\r\n\r\n          // Create the abort callback\r\n          callback = callback('abort')\r\n\r\n          try {\r\n            // Do send the request (this may raise an exception)\r\n            xhr.send((options.hasContent && options.data) || null)\r\n          } catch (e) {\r\n            // #14683: Only rethrow if this hasn't been notified as an error yet\r\n            if (callback) {\r\n              throw e\r\n            }\r\n          }\r\n        },\r\n\r\n        abort: function () {\r\n          if (callback) {\r\n            callback()\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  // Install script dataType\r\n  jQuery.ajaxSetup({\r\n    accepts: {\r\n      script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript'\r\n    },\r\n    contents: {\r\n      script: /\\b(?:java|ecma)script\\b/\r\n    },\r\n    converters: {\r\n      'text script': function (text) {\r\n        jQuery.globalEval(text)\r\n        return text\r\n      }\r\n    }\r\n  })\r\n\r\n  // Handle cache's special case and crossDomain\r\n  jQuery.ajaxPrefilter('script', function (s) {\r\n    if (s.cache === undefined) {\r\n      s.cache = false\r\n    }\r\n    if (s.crossDomain) {\r\n      s.type = 'GET'\r\n    }\r\n  })\r\n\r\n  // Bind script tag hack transport\r\n  jQuery.ajaxTransport('script', function (s) {\r\n    // This transport only deals with cross domain requests\r\n    if (s.crossDomain) {\r\n      var script, callback\r\n      return {\r\n        send: function (_, complete) {\r\n          script = jQuery('<script>')\r\n            .prop({\r\n              charset: s.scriptCharset,\r\n              src: s.url\r\n            })\r\n            .on(\r\n              'load error',\r\n              (callback = function (evt) {\r\n                script.remove()\r\n                callback = null\r\n                if (evt) {\r\n                  complete(evt.type === 'error' ? 404 : 200, evt.type)\r\n                }\r\n              })\r\n            )\r\n\r\n          // Use native DOM manipulation to avoid our domManip AJAX trickery\r\n          document.head.appendChild(script[0])\r\n        },\r\n        abort: function () {\r\n          if (callback) {\r\n            callback()\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  var oldCallbacks = [],\r\n    rjsonp = /(=)\\?(?=&|$)|\\?\\?/\r\n\r\n  // Default jsonp settings\r\n  jQuery.ajaxSetup({\r\n    jsonp: 'callback',\r\n    jsonpCallback: function () {\r\n      var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++\r\n      this[callback] = true\r\n      return callback\r\n    }\r\n  })\r\n\r\n  // Detect, normalize options and install callbacks for jsonp requests\r\n  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {\r\n    var callbackName,\r\n      overwritten,\r\n      responseContainer,\r\n      jsonProp =\r\n        s.jsonp !== false &&\r\n        (rjsonp.test(s.url)\r\n          ? 'url'\r\n          : typeof s.data === 'string' &&\r\n            (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 &&\r\n            rjsonp.test(s.data) &&\r\n            'data')\r\n\r\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\r\n    if (jsonProp || s.dataTypes[0] === 'jsonp') {\r\n      // Get callback name, remembering preexisting value associated with it\r\n      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback\r\n\r\n      // Insert callback into url or form data\r\n      if (jsonProp) {\r\n        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName)\r\n      } else if (s.jsonp !== false) {\r\n        s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName\r\n      }\r\n\r\n      // Use data converter to retrieve json after script execution\r\n      s.converters['script json'] = function () {\r\n        if (!responseContainer) {\r\n          jQuery.error(callbackName + ' was not called')\r\n        }\r\n        return responseContainer[0]\r\n      }\r\n\r\n      // Force json dataType\r\n      s.dataTypes[0] = 'json'\r\n\r\n      // Install callback\r\n      overwritten = window[callbackName]\r\n      window[callbackName] = function () {\r\n        responseContainer = arguments\r\n      }\r\n\r\n      // Clean-up function (fires after converters)\r\n      jqXHR.always(function () {\r\n        // If previous value didn't exist - remove it\r\n        if (overwritten === undefined) {\r\n          jQuery(window).removeProp(callbackName)\r\n\r\n          // Otherwise restore preexisting value\r\n        } else {\r\n          window[callbackName] = overwritten\r\n        }\r\n\r\n        // Save back as free\r\n        if (s[callbackName]) {\r\n          // Make sure that re-using the options doesn't screw things around\r\n          s.jsonpCallback = originalSettings.jsonpCallback\r\n\r\n          // Save the callback name for future use\r\n          oldCallbacks.push(callbackName)\r\n        }\r\n\r\n        // Call if it was a function and we have a response\r\n        if (responseContainer && jQuery.isFunction(overwritten)) {\r\n          overwritten(responseContainer[0])\r\n        }\r\n\r\n        responseContainer = overwritten = undefined\r\n      })\r\n\r\n      // Delegate to script\r\n      return 'script'\r\n    }\r\n  })\r\n\r\n  // Argument \"data\" should be string of html\r\n  // context (optional): If specified, the fragment will be created in this context,\r\n  // defaults to document\r\n  // keepScripts (optional): If true, will include scripts passed in the html string\r\n  jQuery.parseHTML = function (data, context, keepScripts) {\r\n    if (!data || typeof data !== 'string') {\r\n      return null\r\n    }\r\n    if (typeof context === 'boolean') {\r\n      keepScripts = context\r\n      context = false\r\n    }\r\n    context = context || document\r\n\r\n    var parsed = rsingleTag.exec(data),\r\n      scripts = !keepScripts && []\r\n\r\n    // Single tag\r\n    if (parsed) {\r\n      return [context.createElement(parsed[1])]\r\n    }\r\n\r\n    parsed = buildFragment([data], context, scripts)\r\n\r\n    if (scripts && scripts.length) {\r\n      jQuery(scripts).remove()\r\n    }\r\n\r\n    return jQuery.merge([], parsed.childNodes)\r\n  }\r\n\r\n  // Keep a copy of the old load method\r\n  var _load = jQuery.fn.load\r\n\r\n  /**\r\n   * Load a url into a page\r\n   */\r\n  jQuery.fn.load = function (url, params, callback) {\r\n    if (typeof url !== 'string' && _load) {\r\n      return _load.apply(this, arguments)\r\n    }\r\n\r\n    var selector,\r\n      type,\r\n      response,\r\n      self = this,\r\n      off = url.indexOf(' ')\r\n\r\n    if (off > -1) {\r\n      selector = jQuery.trim(url.slice(off))\r\n      url = url.slice(0, off)\r\n    }\r\n\r\n    // If it's a function\r\n    if (jQuery.isFunction(params)) {\r\n      // We assume that it's the callback\r\n      callback = params\r\n      params = undefined\r\n\r\n      // Otherwise, build a param string\r\n    } else if (params && typeof params === 'object') {\r\n      type = 'POST'\r\n    }\r\n\r\n    // If we have elements to modify, make the request\r\n    if (self.length > 0) {\r\n      jQuery\r\n        .ajax({\r\n          url: url,\r\n\r\n          // If \"type\" variable is undefined, then \"GET\" method will be used.\r\n          // Make value of this field explicit since\r\n          // user can override it through ajaxSetup method\r\n          type: type || 'GET',\r\n          dataType: 'html',\r\n          data: params\r\n        })\r\n        .done(function (responseText) {\r\n          // Save response for use in complete callback\r\n          response = arguments\r\n\r\n          self.html(\r\n            selector\r\n              ? // If a selector was specified, locate the right elements in a dummy div\r\n                // Exclude scripts to avoid IE 'Permission Denied' errors\r\n                jQuery('<div>')\r\n                  .append(jQuery.parseHTML(responseText))\r\n                  .find(selector)\r\n              : // Otherwise use the full result\r\n                responseText\r\n          )\r\n\r\n          // If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\r\n          // but they are ignored because response was set above.\r\n          // If it fails, this function gets \"jqXHR\", \"status\", \"error\"\r\n        })\r\n        .always(\r\n          callback &&\r\n            function (jqXHR, status) {\r\n              self.each(function () {\r\n                callback.apply(this, response || [jqXHR.responseText, status, jqXHR])\r\n              })\r\n            }\r\n        )\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  // Attach a bunch of functions for handling common AJAX events\r\n  jQuery.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function (i, type) {\r\n    jQuery.fn[type] = function (fn) {\r\n      return this.on(type, fn)\r\n    }\r\n  })\r\n\r\n  jQuery.expr.filters.animated = function (elem) {\r\n    return jQuery.grep(jQuery.timers, function (fn) {\r\n      return elem === fn.elem\r\n    }).length\r\n  }\r\n\r\n  /**\r\n   * Gets a window from an element\r\n   */\r\n  function getWindow (elem) {\r\n    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView\r\n  }\r\n\r\n  jQuery.offset = {\r\n    setOffset: function (elem, options, i) {\r\n      var curPosition,\r\n        curLeft,\r\n        curCSSTop,\r\n        curTop,\r\n        curOffset,\r\n        curCSSLeft,\r\n        calculatePosition,\r\n        position = jQuery.css(elem, 'position'),\r\n        curElem = jQuery(elem),\r\n        props = {}\r\n\r\n      // Set position first, in-case top/left are set even on static elem\r\n      if (position === 'static') {\r\n        elem.style.position = 'relative'\r\n      }\r\n\r\n      curOffset = curElem.offset()\r\n      curCSSTop = jQuery.css(elem, 'top')\r\n      curCSSLeft = jQuery.css(elem, 'left')\r\n      calculatePosition =\r\n        (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1\r\n\r\n      // Need to be able to calculate position if either\r\n      // top or left is auto and position is either absolute or fixed\r\n      if (calculatePosition) {\r\n        curPosition = curElem.position()\r\n        curTop = curPosition.top\r\n        curLeft = curPosition.left\r\n      } else {\r\n        curTop = parseFloat(curCSSTop) || 0\r\n        curLeft = parseFloat(curCSSLeft) || 0\r\n      }\r\n\r\n      if (jQuery.isFunction(options)) {\r\n        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\r\n        options = options.call(elem, i, jQuery.extend({}, curOffset))\r\n      }\r\n\r\n      if (options.top != null) {\r\n        props.top = options.top - curOffset.top + curTop\r\n      }\r\n      if (options.left != null) {\r\n        props.left = options.left - curOffset.left + curLeft\r\n      }\r\n\r\n      if ('using' in options) {\r\n        options.using.call(elem, props)\r\n      } else {\r\n        curElem.css(props)\r\n      }\r\n    }\r\n  }\r\n\r\n  jQuery.fn.extend({\r\n    offset: function (options) {\r\n      if (arguments.length) {\r\n        return options === undefined\r\n          ? this\r\n          : this.each(function (i) {\r\n              jQuery.offset.setOffset(this, options, i)\r\n            })\r\n      }\r\n\r\n      var docElem,\r\n        win,\r\n        elem = this[0],\r\n        box = { top: 0, left: 0 },\r\n        doc = elem && elem.ownerDocument\r\n\r\n      if (!doc) {\r\n        return\r\n      }\r\n\r\n      docElem = doc.documentElement\r\n\r\n      // Make sure it's not a disconnected DOM node\r\n      if (!jQuery.contains(docElem, elem)) {\r\n        return box\r\n      }\r\n\r\n      box = elem.getBoundingClientRect()\r\n      win = getWindow(doc)\r\n      return {\r\n        top: box.top + win.pageYOffset - docElem.clientTop,\r\n        left: box.left + win.pageXOffset - docElem.clientLeft\r\n      }\r\n    },\r\n\r\n    position: function () {\r\n      if (!this[0]) {\r\n        return\r\n      }\r\n\r\n      var offsetParent,\r\n        offset,\r\n        elem = this[0],\r\n        parentOffset = { top: 0, left: 0 }\r\n\r\n      // Fixed elements are offset from window (parentOffset = {top:0, left: 0},\r\n      // because it is its only offset parent\r\n      if (jQuery.css(elem, 'position') === 'fixed') {\r\n        // Assume getBoundingClientRect is there when computed position is fixed\r\n        offset = elem.getBoundingClientRect()\r\n      } else {\r\n        // Get *real* offsetParent\r\n        offsetParent = this.offsetParent()\r\n\r\n        // Get correct offsets\r\n        offset = this.offset()\r\n        if (!jQuery.nodeName(offsetParent[0], 'html')) {\r\n          parentOffset = offsetParent.offset()\r\n        }\r\n\r\n        // Add offsetParent borders\r\n        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true)\r\n        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true)\r\n      }\r\n\r\n      // Subtract parent offsets and element margins\r\n      return {\r\n        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),\r\n        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)\r\n      }\r\n    },\r\n\r\n    // This method will return documentElement in the following cases:\r\n    // 1) For the element inside the iframe without offsetParent, this method will return\r\n    //    documentElement of the parent window\r\n    // 2) For the hidden or detached element\r\n    // 3) For body or html element, i.e. in case of the html node - it will return itself\r\n    //\r\n    // but those exceptions were never presented as a real life use-cases\r\n    // and might be considered as more preferable results.\r\n    //\r\n    // This logic, however, is not guaranteed and can change at any point in the future\r\n    offsetParent: function () {\r\n      return this.map(function () {\r\n        var offsetParent = this.offsetParent\r\n\r\n        while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {\r\n          offsetParent = offsetParent.offsetParent\r\n        }\r\n\r\n        return offsetParent || documentElement\r\n      })\r\n    }\r\n  })\r\n\r\n  // Create scrollLeft and scrollTop methods\r\n  jQuery.each({ scrollLeft: 'pageXOffset', scrollTop: 'pageYOffset' }, function (method, prop) {\r\n    var top = 'pageYOffset' === prop\r\n\r\n    jQuery.fn[method] = function (val) {\r\n      return access(\r\n        this,\r\n        function (elem, method, val) {\r\n          var win = getWindow(elem)\r\n\r\n          if (val === undefined) {\r\n            return win ? win[prop] : elem[method]\r\n          }\r\n\r\n          if (win) {\r\n            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset)\r\n          } else {\r\n            elem[method] = val\r\n          }\r\n        },\r\n        method,\r\n        val,\r\n        arguments.length\r\n      )\r\n    }\r\n  })\r\n\r\n  // Support: Safari<7-8+, Chrome<37-44+\r\n  // Add the top/left cssHooks using jQuery.fn.position\r\n  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\r\n  // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280\r\n  // getComputedStyle returns percent when specified for top/left/bottom/right;\r\n  // rather than make the css module depend on the offset module, just check for it here\r\n  jQuery.each(['top', 'left'], function (i, prop) {\r\n    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {\r\n      if (computed) {\r\n        computed = curCSS(elem, prop)\r\n\r\n        // If curCSS returns percentage, fallback to offset\r\n        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed\r\n      }\r\n    })\r\n  })\r\n\r\n  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\r\n  jQuery.each({ Height: 'height', Width: 'width' }, function (name, type) {\r\n    jQuery.each({ padding: 'inner' + name, content: type, '': 'outer' + name }, function (defaultExtra, funcName) {\r\n      // Margin is only for outerHeight, outerWidth\r\n      jQuery.fn[funcName] = function (margin, value) {\r\n        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'),\r\n          extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border')\r\n\r\n        return access(\r\n          this,\r\n          function (elem, type, value) {\r\n            var doc\r\n\r\n            if (jQuery.isWindow(elem)) {\r\n              // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\r\n              // isn't a whole lot we can do. See pull request at this URL for discussion:\r\n              // https://github.com/jquery/jquery/pull/764\r\n              return elem.document.documentElement['client' + name]\r\n            }\r\n\r\n            // Get document width or height\r\n            if (elem.nodeType === 9) {\r\n              doc = elem.documentElement\r\n\r\n              // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\r\n              // whichever is greatest\r\n              return Math.max(\r\n                elem.body['scroll' + name],\r\n                doc['scroll' + name],\r\n                elem.body['offset' + name],\r\n                doc['offset' + name],\r\n                doc['client' + name]\r\n              )\r\n            }\r\n\r\n            return value === undefined\r\n              ? // Get width or height on the element, requesting but not forcing parseFloat\r\n                jQuery.css(elem, type, extra)\r\n              : // Set width or height on the element\r\n                jQuery.style(elem, type, value, extra)\r\n          },\r\n          type,\r\n          chainable ? margin : undefined,\r\n          chainable,\r\n          null\r\n        )\r\n      }\r\n    })\r\n  })\r\n\r\n  jQuery.fn.extend({\r\n    bind: function (types, data, fn) {\r\n      return this.on(types, null, data, fn)\r\n    },\r\n    unbind: function (types, fn) {\r\n      return this.off(types, null, fn)\r\n    },\r\n\r\n    delegate: function (selector, types, data, fn) {\r\n      return this.on(types, selector, data, fn)\r\n    },\r\n    undelegate: function (selector, types, fn) {\r\n      // ( namespace ) or ( selector, types [, fn] )\r\n      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn)\r\n    },\r\n    size: function () {\r\n      return this.length\r\n    }\r\n  })\r\n\r\n  jQuery.fn.andSelf = jQuery.fn.addBack\r\n\r\n  // Register as a named AMD module, since jQuery can be concatenated with other\r\n  // files that may use define, but not via a proper concatenation script that\r\n  // understands anonymous AMD modules. A named AMD is safest and most robust\r\n  // way to register. Lowercase jquery is used because AMD module names are\r\n  // derived from file names, and jQuery is normally delivered in a lowercase\r\n  // file name. Do this after creating the global so that if an AMD module wants\r\n  // to call noConflict to hide this version of jQuery, it will work.\r\n\r\n  // Note that for maximum portability, libraries that are not jQuery should\r\n  // declare themselves as anonymous modules, and avoid setting a global if an\r\n  // AMD loader is present. jQuery is a special case. For more information, see\r\n  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\r\n\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n      return jQuery\r\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n  }\r\n\r\n  var // Map over jQuery in case of overwrite\r\n    _jQuery = window.jQuery,\r\n    // Map over the $ in case of overwrite\r\n    _$ = window.$\r\n\r\n  jQuery.noConflict = function (deep) {\r\n    if (window.$ === jQuery) {\r\n      window.$ = _$\r\n    }\r\n\r\n    if (deep && window.jQuery === jQuery) {\r\n      window.jQuery = _jQuery\r\n    }\r\n\r\n    return jQuery\r\n  }\r\n\r\n  // Expose jQuery and $ identifiers, even in AMD\r\n  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\r\n  // and CommonJS for browser emulators (#13566)\r\n  if (!noGlobal) {\r\n    window.jQuery = window.$ = jQuery\r\n  }\r\n\r\n  return jQuery\r\n})\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/jquery/jquery.js?");

/***/ }),

/***/ 2:
/*!*****************************************************!*\
  !*** ./src/public/js/vendor/modernizr/modernizr.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var __webpack_provided_window_dot_Modernizr = __webpack_require__(/*! modernizr */ 2);\n/*! modernizr 3.3.1 (Custom Build) | MIT *\r\n * https://modernizr.com/download/?-animation-applicationcache-audio-audioloop-audiopreload-backgroundblendmode-backgroundcliptext-backgroundsize-bgpositionshorthand-bgpositionxy-bgrepeatspace_bgrepeatround-bgsizecover-borderradius-boxshadow-boxsizing-canvas-canvasblending-canvastext-canvaswinding-checked-contextmenu-cookies-cors-cssanimations-csscolumns-cssfilters-cssmask-cssremunit-cssscrollbar-csstransforms-csstransitions-cssvalid-cssvhunit-cssvwunit-cubicbezierrange-customevent-ellipsis-emoji-eventlistener-fileinput-filereader-flash-flexbox-flexboxlegacy-flexboxtweener-flexwrap-formvalidation-generatedcontent-geolocation-history-htmlimports-imgcrossorigin-inlinesvg-input-inputtypes-json-lastchild-localstorage-mediaqueries-multiplebgs-notification-nthchild-olreversed-opacity-overflowscrolling-placeholder-queryselector-requestanimationframe-rgba-search-supports-svg-svgfilters-textareamaxlength-todataurljpeg_todataurlpng_todataurlwebp-unicode-unicoderange-video-webaudio-webgl-websockets-setclasses !*/\r\n!(function (A, e, t) {\r\n  function n (A, e) {\r\n    return typeof A === e\r\n  }\r\n  function a () {\r\n    var A, e, t, a, i, o, r\r\n    for (var d in E)\r\n      if (E.hasOwnProperty(d)) {\r\n        if (\r\n          ((A = []),\r\n          (e = E[d]),\r\n          e.name && (A.push(e.name.toLowerCase()), e.options && e.options.aliases && e.options.aliases.length))\r\n        )\r\n          for (t = 0; t < e.options.aliases.length; t++) A.push(e.options.aliases[t].toLowerCase())\r\n        for (a = n(e.fn, 'function') ? e.fn() : e.fn, i = 0; i < A.length; i++)\r\n          (o = A[i]),\r\n            (r = o.split('.')),\r\n            1 === r.length\r\n              ? (Modernizr[r[0]] = a)\r\n              : (!Modernizr[r[0]] ||\r\n                  Modernizr[r[0]] instanceof Boolean ||\r\n                  (Modernizr[r[0]] = new Boolean(Modernizr[r[0]])),\r\n                (Modernizr[r[0]][r[1]] = a)),\r\n            v.push((a ? '' : 'no-') + r.join('-'))\r\n      }\r\n  }\r\n  function i (A) {\r\n    var e = I.className,\r\n      t = Modernizr._config.classPrefix || ''\r\n    if ((y && (e = e.baseVal), Modernizr._config.enableJSClass)) {\r\n      var n = new RegExp('(^|\\\\s)' + t + 'no-js(\\\\s|$)')\r\n      e = e.replace(n, '$1' + t + 'js$2')\r\n    }\r\n    Modernizr._config.enableClasses &&\r\n      ((e += ' ' + t + A.join(' ' + t)), y ? (I.className.baseVal = e) : (I.className = e))\r\n  }\r\n  function o () {\r\n    return 'function' != typeof e.createElement\r\n      ? e.createElement(arguments[0])\r\n      : y\r\n      ? e.createElementNS.call(e, 'http://www.w3.org/2000/svg', arguments[0])\r\n      : e.createElement.apply(e, arguments)\r\n  }\r\n  function r () {\r\n    var A = e.body\r\n    return A || ((A = o(y ? 'svg' : 'body')), (A.fake = !0)), A\r\n  }\r\n  function d (A, e) {\r\n    if ('object' == typeof A) for (var t in A) k(A, t) && d(t, A[t])\r\n    else {\r\n      A = A.toLowerCase()\r\n      var n = A.split('.'),\r\n        a = Modernizr[n[0]]\r\n      if ((2 == n.length && (a = a[n[1]]), 'undefined' != typeof a)) return Modernizr\r\n      ;(e = 'function' == typeof e ? e() : e),\r\n        1 == n.length\r\n          ? (Modernizr[n[0]] = e)\r\n          : (!Modernizr[n[0]] || Modernizr[n[0]] instanceof Boolean || (Modernizr[n[0]] = new Boolean(Modernizr[n[0]])),\r\n            (Modernizr[n[0]][n[1]] = e)),\r\n        i([(e && 0 != e ? '' : 'no-') + n.join('-')]),\r\n        Modernizr._trigger(A, e)\r\n    }\r\n    return Modernizr\r\n  }\r\n  function w (A) {\r\n    return A.replace(/([a-z])-([a-z])/g, function (A, e, t) {\r\n      return e + t.toUpperCase()\r\n    }).replace(/^-/, '')\r\n  }\r\n  function s (A, t, n, a) {\r\n    var i,\r\n      d,\r\n      w,\r\n      s,\r\n      l = 'modernizr',\r\n      D = o('div'),\r\n      u = r()\r\n    if (parseInt(n, 10)) for (; n--; ) (w = o('div')), (w.id = a ? a[n] : l + (n + 1)), D.appendChild(w)\r\n    return (\r\n      (i = o('style')),\r\n      (i.type = 'text/css'),\r\n      (i.id = 's' + l),\r\n      (u.fake ? u : D).appendChild(i),\r\n      u.appendChild(D),\r\n      i.styleSheet ? (i.styleSheet.cssText = A) : i.appendChild(e.createTextNode(A)),\r\n      (D.id = l),\r\n      u.fake &&\r\n        ((u.style.background = ''),\r\n        (u.style.overflow = 'hidden'),\r\n        (s = I.style.overflow),\r\n        (I.style.overflow = 'hidden'),\r\n        I.appendChild(u)),\r\n      (d = t(D, A)),\r\n      u.fake ? (u.parentNode.removeChild(u), (I.style.overflow = s), I.offsetHeight) : D.parentNode.removeChild(D),\r\n      !!d\r\n    )\r\n  }\r\n  function l (A, e) {\r\n    return !!~('' + A).indexOf(e)\r\n  }\r\n  function D (A, e) {\r\n    return function () {\r\n      return A.apply(e, arguments)\r\n    }\r\n  }\r\n  function u (A, e, t) {\r\n    var a\r\n    for (var i in A) if (A[i] in e) return t === !1 ? A[i] : ((a = e[A[i]]), n(a, 'function') ? D(a, t || e) : a)\r\n    return !1\r\n  }\r\n  function P (A) {\r\n    return A.replace(/([A-Z])/g, function (A, e) {\r\n      return '-' + e.toLowerCase()\r\n    }).replace(/^ms-/, '-ms-')\r\n  }\r\n  function c (e, n) {\r\n    var a = e.length\r\n    if ('CSS' in A && 'supports' in A.CSS) {\r\n      for (; a--; ) if (A.CSS.supports(P(e[a]), n)) return !0\r\n      return !1\r\n    }\r\n    if ('CSSSupportsRule' in A) {\r\n      for (var i = []; a--; ) i.push('(' + P(e[a]) + ':' + n + ')')\r\n      return (\r\n        (i = i.join(' or ')),\r\n        s('@supports (' + i + ') { #modernizr { position: absolute; } }', function (A) {\r\n          return 'absolute' == getComputedStyle(A, null).position\r\n        })\r\n      )\r\n    }\r\n    return t\r\n  }\r\n  function f (A, e, a, i) {\r\n    function r () {\r\n      s && (delete O.style, delete O.modElem)\r\n    }\r\n    if (((i = n(i, 'undefined') ? !1 : i), !n(a, 'undefined'))) {\r\n      var d = c(A, a)\r\n      if (!n(d, 'undefined')) return d\r\n    }\r\n    for (var s, D, u, P, f, p = ['modernizr', 'tspan', 'samp']; !O.style && p.length; )\r\n      (s = !0), (O.modElem = o(p.shift())), (O.style = O.modElem.style)\r\n    for (u = A.length, D = 0; u > D; D++)\r\n      if (((P = A[D]), (f = O.style[P]), l(P, '-') && (P = w(P)), O.style[P] !== t)) {\r\n        if (i || n(a, 'undefined')) return r(), 'pfx' == e ? P : !0\r\n        try {\r\n          O.style[P] = a\r\n        } catch (g) {}\r\n        if (O.style[P] != f) return r(), 'pfx' == e ? P : !0\r\n      }\r\n    return r(), !1\r\n  }\r\n  function p (A, e, t, a, i) {\r\n    var o = A.charAt(0).toUpperCase() + A.slice(1),\r\n      r = (A + ' ' + Z.join(o + ' ') + o).split(' ')\r\n    return n(e, 'string') || n(e, 'undefined')\r\n      ? f(r, e, a, i)\r\n      : ((r = (A + ' ' + F.join(o + ' ') + o).split(' ')), u(r, e, t))\r\n  }\r\n  function g (A, e, n) {\r\n    return p(A, t, t, e, n)\r\n  }\r\n  var v = [],\r\n    E = [],\r\n    B = {\r\n      _version: '3.3.1',\r\n      _config: { classPrefix: '', enableClasses: !0, enableJSClass: !0, usePrefixes: !0 },\r\n      _q: [],\r\n      on: function (A, e) {\r\n        var t = this\r\n        setTimeout(function () {\r\n          e(t[A])\r\n        }, 0)\r\n      },\r\n      addTest: function (A, e, t) {\r\n        E.push({ name: A, fn: e, options: t })\r\n      },\r\n      addAsyncTest: function (A) {\r\n        E.push({ name: null, fn: A })\r\n      }\r\n    },\r\n    Modernizr = function () {}\r\n  ;(Modernizr.prototype = B),\r\n    (Modernizr = new Modernizr()),\r\n    Modernizr.addTest('applicationcache', 'applicationCache' in A),\r\n    Modernizr.addTest('cookies', function () {\r\n      try {\r\n        e.cookie = 'cookietest=1'\r\n        var A = -1 != e.cookie.indexOf('cookietest=')\r\n        return (e.cookie = 'cookietest=1; expires=Thu, 01-Jan-1970 00:00:01 GMT'), A\r\n      } catch (t) {\r\n        return !1\r\n      }\r\n    }),\r\n    Modernizr.addTest('cors', 'XMLHttpRequest' in A && 'withCredentials' in new XMLHttpRequest()),\r\n    Modernizr.addTest('customevent', 'CustomEvent' in A && 'function' == typeof A.CustomEvent),\r\n    Modernizr.addTest('eventlistener', 'addEventListener' in A),\r\n    Modernizr.addTest('geolocation', 'geolocation' in navigator),\r\n    Modernizr.addTest('history', function () {\r\n      var e = navigator.userAgent\r\n      return (-1 === e.indexOf('Android 2.') && -1 === e.indexOf('Android 4.0')) ||\r\n        -1 === e.indexOf('Mobile Safari') ||\r\n        -1 !== e.indexOf('Chrome') ||\r\n        -1 !== e.indexOf('Windows Phone')\r\n        ? A.history && 'pushState' in A.history\r\n        : !1\r\n    }),\r\n    Modernizr.addTest('json', 'JSON' in A && 'parse' in JSON && 'stringify' in JSON),\r\n    Modernizr.addTest('queryselector', 'querySelector' in e && 'querySelectorAll' in e),\r\n    Modernizr.addTest(\r\n      'svg',\r\n      !!e.createElementNS && !!e.createElementNS('http://www.w3.org/2000/svg', 'svg').createSVGRect\r\n    )\r\n  var Q = !1\r\n  try {\r\n    Q = 'WebSocket' in A && 2 === A.WebSocket.CLOSING\r\n  } catch (m) {}\r\n  Modernizr.addTest('websockets', Q),\r\n    Modernizr.addTest('webaudio', function () {\r\n      var e = 'webkitAudioContext' in A,\r\n        t = 'AudioContext' in A\r\n      return Modernizr._config.usePrefixes ? e || t : t\r\n    })\r\n  var C = 'CSS' in A && 'supports' in A.CSS,\r\n    h = 'supportsCSS' in A\r\n  Modernizr.addTest('supports', C || h),\r\n    Modernizr.addTest('filereader', !!(A.File && A.FileList && A.FileReader)),\r\n    Modernizr.addTest('localstorage', function () {\r\n      var A = 'modernizr'\r\n      try {\r\n        return localStorage.setItem(A, A), localStorage.removeItem(A), !0\r\n      } catch (e) {\r\n        return !1\r\n      }\r\n    }),\r\n    Modernizr.addTest('svgfilters', function () {\r\n      var e = !1\r\n      try {\r\n        e = 'SVGFEColorMatrixElement' in A && 2 == SVGFEColorMatrixElement.SVG_FECOLORMATRIX_TYPE_SATURATE\r\n      } catch (t) {}\r\n      return e\r\n    })\r\n  var I = e.documentElement\r\n  Modernizr.addTest('contextmenu', 'contextMenu' in I && 'HTMLMenuItemElement' in A)\r\n  var y = 'svg' === I.nodeName.toLowerCase()\r\n  Modernizr.addTest('audio', function () {\r\n    var A = o('audio'),\r\n      e = !1\r\n    try {\r\n      ;(e = !!A.canPlayType) &&\r\n        ((e = new Boolean(e)),\r\n        (e.ogg = A.canPlayType('audio/ogg; codecs=\"vorbis\"').replace(/^no$/, '')),\r\n        (e.mp3 = A.canPlayType('audio/mpeg; codecs=\"mp3\"').replace(/^no$/, '')),\r\n        (e.opus =\r\n          A.canPlayType('audio/ogg; codecs=\"opus\"') || A.canPlayType('audio/webm; codecs=\"opus\"').replace(/^no$/, '')),\r\n        (e.wav = A.canPlayType('audio/wav; codecs=\"1\"').replace(/^no$/, '')),\r\n        (e.m4a = (A.canPlayType('audio/x-m4a;') || A.canPlayType('audio/aac;')).replace(/^no$/, '')))\r\n    } catch (t) {}\r\n    return e\r\n  }),\r\n    Modernizr.addTest('canvas', function () {\r\n      var A = o('canvas')\r\n      return !(!A.getContext || !A.getContext('2d'))\r\n    }),\r\n    Modernizr.addTest('canvastext', function () {\r\n      return Modernizr.canvas === !1 ? !1 : 'function' == typeof o('canvas').getContext('2d').fillText\r\n    }),\r\n    Modernizr.addTest('emoji', function () {\r\n      if (!Modernizr.canvastext) return !1\r\n      var e = A.devicePixelRatio || 1,\r\n        t = 12 * e,\r\n        n = o('canvas'),\r\n        a = n.getContext('2d')\r\n      return (\r\n        (a.fillStyle = '#f00'),\r\n        (a.textBaseline = 'top'),\r\n        (a.font = '32px Arial'),\r\n        a.fillText('🐨', 0, 0),\r\n        0 !== a.getImageData(t, t, 1, 1).data[0]\r\n      )\r\n    }),\r\n    Modernizr.addTest('olreversed', 'reversed' in o('ol')),\r\n    Modernizr.addTest('video', function () {\r\n      var A = o('video'),\r\n        e = !1\r\n      try {\r\n        ;(e = !!A.canPlayType) &&\r\n          ((e = new Boolean(e)),\r\n          (e.ogg = A.canPlayType('video/ogg; codecs=\"theora\"').replace(/^no$/, '')),\r\n          (e.h264 = A.canPlayType('video/mp4; codecs=\"avc1.42E01E\"').replace(/^no$/, '')),\r\n          (e.webm = A.canPlayType('video/webm; codecs=\"vp8, vorbis\"').replace(/^no$/, '')),\r\n          (e.vp9 = A.canPlayType('video/webm; codecs=\"vp9\"').replace(/^no$/, '')),\r\n          (e.hls = A.canPlayType('application/x-mpegURL; codecs=\"avc1.42E01E\"').replace(/^no$/, '')))\r\n      } catch (t) {}\r\n      return e\r\n    }),\r\n    Modernizr.addTest('webanimations', 'animate' in o('div')),\r\n    Modernizr.addTest('webgl', function () {\r\n      var e = o('canvas'),\r\n        t = 'probablySupportsContext' in e ? 'probablySupportsContext' : 'supportsContext'\r\n      return t in e ? e[t]('webgl') || e[t]('experimental-webgl') : 'WebGLRenderingContext' in A\r\n    }),\r\n    Modernizr.addTest('canvasblending', function () {\r\n      if (Modernizr.canvas === !1) return !1\r\n      var A = o('canvas').getContext('2d')\r\n      try {\r\n        A.globalCompositeOperation = 'screen'\r\n      } catch (e) {}\r\n      return 'screen' === A.globalCompositeOperation\r\n    }),\r\n    Modernizr.addTest('audioloop', 'loop' in o('audio'))\r\n  var b = o('canvas')\r\n  Modernizr.addTest('todataurljpeg', function () {\r\n    return !!Modernizr.canvas && 0 === b.toDataURL('image/jpeg').indexOf('data:image/jpeg')\r\n  }),\r\n    Modernizr.addTest('todataurlpng', function () {\r\n      return !!Modernizr.canvas && 0 === b.toDataURL('image/png').indexOf('data:image/png')\r\n    }),\r\n    Modernizr.addTest('todataurlwebp', function () {\r\n      var A = !1\r\n      try {\r\n        A = !!Modernizr.canvas && 0 === b.toDataURL('image/webp').indexOf('data:image/webp')\r\n      } catch (e) {}\r\n      return A\r\n    }),\r\n    Modernizr.addTest('canvaswinding', function () {\r\n      if (Modernizr.canvas === !1) return !1\r\n      var A = o('canvas').getContext('2d')\r\n      return A.rect(0, 0, 10, 10), A.rect(2, 2, 6, 6), A.isPointInPath(5, 5, 'evenodd') === !1\r\n    }),\r\n    Modernizr.addTest('bgpositionshorthand', function () {\r\n      var A = o('a'),\r\n        e = A.style,\r\n        t = 'right 10px bottom 10px'\r\n      return (e.cssText = 'background-position: ' + t + ';'), e.backgroundPosition === t\r\n    }),\r\n    Modernizr.addTest('multiplebgs', function () {\r\n      var A = o('a').style\r\n      return (\r\n        (A.cssText = 'background:url(https://),url(https://),red url(https://)'), /(url\\s*\\(.*?){3}/.test(A.background)\r\n      )\r\n    }),\r\n    Modernizr.addTest('cssremunit', function () {\r\n      var A = o('a').style\r\n      try {\r\n        A.fontSize = '3rem'\r\n      } catch (e) {}\r\n      return /rem/.test(A.fontSize)\r\n    }),\r\n    Modernizr.addTest('rgba', function () {\r\n      var A = o('a').style\r\n      return (A.cssText = 'background-color:rgba(150,255,150,.5)'), ('' + A.backgroundColor).indexOf('rgba') > -1\r\n    }),\r\n    Modernizr.addTest('fileinput', function () {\r\n      if (\r\n        navigator.userAgent.match(\r\n          /(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\\/(1.0|2.0|2.5|3.0))/\r\n        )\r\n      )\r\n        return !1\r\n      var A = o('input')\r\n      return (A.type = 'file'), !A.disabled\r\n    }),\r\n    Modernizr.addTest('placeholder', 'placeholder' in o('input') && 'placeholder' in o('textarea')),\r\n    Modernizr.addTest('imgcrossorigin', 'crossOrigin' in o('img')),\r\n    Modernizr.addTest('inlinesvg', function () {\r\n      var A = o('div')\r\n      return (\r\n        (A.innerHTML = '<svg/>'),\r\n        'http://www.w3.org/2000/svg' == ('undefined' != typeof SVGRect && A.firstChild && A.firstChild.namespaceURI)\r\n      )\r\n    }),\r\n    Modernizr.addTest('textareamaxlength', !!('maxLength' in o('textarea')))\r\n  var V = o('input'),\r\n    q = 'autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '),\r\n    S = {}\r\n  Modernizr.input = (function (e) {\r\n    for (var t = 0, n = e.length; n > t; t++) S[e[t]] = !!(e[t] in V)\r\n    return S.list && (S.list = !(!o('datalist') || !A.HTMLDataListElement)), S\r\n  })(q)\r\n  var M = 'search tel url email datetime date month week time datetime-local number range color'.split(' '),\r\n    x = {}\r\n  Modernizr.inputtypes = (function (A) {\r\n    for (var n, a, i, o = A.length, r = '1)', d = 0; o > d; d++)\r\n      V.setAttribute('type', (n = A[d])),\r\n        (i = 'text' !== V.type && 'style' in V),\r\n        i &&\r\n          ((V.value = r),\r\n          (V.style.cssText = 'position:absolute;visibility:hidden;'),\r\n          /^range$/.test(n) && V.style.WebkitAppearance !== t\r\n            ? (I.appendChild(V),\r\n              (a = e.defaultView),\r\n              (i =\r\n                a.getComputedStyle &&\r\n                'textfield' !== a.getComputedStyle(V, null).WebkitAppearance &&\r\n                0 !== V.offsetHeight),\r\n              I.removeChild(V))\r\n            : /^(search|tel)$/.test(n) ||\r\n              (i = /^(url|email)$/.test(n) ? V.checkValidity && V.checkValidity() === !1 : V.value != r)),\r\n        (x[A[d]] = !!i)\r\n    return x\r\n  })(M)\r\n  var T = (function () {\r\n    function A (A, e) {\r\n      var a\r\n      return A\r\n        ? ((e && 'string' != typeof e) || (e = o(e || 'div')),\r\n          (A = 'on' + A),\r\n          (a = A in e),\r\n          !a &&\r\n            n &&\r\n            (e.setAttribute || (e = o('div')),\r\n            e.setAttribute(A, ''),\r\n            (a = 'function' == typeof e[A]),\r\n            e[A] !== t && (e[A] = t),\r\n            e.removeAttribute(A)),\r\n          a)\r\n        : !1\r\n    }\r\n    var n = !('onblur' in e.documentElement)\r\n    return A\r\n  })()\r\n  ;(B.hasEvent = T), Modernizr.addTest('inputsearchevent', T('search'))\r\n  var R = B._config.usePrefixes ? ' -webkit- -moz- -o- -ms- '.split(' ') : ['', '']\r\n  ;(B._prefixes = R),\r\n    Modernizr.addTest('cubicbezierrange', function () {\r\n      var A = o('a')\r\n      return (A.style.cssText = R.join('transition-timing-function:cubic-bezier(1,0,0,1.1); ')), !!A.style.length\r\n    }),\r\n    Modernizr.addTest('opacity', function () {\r\n      var A = o('a').style\r\n      return (A.cssText = R.join('opacity:.55;')), /^0.55$/.test(A.opacity)\r\n    })\r\n  var k\r\n  !(function () {\r\n    var A = {}.hasOwnProperty\r\n    k =\r\n      n(A, 'undefined') || n(A.call, 'undefined')\r\n        ? function (A, e) {\r\n            return e in A && n(A.constructor.prototype[e], 'undefined')\r\n          }\r\n        : function (e, t) {\r\n            return A.call(e, t)\r\n          }\r\n  })(),\r\n    (B._l = {}),\r\n    (B.on = function (A, e) {\r\n      this._l[A] || (this._l[A] = []),\r\n        this._l[A].push(e),\r\n        Modernizr.hasOwnProperty(A) &&\r\n          setTimeout(function () {\r\n            Modernizr._trigger(A, Modernizr[A])\r\n          }, 0)\r\n    }),\r\n    (B._trigger = function (A, e) {\r\n      if (this._l[A]) {\r\n        var t = this._l[A]\r\n        setTimeout(function () {\r\n          var A, n\r\n          for (A = 0; A < t.length; A++) (n = t[A])(e)\r\n        }, 0),\r\n          delete this._l[A]\r\n      }\r\n    }),\r\n    Modernizr._q.push(function () {\r\n      B.addTest = d\r\n    }),\r\n    Modernizr.addAsyncTest(function () {\r\n      var t,\r\n        n,\r\n        a = function (A) {\r\n          I.contains(A) || I.appendChild(A)\r\n        },\r\n        i = function (A) {\r\n          A.fake && A.parentNode && A.parentNode.removeChild(A)\r\n        },\r\n        w = function (A, e) {\r\n          var t = !!A\r\n          if (\r\n            (t && ((t = new Boolean(t)), (t.blocked = 'blocked' === A)),\r\n            d('flash', function () {\r\n              return t\r\n            }),\r\n            e && P.contains(e))\r\n          ) {\r\n            for (; e.parentNode !== P; ) e = e.parentNode\r\n            P.removeChild(e)\r\n          }\r\n        }\r\n      try {\r\n        n = 'ActiveXObject' in A && 'Pan' in new A.ActiveXObject('ShockwaveFlash.ShockwaveFlash')\r\n      } catch (s) {}\r\n      if (((t = !(('plugins' in navigator && 'Shockwave Flash' in navigator.plugins) || n)), t || y)) w(!1)\r\n      else {\r\n        var l,\r\n          D,\r\n          u = o('embed'),\r\n          P = r()\r\n        if (((u.type = 'application/x-shockwave-flash'), P.appendChild(u), !('Pan' in u || n)))\r\n          return a(P), w('blocked', u), void i(P)\r\n        ;(l = function () {\r\n          return (\r\n            a(P),\r\n            I.contains(P)\r\n              ? (I.contains(u) ? ((D = u.style.cssText), '' !== D ? w('blocked', u) : w(!0, u)) : w('blocked'),\r\n                void i(P))\r\n              : ((P = e.body || P),\r\n                (u = o('embed')),\r\n                (u.type = 'application/x-shockwave-flash'),\r\n                P.appendChild(u),\r\n                setTimeout(l, 1e3))\r\n          )\r\n        }),\r\n          setTimeout(l, 10)\r\n      }\r\n    }),\r\n    d('htmlimports', 'import' in o('link')),\r\n    Modernizr.addAsyncTest(function () {\r\n      function A (n) {\r\n        clearTimeout(e)\r\n        var i = n !== t && 'loadeddata' === n.type ? !0 : !1\r\n        a.removeEventListener('loadeddata', A, !1), d('audiopreload', i), a.parentNode.removeChild(a)\r\n      }\r\n      var e,\r\n        n = 300,\r\n        a = o('audio'),\r\n        i = a.style\r\n      if (!(Modernizr.audio && 'preload' in a)) return void d('audiopreload', !1)\r\n      ;(i.position = 'absolute'), (i.height = 0), (i.width = 0)\r\n      try {\r\n        if (Modernizr.audio.mp3)\r\n          a.src =\r\n            'data:audio/mpeg;base64,//MUxAAB6AXgAAAAAPP+c6nf//yi/6f3//MUxAMAAAIAAAjEcH//0fTX6C9Lf//0//MUxA4BeAIAAAAAAKX2/6zv//+IlR4f//MUxBMCMAH8AAAAABYWalVMQU1FMy45//MUxBUB0AH0AAAAADkuM1VVVVVVVVVV//MUxBgBUATowAAAAFVVVVVVVVVVVVVV'\r\n        else if (Modernizr.audio.m4a)\r\n          a.src =\r\n            'data:audio/x-m4a;base64,AAAAGGZ0eXBNNEEgAAACAGlzb21pc28yAAAACGZyZWUAAAAfbWRhdN4EAABsaWJmYWFjIDEuMjgAAAFoAQBHAAACiG1vb3YAAABsbXZoZAAAAAB8JbCAfCWwgAAAA+gAAAAYAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAG0dHJhawAAAFx0a2hkAAAAD3wlsIB8JbCAAAAAAQAAAAAAAAAYAAAAAAAAAAAAAAAAAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAABUG1kaWEAAAAgbWRoZAAAAAB8JbCAfCWwgAAArEQAAAQAVcQAAAAAAC1oZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU291bmRIYW5kbGVyAAAAAPttaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAL9zdGJsAAAAW3N0c2QAAAAAAAAAAQAAAEttcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAACdlc2RzAAAAAAMZAAEABBFAFQAAAAABftAAAAAABQISCAYBAgAAABhzdHRzAAAAAAAAAAEAAAABAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAXAAAAAQAAABRzdGNvAAAAAAAAAAEAAAAoAAAAYHVkdGEAAABYbWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAraWxzdAAAACOpdG9vAAAAG2RhdGEAAAABAAAAAExhdmY1Mi42NC4y'\r\n        else if (Modernizr.audio.ogg)\r\n          a.src =\r\n            'data:audio/ogg;base64,T2dnUwACAAAAAAAAAAD/QwAAAAAAAM2LVKsBHgF2b3JiaXMAAAAAAUSsAAAAAAAAgLsAAAAAAAC4AU9nZ1MAAAAAAAAAAAAA/0MAAAEAAADmvOe6Dy3/////////////////MgN2b3JiaXMdAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAwNzA2MjIAAAAAAQV2b3JiaXMfQkNWAQAAAQAYY1QpRplS0kqJGXOUMUaZYpJKiaWEFkJInXMUU6k515xrrLm1IIQQGlNQKQWZUo5SaRljkCkFmVIQS0kldBI6J51jEFtJwdaYa4tBthyEDZpSTCnElFKKQggZU4wpxZRSSkIHJXQOOuYcU45KKEG4nHOrtZaWY4updJJK5yRkTEJIKYWSSgelU05CSDWW1lIpHXNSUmpB6CCEEEK2IIQNgtCQVQAAAQDAQBAasgoAUAAAEIqhGIoChIasAgAyAAAEoCiO4iiOIzmSY0kWEBqyCgAAAgAQAADAcBRJkRTJsSRL0ixL00RRVX3VNlVV9nVd13Vd13UgNGQVAAABAEBIp5mlGiDCDGQYCA1ZBQAgAAAARijCEANCQ1YBAAABAABiKDmIJrTmfHOOg2Y5aCrF5nRwItXmSW4q5uacc845J5tzxjjnnHOKcmYxaCa05pxzEoNmKWgmtOacc57E5kFrqrTmnHPGOaeDcUYY55xzmrTmQWo21uaccxa0pjlqLsXmnHMi5eZJbS7V5pxzzjnnnHPOOeecc6oXp3NwTjjnnHOi9uZabkIX55xzPhmne3NCOOecc84555xzzjnnnHOC0JBVAAAQAABBGDaGcacgSJ+jgRhFiGnIpAfdo8MkaAxyCqlHo6ORUuoglFTGSSmdIDRkFQAACAAAIYQUUkghhRRSSCGFFFKIIYYYYsgpp5yCCiqppKKKMsoss8wyyyyzzDLrsLPOOuwwxBBDDK20EktNtdVYY62555xrDtJaaa211koppZRSSikIDVkFAIAAABAIGWSQQUYhhRRSiCGmnHLKKaigAkJDVgEAgAAAAgAAADzJc0RHdERHdERHdERHdETHczxHlERJlERJtEzL1ExPFVXVlV1b1mXd9m1hF3bd93Xf93Xj14VhWZZlWZZlWZZlWZZlWZZlWYLQkFUAAAgAAIAQQgghhRRSSCGlGGPMMeegk1BCIDRkFQAACAAgAAAAwFEcxXEkR3IkyZIsSZM0S7M8zdM8TfREURRN01RFV3RF3bRF2ZRN13RN2XRVWbVdWbZt2dZtX5Zt3/d93/d93/d93/d93/d1HQgNWQUASAAA6EiOpEiKpEiO4ziSJAGhIasAABkAAAEAKIqjOI7jSJIkSZakSZ7lWaJmaqZneqqoAqEhqwAAQAAAAQAAAAAAKJriKabiKaLiOaIjSqJlWqKmaq4om7Lruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7rui4QGrIKAJAAANCRHMmRHEmRFEmRHMkBQkNWAQAyAAACAHAMx5AUybEsS9M8zdM8TfRET/RMTxVd0QVCQ1YBAIAAAAIAAAAAADAkw1IsR3M0SZRUS7VUTbVUSxVVT1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTVN0zRNIDRkJQAABADAYo3B5SAhJSXl3hDCEJOeMSYhtV4hBJGS3jEGFYOeMqIMct5C4xCDHggNWREARAEAAMYgxxBzyDlHqZMSOeeodJQa5xyljlJnKcWYYs0oldhSrI1zjlJHraOUYiwtdpRSjanGAgAAAhwAAAIshEJDVgQAUQAAhDFIKaQUYow5p5xDjCnnmHOGMeYcc44556B0UirnnHROSsQYc445p5xzUjonlXNOSiehAACAAAcAgAALodCQFQFAnACAQZI8T/I0UZQ0TxRFU3RdUTRd1/I81fRMU1U90VRVU1Vt2VRVWZY8zzQ901RVzzRV1VRVWTZVVZZFVdVt03V123RV3ZZt2/ddWxZ2UVVt3VRd2zdV1/Zd2fZ9WdZ1Y/I8VfVM03U903Rl1XVtW3VdXfdMU5ZN15Vl03Vt25VlXXdl2fc103Rd01Vl2XRd2XZlV7ddWfZ903WF35VlX1dlWRh2XfeFW9eV5XRd3VdlVzdWWfZ9W9eF4dZ1YZk8T1U903RdzzRdV3VdX1dd19Y105Rl03Vt2VRdWXZl2fddV9Z1zzRl2XRd2zZdV5ZdWfZ9V5Z13XRdX1dlWfhVV/Z1WdeV4dZt4Tdd1/dVWfaFV5Z14dZ1Ybl1XRg+VfV9U3aF4XRl39eF31luXTiW0XV9YZVt4VhlWTl+4ViW3feVZXRdX1ht2RhWWRaGX/id5fZ943h1XRlu3efMuu8Mx++k+8rT1W1jmX3dWWZfd47hGDq/8OOpqq+brisMpywLv+3rxrP7vrKMruv7qiwLvyrbwrHrvvP8vrAso+z6wmrLwrDatjHcvm4sv3Acy2vryjHrvlG2dXxfeArD83R1XXlmXcf2dXTjRzh+ygAAgAEHAIAAE8pAoSErAoA4AQCPJImiZFmiKFmWKIqm6LqiaLqupGmmqWmeaVqaZ5qmaaqyKZquLGmaaVqeZpqap5mmaJqua5qmrIqmKcumasqyaZqy7LqybbuubNuiacqyaZqybJqmLLuyq9uu7Oq6pFmmqXmeaWqeZ5qmasqyaZquq3meanqeaKqeKKqqaqqqraqqLFueZ5qa6KmmJ4qqaqqmrZqqKsumqtqyaaq2bKqqbbuq7Pqybeu6aaqybaqmLZuqatuu7OqyLNu6L2maaWqeZ5qa55mmaZqybJqqK1uep5qeKKqq5ommaqqqLJumqsqW55mqJ4qq6omea5qqKsumatqqaZq2bKqqLZumKsuubfu+68qybqqqbJuqauumasqybMu+78qq7oqmKcumqtqyaaqyLduy78uyrPuiacqyaaqybaqqLsuybRuzbPu6aJqybaqmLZuqKtuyLfu6LNu678qub6uqrOuyLfu67vqucOu6MLyybPuqrPq6K9u6b+sy2/Z9RNOUZVM1bdtUVVl2Zdn2Zdv2fdE0bVtVVVs2TdW2ZVn2fVm2bWE0Tdk2VVXWTdW0bVmWbWG2ZeF2Zdm3ZVv2ddeVdV/XfePXZd3murLty7Kt+6qr+rbu+8Jw667wCgAAGHAAAAgwoQwUGrISAIgCAACMYYwxCI1SzjkHoVHKOecgZM5BCCGVzDkIIZSSOQehlJQy5yCUklIIoZSUWgshlJRSawUAABQ4AAAE2KApsThAoSErAYBUAACD41iW55miatqyY0meJ4qqqaq27UiW54miaaqqbVueJ4qmqaqu6+ua54miaaqq6+q6aJqmqaqu67q6Lpqiqaqq67qyrpumqqquK7uy7Oumqqqq68quLPvCqrquK8uybevCsKqu68qybNu2b9y6ruu+7/vCka3rui78wjEMRwEA4AkOAEAFNqyOcFI0FlhoyEoAIAMAgDAGIYMQQgYhhJBSSiGllBIAADDgAAAQYEIZKDRkRQAQJwAAGEMppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkgppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkqppJRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoplVJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSSimllFJKKaWUUkoppZRSCgCQinAAkHowoQwUGrISAEgFAACMUUopxpyDEDHmGGPQSSgpYsw5xhyUklLlHIQQUmktt8o5CCGk1FJtmXNSWosx5hgz56SkFFvNOYdSUoux5ppr7qS0VmuuNedaWqs115xzzbm0FmuuOdecc8sx15xzzjnnGHPOOeecc84FAOA0OACAHtiwOsJJ0VhgoSErAYBUAAACGaUYc8456BBSjDnnHIQQIoUYc845CCFUjDnnHHQQQqgYc8w5CCGEkDnnHIQQQgghcw466CCEEEIHHYQQQgihlM5BCCGEEEooIYQQQgghhBA6CCGEEEIIIYQQQgghhFJKCCGEEEIJoZRQAABggQMAQIANqyOcFI0FFhqyEgAAAgCAHJagUs6EQY5Bjw1BylEzDUJMOdGZYk5qMxVTkDkQnXQSGWpB2V4yCwAAgCAAIMAEEBggKPhCCIgxAABBiMwQCYVVsMCgDBoc5gHAA0SERACQmKBIu7iALgNc0MVdB0IIQhCCWBxAAQk4OOGGJ97whBucoFNU6iAAAAAAAAwA4AEA4KAAIiKaq7C4wMjQ2ODo8AgAAAAAABYA+AAAOD6AiIjmKiwuMDI0Njg6PAIAAAAAAAAAAICAgAAAAAAAQAAAAICAT2dnUwAE7AwAAAAAAAD/QwAAAgAAADuydfsFAQEBAQEACg4ODg=='\r\n        else {\r\n          if (!Modernizr.audio.wav) return void d('audiopreload', !1)\r\n          a.src =\r\n            'data:audio/wav;base64,UklGRvwZAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YdgZAAAAAAEA/v8CAP//AAABAP////8DAPz/BAD9/wEAAAAAAAAAAAABAP7/AgD//wAAAQD//wAAAQD//wAAAQD+/wIA//8AAAAAAAD//wIA/v8BAAAA//8BAAAA//8BAP//AQAAAP//AQD//wEAAAD//wEA//8BAP//AQD//wEA//8BAP//AQD+/wMA/f8DAP3/AgD+/wIA/////wMA/f8CAP7/AgD+/wMA/f8CAP7/AgD//wAAAAAAAAAAAQD+/wIA/v8CAP7/AwD9/wIA/v8BAAEA/v8CAP7/AQAAAAAAAAD//wEAAAD//wIA/f8DAP7/AQD//wEAAAD//wEA//8CAP7/AQD//wIA/v8CAP7/AQAAAAAAAAD//wEAAAAAAAAA//8BAP//AgD9/wQA+/8FAPz/AgAAAP//AgD+/wEAAAD//wIA/v8CAP3/BAD8/wQA/P8DAP7/AwD8/wQA/P8DAP7/AQAAAAAA//8BAP//AgD+/wEAAAD//wIA/v8BAP//AQD//wEAAAD//wEA//8BAAAAAAAAAP//AgD+/wEAAAAAAAAAAAD//wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP//AgD+/wIA/v8BAP//AQABAP7/AQD//wIA/v8CAP3/AwD/////AgD9/wMA/v8BAP//AQAAAP//AQD//wEA//8BAP//AAABAP//AAABAP//AQD//wAAAAACAP3/AwD9/wIA//8BAP//AQD//wEA//8BAP//AgD9/wMA/v8AAAIA/f8CAAAA/v8EAPv/BAD9/wIAAAD+/wQA+v8HAPr/BAD+/wEAAAD//wIA/f8EAPz/BAD7/wUA/P8EAPz/AwD+/wEAAAD//wEAAAAAAP//AgD8/wUA+/8FAPz/AwD9/wIA//8AAAEA/v8CAP//AQD//wAAAAABAP//AgD9/wMA/f8EAPz/AwD+/wAAAwD7/wUA/P8DAP7/AQAAAP//AgD+/wEAAQD+/wIA/v8BAAEA/v8CAP7/AQAAAP//AgD9/wMA/f8DAP7/AgD+/wEAAAAAAAEA//8AAAEA/v8DAP3/AgD//wEA//8BAP7/AwD9/wMA/v8BAP//AQAAAP//AgD9/wMA/v8BAP//AQAAAP//AgD+/wEAAQD+/wIA/////wIA//8AAAEA/f8DAP//AAABAP////8DAP3/AwD+/wEA//8BAP//AQAAAAAA//8BAP//AQD//wEA//8BAP//AAAAAAEA//8BAP7/AgD//wEA//8AAAAAAAAAAAAAAAD//wIA/v8BAAAA//8BAAEA/v8BAAAA//8DAPz/AwD+/wIA/v8CAP3/AwD+/wEAAAD//wEA//8BAAAA//8BAAAA/v8EAPv/BAD+/wAAAAABAP7/AgD//wAAAAABAP7/AgD//wAAAAAAAAAAAAABAP3/BAD8/wQA/f8BAAAAAAABAP7/AgD+/wIA/v8CAP7/AgD+/wIA/v8BAAAAAAD//wIA/f8DAP7/AAABAP//AAACAPz/BAD9/wIA//8AAP//AwD9/wMA/P8EAP3/AwD9/wIA//8BAP//AQD+/wMA/f8DAP7/AAABAP//AQAAAP//AQD//wIA/f8DAP7/AQAAAP//AQAAAAAA//8CAP7/AQABAP7/AgD+/wEAAQD+/wIA/v8CAP////8CAP7/AgD//wAAAAABAP7/AwD9/wIAAAD+/wMA/f8CAP//AQD+/wMA/f8CAP//AAACAPz/BQD6/wUA/v///wIA/v8CAP3/BAD7/wYA+v8FAPz/AwD/////AgD+/wEAAAD//wEAAAD//wIA/f8DAP7/AQAAAP//AgD//wAA//8BAAAAAAAAAP//AQD//wEA//8AAAIA/f8DAP3/AgAAAP//AQD//wEA//8AAAEA//8BAP////8CAP//AAABAP3/BAD9/wIA/v8BAAEA//8BAP7/AgD//wEA//8AAAEA//8BAP//AAAAAAEA//8BAP7/AgD//wEA//8AAAAAAQD+/wIA/v8BAAAAAAD//wIA/v8BAAAAAAAAAAAAAQD+/wMA/f8CAP//AQD//wIA/f8DAP7/AQD//wEA//8CAP7/AAABAP7/AwD9/wMA/v8AAAEA//8BAAAAAAD//wIA/v8BAAAA//8CAP7/AgD+/wEA//8CAP7/AgD//wAAAAAAAAAAAQD//wEA/v8DAPz/BQD8/wIA//8AAAEAAAD//wEA//8BAP//AQAAAAAA//8BAP//AgD+/wEAAAAAAP//AQD+/wMA/////wEA/v8CAP//AQD//wEA//8AAAEA//8BAAAA/v8EAPz/AwD+/wEAAAAAAAAA//8CAP7/AQD//wEA//8BAP//AAABAP7/AwD9/wIA//8BAP//AQD//wEA//8AAAEA/v8EAPv/BAD9/wIA//8BAP7/AwD9/wIA//8AAAEA//8BAP//AQD//wAAAQD//wEAAAD+/wMA/v8AAAIA/f8DAP7/AQD//wAAAQD+/wMA/f8CAP//AAABAP7/AgD+/wMA/f8CAP7/AQABAP7/AgD+/wIA/v8CAP7/AwD8/wMA//8AAAEA//8AAAAAAAABAP//AQD//wAAAQD//wIA/f8DAP3/AwD+/wAAAgD9/wIA//8AAAEAAAD+/wMA/P8FAPv/BAD9/wIA//8AAP//AgD+/wIA/v8BAAAAAAD//wEAAAAAAP//AQD//wEA//8BAP//AAABAP7/AwD9/wIA//8BAP//AAABAP//AQD//wAAAQD//wEA//8BAP//AAABAAAA//8BAP7/AwD9/wMA/f8DAP3/AgD//wEA//8BAP7/AgD//wAAAgD8/wQA/f8CAP//AQD+/wMA/f8CAP7/AgD//wAAAAAAAAAAAAABAP7/AwD9/wIA/v8DAP3/AwD9/wIA/v8DAPz/BQD7/wQA/f8CAP7/AwD9/wMA/f8CAP//AQAAAP7/AwD+/wEA//8AAAEAAAAAAP//AAABAP//AQAAAP7/AwD9/wMA/f8CAP//AQD//wEA//8AAAIA/f8CAAAA//8BAAAA//8BAAAA/v8EAPv/BAD9/wIA//8AAAEA/v8CAP//AAABAP//AAABAP//AAABAP7/AwD8/wQA/f8CAAAA/v8DAP3/AwD9/wMA/v8BAAAA//8BAAAA//8CAP7/AQAAAAAAAAAAAAAA//8CAP7/AgD+/wIA/v8CAP7/AgD//wAAAQD//wAAAQD//wAAAQD//wAAAQD+/wIA//8AAAAAAQD+/wMA/f8CAP//AQD//wEA//8AAAEA/v8DAP3/AgD//wAAAAABAP7/AwD9/wIA//8AAAEA/v8DAP3/AgD//wAAAAABAP7/AwD8/wMA/v8CAP//AAD//wIA/v8CAP7/AQABAP7/AQAAAP//AgD/////AQD//wEAAAD//wEA/v8EAPv/BAD9/wMA/v8BAAAA//8BAAEA/P8GAPr/BQD8/wMA/v8BAAAA//8CAP7/AQABAP3/BAD7/wYA+/8EAPz/AwD//wEA//8BAP7/BAD8/wMA/v8AAAIA/v8BAAAA//8BAAAA//8BAAAA//8CAP3/AwD+/wAAAgD8/wUA/P8DAP7/AAABAAAAAAD//wEAAAD//wIA/f8DAP7/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/f8EAPz/AwD/////AgD+/wIA/f8DAP7/AgD+/wEA//8CAP7/AQD//wEAAAAAAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAP//AQAAAP//AAACAP3/BAD7/wQA/v8BAAAA//8BAP//AQAAAP//AQAAAP7/BAD7/wUA+/8EAP3/AgD//wAAAQD+/wIA//8AAAEA/v8CAP//AQD+/wEAAAAAAAAAAAD//wEA//8CAP3/AwD9/wIA//8AAAAAAAAAAAAA//8BAP//AgD+/wEA//8CAP7/AQAAAP//AgD/////AgD/////AgD+/wIA//8AAP//AQABAP7/AgD9/wMA/v8CAP////8BAAAAAAAAAAAA//8CAP////8DAPz/AwD+/wEAAAAAAP//AQD//wEAAAD//wEAAAD+/wQA+/8FAPz/AgAAAP//AgD9/wMA/v8BAAAAAAD//wEAAAD//wIA/v8BAAAAAAD//wIA/v8BAAAA//8BAAAA//8CAP7/AQD//wEA//8BAAAA//8BAP//AAABAP//AQAAAP7/AgD//wEA//8AAAAAAQD+/wMA/P8EAP7///8DAPz/BQD8/wEAAQD+/wMA/v8AAAEA//8BAP//AQD//wEA/v8CAP//AQD//wAAAAABAAAA//8BAP//AQAAAAAA//8BAP//AgD+/wAAAQD//wIA/f8CAP//AQAAAP7/AwD9/wMA/v8BAP//AAABAP//AgD9/wIA//8BAAAA//8BAAAA//8CAP3/AwD+/wEAAAD+/wQA/P8DAP7/AAACAP7/AQAAAP//AQAAAP//AQAAAP//AgD9/wIAAAD//wIA/f8DAP7/AQD//wEA//8CAP7/AQD//wAAAQD//wEA//8AAAAAAQD//wEAAAD9/wUA+/8FAPz/AgD//wAAAQD//wAAAQD+/wMA/f8BAAEA/v8CAP7/AgD+/wIA/v8BAAAAAAAAAAAAAAD//wIA/v8CAP////8CAP7/AgD+/wIA/v8CAP7/AQAAAP//AQAAAP//AQD//wAAAQD//wAAAQD+/wMA/f8CAAAA/v8DAP3/AgAAAP//AQAAAP7/AwD9/wMA/v8BAP//AQD//wEAAAD+/wMA/f8CAAAA/v8CAP//AAAAAAEA//8AAAEA/v8DAP3/AwD9/wIA//8BAP//AgD8/wQA/v8BAAAA/v8CAP//AQD//wAAAAAAAAEA/f8EAPz/BAD9/wIA//8AAAAAAAABAP//AAAAAAAAAAABAP3/BAD9/wIA/v8BAAEA//8AAAAA//8CAP7/AgD9/wQA+/8FAPv/BQD8/wMA/f8DAP3/AwD+/wAAAgD9/wMA/f8CAAAA/v8EAPv/BQD7/wUA/P8DAP///v8DAP3/BAD8/wMA/f8DAP7/AQD//wEAAAD//wEA/v8CAAAA/v8CAP7/AgD//wAAAAAAAAAAAQD+/wIA//8AAAEA/v8DAPz/BAD9/wIA//8AAP//AgD//wEA/v8BAAAAAQD//wAAAAAAAAEA//8AAAEA//8BAP//AAABAP//AQD+/wIA/v8DAPz/BAD8/wQA/f8BAAAAAQD+/wMA/P8DAP//AAAAAAAAAAD//wMA+/8FAP3/AQABAP3/BAD8/wMA/v8BAAAA//8CAP3/AwD+/wEAAQD9/wMA/f8EAPz/BAD7/wQA/v8BAAEA/f8DAP7/AQAAAP//AgD+/wEAAAD//wIA/v8CAP7/AgD+/wEAAQD//wEA/v8CAP7/BAD7/wQA/f8CAAAA//8AAAAAAAABAP//AQD+/wEAAQD+/wMA/f8BAAEA/v8DAPz/AwD/////AwD8/wQA/P8DAP7/AgD//wAA//8BAAAAAAAAAP//AgD+/wEAAAD//wIA/v8BAAAA//8CAP3/AgD//wAAAQD+/wIA/v8BAAAA//8CAP7/AgD+/wEA//8CAP3/BAD7/wQA/v8BAAAA//8AAAEAAAD//wIA/f8DAP7/AgD+/wIA/v8CAP7/AgD+/wEAAAAAAP//AgD9/wMA/v8BAP//AgD9/wMA/v8AAAEA//8BAP//AQD//wEA//8AAAEA/v8EAPz/AgD//wAAAQAAAP//AAABAP//AQD//wEAAAD//wEA//8BAAEA/f8DAP7/AQABAP3/AwD+/wIA/////wEAAAAAAAAAAAD//wIA/v8CAP////8CAP7/AgD//wAA//8CAP3/BAD9/wAAAgD9/wMA/v8BAP//AQAAAP//AQAAAP//AgD9/wMA/f8EAPz/AwD+/wEAAAAAAAAAAAD//wIA/f8EAP3/AAABAAAA//8CAP7/AQAAAP//AQAAAAAA//8BAP//AQAAAP//AQAAAP//AQAAAP//AgD9/wMA/v8BAP//AQAAAP//AQD//wIA/v8CAP3/BAD9/wEAAAD//wEAAQD9/wMA/f8CAAAA/v8DAP3/AgD//wAAAQD+/wIA/v8CAP7/AQAAAP//AgD+/wEAAAAAAP//AwD7/wUA/f8BAAEA/v8BAAEA/v8DAP3/AgD//wEA//8BAP//AQD//wEA//8CAP3/BAD7/wQA/////wIA/v8AAAIA/v8CAP3/BAD7/wUA/P8DAP3/AwD9/wMA/v8AAAIA/v8CAP7/AgD+/wIA//8AAAEA/v8CAP7/AgD//wAAAAD//wEAAAAAAAAA//8BAP7/BAD7/wUA/P8CAAAA//8BAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAAAA//8CAP3/AwD+/wEA//8CAP3/AwD+/wAAAwD8/wIAAAD//wIA/////wIA/v8CAP7/AgD+/wEAAAAAAAAAAAAAAP//AgD+/wIA//8AAAAA//8CAP7/AgD+/wEA//8CAP3/AwD9/wMA/v8BAP7/AwD9/wMA/f8CAP//AQD+/wIA//8BAP//AQD+/wMA/v8BAAAA//8BAAAA//8CAP7/AQAAAP//AgD+/wIA/v8CAP//AAAAAAEA//8BAP//AAABAAAA//8BAP//AQD//wEA//8BAP//AQAAAP//AQD//wEAAAD//wIA/f8CAAAA//8BAAAA//8BAP//AAABAP//AQD//wAAAAAAAAEA/v8CAP//AQD//wAAAAABAP7/AwD9/wIAAAD+/wIA//8BAP//AgD9/wMA/f8DAP7/AgD+/wEAAAAAAAEA/v8CAP7/AgD//wAAAAAAAAAAAAAAAP//AgD/////AgD9/wQA/f8BAAAAAAAAAAEA/f8DAP////8DAP3/AQABAP7/AgD//wAAAQD+/wMA/f8CAP7/AQABAP7/AwD7/wYA+v8FAP3/AQABAP7/AgD+/wMA/f8CAP7/AwD+/wEA//8BAP//AQAAAP7/BQD5/wcA+v8FAPz/AwD+/wIA/v8BAAAA//8DAPv/BQD8/wMA/////wEAAAAAAAAAAAD//wIA/f8DAP7/AQAAAP//AQAAAP//AgD+/wIA/v8BAAEA/f8EAPz/AwD+/wEA//8CAP7/AQD//wEA//8CAP7/AQAAAP//AgD+/wEAAAAAAAAAAAAAAAAAAAD//wIA/f8EAPz/AwD+/wEA//8CAP7/AgD+/wEAAQD+/wEAAQD+/wIA/////wIA//8AAAAAAAAAAAAAAAD//wEAAAAAAP//AgD9/wMA/v8BAP//AQAAAP//AQD//wEA//8BAP//AQD//wEA//8BAP//AQAAAP7/AwD9/wMA/v8BAP7/AwD9/wMA/v8BAP//AAABAP//AQD//wAAAAABAP//AAAAAAAAAQD//wEA/v8CAAAA/v8EAPv/BAD9/wIAAAD+/wMA/P8DAP//AAAAAP//AQD//wIA/f8DAP3/AwD9/wMA/v8BAAAA//8BAAAA//8CAP3/AwD9/wQA+/8FAPv/BQD8/wMA/v8BAAAA//8BAP//AgD+/wEAAAD//wIA/v8BAAEA/f8DAP3/AgAAAP//AQD//wAAAQD//wEA//8BAP//AQD//wEA/v8DAP3/AgAAAP7/AwD9/wIAAAD//wEAAAD//wIA/f8DAP7/AgD9/wQA+/8FAPz/AgAAAP//AgD9/wIA//8BAP//AQD//wEA//8BAP//AQD//wIA/f8DAP3/AgD//wAAAQD+/wIA/v8BAAEA/v8CAP7/AgD+/wMA/P8DAP//AAABAP7/AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEA/v8CAP3/BAD8/wMA/v8BAAAAAAD//wEAAAAAAAAAAAD//wEAAAAAAAAA//8BAP//AgD+/wEA//8CAP3/AwD9/wMA/f8EAPv/BAD+/wAAAQD//wEA//8BAP//AAABAP//AQD//wEAAAD//wEA//8BAP//AgD9/wMA/v8AAAIA/f8DAP7/AAACAP3/AwD+/wEA//8BAP//AQAAAP//AQAAAP7/AwD9/wMA/v8AAAEA//8BAP//AAAAAAEA//8AAAEA/v8CAP//AAAAAAEA/v8DAPz/BAD9/wEAAQD+/wEAAQD9/wQA/P8DAP7/AQAAAAAAAAAAAAAAAAAAAAAAAQD+/wIA/////wIA/v8BAAAA//8BAP//AQD//wEA//8BAAAA/v8EAPz/AwD///7/BAD8/wMA/////wIA/v8CAP////8CAP7/AgD+/wIA/v8CAP////8CAP7/AwD9/wIA/v8CAP//AAABAP7/AwD9/wEAAQD+/wMA/f8CAP//AAAAAAEA/v8DAPz/BAD9/wIA/v8CAP7/AgD//wAAAAD//wIA/v8CAP7/AQAAAAAA//8CAP7/AgD+/wIA/v8CAP7/AwD8/wUA+v8GAPv/AwD//wAAAAAAAAAA//8DAPv/BQD9/wAAAgD9/wMA/v8BAP//AQAAAP//AgD9/wMA/v8BAAAA//8BAAAAAAAAAP//AQAAAAAAAAD//wEA//8CAP3/AwD+/wAAAgD+/wEAAAD//wIA/v8CAP7/AgD/////AwD8/wUA/P8CAP//AQD//wIA/f8DAP3/AwD+/wAAAQD+/wMA/f8DAP3/AgD//wAAAQD//wEA//8BAP7/AwD+/wEA//8AAAEA//8CAPz/BAD9/wIA//8AAAEA/v8DAPz/BAD9/wIA//8AAAEA/v8CAP7/AgD//wEA/f8EAPz/BAD+////AgD//wAAAQD//wAAAQD//wEA//8BAP7/AwD+/wEA'\r\n        }\r\n      } catch (r) {\r\n        return void d('audiopreload', !1)\r\n      }\r\n      a.setAttribute('preload', 'auto'),\r\n        (a.style.cssText = 'display:none'),\r\n        I.appendChild(a),\r\n        setTimeout(function () {\r\n          a.addEventListener('loadeddata', A, !1), (e = setTimeout(A, n))\r\n        }, 0)\r\n    })\r\n  var U = (B.testStyles = s)\r\n  Modernizr.addTest('unicoderange', function () {\r\n    return Modernizr.testStyles(\r\n      '@font-face{font-family:\"unicodeRange\";src:local(\"Arial\");unicode-range:U+0020,U+002E}#modernizr span{font-size:20px;display:inline-block;font-family:\"unicodeRange\",monospace}#modernizr .mono{font-family:monospace}',\r\n      function (A) {\r\n        for (var e = ['.', '.', 'm', 'm'], t = 0; t < e.length; t++) {\r\n          var n = o('span')\r\n          ;(n.innerHTML = e[t]), (n.className = t % 2 ? 'mono' : ''), A.appendChild(n), (e[t] = n.clientWidth)\r\n        }\r\n        return e[0] !== e[1] && e[2] === e[3]\r\n      }\r\n    )\r\n  }),\r\n    Modernizr.addTest('unicode', function () {\r\n      var A,\r\n        e = o('span'),\r\n        t = o('span')\r\n      return (\r\n        U('#modernizr{font-family:Arial,sans;font-size:300em;}', function (n) {\r\n          ;(e.innerHTML = y ? '妇' : '&#5987;'),\r\n            (t.innerHTML = y ? '☆' : '&#9734;'),\r\n            n.appendChild(e),\r\n            n.appendChild(t),\r\n            (A = 'offsetWidth' in e && e.offsetWidth !== t.offsetWidth)\r\n        }),\r\n        A\r\n      )\r\n    }),\r\n    Modernizr.addTest('checked', function () {\r\n      return U(\r\n        '#modernizr {position:absolute} #modernizr input {margin-left:10px} #modernizr :checked {margin-left:20px;display:block}',\r\n        function (A) {\r\n          var e = o('input')\r\n          return (\r\n            e.setAttribute('type', 'checkbox'),\r\n            e.setAttribute('checked', 'checked'),\r\n            A.appendChild(e),\r\n            20 === e.offsetLeft\r\n          )\r\n        }\r\n      )\r\n    }),\r\n    U('#modernizr{font:0/0 a}#modernizr:after{content:\":)\";visibility:hidden;font:7px/1 a}', function (A) {\r\n      Modernizr.addTest('generatedcontent', A.offsetHeight >= 7)\r\n    }),\r\n    U(\r\n      '#modernizr div {width:100px} #modernizr :last-child{width:200px;display:block}',\r\n      function (A) {\r\n        Modernizr.addTest('lastchild', A.lastChild.offsetWidth > A.firstChild.offsetWidth)\r\n      },\r\n      2\r\n    ),\r\n    Modernizr.addTest('cssvalid', function () {\r\n      return U(\r\n        '#modernizr input{height:0;border:0;padding:0;margin:0;width:10px} #modernizr input:valid{width:50px}',\r\n        function (A) {\r\n          var e = o('input')\r\n          return A.appendChild(e), e.clientWidth > 10\r\n        }\r\n      )\r\n    }),\r\n    U('#modernizr { height: 50vh; }', function (e) {\r\n      var t = parseInt(A.innerHeight / 2, 10),\r\n        n = parseInt((A.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle).height, 10)\r\n      Modernizr.addTest('cssvhunit', n == t)\r\n    }),\r\n    U(\r\n      '#modernizr div {width:1px} #modernizr div:nth-child(2n) {width:2px;}',\r\n      function (A) {\r\n        for (var e = A.getElementsByTagName('div'), t = !0, n = 0; 5 > n; n++) t = t && e[n].offsetWidth === (n % 2) + 1\r\n        Modernizr.addTest('nthchild', t)\r\n      },\r\n      5\r\n    ),\r\n    U('#modernizr { width: 50vw; }', function (e) {\r\n      var t = parseInt(A.innerWidth / 2, 10),\r\n        n = parseInt((A.getComputedStyle ? getComputedStyle(e, null) : e.currentStyle).width, 10)\r\n      Modernizr.addTest('cssvwunit', n == t)\r\n    }),\r\n    U(\r\n      '#modernizr{overflow: scroll; width: 40px; height: 40px; }#' +\r\n        R.join('scrollbar{width:0px} #modernizr::')\r\n          .split('#')\r\n          .slice(1)\r\n          .join('#') +\r\n        'scrollbar{width:0px}',\r\n      function (A) {\r\n        Modernizr.addTest('cssscrollbar', 40 == A.scrollWidth)\r\n      }\r\n    ),\r\n    Modernizr.addTest('formvalidation', function () {\r\n      var e = o('form')\r\n      if (!('checkValidity' in e && 'addEventListener' in e)) return !1\r\n      if ('reportValidity' in e) return !0\r\n      var t,\r\n        n = !1\r\n      return (\r\n        (Modernizr.formvalidationapi = !0),\r\n        e.addEventListener(\r\n          'submit',\r\n          function (e) {\r\n            ;(!A.opera || A.operamini) && e.preventDefault(), e.stopPropagation()\r\n          },\r\n          !1\r\n        ),\r\n        (e.innerHTML = '<input name=\"modTest\" required=\"required\" /><button></button>'),\r\n        U('#modernizr form{position:absolute;top:-99999em}', function (A) {\r\n          A.appendChild(e),\r\n            (t = e.getElementsByTagName('input')[0]),\r\n            t.addEventListener(\r\n              'invalid',\r\n              function (A) {\r\n                ;(n = !0), A.preventDefault(), A.stopPropagation()\r\n              },\r\n              !1\r\n            ),\r\n            (Modernizr.formvalidationmessage = !!t.validationMessage),\r\n            e.getElementsByTagName('button')[0].click()\r\n        }),\r\n        n\r\n      )\r\n    })\r\n  var W = (function () {\r\n    var e = A.matchMedia || A.msMatchMedia\r\n    return e\r\n      ? function (A) {\r\n          var t = e(A)\r\n          return (t && t.matches) || !1\r\n        }\r\n      : function (e) {\r\n          var t = !1\r\n          return (\r\n            s('@media ' + e + ' { #modernizr { position: absolute; } }', function (e) {\r\n              t = 'absolute' == (A.getComputedStyle ? A.getComputedStyle(e, null) : e.currentStyle).position\r\n            }),\r\n            t\r\n          )\r\n        }\r\n  })()\r\n  ;(B.mq = W), Modernizr.addTest('mediaqueries', W('only all'))\r\n  var z = 'Moz O ms Webkit',\r\n    Z = B._config.usePrefixes ? z.split(' ') : []\r\n  B._cssomPrefixes = Z\r\n  var K = function (e) {\r\n    var n,\r\n      a = R.length,\r\n      i = A.CSSRule\r\n    if ('undefined' == typeof i) return t\r\n    if (!e) return !1\r\n    if (((e = e.replace(/^@/, '')), (n = e.replace(/-/g, '_').toUpperCase() + '_RULE'), n in i)) return '@' + e\r\n    for (var o = 0; a > o; o++) {\r\n      var r = R[o],\r\n        d = r.toUpperCase() + '_' + n\r\n      if (d in i) return '@-' + r.toLowerCase() + '-' + e\r\n    }\r\n    return !1\r\n  }\r\n  B.atRule = K\r\n  var F = B._config.usePrefixes ? z.toLowerCase().split(' ') : []\r\n  B._domPrefixes = F\r\n  var J = { elem: o('modernizr') }\r\n  Modernizr._q.push(function () {\r\n    delete J.elem\r\n  })\r\n  var O = { style: J.elem.style }\r\n  Modernizr._q.unshift(function () {\r\n    delete O.style\r\n  }),\r\n    (B.testAllProps = p)\r\n  var G = (B.prefixed = function (A, e, t) {\r\n    return 0 === A.indexOf('@') ? K(A) : (-1 != A.indexOf('-') && (A = w(A)), e ? p(A, e, t) : p(A, 'pfx'))\r\n  })\r\n  Modernizr.addTest('requestanimationframe', !!G('requestAnimationFrame', A), { aliases: ['raf'] }),\r\n    Modernizr.addTest('backgroundblendmode', G('backgroundBlendMode', 'text')),\r\n    (B.testAllProps = g),\r\n    Modernizr.addTest('cssanimations', g('animationName', 'a', !0)),\r\n    Modernizr.addTest('backgroundcliptext', function () {\r\n      return g('backgroundClip', 'text')\r\n    }),\r\n    Modernizr.addTest('bgpositionxy', function () {\r\n      return g('backgroundPositionX', '3px', !0) && g('backgroundPositionY', '5px', !0)\r\n    }),\r\n    Modernizr.addTest('bgrepeatround', g('backgroundRepeat', 'round')),\r\n    Modernizr.addTest('bgrepeatspace', g('backgroundRepeat', 'space')),\r\n    Modernizr.addTest('backgroundsize', g('backgroundSize', '100%', !0)),\r\n    Modernizr.addTest('bgsizecover', g('backgroundSize', 'cover')),\r\n    Modernizr.addTest('borderradius', g('borderRadius', '0px', !0)),\r\n    (function () {\r\n      Modernizr.addTest('csscolumns', function () {\r\n        var A = !1,\r\n          e = g('columnCount')\r\n        try {\r\n          ;(A = !!e) && (A = new Boolean(A))\r\n        } catch (t) {}\r\n        return A\r\n      })\r\n      for (\r\n        var A,\r\n          e,\r\n          t = [\r\n            'Width',\r\n            'Span',\r\n            'Fill',\r\n            'Gap',\r\n            'Rule',\r\n            'RuleColor',\r\n            'RuleStyle',\r\n            'RuleWidth',\r\n            'BreakBefore',\r\n            'BreakAfter',\r\n            'BreakInside'\r\n          ],\r\n          n = 0;\r\n        n < t.length;\r\n        n++\r\n      )\r\n        (A = t[n].toLowerCase()),\r\n          (e = g('column' + t[n])),\r\n          ('breakbefore' === A || 'breakafter' === A || 'breakinside' == A) && (e = e || g(t[n])),\r\n          Modernizr.addTest('csscolumns.' + A, e)\r\n    })(),\r\n    Modernizr.addTest('ellipsis', g('textOverflow', 'ellipsis')),\r\n    Modernizr.addTest('cssfilters', function () {\r\n      if (Modernizr.supports) return g('filter', 'blur(2px)')\r\n      var A = o('a')\r\n      return (\r\n        (A.style.cssText = R.join('filter:blur(2px); ')),\r\n        !!A.style.length && (e.documentMode === t || e.documentMode > 9)\r\n      )\r\n    }),\r\n    Modernizr.addTest('boxshadow', g('boxShadow', '1px 1px', !0)),\r\n    Modernizr.addTest('boxsizing', g('boxSizing', 'border-box', !0) && (e.documentMode === t || e.documentMode > 7)),\r\n    Modernizr.addTest('flexbox', g('flexBasis', '1px', !0)),\r\n    Modernizr.addTest('flexboxlegacy', g('boxDirection', 'reverse', !0)),\r\n    Modernizr.addTest('flexboxtweener', g('flexAlign', 'end', !0)),\r\n    Modernizr.addTest('flexwrap', g('flexWrap', 'wrap', !0)),\r\n    Modernizr.addTest('cssmask', g('maskRepeat', 'repeat-x', !0)),\r\n    Modernizr.addTest('csstransforms', function () {\r\n      return -1 === navigator.userAgent.indexOf('Android 2.') && g('transform', 'scale(1)', !0)\r\n    }),\r\n    Modernizr.addTest('csstransitions', g('transition', 'all', !0)),\r\n    Modernizr.addTest('overflowscrolling', g('overflowScrolling', 'touch', !0)),\r\n    a(),\r\n    i(v),\r\n    delete B.addTest,\r\n    delete B.addAsyncTest\r\n  for (var Y = 0; Y < Modernizr._q.length; Y++) Modernizr._q[Y]()\r\n  __webpack_provided_window_dot_Modernizr = Modernizr\r\n})(window, document)\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/modernizr/modernizr.js?");

/***/ }),

/***/ 1:
/*!*******************************************************!*\
  !*** ./src/public/js/vendor/underscore/underscore.js ***!
  \*******************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3\r\n//     http://underscorejs.org\r\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\r\n//     Underscore may be freely distributed under the MIT license.\r\n;(function () {\r\n  function n (n) {\r\n    function t (t, r, e, u, i, o) {\r\n      for (; i >= 0 && o > i; i += n) {\r\n        var a = u ? u[i] : i\r\n        e = r(e, t[a], a, t)\r\n      }\r\n      return e\r\n    }\r\n    return function (r, e, u, i) {\r\n      e = b(e, i, 4)\r\n      var o = !k(r) && m.keys(r),\r\n        a = (o || r).length,\r\n        c = n > 0 ? 0 : a - 1\r\n      return arguments.length < 3 && ((u = r[o ? o[c] : c]), (c += n)), t(r, e, u, o, c, a)\r\n    }\r\n  }\r\n  function t (n) {\r\n    return function (t, r, e) {\r\n      r = x(r, e)\r\n      for (var u = O(t), i = n > 0 ? 0 : u - 1; i >= 0 && u > i; i += n) if (r(t[i], i, t)) return i\r\n      return -1\r\n    }\r\n  }\r\n  function r (n, t, r) {\r\n    return function (e, u, i) {\r\n      var o = 0,\r\n        a = O(e)\r\n      if ('number' == typeof i)\r\n        n > 0 ? (o = i >= 0 ? i : Math.max(i + a, o)) : (a = i >= 0 ? Math.min(i + 1, a) : i + a + 1)\r\n      else if (r && i && a) return (i = r(e, u)), e[i] === u ? i : -1\r\n      if (u !== u) return (i = t(l.call(e, o, a), m.isNaN)), i >= 0 ? i + o : -1\r\n      for (i = n > 0 ? o : a - 1; i >= 0 && a > i; i += n) if (e[i] === u) return i\r\n      return -1\r\n    }\r\n  }\r\n  function e (n, t) {\r\n    var r = I.length,\r\n      e = n.constructor,\r\n      u = (m.isFunction(e) && e.prototype) || a,\r\n      i = 'constructor'\r\n    for (m.has(n, i) && !m.contains(t, i) && t.push(i); r--; )\r\n      (i = I[r]), i in n && n[i] !== u[i] && !m.contains(t, i) && t.push(i)\r\n  }\r\n  var u = this,\r\n    i = u._,\r\n    o = Array.prototype,\r\n    a = Object.prototype,\r\n    c = Function.prototype,\r\n    f = o.push,\r\n    l = o.slice,\r\n    s = a.toString,\r\n    p = a.hasOwnProperty,\r\n    h = Array.isArray,\r\n    v = Object.keys,\r\n    g = c.bind,\r\n    y = Object.create,\r\n    d = function () {},\r\n    m = function (n) {\r\n      return n instanceof m ? n : this instanceof m ? void (this._wrapped = n) : new m(n)\r\n    }\r\n   true\r\n    ? ( true && module.exports && (exports = module.exports = m), (exports._ = m))\r\n    : (0),\r\n    (m.VERSION = '1.8.3')\r\n  var b = function (n, t, r) {\r\n      if (t === void 0) return n\r\n      switch (null == r ? 3 : r) {\r\n        case 1:\r\n          return function (r) {\r\n            return n.call(t, r)\r\n          }\r\n        case 2:\r\n          return function (r, e) {\r\n            return n.call(t, r, e)\r\n          }\r\n        case 3:\r\n          return function (r, e, u) {\r\n            return n.call(t, r, e, u)\r\n          }\r\n        case 4:\r\n          return function (r, e, u, i) {\r\n            return n.call(t, r, e, u, i)\r\n          }\r\n      }\r\n      return function () {\r\n        return n.apply(t, arguments)\r\n      }\r\n    },\r\n    x = function (n, t, r) {\r\n      return null == n ? m.identity : m.isFunction(n) ? b(n, t, r) : m.isObject(n) ? m.matcher(n) : m.property(n)\r\n    }\r\n  m.iteratee = function (n, t) {\r\n    return x(n, t, 1 / 0)\r\n  }\r\n  var _ = function (n, t) {\r\n      return function (r) {\r\n        var e = arguments.length\r\n        if (2 > e || null == r) return r\r\n        for (var u = 1; e > u; u++)\r\n          for (var i = arguments[u], o = n(i), a = o.length, c = 0; a > c; c++) {\r\n            var f = o[c]\r\n            ;(t && r[f] !== void 0) || (r[f] = i[f])\r\n          }\r\n        return r\r\n      }\r\n    },\r\n    j = function (n) {\r\n      if (!m.isObject(n)) return {}\r\n      if (y) return y(n)\r\n      d.prototype = n\r\n      var t = new d()\r\n      return (d.prototype = null), t\r\n    },\r\n    w = function (n) {\r\n      return function (t) {\r\n        return null == t ? void 0 : t[n]\r\n      }\r\n    },\r\n    A = Math.pow(2, 53) - 1,\r\n    O = w('length'),\r\n    k = function (n) {\r\n      var t = O(n)\r\n      return 'number' == typeof t && t >= 0 && A >= t\r\n    }\r\n  ;(m.each = m.forEach = function (n, t, r) {\r\n    t = b(t, r)\r\n    var e, u\r\n    if (k(n)) for (e = 0, u = n.length; u > e; e++) t(n[e], e, n)\r\n    else {\r\n      var i = m.keys(n)\r\n      for (e = 0, u = i.length; u > e; e++) t(n[i[e]], i[e], n)\r\n    }\r\n    return n\r\n  }),\r\n    (m.map = m.collect = function (n, t, r) {\r\n      t = x(t, r)\r\n      for (var e = !k(n) && m.keys(n), u = (e || n).length, i = Array(u), o = 0; u > o; o++) {\r\n        var a = e ? e[o] : o\r\n        i[o] = t(n[a], a, n)\r\n      }\r\n      return i\r\n    }),\r\n    (m.reduce = m.foldl = m.inject = n(1)),\r\n    (m.reduceRight = m.foldr = n(-1)),\r\n    (m.find = m.detect = function (n, t, r) {\r\n      var e\r\n      return (e = k(n) ? m.findIndex(n, t, r) : m.findKey(n, t, r)), e !== void 0 && e !== -1 ? n[e] : void 0\r\n    }),\r\n    (m.filter = m.select = function (n, t, r) {\r\n      var e = []\r\n      return (\r\n        (t = x(t, r)),\r\n        m.each(n, function (n, r, u) {\r\n          t(n, r, u) && e.push(n)\r\n        }),\r\n        e\r\n      )\r\n    }),\r\n    (m.reject = function (n, t, r) {\r\n      return m.filter(n, m.negate(x(t)), r)\r\n    }),\r\n    (m.every = m.all = function (n, t, r) {\r\n      t = x(t, r)\r\n      for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {\r\n        var o = e ? e[i] : i\r\n        if (!t(n[o], o, n)) return !1\r\n      }\r\n      return !0\r\n    }),\r\n    (m.some = m.any = function (n, t, r) {\r\n      t = x(t, r)\r\n      for (var e = !k(n) && m.keys(n), u = (e || n).length, i = 0; u > i; i++) {\r\n        var o = e ? e[i] : i\r\n        if (t(n[o], o, n)) return !0\r\n      }\r\n      return !1\r\n    }),\r\n    (m.contains = m.includes = m.include = function (n, t, r, e) {\r\n      return k(n) || (n = m.values(n)), ('number' != typeof r || e) && (r = 0), m.indexOf(n, t, r) >= 0\r\n    }),\r\n    (m.invoke = function (n, t) {\r\n      var r = l.call(arguments, 2),\r\n        e = m.isFunction(t)\r\n      return m.map(n, function (n) {\r\n        var u = e ? t : n[t]\r\n        return null == u ? u : u.apply(n, r)\r\n      })\r\n    }),\r\n    (m.pluck = function (n, t) {\r\n      return m.map(n, m.property(t))\r\n    }),\r\n    (m.where = function (n, t) {\r\n      return m.filter(n, m.matcher(t))\r\n    }),\r\n    (m.findWhere = function (n, t) {\r\n      return m.find(n, m.matcher(t))\r\n    }),\r\n    (m.max = function (n, t, r) {\r\n      var e,\r\n        u,\r\n        i = -1 / 0,\r\n        o = -1 / 0\r\n      if (null == t && null != n) {\r\n        n = k(n) ? n : m.values(n)\r\n        for (var a = 0, c = n.length; c > a; a++) (e = n[a]), e > i && (i = e)\r\n      } else\r\n        (t = x(t, r)),\r\n          m.each(n, function (n, r, e) {\r\n            ;(u = t(n, r, e)), (u > o || (u === -1 / 0 && i === -1 / 0)) && ((i = n), (o = u))\r\n          })\r\n      return i\r\n    }),\r\n    (m.min = function (n, t, r) {\r\n      var e,\r\n        u,\r\n        i = 1 / 0,\r\n        o = 1 / 0\r\n      if (null == t && null != n) {\r\n        n = k(n) ? n : m.values(n)\r\n        for (var a = 0, c = n.length; c > a; a++) (e = n[a]), i > e && (i = e)\r\n      } else\r\n        (t = x(t, r)),\r\n          m.each(n, function (n, r, e) {\r\n            ;(u = t(n, r, e)), (o > u || (1 / 0 === u && 1 / 0 === i)) && ((i = n), (o = u))\r\n          })\r\n      return i\r\n    }),\r\n    (m.shuffle = function (n) {\r\n      for (var t, r = k(n) ? n : m.values(n), e = r.length, u = Array(e), i = 0; e > i; i++)\r\n        (t = m.random(0, i)), t !== i && (u[i] = u[t]), (u[t] = r[i])\r\n      return u\r\n    }),\r\n    (m.sample = function (n, t, r) {\r\n      return null == t || r\r\n        ? (k(n) || (n = m.values(n)), n[m.random(n.length - 1)])\r\n        : m.shuffle(n).slice(0, Math.max(0, t))\r\n    }),\r\n    (m.sortBy = function (n, t, r) {\r\n      return (\r\n        (t = x(t, r)),\r\n        m.pluck(\r\n          m\r\n            .map(n, function (n, r, e) {\r\n              return { value: n, index: r, criteria: t(n, r, e) }\r\n            })\r\n            .sort(function (n, t) {\r\n              var r = n.criteria,\r\n                e = t.criteria\r\n              if (r !== e) {\r\n                if (r > e || r === void 0) return 1\r\n                if (e > r || e === void 0) return -1\r\n              }\r\n              return n.index - t.index\r\n            }),\r\n          'value'\r\n        )\r\n      )\r\n    })\r\n  var F = function (n) {\r\n    return function (t, r, e) {\r\n      var u = {}\r\n      return (\r\n        (r = x(r, e)),\r\n        m.each(t, function (e, i) {\r\n          var o = r(e, i, t)\r\n          n(u, e, o)\r\n        }),\r\n        u\r\n      )\r\n    }\r\n  }\r\n  ;(m.groupBy = F(function (n, t, r) {\r\n    m.has(n, r) ? n[r].push(t) : (n[r] = [t])\r\n  })),\r\n    (m.indexBy = F(function (n, t, r) {\r\n      n[r] = t\r\n    })),\r\n    (m.countBy = F(function (n, t, r) {\r\n      m.has(n, r) ? n[r]++ : (n[r] = 1)\r\n    })),\r\n    (m.toArray = function (n) {\r\n      return n ? (m.isArray(n) ? l.call(n) : k(n) ? m.map(n, m.identity) : m.values(n)) : []\r\n    }),\r\n    (m.size = function (n) {\r\n      return null == n ? 0 : k(n) ? n.length : m.keys(n).length\r\n    }),\r\n    (m.partition = function (n, t, r) {\r\n      t = x(t, r)\r\n      var e = [],\r\n        u = []\r\n      return (\r\n        m.each(n, function (n, r, i) {\r\n          ;(t(n, r, i) ? e : u).push(n)\r\n        }),\r\n        [e, u]\r\n      )\r\n    }),\r\n    (m.first = m.head = m.take = function (n, t, r) {\r\n      return null == n ? void 0 : null == t || r ? n[0] : m.initial(n, n.length - t)\r\n    }),\r\n    (m.initial = function (n, t, r) {\r\n      return l.call(n, 0, Math.max(0, n.length - (null == t || r ? 1 : t)))\r\n    }),\r\n    (m.last = function (n, t, r) {\r\n      return null == n ? void 0 : null == t || r ? n[n.length - 1] : m.rest(n, Math.max(0, n.length - t))\r\n    }),\r\n    (m.rest = m.tail = m.drop = function (n, t, r) {\r\n      return l.call(n, null == t || r ? 1 : t)\r\n    }),\r\n    (m.compact = function (n) {\r\n      return m.filter(n, m.identity)\r\n    })\r\n  var S = function (n, t, r, e) {\r\n    for (var u = [], i = 0, o = e || 0, a = O(n); a > o; o++) {\r\n      var c = n[o]\r\n      if (k(c) && (m.isArray(c) || m.isArguments(c))) {\r\n        t || (c = S(c, t, r))\r\n        var f = 0,\r\n          l = c.length\r\n        for (u.length += l; l > f; ) u[i++] = c[f++]\r\n      } else r || (u[i++] = c)\r\n    }\r\n    return u\r\n  }\r\n  ;(m.flatten = function (n, t) {\r\n    return S(n, t, !1)\r\n  }),\r\n    (m.without = function (n) {\r\n      return m.difference(n, l.call(arguments, 1))\r\n    }),\r\n    (m.uniq = m.unique = function (n, t, r, e) {\r\n      m.isBoolean(t) || ((e = r), (r = t), (t = !1)), null != r && (r = x(r, e))\r\n      for (var u = [], i = [], o = 0, a = O(n); a > o; o++) {\r\n        var c = n[o],\r\n          f = r ? r(c, o, n) : c\r\n        t\r\n          ? ((o && i === f) || u.push(c), (i = f))\r\n          : r\r\n          ? m.contains(i, f) || (i.push(f), u.push(c))\r\n          : m.contains(u, c) || u.push(c)\r\n      }\r\n      return u\r\n    }),\r\n    (m.union = function () {\r\n      return m.uniq(S(arguments, !0, !0))\r\n    }),\r\n    (m.intersection = function (n) {\r\n      for (var t = [], r = arguments.length, e = 0, u = O(n); u > e; e++) {\r\n        var i = n[e]\r\n        if (!m.contains(t, i)) {\r\n          for (var o = 1; r > o && m.contains(arguments[o], i); o++);\r\n          o === r && t.push(i)\r\n        }\r\n      }\r\n      return t\r\n    }),\r\n    (m.difference = function (n) {\r\n      var t = S(arguments, !0, !0, 1)\r\n      return m.filter(n, function (n) {\r\n        return !m.contains(t, n)\r\n      })\r\n    }),\r\n    (m.zip = function () {\r\n      return m.unzip(arguments)\r\n    }),\r\n    (m.unzip = function (n) {\r\n      for (var t = (n && m.max(n, O).length) || 0, r = Array(t), e = 0; t > e; e++) r[e] = m.pluck(n, e)\r\n      return r\r\n    }),\r\n    (m.object = function (n, t) {\r\n      for (var r = {}, e = 0, u = O(n); u > e; e++) t ? (r[n[e]] = t[e]) : (r[n[e][0]] = n[e][1])\r\n      return r\r\n    }),\r\n    (m.findIndex = t(1)),\r\n    (m.findLastIndex = t(-1)),\r\n    (m.sortedIndex = function (n, t, r, e) {\r\n      r = x(r, e, 1)\r\n      for (var u = r(t), i = 0, o = O(n); o > i; ) {\r\n        var a = Math.floor((i + o) / 2)\r\n        r(n[a]) < u ? (i = a + 1) : (o = a)\r\n      }\r\n      return i\r\n    }),\r\n    (m.indexOf = r(1, m.findIndex, m.sortedIndex)),\r\n    (m.lastIndexOf = r(-1, m.findLastIndex)),\r\n    (m.range = function (n, t, r) {\r\n      null == t && ((t = n || 0), (n = 0)), (r = r || 1)\r\n      for (var e = Math.max(Math.ceil((t - n) / r), 0), u = Array(e), i = 0; e > i; i++, n += r) u[i] = n\r\n      return u\r\n    })\r\n  var E = function (n, t, r, e, u) {\r\n    if (!(e instanceof t)) return n.apply(r, u)\r\n    var i = j(n.prototype),\r\n      o = n.apply(i, u)\r\n    return m.isObject(o) ? o : i\r\n  }\r\n  ;(m.bind = function (n, t) {\r\n    if (g && n.bind === g) return g.apply(n, l.call(arguments, 1))\r\n    if (!m.isFunction(n)) throw new TypeError('Bind must be called on a function')\r\n    var r = l.call(arguments, 2),\r\n      e = function () {\r\n        return E(n, e, t, this, r.concat(l.call(arguments)))\r\n      }\r\n    return e\r\n  }),\r\n    (m.partial = function (n) {\r\n      var t = l.call(arguments, 1),\r\n        r = function () {\r\n          for (var e = 0, u = t.length, i = Array(u), o = 0; u > o; o++) i[o] = t[o] === m ? arguments[e++] : t[o]\r\n          for (; e < arguments.length; ) i.push(arguments[e++])\r\n          return E(n, r, this, this, i)\r\n        }\r\n      return r\r\n    }),\r\n    (m.bindAll = function (n) {\r\n      var t,\r\n        r,\r\n        e = arguments.length\r\n      if (1 >= e) throw new Error('bindAll must be passed function names')\r\n      for (t = 1; e > t; t++) (r = arguments[t]), (n[r] = m.bind(n[r], n))\r\n      return n\r\n    }),\r\n    (m.memoize = function (n, t) {\r\n      var r = function (e) {\r\n        var u = r.cache,\r\n          i = '' + (t ? t.apply(this, arguments) : e)\r\n        return m.has(u, i) || (u[i] = n.apply(this, arguments)), u[i]\r\n      }\r\n      return (r.cache = {}), r\r\n    }),\r\n    (m.delay = function (n, t) {\r\n      var r = l.call(arguments, 2)\r\n      return setTimeout(function () {\r\n        return n.apply(null, r)\r\n      }, t)\r\n    }),\r\n    (m.defer = m.partial(m.delay, m, 1)),\r\n    (m.throttle = function (n, t, r) {\r\n      var e,\r\n        u,\r\n        i,\r\n        o = null,\r\n        a = 0\r\n      r || (r = {})\r\n      var c = function () {\r\n        ;(a = r.leading === !1 ? 0 : m.now()), (o = null), (i = n.apply(e, u)), o || (e = u = null)\r\n      }\r\n      return function () {\r\n        var f = m.now()\r\n        a || r.leading !== !1 || (a = f)\r\n        var l = t - (f - a)\r\n        return (\r\n          (e = this),\r\n          (u = arguments),\r\n          0 >= l || l > t\r\n            ? (o && (clearTimeout(o), (o = null)), (a = f), (i = n.apply(e, u)), o || (e = u = null))\r\n            : o || r.trailing === !1 || (o = setTimeout(c, l)),\r\n          i\r\n        )\r\n      }\r\n    }),\r\n    (m.debounce = function (n, t, r) {\r\n      var e,\r\n        u,\r\n        i,\r\n        o,\r\n        a,\r\n        c = function () {\r\n          var f = m.now() - o\r\n          t > f && f >= 0 ? (e = setTimeout(c, t - f)) : ((e = null), r || ((a = n.apply(i, u)), e || (i = u = null)))\r\n        }\r\n      return function () {\r\n        ;(i = this), (u = arguments), (o = m.now())\r\n        var f = r && !e\r\n        return e || (e = setTimeout(c, t)), f && ((a = n.apply(i, u)), (i = u = null)), a\r\n      }\r\n    }),\r\n    (m.wrap = function (n, t) {\r\n      return m.partial(t, n)\r\n    }),\r\n    (m.negate = function (n) {\r\n      return function () {\r\n        return !n.apply(this, arguments)\r\n      }\r\n    }),\r\n    (m.compose = function () {\r\n      var n = arguments,\r\n        t = n.length - 1\r\n      return function () {\r\n        for (var r = t, e = n[t].apply(this, arguments); r--; ) e = n[r].call(this, e)\r\n        return e\r\n      }\r\n    }),\r\n    (m.after = function (n, t) {\r\n      return function () {\r\n        return --n < 1 ? t.apply(this, arguments) : void 0\r\n      }\r\n    }),\r\n    (m.before = function (n, t) {\r\n      var r\r\n      return function () {\r\n        return --n > 0 && (r = t.apply(this, arguments)), 1 >= n && (t = null), r\r\n      }\r\n    }),\r\n    (m.once = m.partial(m.before, 2))\r\n  var M = !{ toString: null }.propertyIsEnumerable('toString'),\r\n    I = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']\r\n  ;(m.keys = function (n) {\r\n    if (!m.isObject(n)) return []\r\n    if (v) return v(n)\r\n    var t = []\r\n    for (var r in n) m.has(n, r) && t.push(r)\r\n    return M && e(n, t), t\r\n  }),\r\n    (m.allKeys = function (n) {\r\n      if (!m.isObject(n)) return []\r\n      var t = []\r\n      for (var r in n) t.push(r)\r\n      return M && e(n, t), t\r\n    }),\r\n    (m.values = function (n) {\r\n      for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = n[t[u]]\r\n      return e\r\n    }),\r\n    (m.mapObject = function (n, t, r) {\r\n      t = x(t, r)\r\n      for (var e, u = m.keys(n), i = u.length, o = {}, a = 0; i > a; a++) (e = u[a]), (o[e] = t(n[e], e, n))\r\n      return o\r\n    }),\r\n    (m.pairs = function (n) {\r\n      for (var t = m.keys(n), r = t.length, e = Array(r), u = 0; r > u; u++) e[u] = [t[u], n[t[u]]]\r\n      return e\r\n    }),\r\n    (m.invert = function (n) {\r\n      for (var t = {}, r = m.keys(n), e = 0, u = r.length; u > e; e++) t[n[r[e]]] = r[e]\r\n      return t\r\n    }),\r\n    (m.functions = m.methods = function (n) {\r\n      var t = []\r\n      for (var r in n) m.isFunction(n[r]) && t.push(r)\r\n      return t.sort()\r\n    }),\r\n    (m.extend = _(m.allKeys)),\r\n    (m.extendOwn = m.assign = _(m.keys)),\r\n    (m.findKey = function (n, t, r) {\r\n      t = x(t, r)\r\n      for (var e, u = m.keys(n), i = 0, o = u.length; o > i; i++) if (((e = u[i]), t(n[e], e, n))) return e\r\n    }),\r\n    (m.pick = function (n, t, r) {\r\n      var e,\r\n        u,\r\n        i = {},\r\n        o = n\r\n      if (null == o) return i\r\n      m.isFunction(t)\r\n        ? ((u = m.allKeys(o)), (e = b(t, r)))\r\n        : ((u = S(arguments, !1, !1, 1)),\r\n          (e = function (n, t, r) {\r\n            return t in r\r\n          }),\r\n          (o = Object(o)))\r\n      for (var a = 0, c = u.length; c > a; a++) {\r\n        var f = u[a],\r\n          l = o[f]\r\n        e(l, f, o) && (i[f] = l)\r\n      }\r\n      return i\r\n    }),\r\n    (m.omit = function (n, t, r) {\r\n      if (m.isFunction(t)) t = m.negate(t)\r\n      else {\r\n        var e = m.map(S(arguments, !1, !1, 1), String)\r\n        t = function (n, t) {\r\n          return !m.contains(e, t)\r\n        }\r\n      }\r\n      return m.pick(n, t, r)\r\n    }),\r\n    (m.defaults = _(m.allKeys, !0)),\r\n    (m.create = function (n, t) {\r\n      var r = j(n)\r\n      return t && m.extendOwn(r, t), r\r\n    }),\r\n    (m.clone = function (n) {\r\n      return m.isObject(n) ? (m.isArray(n) ? n.slice() : m.extend({}, n)) : n\r\n    }),\r\n    (m.tap = function (n, t) {\r\n      return t(n), n\r\n    }),\r\n    (m.isMatch = function (n, t) {\r\n      var r = m.keys(t),\r\n        e = r.length\r\n      if (null == n) return !e\r\n      for (var u = Object(n), i = 0; e > i; i++) {\r\n        var o = r[i]\r\n        if (t[o] !== u[o] || !(o in u)) return !1\r\n      }\r\n      return !0\r\n    })\r\n  var N = function (n, t, r, e) {\r\n    if (n === t) return 0 !== n || 1 / n === 1 / t\r\n    if (null == n || null == t) return n === t\r\n    n instanceof m && (n = n._wrapped), t instanceof m && (t = t._wrapped)\r\n    var u = s.call(n)\r\n    if (u !== s.call(t)) return !1\r\n    switch (u) {\r\n      case '[object RegExp]':\r\n      case '[object String]':\r\n        return '' + n == '' + t\r\n      case '[object Number]':\r\n        return +n !== +n ? +t !== +t : 0 === +n ? 1 / +n === 1 / t : +n === +t\r\n      case '[object Date]':\r\n      case '[object Boolean]':\r\n        return +n === +t\r\n    }\r\n    var i = '[object Array]' === u\r\n    if (!i) {\r\n      if ('object' != typeof n || 'object' != typeof t) return !1\r\n      var o = n.constructor,\r\n        a = t.constructor\r\n      if (\r\n        o !== a &&\r\n        !(m.isFunction(o) && o instanceof o && m.isFunction(a) && a instanceof a) &&\r\n        'constructor' in n &&\r\n        'constructor' in t\r\n      )\r\n        return !1\r\n    }\r\n    ;(r = r || []), (e = e || [])\r\n    for (var c = r.length; c--; ) if (r[c] === n) return e[c] === t\r\n    if ((r.push(n), e.push(t), i)) {\r\n      if (((c = n.length), c !== t.length)) return !1\r\n      for (; c--; ) if (!N(n[c], t[c], r, e)) return !1\r\n    } else {\r\n      var f,\r\n        l = m.keys(n)\r\n      if (((c = l.length), m.keys(t).length !== c)) return !1\r\n      for (; c--; ) if (((f = l[c]), !m.has(t, f) || !N(n[f], t[f], r, e))) return !1\r\n    }\r\n    return r.pop(), e.pop(), !0\r\n  }\r\n  ;(m.isEqual = function (n, t) {\r\n    return N(n, t)\r\n  }),\r\n    (m.isEmpty = function (n) {\r\n      return null == n\r\n        ? !0\r\n        : k(n) && (m.isArray(n) || m.isString(n) || m.isArguments(n))\r\n        ? 0 === n.length\r\n        : 0 === m.keys(n).length\r\n    }),\r\n    (m.isElement = function (n) {\r\n      return !(!n || 1 !== n.nodeType)\r\n    }),\r\n    (m.isArray =\r\n      h ||\r\n      function (n) {\r\n        return '[object Array]' === s.call(n)\r\n      }),\r\n    (m.isObject = function (n) {\r\n      var t = typeof n\r\n      return 'function' === t || ('object' === t && !!n)\r\n    }),\r\n    m.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function (n) {\r\n      m['is' + n] = function (t) {\r\n        return s.call(t) === '[object ' + n + ']'\r\n      }\r\n    }),\r\n    m.isArguments(arguments) ||\r\n      (m.isArguments = function (n) {\r\n        return m.has(n, 'callee')\r\n      }),\r\n     true &&\r\n      'object' != typeof Int8Array &&\r\n      (m.isFunction = function (n) {\r\n        return 'function' == typeof n || !1\r\n      }),\r\n    (m.isFinite = function (n) {\r\n      return isFinite(n) && !isNaN(parseFloat(n))\r\n    }),\r\n    (m.isNaN = function (n) {\r\n      return m.isNumber(n) && n !== +n\r\n    }),\r\n    (m.isBoolean = function (n) {\r\n      return n === !0 || n === !1 || '[object Boolean]' === s.call(n)\r\n    }),\r\n    (m.isNull = function (n) {\r\n      return null === n\r\n    }),\r\n    (m.isUndefined = function (n) {\r\n      return n === void 0\r\n    }),\r\n    (m.has = function (n, t) {\r\n      return null != n && p.call(n, t)\r\n    }),\r\n    (m.noConflict = function () {\r\n      return (u._ = i), this\r\n    }),\r\n    (m.identity = function (n) {\r\n      return n\r\n    }),\r\n    (m.constant = function (n) {\r\n      return function () {\r\n        return n\r\n      }\r\n    }),\r\n    (m.noop = function () {}),\r\n    (m.property = w),\r\n    (m.propertyOf = function (n) {\r\n      return null == n\r\n        ? function () {}\r\n        : function (t) {\r\n            return n[t]\r\n          }\r\n    }),\r\n    (m.matcher = m.matches = function (n) {\r\n      return (\r\n        (n = m.extendOwn({}, n)),\r\n        function (t) {\r\n          return m.isMatch(t, n)\r\n        }\r\n      )\r\n    }),\r\n    (m.times = function (n, t, r) {\r\n      var e = Array(Math.max(0, n))\r\n      t = b(t, r, 1)\r\n      for (var u = 0; n > u; u++) e[u] = t(u)\r\n      return e\r\n    }),\r\n    (m.random = function (n, t) {\r\n      return null == t && ((t = n), (n = 0)), n + Math.floor(Math.random() * (t - n + 1))\r\n    }),\r\n    (m.now =\r\n      Date.now ||\r\n      function () {\r\n        return new Date().getTime()\r\n      })\r\n  var B = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '\"': '&quot;', \"'\": '&#x27;', '`': '&#x60;' },\r\n    T = m.invert(B),\r\n    R = function (n) {\r\n      var t = function (t) {\r\n          return n[t]\r\n        },\r\n        r = '(?:' + m.keys(n).join('|') + ')',\r\n        e = RegExp(r),\r\n        u = RegExp(r, 'g')\r\n      return function (n) {\r\n        return (n = null == n ? '' : '' + n), e.test(n) ? n.replace(u, t) : n\r\n      }\r\n    }\r\n  ;(m.escape = R(B)),\r\n    (m.unescape = R(T)),\r\n    (m.result = function (n, t, r) {\r\n      var e = null == n ? void 0 : n[t]\r\n      return e === void 0 && (e = r), m.isFunction(e) ? e.call(n) : e\r\n    })\r\n  var q = 0\r\n  ;(m.uniqueId = function (n) {\r\n    var t = ++q + ''\r\n    return n ? n + t : t\r\n  }),\r\n    (m.templateSettings = { evaluate: /<%([\\s\\S]+?)%>/g, interpolate: /<%=([\\s\\S]+?)%>/g, escape: /<%-([\\s\\S]+?)%>/g })\r\n  var K = /(.)^/,\r\n    z = { \"'\": \"'\", '\\\\': '\\\\', '\\r': 'r', '\\n': 'n', '\\u2028': 'u2028', '\\u2029': 'u2029' },\r\n    D = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g,\r\n    L = function (n) {\r\n      return '\\\\' + z[n]\r\n    }\r\n  ;(m.template = function (n, t, r) {\r\n    !t && r && (t = r), (t = m.defaults({}, t, m.templateSettings))\r\n    var e = RegExp(\r\n        [(t.escape || K).source, (t.interpolate || K).source, (t.evaluate || K).source].join('|') + '|$',\r\n        'g'\r\n      ),\r\n      u = 0,\r\n      i = \"__p+='\"\r\n    n.replace(e, function (t, r, e, o, a) {\r\n      return (\r\n        (i += n.slice(u, a).replace(D, L)),\r\n        (u = a + t.length),\r\n        r\r\n          ? (i += \"'+\\n((__t=(\" + r + \"))==null?'':_.escape(__t))+\\n'\")\r\n          : e\r\n          ? (i += \"'+\\n((__t=(\" + e + \"))==null?'':__t)+\\n'\")\r\n          : o && (i += \"';\\n\" + o + \"\\n__p+='\"),\r\n        t\r\n      )\r\n    }),\r\n      (i += \"';\\n\"),\r\n      t.variable || (i = 'with(obj||{}){\\n' + i + '}\\n'),\r\n      (i =\r\n        \"var __t,__p='',__j=Array.prototype.join,\" +\r\n        \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\r\n        i +\r\n        'return __p;\\n')\r\n    try {\r\n      var o = new Function(t.variable || 'obj', '_', i)\r\n    } catch (a) {\r\n      throw ((a.source = i), a)\r\n    }\r\n    var c = function (n) {\r\n        return o.call(this, n, m)\r\n      },\r\n      f = t.variable || 'obj'\r\n    return (c.source = 'function(' + f + '){\\n' + i + '}'), c\r\n  }),\r\n    (m.chain = function (n) {\r\n      var t = m(n)\r\n      return (t._chain = !0), t\r\n    })\r\n  var P = function (n, t) {\r\n    return n._chain ? m(t).chain() : t\r\n  }\r\n  ;(m.mixin = function (n) {\r\n    m.each(m.functions(n), function (t) {\r\n      var r = (m[t] = n[t])\r\n      m.prototype[t] = function () {\r\n        var n = [this._wrapped]\r\n        return f.apply(n, arguments), P(this, r.apply(m, n))\r\n      }\r\n    })\r\n  }),\r\n    m.mixin(m),\r\n    m.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (n) {\r\n      var t = o[n]\r\n      m.prototype[n] = function () {\r\n        var r = this._wrapped\r\n        return t.apply(r, arguments), ('shift' !== n && 'splice' !== n) || 0 !== r.length || delete r[0], P(this, r)\r\n      }\r\n    }),\r\n    m.each(['concat', 'join', 'slice'], function (n) {\r\n      var t = o[n]\r\n      m.prototype[n] = function () {\r\n        return P(this, t.apply(this._wrapped, arguments))\r\n      }\r\n    }),\r\n    (m.prototype.value = function () {\r\n      return this._wrapped\r\n    }),\r\n    (m.prototype.valueOf = m.prototype.toJSON = m.prototype.value),\r\n    (m.prototype.toString = function () {\r\n      return '' + this._wrapped\r\n    }),\r\n     true &&\r\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n        return m\r\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\r\n}.call(this))\r\n\n\n//# sourceURL=webpack://trudesk/./src/public/js/vendor/underscore/underscore.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	__webpack_require__(0);
/******/ 	__webpack_require__(25);
/******/ 	__webpack_require__(3);
/******/ 	__webpack_require__(28);
/******/ 	__webpack_require__(29);
/******/ 	__webpack_require__(9);
/******/ 	__webpack_require__(2);
/******/ 	var __webpack_exports__ = __webpack_require__(1);
/******/ 	
/******/ })()
;